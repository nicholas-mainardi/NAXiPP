/** \file
 *  This C source file was generated by $ANTLR version 3.5.2
 *
 *     -  From the grammar source file : Grammar/RFC5280.g
 *     -                            On : 2019-08-01 19:09:11
 *     -                for the parser : RFC5280ParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "RFC5280Parser.h"

    int warning = 0;
    cert_info* cert;
/*RFC5280Parser_prog_return *tree;*/
    #ifdef DEBUG
    rule *rule_list;
    RULE_TREE *rule_tree;
    int tree_depth = -1;
    pRFC5280Parser parser_ctx=NULL;
    const char * alg_id_oids[18] = {"RSAPSSOID","SHA1DSAOID","SHA1RSAOID","SHA1ECOID","SHA224RSAOID","SHA224ECOID","SHA224DSAOID","SHA256DSAOID","SHA256ECOID",
    	"SHA256RSAOID","SHA384ECOID","SHA384RSAOID","SHA512RSAOID","SHA512ECOID","MD2RSAOID","MD5RSAOID","GOST01SIGN","GOST94SIGN"};
    const char * int_tokens[4] = {"Int0","Int1","Int2","IntTag"};
    const char * wrong_string_tags[8] = {"OIDCOUNTRY","OIDSERIAL","OIDDNQUALIFIER","LEGACYEMAILOID","AppTag1","AppTag2","ConstructedTag2","ConstructedTag1"};
    const char * string_tags[8] = {"UTF8Tag","NumericStringTag","VisibleStringTag","UniverStringTag","TeletexTag","PrintStringTag","IA5StringTag","BMPTag"};
    const char * string_rules[10] = {"utf8String","visibleString","univerString","teletexString","printString","numericString","ia5String","displayTextString","directoryString","bmpString"};
    const char * dn_oids[15] = {"OIDCN","OIDON","NAMEOID","SURNAMEOID","OIDINIT","OIDGENQUALIFIER","OIDLOCAL","OIDSORP","OIDOU","OIDTITLE","OIDDNQUALIFIER","OIDCOUNTRY",
    	"OIDSERIAL","OIDPSEUDO","OIDGIVENAME"};
    const char * tag_tokens[9] = {"Tag0","Tag1","Tag2","Tag3","Tag4","Tag5","Tag6","Tag7","Tag8"};
    const char * not_bc_rules[11] = {"notDependentExts","extensionsNotBC","extensionsNotBCNotKeyUsage","extensionsNotBCNotKeyUsageNotSki"
    ,"extensionsNotBCNotKeyUsageNotSkiNoSubAlt","extensionsNotBCNotKeyUsageNotSkiSubAlt","extensionsNotBCNotKeyUsageSubAlt","extensionsNotBCNotSki"
    ,"extensionsNotBCNotSkiSubAlt","extensionsNotBCSubAlt","extensionsNotBCNotKeyUsageNotSkiNoSubAlt"};
    const char * extension_oids[17] = {"OIDAKI","OIDSKI","OIDCERTPOL","OIDKEYUS","OIDPOLMAP","OIDSUBALT","OIDISSALT","OIDSUBDIR","OIDBC","OIDNAME","OIDPOLCONST"
    ,"OIDEXTKEY","OIDCRL","OIDINHIBIT","OIDFRESHCRL","AIAOID","SIAOID"};
    
    void push_rule(char *func);
    void pop_rule();
    int lookahead(int i,pRFC5280Parser ctx);
    
   /*int max=0;

   ANTLR3_UCHAR max_lookahead(int n,pRFC5280Parser ctx)
   {
        if(n > max)
		max = n;
   	return ctx->pParser->tstream->istream->_LA(ctx->pParser->tstream->istream, n);
   }*/
    int rule_list_lookup(rule *rule_list,char *rule)
    {
    	int found = 0;
    	while(rule_list != NULL)
    	{
    		if(!strcmp(rule_list->fname,rule))
    		{
    			found = 1;
    			break;
    		}
    		rule_list = rule_list->next;
    	}
    	return found;
    }

    int search_token(char **tokens,int length,char *item)
    {
    	int i,found = 0;
    	for(i=0;i<length;i++)
    	{
    		if(!strcmp(tokens[i],item))
    		{
    			found=1;
    			break;
    		}
    	}
    	return found;
    }
    
    int search_lookahead(int start, int end, char *token,pANTLR3_UINT8 * tokenNames)
    {
    	for(start;start<=end;start++)
    	{
    		if(!strcmp(token,tokenNames[lookahead(start,parser_ctx)]))
    		{
    			return 1;
    		}
    	}
    	return 0;
    }
    
    #endif
    
    void errorHandling (pANTLR3_BASE_RECOGNIZER recognizer,pANTLR3_UINT8 * tokenNames)
    {
    	printf("It's parser error \n");
        pANTLR3_EXCEPTION e = recognizer->state->exception;
        printf("Error occured at line %d, in character %d \n",e->line,e->charPositionInLine);
        int i;
        pANTLR3_COMMON_TOKEN token = (pANTLR3_COMMON_TOKEN) e->token;
        pANTLR3_STACK st = recognizer->getRuleInvocationStack(recognizer);
        if(st!=NULL)
        	printf("rule is %s \n",st->pop(st));
            printf("Expected token was %s and actual is %s \n",recognizer->state->text,tokenNames[token->type]);
        printf("Rule was %s \n",(char*) e->ruleName);
        printf("message is %s \n",(char*) e->message);
        #ifdef DEBUG
        printf("Rule is %s \n",rule_list->fname);
        if(rule_tree->depth > tree_depth)
        {
        push_rule("error");
        pop_rule();
        }
        printf("Parsed elements of current rule are: \n");
        rule *iterator = rule_tree->rule_list;
        while(iterator != NULL)
        {
        	printf("%s - ",iterator->fname);
        	iterator=iterator->next;
        }
        printf("analyzing lookahead: %x \n",parser_ctx);
        for(i=-1;i<4;i++)
        	printf("%s - ",tokenNames[lookahead(i,parser_ctx)]);
        /*printf("Tree is %x \n",tree->tree);
        printf("Tree is %s \n",tree->tree->toStringTree(tree->tree)->chars);*/
       	if(!strcmp(rule_list->fname,"extensionsMustBeCAandSki") && search_token(alg_id_oids,18,tokenNames[lookahead(3,parser_ctx)]) && 
        	!(rule_list_lookup(rule_tree->rule_list,"subjectKeyId") && rule_list_lookup(rule_tree->rule_list,"bcoid")))
        	exit(MISSING_CRITICAL_BC_SKI_ERROR);
        if( (!strcmp(rule_list->fname,"extensionsNotBCNotKeyUsage") ||( !strcmp(rule_list->fname,"extensionsNotCertSignAndSki") && strcmp(tokenNames[token->type],"BitStringKeyCert"))
        	|| !strcmp(rule_list->fname,"extensionsNotBC")) && !rule_list_lookup(rule_tree->rule_list,"subjectKeyId") && search_token(alg_id_oids,18,tokenNames[lookahead(3,parser_ctx)]))
        	exit(MISSING_SKI_ERROR);
        if(!strcmp(rule_list->fname,"ads") && rule_list_lookup(rule_tree->rule_list,"ads"))
        	exit(EMPTY_ACCESS_DESCRIPTION_LIST_ERROR);
        if(!strcmp(rule_list->fname,"generalNames") && rule_list_lookup(rule_tree->rule_list,"generalNames"))
        	exit(EMPTY_GENERAL_NAMES_ERROR);
        if((!strcmp(rule_list->fname,"printable")) && strcmp(tokenNames[token->type],"Value") && strcmp(tokenNames[token->type],"Val"))
        	exit(EMPTY_PRINTABLE_STRING_ERROR);
        if((!strcmp(rule_list->fname,"tbscertificate")) && !strcmp(tokenNames[token->type],"ConstructedTag0"))
        	exit(WRONG_VERSION_ERROR);
        if((!strcmp(rule_list->fname,"extensions") && rule_list_lookup(rule_tree->rule_list,"basicConstraintsNotCritical") && !rule_list_lookup(rule_tree->rule_list->next->next,"truevalue") 
        && search_token(int_tokens,4,tokenNames[token->type])) || (!strcmp(rule_list->fname,"extensionsNoPathLen") && rule_list_lookup(rule_tree->rule_list,"basicConstraints") 
        && search_token(int_tokens,4,tokenNames[token->type])))
        	exit(PATHLEN_NO_CA_ERROR);
        if(!strcmp(rule_list->fname,"val") && !strcmp(tokenNames[lookahead(-1,parser_ctx)],"BitStringKeyCert"))
        	exit(UNEXPECTED_CERT_SIGN_BIT_ERROR);
        if((search_token(wrong_string_tags,8,tokenNames[lookahead(-1,parser_ctx)]) || search_token(string_rules,10,rule_list->fname)) && search_token(string_tags,8,tokenNames[token->type]))	        
        	exit(WRONG_STRING_TYPE_ERROR);
        if(cert->version < 3 && !strcmp(tokenNames[token->type],"ConstructedTag3") && !strcmp(tokenNames[lookahead(3,parser_ctx)],"OIDTag"))
        	exit(EXTENSION_NO_VERSION3_ERROR);
        if(!strcmp(rule_list->fname,"dn") &&  !search_token(dn_oids,15,tokenNames[lookahead(2,parser_ctx)]) && strstr(tokenNames[lookahead(2,parser_ctx)],"OID"))
        	exit(DN_WRONG_OID);
        if(!strcmp(rule_list->fname,"val") && strstr(tokenNames[lookahead(-1,parser_ctx)],"Tag"))
        	exit(EMPTY_VALUE_ERROR);
        if(!strcmp(rule_list->fname,"extensionsNotCertSignAndSki") && search_token(int_tokens,4,tokenNames[token->type]))
        {
        	if(!strcmp(tokenNames[lookahead(-1,parser_ctx)],"TrueTag"))
        		exit(PATHLEN_NO_BC_CRITICAL_ERROR);
        	else
        		exit(PATHLEN_NO_CA_ERROR);
        }
        if(!strcmp(rule_list->fname,"extensionsCertSignAndSki") && search_token(alg_id_oids,18,tokenNames[lookahead(3,parser_ctx)]))
        	exit(MISSING_SKI_AND_CERT_SIGN_ERROR);
        if(!strcmp(rule_list->fname,"constructedOctetString") && !strcmp(tokenNames[token->type],"TrueTag"))
        	exit(CRITICAL_EXTENSION_ERROR);
        if(search_token(tag_tokens,9,tokenNames[token->type]) && strcmp("VALUE",tokenNames[lookahead(2,parser_ctx)]) && strcmp("Val",tokenNames[lookahead(2,parser_ctx)]) 
        && strcmp("PRINTABLE",tokenNames[lookahead(2,parser_ctx)]))
        	exit(EMPTY_NUMERIC_TAG_ERROR);
        if(!strcmp(rule_list->fname,"policyQualifiers") &&  strcmp("UNOTICEOID",tokenNames[lookahead(3,parser_ctx)]) && strcmp("CPSOID",tokenNames[lookahead(3,parser_ctx)]) 
        && strstr(tokenNames[lookahead(3,parser_ctx)],"OID"))
        	exit(POLICY_WRONG_OID_ERROR);
        if(!strcmp(rule_list->fname,"policies") && strstr(tokenNames[lookahead(3,parser_ctx)],"OID"))
        	exit(POLICY_WRONG_OID_ERROR);
        if(!strcmp(rule_list->fname,"extensionsCertSign") && search_token(alg_id_oids,18,tokenNames[lookahead(3,parser_ctx)]))
        	exit(MISSING_CERT_SIGN_ERROR);        	
        if(!strcmp(rule_list->fname,"generalSubtrees") && rule_list_lookup(rule_tree->rule_list,"generalSubtrees"))
        	exit(GENERAL_SUBTREES_EMPTY_ERROR);
        if(!strcmp(rule_list->fname,"tbscertificate") && !strcmp("OIDTag",tokenNames[lookahead(2,parser_ctx)]) && !strcmp("VALUE",tokenNames[lookahead(3,parser_ctx)]))
        	exit(WRONG_ALG_ID_OID_ERROR);
        if(search_token(not_bc_rules,11,rule_list->fname) && !strcmp(tokenNames[lookahead(3,parser_ctx)],"OIDBC"))	
        	exit(REPEATED_BC_ERROR);
        if(rule_list_lookup(rule_tree->rule_list,"subjectPKinfo") && (!strcmp(rule_list->fname,"extensions") || !strcmp(rule_list->fname,"extensionsWithSubAlt")))
        	exit(EMPTY_EXTENSIONS_LIST_ERROR);
        if(strstr(rule_list->fname,"extension") && !search_token(extension_oids,17,tokenNames[lookahead(3,parser_ctx)]) && strstr(tokenNames[lookahead(3,parser_ctx)],"OID"))
        	exit(EXTENSION_WRONG_OID_ERROR);
        /*if(rule_list->next && rule_list->next->next && !strcmp(rule_list->next->next->fname,"issuer") && !strcmp(tokenNames[token->type],"Null") && (strstr(cert->signature_algorithm->oid->ln,"Pss") || !strstr(cert->signature_algorithm->oid->ln,"RSA")) 
        && !strstr(cert->signature_algorithm->oid->ln,"GOST"))*/
	if(rule_list->next && rule_list->next->next && !strcmp(rule_list->next->next->fname,"issuer") && !strcmp(tokenNames[token->type],"Null") && (strstr(OBJ_nid2ln(OBJ_obj2nid(cert->signature_algorithm->oid)),"Pss") || !strstr(OBJ_nid2ln(OBJ_obj2nid(cert->signature_algorithm->oid)),"RSA")) 
        && !strstr(OBJ_nid2ln(OBJ_obj2nid(cert->signature_algorithm->oid)),"GOST"))
        	exit(UNEXPECTED_NULL_ALG_ID_PARAMS_ERROR);
        if(search_token(int_tokens,4,tokenNames[token->type]) && search_lookahead(-5,0,"OIDBC",tokenNames))
        	if(!search_lookahead(-2,0,"TrueTag",tokenNames))
        		exit(PATHLEN_NO_CA_ERROR);
        	else
        		exit(PATHLEN_NO_BC_CRITICAL_ERROR);
        if(!strcmp(rule_list->fname,"prog") && rule_list_lookup(rule_tree->rule_list,"certificate"))
		exit(END_OF_CERT_EXPECTED_ERROR);
	#endif
        exit(GENERIC_ERROR);
    }
    
    static pANTLR3_UINT8* getTokenNames();
    void* missingHandling (pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM istream, pANTLR3_EXCEPTION e, ANTLR3_UINT32 expectedTokenType, pANTLR3_BITSET_LIST follow)
    {
    	pANTLR3_UINT8* tokenNames = getTokenNames();
    	printf("Expected token is %s \n",tokenNames[expectedTokenType]);
    	pANTLR3_COMMON_TOKEN token = (pANTLR3_COMMON_TOKEN) e->token;
            	printf("actual token is %s \n",tokenNames[token->type]);
        	printf("Rule was %s \n",(char*) e->ruleName);
        	printf("message is %s \n",(char*) e->message);
        	#ifdef DEBUG
        	printf("Rule is %s \n",rule_list->fname);
        	if(rule_tree->depth > tree_depth)
        	{
        		push_rule("error");
       		pop_rule();
        	}
        	printf("Parsed elements of current rule are: \n");
        	rule *iterator = rule_tree->rule_list;
        	while(iterator != NULL)
        	{
        		printf("%s - ",iterator->fname);
        		iterator=iterator->next;
        	}
        	if(!strcmp(tokenNames[token->type],"ConstructedOctetTag") && !strcmp(tokenNames[expectedTokenType],"TrueTag"))
        		exit(BC_NOT_CRITICAL_ERROR);
        	if((search_token(alg_id_oids,18,tokenNames[token->type]) && !strcmp(tokenNames[expectedTokenType],"OIDBC")) || 
        	(rule_list_lookup(rule_tree->rule_list,"bcoid") && !strcmp(rule_list->fname,"truevalue") && !strcmp(tokenNames[token->type],"FalseTag")))
        		if(!rule_list_lookup(rule_tree->rule_list,"constructedOctetString"))
        			exit(BC_NOT_CRITICAL_ERROR);	
        		else
        			exit(MISSING_CA_ERROR);
        	if(!strcmp(tokenNames[token->type],"SequenceTag") && !strcmp(tokenNames[expectedTokenType],"ConstructedTag3"))
        		exit(MISSING_EXTENSION_TAG3_ERROR);
        	if(search_token(int_tokens,4,tokenNames[token->type]) && !strcmp(tokenNames[lookahead(-1,parser_ctx)],"TrueTag") && !strcmp(tokenNames[lookahead(-3,parser_ctx)],"ConstructedOctetTag")
        	&& (!strcmp(tokenNames[lookahead(-4,parser_ctx)],"OIDBC") || !strcmp(tokenNames[lookahead(-5,parser_ctx)],"OIDBC")))
        		exit(PATHLEN_NO_BC_CRITICAL_ERROR);	
        	if(!strcmp(rule_list->fname,"set") && !strcmp(rule_list->next->fname,"rdnsNotEmpty") && !strcmp(rule_list->next->next->fname,"notEmptyName") 
        	&& !strcmp(tokenNames[expectedTokenType],"SetTag"))
        		exit(EMPTY_RDNS_ERROR);
        	printf("analyzing lookahead: %x \n",parser_ctx);
              	int i;
        	for(i=-5;i<8;i++)
        		printf("%s - ",tokenNames[lookahead(i,parser_ctx)]);        		
    	
    	#endif
    	exit(GENERIC_ERROR);
    }
    
    void mismatchHandling (pANTLR3_BASE_RECOGNIZER recognizer, ANTLR3_UINT32 ttype, pANTLR3_BITSET_LIST follow)
    {
    	pANTLR3_EXCEPTION e = recognizer->state->exception;
    	pANTLR3_UINT8* tokenNames = getTokenNames();
    	printf("Expected token is %s \n",tokenNames[ttype]);
    	pANTLR3_COMMON_TOKEN token = (pANTLR3_COMMON_TOKEN) e->token;
            	printf("actual token is %s \n",tokenNames[token->type]);
        	printf("Rule was %s \n",(char*) e->ruleName);
        	printf("message is %s \n",(char*) e->message);
    	exit(1);
    }

/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pRFC5280Parser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pRFC5280Parser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pRFC5280Parser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pRFC5280Parser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   RFC5280ParserTokenNames[174+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "AIAOID",
        (pANTLR3_UINT8) "ANYPOLICYOID",
        (pANTLR3_UINT8) "ANYUSAGEOID",
        (pANTLR3_UINT8) "AppTag1",
        (pANTLR3_UINT8) "AppTag2",
        (pANTLR3_UINT8) "BASIS2OID",
        (pANTLR3_UINT8) "BMPTag",
        (pANTLR3_UINT8) "BitStringKeyCert",
        (pANTLR3_UINT8) "BitStringTag",
        (pANTLR3_UINT8) "CAISSUEROID",
        (pANTLR3_UINT8) "CAREPOOID",
        (pANTLR3_UINT8) "CLIENTAUTHOID",
        (pANTLR3_UINT8) "CODESIGNOID",
        (pANTLR3_UINT8) "CPSOID",
        (pANTLR3_UINT8) "ConstructedBitStringTag",
        (pANTLR3_UINT8) "ConstructedOctetTag",
        (pANTLR3_UINT8) "ConstructedTag0",
        (pANTLR3_UINT8) "ConstructedTag1",
        (pANTLR3_UINT8) "ConstructedTag2",
        (pANTLR3_UINT8) "ConstructedTag3",
        (pANTLR3_UINT8) "ConstructedTag4",
        (pANTLR3_UINT8) "ConstructedTag5",
        (pANTLR3_UINT8) "ConstructedTag6",
        (pANTLR3_UINT8) "ConstructedTag7",
        (pANTLR3_UINT8) "ConstructedTag8",
        (pANTLR3_UINT8) "DHPKOID",
        (pANTLR3_UINT8) "DNOID",
        (pANTLR3_UINT8) "DSADHOID",
        (pANTLR3_UINT8) "DSAPKOID",
        (pANTLR3_UINT8) "ECDHOID",
        (pANTLR3_UINT8) "ECKAOID",
        (pANTLR3_UINT8) "ECMQVOID",
        (pANTLR3_UINT8) "ECOID",
        (pANTLR3_UINT8) "ECPKOID",
        (pANTLR3_UINT8) "EMAILPROTECTOID",
        (pANTLR3_UINT8) "EVERY",
        (pANTLR3_UINT8) "EXTSOID",
        (pANTLR3_UINT8) "FalseTag",
        (pANTLR3_UINT8) "GNBASISOID",
        (pANTLR3_UINT8) "GOST01PK",
        (pANTLR3_UINT8) "GOST01SIGN",
        (pANTLR3_UINT8) "GOST94PK",
        (pANTLR3_UINT8) "GOST94SIGN",
        (pANTLR3_UINT8) "GOSTOID",
        (pANTLR3_UINT8) "GeneralStringTag",
        (pANTLR3_UINT8) "GeneralTimeTag",
        (pANTLR3_UINT8) "GraphicalStringTag",
        (pANTLR3_UINT8) "HASHOID",
        (pANTLR3_UINT8) "IA5StringTag",
        (pANTLR3_UINT8) "Int0",
        (pANTLR3_UINT8) "Int1",
        (pANTLR3_UINT8) "Int2",
        (pANTLR3_UINT8) "IntTag",
        (pANTLR3_UINT8) "KEAPKOID",
        (pANTLR3_UINT8) "LEGACYEMAILOID",
        (pANTLR3_UINT8) "LENGTH",
        (pANTLR3_UINT8) "MD2RSAOID",
        (pANTLR3_UINT8) "MD5RSAOID",
        (pANTLR3_UINT8) "MGF1OID",
        (pANTLR3_UINT8) "NAMEOID",
        (pANTLR3_UINT8) "Null",
        (pANTLR3_UINT8) "NumericStringTag",
        (pANTLR3_UINT8) "OCSPOID",
        (pANTLR3_UINT8) "OCSPSIGNOID",
        (pANTLR3_UINT8) "OIDAKI",
        (pANTLR3_UINT8) "OIDBC",
        (pANTLR3_UINT8) "OIDCERTPOL",
        (pANTLR3_UINT8) "OIDCN",
        (pANTLR3_UINT8) "OIDCOUNTRY",
        (pANTLR3_UINT8) "OIDCRL",
        (pANTLR3_UINT8) "OIDDNQUALIFIER",
        (pANTLR3_UINT8) "OIDEXTKEY",
        (pANTLR3_UINT8) "OIDFRESHCRL",
        (pANTLR3_UINT8) "OIDGENQUALIFIER",
        (pANTLR3_UINT8) "OIDGIVENAME",
        (pANTLR3_UINT8) "OIDINHIBIT",
        (pANTLR3_UINT8) "OIDINIT",
        (pANTLR3_UINT8) "OIDISSALT",
        (pANTLR3_UINT8) "OIDKEYUS",
        (pANTLR3_UINT8) "OIDLOCAL",
        (pANTLR3_UINT8) "OIDNAME",
        (pANTLR3_UINT8) "OIDON",
        (pANTLR3_UINT8) "OIDOU",
        (pANTLR3_UINT8) "OIDPOLCONST",
        (pANTLR3_UINT8) "OIDPOLMAP",
        (pANTLR3_UINT8) "OIDPSEUDO",
        (pANTLR3_UINT8) "OIDSERIAL",
        (pANTLR3_UINT8) "OIDSKI",
        (pANTLR3_UINT8) "OIDSORP",
        (pANTLR3_UINT8) "OIDSUBALT",
        (pANTLR3_UINT8) "OIDSUBDIR",
        (pANTLR3_UINT8) "OIDTITLE",
        (pANTLR3_UINT8) "OIDTag",
        (pANTLR3_UINT8) "OctetTag",
        (pANTLR3_UINT8) "PPBASISOID",
        (pANTLR3_UINT8) "PRIMEOID",
        (pANTLR3_UINT8) "PRINTABLE",
        (pANTLR3_UINT8) "PRIVATEEXTSOID",
        (pANTLR3_UINT8) "PSPECOID",
        (pANTLR3_UINT8) "PrintStringTag",
        (pANTLR3_UINT8) "RSAOAEPOID",
        (pANTLR3_UINT8) "RSAOID",
        (pANTLR3_UINT8) "RSAPKOID",
        (pANTLR3_UINT8) "RSAPSSOID",
        (pANTLR3_UINT8) "SERVERAUTHOID",
        (pANTLR3_UINT8) "SHA1DSAOID",
        (pANTLR3_UINT8) "SHA1ECOID",
        (pANTLR3_UINT8) "SHA1OID",
        (pANTLR3_UINT8) "SHA1RSAOID",
        (pANTLR3_UINT8) "SHA224DSAOID",
        (pANTLR3_UINT8) "SHA224ECOID",
        (pANTLR3_UINT8) "SHA224OID",
        (pANTLR3_UINT8) "SHA224RSAOID",
        (pANTLR3_UINT8) "SHA256DSAOID",
        (pANTLR3_UINT8) "SHA256ECOID",
        (pANTLR3_UINT8) "SHA256OID",
        (pANTLR3_UINT8) "SHA256RSAOID",
        (pANTLR3_UINT8) "SHA384ECOID",
        (pANTLR3_UINT8) "SHA384OID",
        (pANTLR3_UINT8) "SHA384RSAOID",
        (pANTLR3_UINT8) "SHA512ECOID",
        (pANTLR3_UINT8) "SHA512OID",
        (pANTLR3_UINT8) "SHA512RSAOID",
        (pANTLR3_UINT8) "SIAOID",
        (pANTLR3_UINT8) "SURNAMEOID",
        (pANTLR3_UINT8) "SequenceTag",
        (pANTLR3_UINT8) "SetTag",
        (pANTLR3_UINT8) "TIMESTAMPOID",
        (pANTLR3_UINT8) "TPBASISOID",
        (pANTLR3_UINT8) "TSPOID",
        (pANTLR3_UINT8) "Tag0",
        (pANTLR3_UINT8) "Tag1",
        (pANTLR3_UINT8) "Tag2",
        (pANTLR3_UINT8) "Tag3",
        (pANTLR3_UINT8) "Tag4",
        (pANTLR3_UINT8) "Tag5",
        (pANTLR3_UINT8) "Tag6",
        (pANTLR3_UINT8) "Tag7",
        (pANTLR3_UINT8) "Tag8",
        (pANTLR3_UINT8) "TagInt1",
        (pANTLR3_UINT8) "TagInt10",
        (pANTLR3_UINT8) "TagInt11",
        (pANTLR3_UINT8) "TagInt12",
        (pANTLR3_UINT8) "TagInt13",
        (pANTLR3_UINT8) "TagInt14",
        (pANTLR3_UINT8) "TagInt15",
        (pANTLR3_UINT8) "TagInt16",
        (pANTLR3_UINT8) "TagInt17",
        (pANTLR3_UINT8) "TagInt18",
        (pANTLR3_UINT8) "TagInt19",
        (pANTLR3_UINT8) "TagInt2",
        (pANTLR3_UINT8) "TagInt20",
        (pANTLR3_UINT8) "TagInt21",
        (pANTLR3_UINT8) "TagInt22",
        (pANTLR3_UINT8) "TagInt23",
        (pANTLR3_UINT8) "TagInt3",
        (pANTLR3_UINT8) "TagInt4",
        (pANTLR3_UINT8) "TagInt5",
        (pANTLR3_UINT8) "TagInt6",
        (pANTLR3_UINT8) "TagInt7",
        (pANTLR3_UINT8) "TagInt8",
        (pANTLR3_UINT8) "TagInt9",
        (pANTLR3_UINT8) "TeletexTag",
        (pANTLR3_UINT8) "TrueTag",
        (pANTLR3_UINT8) "UNOTICEOID",
        (pANTLR3_UINT8) "UTCTag",
        (pANTLR3_UINT8) "UTF8Tag",
        (pANTLR3_UINT8) "UniverStringTag",
        (pANTLR3_UINT8) "VAL",
        (pANTLR3_UINT8) "VAL2",
        (pANTLR3_UINT8) "VAL4",
        (pANTLR3_UINT8) "VALUE",
        (pANTLR3_UINT8) "VideoStringTag",
        (pANTLR3_UINT8) "VisibleStringTag"
       };



// Forward declare the locally static matching functions we have generated.
//
static 
 RFC5280Parser_prog_return
	prog    (pRFC5280Parser ctx);
static 
 RFC5280Parser_certificate_return
	certificate    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tbscertificate_return
	tbscertificate    (pRFC5280Parser ctx);
static 
 RFC5280Parser_algorithm_id_return
	algorithm_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsa_md2_alg_id_return
	rsa_md2_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsa_md5_alg_id_return
	rsa_md5_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsa_sha1_alg_id_return
	rsa_sha1_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsa_sha224_alg_id_return
	rsa_sha224_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsa_sha256_alg_id_return
	rsa_sha256_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsa_sha384_alg_id_return
	rsa_sha384_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsa_sha512_alg_id_return
	rsa_sha512_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dsa_sha_alg_id_return
	dsa_sha_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dsa_sha224_alg_id_return
	dsa_sha224_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dsa_sha256_alg_id_return
	dsa_sha256_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ec_sha_alg_id_return
	ec_sha_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ec_sha224_alg_id_return
	ec_sha224_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ec_sha256_alg_id_return
	ec_sha256_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ec_sha384_alg_id_return
	ec_sha384_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ec_sha512_alg_id_return
	ec_sha512_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsa_alg_id_return
	rsa_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dsa_alg_id_return
	dsa_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dh_alg_id_return
	dh_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_kea_alg_id_return
	kea_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ec_alg_id_return
	ec_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ecParams_return
	ecParams    (pRFC5280Parser ctx);
static 
 RFC5280Parser_field_id_return
	field_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_pss_alg_id_return
	pss_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_pss_alg_id_params_return
	pss_alg_id_params    (pRFC5280Parser ctx);
static 
 RFC5280Parser_oaep_alg_id_return
	oaep_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_hash_alg_return
	hash_alg    (pRFC5280Parser ctx);
static 
 RFC5280Parser_mask_gen_alg_return
	mask_gen_alg    (pRFC5280Parser ctx);
static 
 RFC5280Parser_gost_94_alg_id_return
	gost_94_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_gost_01_alg_id_return
	gost_01_alg_id    (pRFC5280Parser ctx);
static 
 RFC5280Parser_version_return
	version    (pRFC5280Parser ctx);
static 
 RFC5280Parser_version2_return
	version2    (pRFC5280Parser ctx);
static 
 RFC5280Parser_version3_return
	version3    (pRFC5280Parser ctx);
static 
 RFC5280Parser_serialnumber_return
	serialnumber    (pRFC5280Parser ctx);
static 
 RFC5280Parser_issuer_return
	issuer    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subject_return
	subject    (pRFC5280Parser ctx);
static 
 RFC5280Parser_validity_return
	validity    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subjectPKinfo_return
	subjectPKinfo    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsapk_return
	rsapk    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dsapk_return
	dsapk    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dhpk_return
	dhpk    (pRFC5280Parser ctx);
static 
 RFC5280Parser_keapk_return
	keapk    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ecpk_return
	ecpk    (pRFC5280Parser ctx);
static 
 RFC5280Parser_gostpk_return
	gostpk    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsapsspk_return
	rsapsspk    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsaoaep_return
	rsaoaep    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subjectuniqueId_return
	subjectuniqueId    (pRFC5280Parser ctx);
static 
 RFC5280Parser_issueruniqueId_return
	issueruniqueId    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsWithSubAlt_return
	extensionsWithSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNoSkiSubAlt_return
	extensionsNoSkiSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensions_return
	extensions    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNoSki_return
	extensionsNoSki    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNoPathLenSubAlt_return
	extensionsNoPathLenSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNoPathLen_return
	extensionsNoPathLen    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNoPathLenNoSkiSubAlt_return
	extensionsNoPathLenNoSkiSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNoPathLenNoSki_return
	extensionsNoPathLenNoSki    (pRFC5280Parser ctx);
static 
 RFC5280Parser_notDependentExtsSubAlt_return
	notDependentExtsSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_notDependentExts_return
	notDependentExts    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsCertSignSubAlt_return
	extensionsCertSignSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsCertSign_return
	extensionsCertSign    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsCertSignAndSkiSubAlt_return
	extensionsCertSignAndSkiSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsCertSignAndSki_return
	extensionsCertSignAndSki    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotCertSignSubAlt_return
	extensionsNotCertSignSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotCertSign_return
	extensionsNotCertSign    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return
	extensionsNotCertSignAndSkiSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotCertSignAndSki_return
	extensionsNotCertSignAndSki    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extension_return
	extension    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionNoSubAlt_return
	extensionNoSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_genericExt_return
	genericExt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_authKeyId_return
	authKeyId    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subjectKeyId_return
	subjectKeyId    (pRFC5280Parser ctx);
static 
 RFC5280Parser_keyUsage_return
	keyUsage    (pRFC5280Parser ctx);
static 
 RFC5280Parser_keyUsageCommon_return
	keyUsageCommon    (pRFC5280Parser ctx);
static 
 RFC5280Parser_certPolicies_return
	certPolicies    (pRFC5280Parser ctx);
static 
 RFC5280Parser_policies_return
	policies    (pRFC5280Parser ctx);
static 
 RFC5280Parser_policyInfo_return
	policyInfo    (pRFC5280Parser ctx);
static 
 RFC5280Parser_policyQualifiers_return
	policyQualifiers    (pRFC5280Parser ctx);
static 
 RFC5280Parser_qualifier_return
	qualifier    (pRFC5280Parser ctx);
static 
 RFC5280Parser_policyQualifiersAnyPolicy_return
	policyQualifiersAnyPolicy    (pRFC5280Parser ctx);
static 
 RFC5280Parser_qualifierAnyPolicy_return
	qualifierAnyPolicy    (pRFC5280Parser ctx);
static 
 RFC5280Parser_cps_return
	cps    (pRFC5280Parser ctx);
static 
 RFC5280Parser_unotice_return
	unotice    (pRFC5280Parser ctx);
static 
 RFC5280Parser_displayTextString_return
	displayTextString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_noticeref_return
	noticeref    (pRFC5280Parser ctx);
static 
 RFC5280Parser_noticeNumbers_return
	noticeNumbers    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subAltName_return
	subAltName    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subAltNameCritical_return
	subAltNameCritical    (pRFC5280Parser ctx);
static 
 RFC5280Parser_issuerAltName_return
	issuerAltName    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subDirAttr_return
	subDirAttr    (pRFC5280Parser ctx);
static 
 RFC5280Parser_attributes_return
	attributes    (pRFC5280Parser ctx);
static 
 RFC5280Parser_attribute_return
	attribute    (pRFC5280Parser ctx);
static 
 RFC5280Parser_basicConstraints_return
	basicConstraints    (pRFC5280Parser ctx);
static 
 RFC5280Parser_basicConstraintsNotCritical_return
	basicConstraintsNotCritical    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extendKeyUsage_return
	extendKeyUsage    (pRFC5280Parser ctx);
static 
 RFC5280Parser_usages_return
	usages    (pRFC5280Parser ctx);
static 
 RFC5280Parser_usage_return
	usage    (pRFC5280Parser ctx);
static 
 RFC5280Parser_crldp_return
	crldp    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dps_return
	dps    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dp_return
	dp    (pRFC5280Parser ctx);
static 
 RFC5280Parser_freshcrl_return
	freshcrl    (pRFC5280Parser ctx);
static 
 RFC5280Parser_aia_return
	aia    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ads_return
	ads    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ad_return
	ad    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sia_return
	sia    (pRFC5280Parser ctx);
static 
 RFC5280Parser_siaads_return
	siaads    (pRFC5280Parser ctx);
static 
 RFC5280Parser_adsia_return
	adsia    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dependentExtension_return
	dependentExtension    (pRFC5280Parser ctx);
static 
 RFC5280Parser_inhibitAnyPolicy_return
	inhibitAnyPolicy    (pRFC5280Parser ctx);
static 
 RFC5280Parser_policyConstraints_return
	policyConstraints    (pRFC5280Parser ctx);
static 
 RFC5280Parser_nameConstraints_return
	nameConstraints    (pRFC5280Parser ctx);
static 
 RFC5280Parser_generalSubtrees_return
	generalSubtrees    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subtree_return
	subtree    (pRFC5280Parser ctx);
static 
 RFC5280Parser_policyMappings_return
	policyMappings    (pRFC5280Parser ctx);
static 
 RFC5280Parser_mappings_return
	mappings    (pRFC5280Parser ctx);
static 
 RFC5280Parser_basicConstraintsCA_return
	basicConstraintsCA    (pRFC5280Parser ctx);
static 
 RFC5280Parser_basicConstraintsCANoSki_return
	basicConstraintsCANoSki    (pRFC5280Parser ctx);
static 
 RFC5280Parser_basicConstraintsCANoSkiSubAlt_return
	basicConstraintsCANoSkiSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_basicConstraintsCASubAlt_return
	basicConstraintsCASubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCAandSkiSubAlt_return
	extensionsMustBeCAandSkiSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCAandSki_return
	extensionsMustBeCAandSki    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCASubAlt_return
	extensionsMustBeCASubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCA_return
	extensionsMustBeCA    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCaAndSkiNoPathLenSubAlt_return
	extensionsMustBeCaAndSkiNoPathLenSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCaAndSkiNoPathLen_return
	extensionsMustBeCaAndSkiNoPathLen    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCaSubAlt_return
	extensionsMustBeCaSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCa_return
	extensionsMustBeCa    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCaAndSkiSubAlt_return
	extensionsMustBeCaAndSkiSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCaAndSki_return
	extensionsMustBeCaAndSki    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return
	extensionsMustBeCaNoPathLenSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsMustBeCaNoPathLen_return
	extensionsMustBeCaNoPathLen    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return
	extensionsNotBCNotKeyUsageNotSkiSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return
	extensionsNotBCNotKeyUsageNotSki    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return
	extensionsNotBCNotKeyUsageNotSkiNoSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return
	extensionsNotBCNotKeyUsageSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotBCNotKeyUsage_return
	extensionsNotBCNotKeyUsage    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotBCSubAlt_return
	extensionsNotBCSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotBC_return
	extensionsNotBC    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotBCNotSkiSubAlt_return
	extensionsNotBCNotSkiSubAlt    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionsNotBCNotSki_return
	extensionsNotBCNotSki    (pRFC5280Parser ctx);
static 
 RFC5280Parser_generalNames_return
	generalNames    (pRFC5280Parser ctx);
static 
 RFC5280Parser_generalName_return
	generalName    (pRFC5280Parser ctx);
static 
 RFC5280Parser_othername_return
	othername    (pRFC5280Parser ctx);
static 
 RFC5280Parser_edipartyname_return
	edipartyname    (pRFC5280Parser ctx);
static 
 RFC5280Parser_standardAttrs_return
	standardAttrs    (pRFC5280Parser ctx);
static 
 RFC5280Parser_countryName_return
	countryName    (pRFC5280Parser ctx);
static 
 RFC5280Parser_adName_return
	adName    (pRFC5280Parser ctx);
static 
 RFC5280Parser_definedAttrs_return
	definedAttrs    (pRFC5280Parser ctx);
static 
 RFC5280Parser_definedAttr_return
	definedAttr    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionAttrs_return
	extensionAttrs    (pRFC5280Parser ctx);
static 
 RFC5280Parser_extensionAttr_return
	extensionAttr    (pRFC5280Parser ctx);
static 
 RFC5280Parser_name_return
	name    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rdns_return
	rdns    (pRFC5280Parser ctx);
static 
 RFC5280Parser_notEmptyName_return
	notEmptyName    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rdnsNotEmpty_return
	rdnsNotEmpty    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rdn_return
	rdn    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dn_return
	dn    (pRFC5280Parser ctx);
static 
 RFC5280Parser_directoryString_return
	directoryString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_signature_return
	signature    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dsa_signature_return
	dsa_signature    (pRFC5280Parser ctx);
static 
 RFC5280Parser_critical_return
	critical    (pRFC5280Parser ctx);
static 
 RFC5280Parser_time_span_return
	time_span    (pRFC5280Parser ctx);
static 
 RFC5280Parser_any_return
	any    (pRFC5280Parser ctx);
static 
 RFC5280Parser_anyToken_return
	anyToken    (pRFC5280Parser ctx);
static 
 RFC5280Parser_octetstring_return
	octetstring    (pRFC5280Parser ctx);
static 
 RFC5280Parser_integer_return
	integer    (pRFC5280Parser ctx);
static 
 RFC5280Parser_integerAbove3_return
	integerAbove3    (pRFC5280Parser ctx);
static 
 RFC5280Parser_int0_return
	int0    (pRFC5280Parser ctx);
static 
 RFC5280Parser_int1_return
	int1    (pRFC5280Parser ctx);
static 
 RFC5280Parser_int2_return
	int2    (pRFC5280Parser ctx);
static 
 RFC5280Parser_bitstring_return
	bitstring    (pRFC5280Parser ctx);
static 
 RFC5280Parser_bitstringCertSign_return
	bitstringCertSign    (pRFC5280Parser ctx);
static 
 RFC5280Parser_oid_return
	oid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_cnoid_return
	cnoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_oidon_return
	oidon    (pRFC5280Parser ctx);
static 
 RFC5280Parser_aiaoid_return
	aiaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_siaoid_return
	siaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_akioid_return
	akioid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_skioid_return
	skioid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_bcoid_return
	bcoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_polconstraintsoid_return
	polconstraintsoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_certpolioid_return
	certpolioid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_polmapoid_return
	polmapoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_keyusageoid_return
	keyusageoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subaltoid_return
	subaltoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_issaltoid_return
	issaltoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_subdiroid_return
	subdiroid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_nameoid_return
	nameoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ekuoid_return
	ekuoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_crldpoid_return
	crldpoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_inhibitanyoid_return
	inhibitanyoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_freshcrloid_return
	freshcrloid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_caissueroid_return
	caissueroid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ocspoid_return
	ocspoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_carepooid_return
	carepooid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tspoid_return
	tspoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_cpsoid_return
	cpsoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_unoticeoid_return
	unoticeoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_oidname_return
	oidname    (pRFC5280Parser ctx);
static 
 RFC5280Parser_surnameoid_return
	surnameoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_givenoid_return
	givenoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_initoid_return
	initoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_genqualifieroid_return
	genqualifieroid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_localoid_return
	localoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sorpoid_return
	sorpoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ouoid_return
	ouoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_titleoid_return
	titleoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dnoid_return
	dnoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_countryoid_return
	countryoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_serialoid_return
	serialoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_pseudooid_return
	pseudooid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsapkoid_return
	rsapkoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dsapkoid_return
	dsapkoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_dhpkoid_return
	dhpkoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_keapkoid_return
	keapkoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ecpkoid_return
	ecpkoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_primeoid_return
	primeoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_basis2oid_return
	basis2oid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_gnoid_return
	gnoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tpoid_return
	tpoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ppoid_return
	ppoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha1oid_return
	sha1oid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha224oid_return
	sha224oid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha256oid_return
	sha256oid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha384oid_return
	sha384oid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha512oid_return
	sha512oid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_mgf1oid_return
	mgf1oid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsapssoid_return
	rsapssoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_rsaoaepoid_return
	rsaoaepoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_pspecoid_return
	pspecoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_md2rsaoid_return
	md2rsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_md5rsaoid_return
	md5rsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha1rsaoid_return
	sha1rsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha224rsaoid_return
	sha224rsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha256rsaoid_return
	sha256rsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha384rsaoid_return
	sha384rsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha512rsaoid_return
	sha512rsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha1dsaoid_return
	sha1dsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha224dsaoid_return
	sha224dsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha256dsaoid_return
	sha256dsaoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha1ecoid_return
	sha1ecoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha224ecoid_return
	sha224ecoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha256ecoid_return
	sha256ecoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha384ecoid_return
	sha384ecoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sha512ecoid_return
	sha512ecoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_gost94pkoid_return
	gost94pkoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_gost01pkoid_return
	gost01pkoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_gost94signoid_return
	gost94signoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_gost01signoid_return
	gost01signoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_serverauthoid_return
	serverauthoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_clientauthoid_return
	clientauthoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_codesignoid_return
	codesignoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_emailprotectoid_return
	emailprotectoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_timestampoid_return
	timestampoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ocspsignoid_return
	ocspsignoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_anyusageoid_return
	anyusageoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_anypolicyoid_return
	anypolicyoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_legacyemailoid_return
	legacyemailoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ecdhoid_return
	ecdhoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ecmqvoid_return
	ecmqvoid    (pRFC5280Parser ctx);
static 
 RFC5280Parser_printString_return
	printString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_ia5String_return
	ia5String    (pRFC5280Parser ctx);
static 
 RFC5280Parser_utc_return
	utc    (pRFC5280Parser ctx);
static 
 RFC5280Parser_genTime_return
	genTime    (pRFC5280Parser ctx);
static 
 RFC5280Parser_truevalue_return
	truevalue    (pRFC5280Parser ctx);
static 
 RFC5280Parser_falsevalue_return
	falsevalue    (pRFC5280Parser ctx);
static 
 RFC5280Parser_utf8String_return
	utf8String    (pRFC5280Parser ctx);
static 
 RFC5280Parser_teletexString_return
	teletexString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_bmpString_return
	bmpString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_univerString_return
	univerString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_visibleString_return
	visibleString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_numericString_return
	numericString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_generalString_return
	generalString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_graphicString_return
	graphicString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_videoString_return
	videoString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_null_return
	null    (pRFC5280Parser ctx);
static 
 RFC5280Parser_sequenceTag_return
	sequenceTag    (pRFC5280Parser ctx);
static 
 RFC5280Parser_set_return
	set    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedOctetString_return
	constructedOctetString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedBitString_return
	constructedBitString    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedTag0_return
	constructedTag0    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tag0_return
	tag0    (pRFC5280Parser ctx);
static 
 RFC5280Parser_onlyTag0_return
	onlyTag0    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedTag1_return
	constructedTag1    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tag1_return
	tag1    (pRFC5280Parser ctx);
static 
 RFC5280Parser_appTag1_return
	appTag1    (pRFC5280Parser ctx);
static 
 RFC5280Parser_appTag2_return
	appTag2    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedTag2_return
	constructedTag2    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tag2_return
	tag2    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedTag3_return
	constructedTag3    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tag3_return
	tag3    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedTag4_return
	constructedTag4    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tag4_return
	tag4    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedTag5_return
	constructedTag5    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tag5_return
	tag5    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedTag6_return
	constructedTag6    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tag6_return
	tag6    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedTag7_return
	constructedTag7    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tag7_return
	tag7    (pRFC5280Parser ctx);
static 
 RFC5280Parser_constructedTag8_return
	constructedTag8    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tag8_return
	tag8    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt1_return
	tagInt1    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt2_return
	tagInt2    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt3_return
	tagInt3    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt4_return
	tagInt4    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt5_return
	tagInt5    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt6_return
	tagInt6    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt7_return
	tagInt7    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt8_return
	tagInt8    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt9_return
	tagInt9    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt10_return
	tagInt10    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt11_return
	tagInt11    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt12_return
	tagInt12    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt13_return
	tagInt13    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt14_return
	tagInt14    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt15_return
	tagInt15    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt16_return
	tagInt16    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt17_return
	tagInt17    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt18_return
	tagInt18    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt19_return
	tagInt19    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt20_return
	tagInt20    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt21_return
	tagInt21    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt22_return
	tagInt22    (pRFC5280Parser ctx);
static 
 RFC5280Parser_tagInt23_return
	tagInt23    (pRFC5280Parser ctx);
static 
 RFC5280Parser_printable_return
	printable    (pRFC5280Parser ctx);
static 
 RFC5280Parser_val_return
	val    (pRFC5280Parser ctx);
static void	RFC5280ParserFree(pRFC5280Parser ctx);
static void     RFC5280ParserReset (pRFC5280Parser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "Grammar/RFC5280.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new RFC5280Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pRFC5280Parser
RFC5280ParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return RFC5280ParserNewSSD(instream, NULL);
}

/** \brief Create a new RFC5280Parser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pRFC5280Parser
RFC5280ParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pRFC5280Parser ctx;	    /* Context structure we will build and return   */

    ctx	= (pRFC5280Parser) ANTLR3_CALLOC(1, sizeof(RFC5280Parser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in RFC5280Parser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our RFC5280Parser interface
     */
    ctx->prog	= prog;
    ctx->certificate	= certificate;
    ctx->tbscertificate	= tbscertificate;
    ctx->algorithm_id	= algorithm_id;
    ctx->rsa_md2_alg_id	= rsa_md2_alg_id;
    ctx->rsa_md5_alg_id	= rsa_md5_alg_id;
    ctx->rsa_sha1_alg_id	= rsa_sha1_alg_id;
    ctx->rsa_sha224_alg_id	= rsa_sha224_alg_id;
    ctx->rsa_sha256_alg_id	= rsa_sha256_alg_id;
    ctx->rsa_sha384_alg_id	= rsa_sha384_alg_id;
    ctx->rsa_sha512_alg_id	= rsa_sha512_alg_id;
    ctx->dsa_sha_alg_id	= dsa_sha_alg_id;
    ctx->dsa_sha224_alg_id	= dsa_sha224_alg_id;
    ctx->dsa_sha256_alg_id	= dsa_sha256_alg_id;
    ctx->ec_sha_alg_id	= ec_sha_alg_id;
    ctx->ec_sha224_alg_id	= ec_sha224_alg_id;
    ctx->ec_sha256_alg_id	= ec_sha256_alg_id;
    ctx->ec_sha384_alg_id	= ec_sha384_alg_id;
    ctx->ec_sha512_alg_id	= ec_sha512_alg_id;
    ctx->rsa_alg_id	= rsa_alg_id;
    ctx->dsa_alg_id	= dsa_alg_id;
    ctx->dh_alg_id	= dh_alg_id;
    ctx->kea_alg_id	= kea_alg_id;
    ctx->ec_alg_id	= ec_alg_id;
    ctx->ecParams	= ecParams;
    ctx->field_id	= field_id;
    ctx->pss_alg_id	= pss_alg_id;
    ctx->pss_alg_id_params	= pss_alg_id_params;
    ctx->oaep_alg_id	= oaep_alg_id;
    ctx->hash_alg	= hash_alg;
    ctx->mask_gen_alg	= mask_gen_alg;
    ctx->gost_94_alg_id	= gost_94_alg_id;
    ctx->gost_01_alg_id	= gost_01_alg_id;
    ctx->version	= version;
    ctx->version2	= version2;
    ctx->version3	= version3;
    ctx->serialnumber	= serialnumber;
    ctx->issuer	= issuer;
    ctx->subject	= subject;
    ctx->validity	= validity;
    ctx->subjectPKinfo	= subjectPKinfo;
    ctx->rsapk	= rsapk;
    ctx->dsapk	= dsapk;
    ctx->dhpk	= dhpk;
    ctx->keapk	= keapk;
    ctx->ecpk	= ecpk;
    ctx->gostpk	= gostpk;
    ctx->rsapsspk	= rsapsspk;
    ctx->rsaoaep	= rsaoaep;
    ctx->subjectuniqueId	= subjectuniqueId;
    ctx->issueruniqueId	= issueruniqueId;
    ctx->extensionsWithSubAlt	= extensionsWithSubAlt;
    ctx->extensionsNoSkiSubAlt	= extensionsNoSkiSubAlt;
    ctx->extensions	= extensions;
    ctx->extensionsNoSki	= extensionsNoSki;
    ctx->extensionsNoPathLenSubAlt	= extensionsNoPathLenSubAlt;
    ctx->extensionsNoPathLen	= extensionsNoPathLen;
    ctx->extensionsNoPathLenNoSkiSubAlt	= extensionsNoPathLenNoSkiSubAlt;
    ctx->extensionsNoPathLenNoSki	= extensionsNoPathLenNoSki;
    ctx->notDependentExtsSubAlt	= notDependentExtsSubAlt;
    ctx->notDependentExts	= notDependentExts;
    ctx->extensionsCertSignSubAlt	= extensionsCertSignSubAlt;
    ctx->extensionsCertSign	= extensionsCertSign;
    ctx->extensionsCertSignAndSkiSubAlt	= extensionsCertSignAndSkiSubAlt;
    ctx->extensionsCertSignAndSki	= extensionsCertSignAndSki;
    ctx->extensionsNotCertSignSubAlt	= extensionsNotCertSignSubAlt;
    ctx->extensionsNotCertSign	= extensionsNotCertSign;
    ctx->extensionsNotCertSignAndSkiSubAlt	= extensionsNotCertSignAndSkiSubAlt;
    ctx->extensionsNotCertSignAndSki	= extensionsNotCertSignAndSki;
    ctx->extension	= extension;
    ctx->extensionNoSubAlt	= extensionNoSubAlt;
    ctx->genericExt	= genericExt;
    ctx->authKeyId	= authKeyId;
    ctx->subjectKeyId	= subjectKeyId;
    ctx->keyUsage	= keyUsage;
    ctx->keyUsageCommon	= keyUsageCommon;
    ctx->certPolicies	= certPolicies;
    ctx->policies	= policies;
    ctx->policyInfo	= policyInfo;
    ctx->policyQualifiers	= policyQualifiers;
    ctx->qualifier	= qualifier;
    ctx->policyQualifiersAnyPolicy	= policyQualifiersAnyPolicy;
    ctx->qualifierAnyPolicy	= qualifierAnyPolicy;
    ctx->cps	= cps;
    ctx->unotice	= unotice;
    ctx->displayTextString	= displayTextString;
    ctx->noticeref	= noticeref;
    ctx->noticeNumbers	= noticeNumbers;
    ctx->subAltName	= subAltName;
    ctx->subAltNameCritical	= subAltNameCritical;
    ctx->issuerAltName	= issuerAltName;
    ctx->subDirAttr	= subDirAttr;
    ctx->attributes	= attributes;
    ctx->attribute	= attribute;
    ctx->basicConstraints	= basicConstraints;
    ctx->basicConstraintsNotCritical	= basicConstraintsNotCritical;
    ctx->extendKeyUsage	= extendKeyUsage;
    ctx->usages	= usages;
    ctx->usage	= usage;
    ctx->crldp	= crldp;
    ctx->dps	= dps;
    ctx->dp	= dp;
    ctx->freshcrl	= freshcrl;
    ctx->aia	= aia;
    ctx->ads	= ads;
    ctx->ad	= ad;
    ctx->sia	= sia;
    ctx->siaads	= siaads;
    ctx->adsia	= adsia;
    ctx->dependentExtension	= dependentExtension;
    ctx->inhibitAnyPolicy	= inhibitAnyPolicy;
    ctx->policyConstraints	= policyConstraints;
    ctx->nameConstraints	= nameConstraints;
    ctx->generalSubtrees	= generalSubtrees;
    ctx->subtree	= subtree;
    ctx->policyMappings	= policyMappings;
    ctx->mappings	= mappings;
    ctx->basicConstraintsCA	= basicConstraintsCA;
    ctx->basicConstraintsCANoSki	= basicConstraintsCANoSki;
    ctx->basicConstraintsCANoSkiSubAlt	= basicConstraintsCANoSkiSubAlt;
    ctx->basicConstraintsCASubAlt	= basicConstraintsCASubAlt;
    ctx->extensionsMustBeCAandSkiSubAlt	= extensionsMustBeCAandSkiSubAlt;
    ctx->extensionsMustBeCAandSki	= extensionsMustBeCAandSki;
    ctx->extensionsMustBeCASubAlt	= extensionsMustBeCASubAlt;
    ctx->extensionsMustBeCA	= extensionsMustBeCA;
    ctx->extensionsMustBeCaAndSkiNoPathLenSubAlt	= extensionsMustBeCaAndSkiNoPathLenSubAlt;
    ctx->extensionsMustBeCaAndSkiNoPathLen	= extensionsMustBeCaAndSkiNoPathLen;
    ctx->extensionsMustBeCaSubAlt	= extensionsMustBeCaSubAlt;
    ctx->extensionsMustBeCa	= extensionsMustBeCa;
    ctx->extensionsMustBeCaAndSkiSubAlt	= extensionsMustBeCaAndSkiSubAlt;
    ctx->extensionsMustBeCaAndSki	= extensionsMustBeCaAndSki;
    ctx->extensionsMustBeCaNoPathLenSubAlt	= extensionsMustBeCaNoPathLenSubAlt;
    ctx->extensionsMustBeCaNoPathLen	= extensionsMustBeCaNoPathLen;
    ctx->extensionsNotBCNotKeyUsageNotSkiSubAlt	= extensionsNotBCNotKeyUsageNotSkiSubAlt;
    ctx->extensionsNotBCNotKeyUsageNotSki	= extensionsNotBCNotKeyUsageNotSki;
    ctx->extensionsNotBCNotKeyUsageNotSkiNoSubAlt	= extensionsNotBCNotKeyUsageNotSkiNoSubAlt;
    ctx->extensionsNotBCNotKeyUsageSubAlt	= extensionsNotBCNotKeyUsageSubAlt;
    ctx->extensionsNotBCNotKeyUsage	= extensionsNotBCNotKeyUsage;
    ctx->extensionsNotBCSubAlt	= extensionsNotBCSubAlt;
    ctx->extensionsNotBC	= extensionsNotBC;
    ctx->extensionsNotBCNotSkiSubAlt	= extensionsNotBCNotSkiSubAlt;
    ctx->extensionsNotBCNotSki	= extensionsNotBCNotSki;
    ctx->generalNames	= generalNames;
    ctx->generalName	= generalName;
    ctx->othername	= othername;
    ctx->edipartyname	= edipartyname;
    ctx->standardAttrs	= standardAttrs;
    ctx->countryName	= countryName;
    ctx->adName	= adName;
    ctx->definedAttrs	= definedAttrs;
    ctx->definedAttr	= definedAttr;
    ctx->extensionAttrs	= extensionAttrs;
    ctx->extensionAttr	= extensionAttr;
    ctx->name	= name;
    ctx->rdns	= rdns;
    ctx->notEmptyName	= notEmptyName;
    ctx->rdnsNotEmpty	= rdnsNotEmpty;
    ctx->rdn	= rdn;
    ctx->dn	= dn;
    ctx->directoryString	= directoryString;
    ctx->signature	= signature;
    ctx->dsa_signature	= dsa_signature;
    ctx->critical	= critical;
    ctx->time_span	= time_span;
    ctx->any	= any;
    ctx->anyToken	= anyToken;
    ctx->octetstring	= octetstring;
    ctx->integer	= integer;
    ctx->integerAbove3	= integerAbove3;
    ctx->int0	= int0;
    ctx->int1	= int1;
    ctx->int2	= int2;
    ctx->bitstring	= bitstring;
    ctx->bitstringCertSign	= bitstringCertSign;
    ctx->oid	= oid;
    ctx->cnoid	= cnoid;
    ctx->oidon	= oidon;
    ctx->aiaoid	= aiaoid;
    ctx->siaoid	= siaoid;
    ctx->akioid	= akioid;
    ctx->skioid	= skioid;
    ctx->bcoid	= bcoid;
    ctx->polconstraintsoid	= polconstraintsoid;
    ctx->certpolioid	= certpolioid;
    ctx->polmapoid	= polmapoid;
    ctx->keyusageoid	= keyusageoid;
    ctx->subaltoid	= subaltoid;
    ctx->issaltoid	= issaltoid;
    ctx->subdiroid	= subdiroid;
    ctx->nameoid	= nameoid;
    ctx->ekuoid	= ekuoid;
    ctx->crldpoid	= crldpoid;
    ctx->inhibitanyoid	= inhibitanyoid;
    ctx->freshcrloid	= freshcrloid;
    ctx->caissueroid	= caissueroid;
    ctx->ocspoid	= ocspoid;
    ctx->carepooid	= carepooid;
    ctx->tspoid	= tspoid;
    ctx->cpsoid	= cpsoid;
    ctx->unoticeoid	= unoticeoid;
    ctx->oidname	= oidname;
    ctx->surnameoid	= surnameoid;
    ctx->givenoid	= givenoid;
    ctx->initoid	= initoid;
    ctx->genqualifieroid	= genqualifieroid;
    ctx->localoid	= localoid;
    ctx->sorpoid	= sorpoid;
    ctx->ouoid	= ouoid;
    ctx->titleoid	= titleoid;
    ctx->dnoid	= dnoid;
    ctx->countryoid	= countryoid;
    ctx->serialoid	= serialoid;
    ctx->pseudooid	= pseudooid;
    ctx->rsapkoid	= rsapkoid;
    ctx->dsapkoid	= dsapkoid;
    ctx->dhpkoid	= dhpkoid;
    ctx->keapkoid	= keapkoid;
    ctx->ecpkoid	= ecpkoid;
    ctx->primeoid	= primeoid;
    ctx->basis2oid	= basis2oid;
    ctx->gnoid	= gnoid;
    ctx->tpoid	= tpoid;
    ctx->ppoid	= ppoid;
    ctx->sha1oid	= sha1oid;
    ctx->sha224oid	= sha224oid;
    ctx->sha256oid	= sha256oid;
    ctx->sha384oid	= sha384oid;
    ctx->sha512oid	= sha512oid;
    ctx->mgf1oid	= mgf1oid;
    ctx->rsapssoid	= rsapssoid;
    ctx->rsaoaepoid	= rsaoaepoid;
    ctx->pspecoid	= pspecoid;
    ctx->md2rsaoid	= md2rsaoid;
    ctx->md5rsaoid	= md5rsaoid;
    ctx->sha1rsaoid	= sha1rsaoid;
    ctx->sha224rsaoid	= sha224rsaoid;
    ctx->sha256rsaoid	= sha256rsaoid;
    ctx->sha384rsaoid	= sha384rsaoid;
    ctx->sha512rsaoid	= sha512rsaoid;
    ctx->sha1dsaoid	= sha1dsaoid;
    ctx->sha224dsaoid	= sha224dsaoid;
    ctx->sha256dsaoid	= sha256dsaoid;
    ctx->sha1ecoid	= sha1ecoid;
    ctx->sha224ecoid	= sha224ecoid;
    ctx->sha256ecoid	= sha256ecoid;
    ctx->sha384ecoid	= sha384ecoid;
    ctx->sha512ecoid	= sha512ecoid;
    ctx->gost94pkoid	= gost94pkoid;
    ctx->gost01pkoid	= gost01pkoid;
    ctx->gost94signoid	= gost94signoid;
    ctx->gost01signoid	= gost01signoid;
    ctx->serverauthoid	= serverauthoid;
    ctx->clientauthoid	= clientauthoid;
    ctx->codesignoid	= codesignoid;
    ctx->emailprotectoid	= emailprotectoid;
    ctx->timestampoid	= timestampoid;
    ctx->ocspsignoid	= ocspsignoid;
    ctx->anyusageoid	= anyusageoid;
    ctx->anypolicyoid	= anypolicyoid;
    ctx->legacyemailoid	= legacyemailoid;
    ctx->ecdhoid	= ecdhoid;
    ctx->ecmqvoid	= ecmqvoid;
    ctx->printString	= printString;
    ctx->ia5String	= ia5String;
    ctx->utc	= utc;
    ctx->genTime	= genTime;
    ctx->truevalue	= truevalue;
    ctx->falsevalue	= falsevalue;
    ctx->utf8String	= utf8String;
    ctx->teletexString	= teletexString;
    ctx->bmpString	= bmpString;
    ctx->univerString	= univerString;
    ctx->visibleString	= visibleString;
    ctx->numericString	= numericString;
    ctx->generalString	= generalString;
    ctx->graphicString	= graphicString;
    ctx->videoString	= videoString;
    ctx->null	= null;
    ctx->sequenceTag	= sequenceTag;
    ctx->set	= set;
    ctx->constructedOctetString	= constructedOctetString;
    ctx->constructedBitString	= constructedBitString;
    ctx->constructedTag0	= constructedTag0;
    ctx->tag0	= tag0;
    ctx->onlyTag0	= onlyTag0;
    ctx->constructedTag1	= constructedTag1;
    ctx->tag1	= tag1;
    ctx->appTag1	= appTag1;
    ctx->appTag2	= appTag2;
    ctx->constructedTag2	= constructedTag2;
    ctx->tag2	= tag2;
    ctx->constructedTag3	= constructedTag3;
    ctx->tag3	= tag3;
    ctx->constructedTag4	= constructedTag4;
    ctx->tag4	= tag4;
    ctx->constructedTag5	= constructedTag5;
    ctx->tag5	= tag5;
    ctx->constructedTag6	= constructedTag6;
    ctx->tag6	= tag6;
    ctx->constructedTag7	= constructedTag7;
    ctx->tag7	= tag7;
    ctx->constructedTag8	= constructedTag8;
    ctx->tag8	= tag8;
    ctx->tagInt1	= tagInt1;
    ctx->tagInt2	= tagInt2;
    ctx->tagInt3	= tagInt3;
    ctx->tagInt4	= tagInt4;
    ctx->tagInt5	= tagInt5;
    ctx->tagInt6	= tagInt6;
    ctx->tagInt7	= tagInt7;
    ctx->tagInt8	= tagInt8;
    ctx->tagInt9	= tagInt9;
    ctx->tagInt10	= tagInt10;
    ctx->tagInt11	= tagInt11;
    ctx->tagInt12	= tagInt12;
    ctx->tagInt13	= tagInt13;
    ctx->tagInt14	= tagInt14;
    ctx->tagInt15	= tagInt15;
    ctx->tagInt16	= tagInt16;
    ctx->tagInt17	= tagInt17;
    ctx->tagInt18	= tagInt18;
    ctx->tagInt19	= tagInt19;
    ctx->tagInt20	= tagInt20;
    ctx->tagInt21	= tagInt21;
    ctx->tagInt22	= tagInt22;
    ctx->tagInt23	= tagInt23;
    ctx->printable	= printable;
    ctx->val	= val;
    ctx->free			= RFC5280ParserFree;
    ctx->reset			= RFC5280ParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
    	RECOGNIZER->displayRecognitionError = errorHandling ;
    	RECOGNIZER->getMissingSymbol = missingHandling;
    	RECOGNIZER->mismatch = mismatchHandling;

    /* Install the token table
     */
    PSRSTATE->tokenNames   = RFC5280ParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
RFC5280ParserReset (pRFC5280Parser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 RFC5280ParserFree(pRFC5280Parser ctx)
 {
    /* Free any scope memory
     */

ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return RFC5280ParserTokenNames;
}


    #define _empty NULL


    oid_list *exts_list;
    oid_list *policies_list;

    counter *counter_list;
    counter *set_pointer;
    counter *any_pointer;
    counter *sequence_pointer;
    counter *general_name_pointer;
    cert_info cert_init = {1,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,0,0,0,255,0,NULL};
    struct asn1_string_st *default_salt;
    struct asn1_string_st *default_trailer;
    ASN1_OBJECT *default_encryption;
    STACK_OF(X509_DNAME_ENTRY) *dname;
    GEN_NAME *gen_name;
    const unsigned char data_salt[1] = {20};
    const unsigned char data_trailer[1] = {1};
    const unsigned char min_base_distance[1]={0};
    x509_EXTENSION *key_usage_ext;
    x509_EXTENSION *bc_ext;
    unsigned char eku_mask = 0;
    int ca_repo = 0;
    int tsp = 0;

    unsigned int compute_len(char* bytes,mpz_t value)
    {
    	if((unsigned char) bytes[1] < 128)
    	{
    		mpz_add_ui(value,value,(unsigned int) bytes[1]);
    		return 2;
    	}
    	mpz_t bytevalue,position;
    	mpz_init(bytevalue);
    	mpz_init_set_ui(position,1);
    	int i;
    	int len = (unsigned char) bytes[1] - 128;
    	for(i=len+1;i>1;i--)
    	{
    		mpz_mul_ui(bytevalue,position,(unsigned char) bytes[i]);
    		mpz_add(value,value,bytevalue);
    		mpz_mul_ui(position,position,256);
    		//value += ((unsigned char) bytes[i])*position;
    		//position *= 256;
    	}
    	return len+2;
    }


    void compute_integer(char* bytes,mpz_t length,mpz_t value)
    {
    	mpz_t bytevalue,position,i;
    	mpz_init(bytevalue);
    	mpz_init_set_ui(position,1);
    	mpz_init_set(i,length);
    	for(mpz_sub_ui(i,i,1);mpz_cmp_ui(i,0)>0;mpz_sub_ui(i,i,1))
    	{
    		mpz_mul_ui(bytevalue,position,(unsigned char) bytes[mpz_get_ui(i)]);
    		mpz_add(value,value,bytevalue);
    		mpz_mul_ui(position,position,256);
    		/*value += ((unsigned char) bytes[i])*position;
    		position *= 256;*/
    	}
    	mpz_mul_si(bytevalue,position,bytes[0]);
    	mpz_add(value,value,bytevalue);
    }


    int compute_oid_value(char *bytes,int len,mpz_t *test)
    {
        int i=1;
        if((unsigned char) bytes[len-1] > 127)
        	exit(BAD_OID_TERMINATOR_ERROR);
        if((unsigned char) bytes[0]<128)
        if ((unsigned char) bytes[0] < 40)
        {
            mpz_init_set_ui(test[0],0);
            mpz_init_set_ui(test[1],(unsigned char) bytes[0]);
        }
        else if ((unsigned char) bytes[0] < 80)
        {
            mpz_init_set_ui(test[0],1);
            mpz_init_set_ui(test[1],(unsigned char) bytes[0]-40);
        }
        else
        {
            mpz_init_set_ui(test[0],2);
            mpz_init_set_ui(test[1],(unsigned char) bytes[0]-80);
        }
        else
        {
            mpz_init_set_ui(test[0],2);
            mpz_init_set_ui(test[1],(unsigned char) bytes[0]-128);
            for(i=1;i<len;i++)
            {
            if((unsigned char) bytes[i] < 128)
            {
                //test[1] = 128*test[1] + (unsigned char) argv[i];
                mpz_mul_ui(test[1],test[1],128);
                mpz_add_ui(test[1],test[1],(unsigned char) bytes[1]);
    	    if(mpz_cmp_ui(test[1],268435455)>0)
    	    	exit(OID_ARC_OVERFLOW_ERROR);
    	    i++;
                break;
            }
            else
            {
                //test[1] = 128*test[1] + ((unsigned char) argv[i]) - 128;
                mpz_mul_ui(test[1],test[1],128);
                mpz_add_ui(test[1],test[1],(unsigned char) bytes[1] -128);
            
            }
            }
            mpz_sub_ui(test[1],test[1],80);
        }
        int j = 2;
        mpz_init_set_ui(test[2],0);
        for(i;i<len;i++)
        {
            if((unsigned char) bytes[i] < 128)
            {
                mpz_mul_ui(test[j],test[j],128);
                mpz_add_ui(test[j],test[j],(unsigned char) bytes[i]);
                if(mpz_cmp_ui(test[j],268435455)>0)
    	    	exit(OID_ARC_OVERFLOW_ERROR);
    	    j++;
                mpz_init_set_ui(test[j],0);
            }
            else
            {
                mpz_mul_ui(test[j],test[j],128);
                mpz_add_ui(test[j],test[j],(unsigned char) bytes[i] -128);
            }
        }
        return j;
    }

    void carnot_mapping(mpz_t x,mpz_t y)
    {
        mpz_t sum;
        mpz_init(sum);
        mpz_add(sum,x,y);
        mpz_mul(x,sum,sum);
        mpz_add(x,x,sum);
        mpz_div_ui(x,x,2);
        mpz_add(x,x,y);
    }

    void compute_index(mpz_t* oid,unsigned long len,mpz_t index)
    {
    unsigned long  j;
    mpz_init_set(index,oid[0]);
        for(j=1;j<len;j++)
        {
            carnot_mapping(index,oid[j]);
        }
    }

    void compute_bitstring (char *value,unsigned long length,ASN1_STRING *bs)
    {
    	if((unsigned char) value[0] > 8)
    		exit(BAD_BITSTRING_ENCODING_ERROR);
    	unsigned char mask = 255 << (unsigned char) value[0];
    	bs->type=3;
    	bs->length = length-1;
    	bs->data = malloc(bs->length);
    	unsigned long i;
    	value[bs->length] &= mask;
    	for(i=0;i<bs->length;i++)
    		bs->data[i] = value[i+1];
    	free(value);
    }

    void check_asn1_string(ASN1_STRING *str)
    {

    	switch(str->type)
    	{
    	case 19: 	{
    		char pattern[100]="^([A-Z]|[a-z]|[0-9]|\\x20|\\-|\\/|\\+|\\(|\\)|:|=|\\?|\\.|,|')+\\z";
    		if(check_string(pattern,str->data,str->length))
    		{
    			printf("Error in Printable String %s \n",str->data);
    			exit(PRINT_STRING_REGEXP_ERROR);
    		}
    		}	break;
    	case 22:	{
    		char pattern[20] = "^[\\x01-\\x7F]+$";
    		if(check_string(pattern,str->data,str->length))
    		{
    			printf("Error in Ia5String %s \n",str->data);
    			exit(IA5_STRING_REGEXP_ERROR);
    		}
    		}	break;
    	case 30:	{
    		char pattern[250]=
    "^(\\x00[\\x01-\\xFF]|[\\x01-\\x07][\\x00-\\xFF]|\\x08([\\x00-\\x5F]|[\\xA0-\\xFF])|[\\x09-\\x1B][\\x00-\\xFF]|\\x1C([\\x00-\\x7F]|[\\xC0-\\xFF])|[\\x1D-\\x2E][\\x00-\\xFF]|\\x2F([\\x00-\\xDF]|[\\xF0-\\xFF])|[\\x30-\\xD7][\\x00-\\xFF]|[\\xE0-\\xFF][\\x00-\\xFF])+$";
    		if(check_string(pattern,str->data,str->length))
    		{
    			printf("Error in BMP String %s \n",str->data);
    			exit(BMP_STRING_REGEXP_ERROR);
    		}
    		}	break;
    	case 18:	{
    		char pattern[50]="^([A-Z]|[a-z]|[0-9]|\\x20)+\\z";
    		if(check_string(pattern,str->data,str->length))
    		{
    			printf("Error in Numeric String %s \n",str->data);
    			exit(NUMERIC_STRING_REGEXP_ERROR);
    		}
    		}	break;
    	case 20:	{
    		char pattern[250] = "^([\\x01-\\x22]|[\\x25-\\x5B]|\\x5D|\\x5F|[\\x61-\\x7A]|\\x7C|[\\x7F-\\xA8]|\\xAB|[\\xB0-\\xB8]|[\\xBB-\\xBF]|[\\xC1-\\xC8]|[\\xCA-\\xCF]|[\\xE0-\\xE4]|[\\xE6-\\xFE])+$";
    		if(check_string(pattern,str->data,str->length))
    		{
    			printf("Error in Teletex String %s \n",str->data);
    			exit(T61_STRING_REGEXP_ERROR);
    		}
    		}	break;
    	case 26:	{
    		char pattern[20]="^[\\x20-\\x7F]+\\z";
    		if(check_string(pattern,str->data,str->length))
    		{
    			printf("Error in Visible String %s \n",str->data);
    			exit(VISIBLE_STRING_REGEXP_ERROR);
    		}
    		}	break;
    	default:	break;
    	}
    }

    struct asn1_string_st * new_asn1_string(int type,int length,char* data)
    {
    		struct asn1_string_st *text;
    		text = malloc(sizeof(struct asn1_string_st));
    		text->type = type;
    		text->length = length;
    		text->data = (unsigned char *) data;
    		check_asn1_string(text);
    		return text;
    }

    int cmp_asn1_string(struct asn1_string_st *first_op,struct asn1_string_st *second_op)
    {
    	if(first_op->type != second_op->type)
    		return 0;
    	if(first_op->length != second_op->length)
    		return 0;
    	int i;
    	for(i=0;i<first_op->length;i++)
    	{
    		if(first_op->data[i] != second_op->data[i])
    			return 0;
    	}
    	return 1;
    }

    void new_alg_id(ASN1_OBJECT *obj)
    {
    cert->signature_algorithm = malloc(sizeof(ALG_ID));
    cert->signature_algorithm->oid = obj;
    cert->signature_algorithm->params=NULL;
    }

    void new_alg_id_pk(ASN1_OBJECT *obj)
    {
    cert->pkey->alg = malloc(sizeof(ALG_ID));
    cert->pkey->alg->oid = obj;
    cert->pkey->alg->params=NULL;
    }

    void new_rsa_pk(ASN1_INTEGER *n,ASN1_INTEGER *e)
    {
    	cert->pkey->pubkey = malloc(sizeof(PUBKEY));
    	cert->pkey->pubkey->rsa = malloc(sizeof(RSA_KEY));
    	cert->pkey->pubkey->rsa->n = n;
    	cert->pkey->pubkey->rsa->e = e;
    }

    new_bitstring_pk(ASN1_STRING *bs)
    {
    	cert->pkey->pubkey = malloc(sizeof(PUBKEY));
    	cert->pkey->pubkey->bitstring_encoding = bs;
    }

    int check_string(char *pattern_string,char *sub,unsigned long size)
    {
        pcre2_code *re;
        PCRE2_SPTR pattern;
        PCRE2_SPTR subject;
        int errornumber,rc;
        PCRE2_SIZE erroroffset;
        pcre2_match_data *match_data;
        
        subject = (PCRE2_SPTR) sub;
        pattern = (PCRE2_SPTR) pattern_string;
        //fprintf(stdout,"%s \n",pattern_string);
        re = pcre2_compile(pattern,PCRE2_ZERO_TERMINATED,0,&errornumber,&erroroffset,NULL);
        //fprintf(stdout,"%d %d \n",errornumber,erroroffset);
        match_data = pcre2_match_data_create_from_pattern(re, NULL);
        rc = pcre2_match(re,subject,size,0,0,match_data,NULL);
        pcre2_match_data_free(match_data);
        pcre2_code_free(re);
        return rc<0;
    }

    void insert_extension(mpz_t index)
    {
    	if(exts_list == NULL)
    	{
    	exts_list = malloc(sizeof(oid_list));
    	mpz_init_set(exts_list->index,index);
    	exts_list->next = NULL;
    	}
    	else
    	{
    	oid_list *el,*previous = NULL;
    	el = exts_list;
    	while(el != NULL)
    	{
    		int outcome = mpz_cmp(index,el->index);
    		if(outcome<0)
    		{
    			//printf("Outcome < 0 \n");
    			oid_list *new = malloc(sizeof(oid_list));
    			mpz_init_set(new->index,index);
    			new->next=el;
    			if(previous != NULL)
    				previous->next=new;
    			else
    				exts_list=new;
    			//printf("Return \n");
    			return;
    		}
    		else if(outcome == 0)
    		{
    			gmp_printf("Duplicated oid with index %Zd \n",index);
    			exit(DUPLICATED_EXTENSION);
    		}
    		previous = el;
    		el = el->next;
    	}
    	oid_list *new = malloc(sizeof(oid_list));
    	mpz_init_set(new->index,index);
    	previous->next = new;
    	new->next = NULL;
    	}
    }

    void insert_policy(mpz_t index)
    {
    	if(policies_list == NULL)
    	{
    	policies_list = malloc(sizeof(oid_list));
    	mpz_init_set(policies_list->index,index);
    	policies_list->next = NULL;
    	}
    	else
    	{
    	oid_list *el,*previous = NULL;
    	el = policies_list;
    	while(el != NULL)
    	{
    		int outcome = mpz_cmp(index,el->index);
    		if(outcome<0)
    		{
    			//printf("Outcome < 0 \n");
    			oid_list *new = malloc(sizeof(oid_list));
    			mpz_init_set(new->index,index);
    			new->next=el;
    			if(previous != NULL)
    				previous->next=new;
    			else
    				policies_list=new;
    			//printf("Return \n");
    			return;
    		}
    		else if(outcome == 0)
    		{
    			gmp_printf("Duplicated oid with index %Zd \n",index);
    			exit(DUPLICATED_POLICY);
    		}
    		previous = el;
    		el = el->next;
    	}
    	oid_list *new = malloc(sizeof(oid_list));
    	mpz_init_set(new->index,index);
    	previous->next = new;
    	new->next = NULL;
    	}
    }

    int store_value(char *value,int i,char **s,int len)
    {
    		int j,z;
    		for(j=0;j<len;j++)
    		{
    		(*s)[i]=(unsigned char) value[j];i++;
    		if(i%16==0)
    		{
    			char *t = malloc(16+i);
    			for(z=0;z<i;z++)
    				t[z]=(*s)[z];
    			free(*s);
    			*s=t;
    		}
    		}
    		return i;
    }
    #ifdef DEBUG
    void update_rule_tree()
    {
    if(rule_tree == NULL)
    {
    	rule_tree = malloc(sizeof(RULE_TREE));
    	rule_tree->rule_list = malloc(sizeof(rule));
    	rule_tree->rule_list->fname = rule_list->fname;
    	rule_tree->rule_list->next = NULL;
    	rule_tree->next =  NULL;
    	rule_tree->depth = tree_depth;
    }
    else 	if(rule_tree->depth == tree_depth)
    	{
    		rule *rule_item = malloc(sizeof(rule));
    		rule_item->fname = rule_list->fname;
    		rule_item->next = NULL;
    		rule *iterator = rule_tree->rule_list;
    		while(iterator->next != NULL)
    			iterator = iterator->next;
    		iterator->next = rule_item;
    	}
    	else if(rule_tree->depth < tree_depth)
    	{
    		RULE_TREE *new_item = malloc(sizeof(RULE_TREE));
    		new_item->depth = tree_depth;
    		new_item->next=rule_tree;
    		new_item->rule_list=malloc(sizeof(rule));
    		new_item->rule_list->fname=rule_list->fname;
    		new_item->rule_list->next=NULL;
    		rule_tree = new_item;
    	}
    	else
    	{
    		RULE_TREE *old_item = rule_tree;
    		rule_tree = old_item->next;
    		rule *iterator = old_item->rule_list;
    		rule *current_item;
    		while(iterator != NULL)
    		{
    			current_item = iterator;
    			iterator = iterator->next;
    			free(current_item);
    		}
    		free(old_item);
    		update_rule_tree();
    	}
    }

    void push_rule(char *func)
    {
    	printf("i'm in push rule %s \n",func);
    	if(rule_list == NULL)
    	{
    		rule_list = malloc(sizeof(rule));
    		//counter_list->counter = length;
    		rule_list->fname=func;
    		rule_list->next = NULL;
    	}
    	else
    	{
    		rule *new_rule=malloc(sizeof(rule));
    		new_rule->fname=func;
    		new_rule->next=rule_list;
    		rule_list=new_rule;
    	}
    	tree_depth++;
    	update_rule_tree();	
    }

    void pop_rule()
    {
    if(rule_list!=NULL)
    {
    	rule *old_rule=rule_list;
    	rule_list=rule_list->next;
    	printf("pop rule %s \n",old_rule->fname);
    	free(old_rule);
    	tree_depth--;
    }
    else
    {
    printf("pop null \n");
    exit(0);
    }
    }

    int lookahead(int i,pRFC5280Parser ctx)
    {
    	return LA(i);
    }

    #endif

    void push(mpz_t length,int length_field)
    {	
    		gmp_printf("%Zd is sequence length \n",length);
    		if(counter_list == NULL)
    		{
    			counter_list = malloc(sizeof(counter));
    			//counter_list->counter = length;
    			mpz_init_set(counter_list->counter,length);
    			counter_list->next = NULL;
    		}
    		else
    		{
    			counter* new_counter = malloc(sizeof(counter));
    			/*new_counter->counter = length;
    			new_counter->start_counter = length;
    			new_counter->start_counter += length_field;*/
    			mpz_init_set(new_counter->counter,length);
    			mpz_init_set(new_counter->start_counter,length);
    			mpz_add_ui(new_counter->start_counter,new_counter->start_counter,length_field);
    			new_counter->next = counter_list;
    			counter_list = new_counter;
    		}
    }

    void check_and_pop(mpz_t len,int length_field)
    {
    if(counter_list != NULL)
    	{
    	//counter_list->counter -= len +length_field;
    	mpz_sub(counter_list->counter,counter_list->counter,len);
    	mpz_sub_ui(counter_list->counter,counter_list->counter,length_field);
    	gmp_printf("Sequence length is %Zd and length field is %d and length subtracted is %Zd \n",counter_list->counter,length_field,len);
    	int outcome = mpz_cmp_ui(counter_list->counter,0);
    	if(outcome < 0)
    	{
    		printf("Sequence Length not ok \n");
    		exit(SEQUENCE_LENGTH_ERROR);
    	}
    	else if(outcome == 0)
    	{
    		printf("Sequence Length ok \n");
    		counter* old_counter = counter_list;
    		counter_list = counter_list->next;
    		if(counter_list!= NULL)
    		check_and_pop(old_counter->start_counter,0);
    		if(set_pointer == old_counter)
    			set_pointer = NULL;
    		if(any_pointer == old_counter)
    			any_pointer = NULL;
    		if(sequence_pointer == old_counter)
    		{	
    			printf("Sequence pointer nulled \n");
    			sequence_pointer = NULL;
    		}
    		if(general_name_pointer == old_counter)
    		{
    			general_name_pointer = NULL;
    		}
    		free(old_counter); 
    	}
    	}	
    }

    void primitive_tag(char *val,mpz_t length,int length_field)
    {
    	/*int i;
    	int len = strlen(val);
    	for(i=0;i<length;i++)
    		printf("%x \n", (unsigned char) val[i]);
    	if(len == length)
    		printf("length ok \n");
    	else
    		printf("length not ok \n");*/
    	check_and_pop(length,length_field);
    }

    void primitive_type(char *val,mpz_t length)
    {
    		int len =compute_len(val,length);
    		check_and_pop(length,len);	
    }

    void constructed_type(char *val)
    {
    		mpz_t length;
    		mpz_init_set_ui(length,0);
    		int len =compute_len(val,length);
    		if (mpz_cmp_ui(length,0)>0)
    			push(length,len);
    		else
    			check_and_pop(length,len);
    }

    void entire_encoding(unsigned int length)
    {
    	mpz_t len;
    	mpz_init_set_ui(len,length);
    	check_and_pop(len,2);
    }

    void populate_string_table()
    {
    ASN1_STRING_TABLE_add(NID_pseudonym,1,ub_pseudonym,DIRSTRING_TYPE,0);
    ASN1_STRING_TABLE_add(NID_generationQualifier,1,ub_name,DIRSTRING_TYPE,0);
    ASN1_STRING_TABLE_add(NID_title,1,ub_title,DIRSTRING_TYPE,0);

    }

    void keyusage_check()
    {
    	if(key_usage_ext == NULL || key_usage_ext->value->keyusage == NULL)
    		return;
    	unsigned char keyus = (unsigned char) key_usage_ext->value->keyusage->data[0];
    	unsigned char mask;
    	if(cert->is_ca)
    		mask = cert->mask_ca;
    	else
    		mask = cert->mask;
    	cert->eku_mask |= eku_mask;
    	printf("key us is %d and mask is %d and eku is %d \n",keyus,mask,cert->eku_mask);	
    	if(keyus & mask)
    	{
    		printf("Error on key usage CA Constraint \n");
    		exit(KEY_USAGE_CONSTRAINT_ERROR);
    	}
    	if(keyus & ~cert->eku_mask)
    	{
    		warning|=UNCONSISTENT_USAGE_FOUND_WARNING;
    	}
    	if(!(keyus & cert->eku_mask))
    		warning|=NO_CONSISTENT_USAGE_FOUND_WARNING;
    	if(keyus & 255)
    	{
    		if(key_usage_ext->value->keyusage->length > 1 && (((unsigned char) key_usage_ext->value->keyusage->data[1]) & 128))
    		{
    			if((keyus & 8) && !(keyus & 1));
    			else
    			{
    				printf("Error on key agreement constraint about decypher only \n");
    				exit(KEY_AGREEMENT_DECYPHER_ONLY_ERROR);	
    			}
    		}
    		else
    		{ 
    			if(((unsigned char) keyus & 9) == 0x01)
    			{
    				printf("Error on key agreement constraint about encypher only \n");
    				exit(KEY_AGREEMENT_ENCYPHER_ONLY_ERROR);					
    			}
    			else;
    		}	
    	}
    	else
    	{
    		printf("At least one bit must be set in key usage \n");
    		exit(KEY_USAGE_NO_BITS_SET);
    	}
    	//if everything is ok, add key usage to extensions stack
    	sk_x509_EXTENSION_push(cert->extensions,key_usage_ext);
    }

    int compare_dn_entries(X509_DNAME_ENTRY *issuer,X509_DNAME_ENTRY *subject)
    {
    	const int nids[16] = {NID_commonName,NID_organizationName,NID_name,NID_surname,NID_givenName,NID_initials,NID_generationQualifier,NID_localityName,NID_organizationalUnitName,
    	NID_stateOrProvinceName,NID_title,NID_pseudonym,NID_dnQualifier,NID_countryName,NID_serialNumber,NID_pkcs9_emailAddress};
    	int j;
    	for(j=0;j<16;j++)
    	{
    		if(OBJ_obj2nid(issuer->string_name->oid) == nids[j])
    			break;
    	}
    	if(j!=16)
    	{
    		if(cmp_asn1_string(issuer->string_name->value,subject->string_name->value))
    			return 1;
    		else
    			return 0;
    	}
    	else
    	{
    		ANY* issuer_iter = issuer->other_name->value;
    		ANY* subject_iter = subject->other_name->value;
    		while(issuer_iter && subject_iter)
    		{
    			if(sizeof(*(issuer_iter->el)) == sizeof(*(subject_iter->el)))
    			{
    				if(sizeof(*(subject_iter->el)) == sizeof(ASN1_STRING))
    					if(!cmp_asn1_string((ASN1_STRING *) subject_iter->el,(ASN1_STRING *) issuer_iter->el))
    						return 0;
    				else 
    				{
    				ASN1_OBJECT *issuer_obj = (ASN1_OBJECT *) issuer_iter->el;
    				ASN1_OBJECT *subject_obj = (ASN1_OBJECT *)subject_iter->el;
    				if( OBJ_obj2nid(issuer_obj) != OBJ_obj2nid(subject_obj))
    					return 0;
    				}
    			}
    			else
    				return 0;
    			issuer_iter = issuer_iter->next;
    			subject_iter = subject_iter->next;
    		}
    		if(issuer_iter == subject_iter)
    			return 1;
    		else
    			return 0;
    	}	
    }

    int compare_dn(STACK_OF(X509_DNAME_ENTRY *issuer),STACK_OF(X509_DNAME_ENTRY) *subject)
    {
    	int i,num,j,z;
    	num = sk_X509_DNAME_ENTRY_num(issuer);
    	printf("num is %d \n",num);
    	if(num == sk_X509_DNAME_ENTRY_num(subject))
    	{	
    		int *subject_indexes =  malloc(sizeof(int)*num);
    		for(i=0;i<num;i++)
    		{
    			X509_DNAME_ENTRY *issuer_entry = sk_X509_DNAME_ENTRY_value(issuer,i);
    			X509_DNAME_ENTRY *subject_entry;
    			for(j=0;j<i;j++)
    				if(i == subject_indexes[j])
    					break;
    			if(j == i)
    			{
    				subject_entry = sk_X509_DNAME_ENTRY_value(subject,i);
    				if(OBJ_obj2nid(issuer_entry->string_name->oid) == OBJ_obj2nid(subject_entry->string_name->oid))
    				{
    					if(compare_dn_entries(issuer_entry,subject_entry))
    					{
    						subject_indexes[i]=i;
    						continue;
    					}
    				}
    			}
    			for(j=i+1;i != j % num;j++)
    			{
    				for(z=0;z<i;z++)
    					if(j % num == subject_indexes[z])
    						break;
    				if(z == i)
    				{
    					subject_entry = sk_X509_DNAME_ENTRY_value(subject,j % num);
    					if(OBJ_obj2nid(issuer_entry->string_name->oid) == OBJ_obj2nid(subject_entry->string_name->oid))
    						if(compare_dn_entries(issuer_entry,subject_entry))
    						{
    							subject_indexes[i]=j % num;	
    							break;
    						}		
    				}
    			}
    			printf("i is %d and %d \n",i,j%num);
    			if(i == j % num)
    				return 0;
    		}
    		return 1;
    	}
    	else
    		return 0;
    }

    void check_aki()
    {
    	if(cert->version > 2 && !cert->key_id)
    	{
    		int self_signed = compare_dn(cert->issuer,cert->subject);
    		if(!self_signed)
    			exit(MISSING_AKI_KEY_ID_ERROR);
    	}
    }

    void print_cert_info()
    {
    	printf("version is %d \n",cert->version);
    	if(cert->serial_number)
    		printf("serial number is %s \n",cert->serial_number->data);
    	printf("signature algorithm is %s \n",OBJ_nid2ln(OBJ_obj2nid(cert->signature_algorithm->oid)));
    	printf("Val time is %d %s , %d %s \n",cert->validity->notBefore->type,cert->validity->notBefore->data,cert->validity->notAfter->type,cert->validity->notAfter->data);
    	printf("Issuer is %s \n",X509_NAME_oneline(cert->issuer,NULL,0));
    	printf("Subject is %s \n",X509_NAME_oneline(cert->subject,NULL,0));
    	printf("Public key is %s \n",cert->pkey->pubkey->bitstring_encoding->data);
    	printf("Public key params is %s \n",OBJ_nid2ln(OBJ_obj2nid(cert->pkey->alg->params->ecpk->named_curve)));
    	printf("Signature is %s %s \n",cert->signature->dsa_sign->r->data,cert->signature->dsa_sign->s->data);
    	printf("Certificate is CA? %d \n",bc_ext->value->basic_constraints->is_ca);
    }
    void final_check()
    {
    while(counter_list != NULL)
    	{
    		if(counter_list->counter != 0)
    		{
    			printf("Sequence length not ok \n");
    			exit(SEQUENCE_LENGTH_ERROR);
    		}
    		counter_list = counter_list->next;
    	}
    	/*oid_list *el;
    	el = exts_list;
    	while(el != NULL)
    	{
    		gmp_printf("%Zd   ",el->index);
    		el = el->next;
    	}
    	printf("\n");*/
    	keyusage_check();
    	check_aki();
    	if(ca_repo && !cert->is_ca)
    		warning |= CA_REPO_NO_CA_WARNING;
    	if(tsp && cert->is_ca)
    		warning |= TSP_CA_WARNING;
    	/*print_cert_info();*/
    	printf("parsing Completed \n");
    	//exit(0);
    }


    void compute_names()
    {
    	int i,counter=0;
    	X509_DNAME_ENTRY* dname;
    	for(i=0;i < sk_X509_DNAME_ENTRY_num(cert->subject);i++)
    	{
    		dname = sk_X509_DNAME_ENTRY_value(cert->subject,i);
    		if(OBJ_obj2nid(dname->string_name->oid) == NID_commonName)
    			counter++;
    	}
    	X509_EXTENSION_VALUE *extn;
    	GEN_NAME *gen_name;
    	for(i=0;i < sk_x509_EXTENSION_num(cert->extensions);i++)
    	{
    		//fprintf(stdout,"Looking for exntesions \n");
    		x509_EXTENSION* ext = sk_x509_EXTENSION_value(cert->extensions,i); 
    		if(OBJ_obj2nid(ext->oid)==NID_subject_alt_name)
    		{
    			extn = ext->value;
    			int j,z;
    			for(j=0;j < sk_GENERAL_NAME_POINTER_num(extn->gen_names);j++)
    			{
    				gen_name = sk_GENERAL_NAME_POINTER_value(extn->gen_names,j);
    				if(gen_name->tag == 1 || gen_name->tag == 2 || gen_name->tag == 6 || gen_name->tag == 7)
    					counter++;
    				else if(gen_name->tag == 4)
    				{
    					for(z=0;z < sk_X509_DNAME_ENTRY_num(gen_name->name->dn);z++)
    					{
    						dname = sk_X509_DNAME_ENTRY_value(gen_name->name->dn,z);
    						if(OBJ_obj2nid(dname->string_name->oid) == NID_commonName)
    							counter++;
    					}
    					/*int lastpos=-1;
    					int index = X509_NAME_get_index_by_NID(gen_name->name->dn,NID_commonName,lastpos); 
    					fprintf(stdout,"Here %d \n",index);
    					while(index != -1)
    					{
    						if(index == -2)
    						{
    							fprintf(stdout,"wrong nid \n");
    							exit(255);
    						}
    						counter++;
    						lastpos = index;
    						index = X509_NAME_get_index_by_NID(gen_name->name->dn,NID_commonName,lastpos); 
    					}*/
    				}
    			}
    		}
    	}
    	fprintf(stdout,"Names: %d",counter);
    }




/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_certificate_in_prog77  */
static	ANTLR3_BITWORD FOLLOW_certificate_in_prog77_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_certificate_in_prog77	= { FOLLOW_certificate_in_prog77_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_prog79  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_prog79_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_prog79	= { FOLLOW_EOF_in_prog79_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_certificate97  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_certificate97_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_certificate97	= { FOLLOW_sequenceTag_in_certificate97_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tbscertificate_in_certificate104  */
static	ANTLR3_BITWORD FOLLOW_tbscertificate_in_certificate104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tbscertificate_in_certificate104	= { FOLLOW_tbscertificate_in_certificate104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate123  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate123_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate123	= { FOLLOW_sequenceTag_in_tbscertificate123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_tbscertificate128  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_tbscertificate128_bits[]	= { ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_tbscertificate128	= { FOLLOW_constructedTag0_in_tbscertificate128_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_version3_in_tbscertificate130  */
static	ANTLR3_BITWORD FOLLOW_version3_in_tbscertificate130_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_version3_in_tbscertificate130	= { FOLLOW_version3_in_tbscertificate130_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_serialnumber_in_tbscertificate132  */
static	ANTLR3_BITWORD FOLLOW_serialnumber_in_tbscertificate132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_serialnumber_in_tbscertificate132	= { FOLLOW_serialnumber_in_tbscertificate132_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md2_alg_id_in_tbscertificate136  */
static	ANTLR3_BITWORD FOLLOW_rsa_md2_alg_id_in_tbscertificate136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md2_alg_id_in_tbscertificate136	= { FOLLOW_rsa_md2_alg_id_in_tbscertificate136_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate138  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate138	= { FOLLOW_issuer_in_tbscertificate138_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate140  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate140	= { FOLLOW_validity_in_tbscertificate140_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate143  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate143	= { FOLLOW_subject_in_tbscertificate143_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate145  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate145	= { FOLLOW_subjectPKinfo_in_tbscertificate145_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate148  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate148	= { FOLLOW_issueruniqueId_in_tbscertificate148_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate153  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate153_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate153	= { FOLLOW_subjectuniqueId_in_tbscertificate153_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate158  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate158	= { FOLLOW_constructedTag3_in_tbscertificate158_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate160  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate160	= { FOLLOW_sequenceTag_in_tbscertificate160_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate163  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate163	= { FOLLOW_extensions_in_tbscertificate163_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate176  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate176	= { FOLLOW_sequenceTag_in_tbscertificate176_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate178  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate178_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate178	= { FOLLOW_subjectPKinfo_in_tbscertificate178_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate181  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate181	= { FOLLOW_issueruniqueId_in_tbscertificate181_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate186  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate186	= { FOLLOW_subjectuniqueId_in_tbscertificate186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate190  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate190	= { FOLLOW_constructedTag3_in_tbscertificate190_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate192  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate192	= { FOLLOW_sequenceTag_in_tbscertificate192_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate194  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate194	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate194_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md2_alg_id_in_tbscertificate198  */
static	ANTLR3_BITWORD FOLLOW_rsa_md2_alg_id_in_tbscertificate198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md2_alg_id_in_tbscertificate198	= { FOLLOW_rsa_md2_alg_id_in_tbscertificate198_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate200  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate200	= { FOLLOW_signature_in_tbscertificate200_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md5_alg_id_in_tbscertificate203  */
static	ANTLR3_BITWORD FOLLOW_rsa_md5_alg_id_in_tbscertificate203_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md5_alg_id_in_tbscertificate203	= { FOLLOW_rsa_md5_alg_id_in_tbscertificate203_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate205  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate205	= { FOLLOW_issuer_in_tbscertificate205_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate207  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate207	= { FOLLOW_validity_in_tbscertificate207_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate210  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate210	= { FOLLOW_subject_in_tbscertificate210_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate212  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate212	= { FOLLOW_subjectPKinfo_in_tbscertificate212_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate215  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate215	= { FOLLOW_issueruniqueId_in_tbscertificate215_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate220  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate220	= { FOLLOW_subjectuniqueId_in_tbscertificate220_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate225  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate225	= { FOLLOW_constructedTag3_in_tbscertificate225_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate227  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate227	= { FOLLOW_sequenceTag_in_tbscertificate227_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate230  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate230	= { FOLLOW_extensions_in_tbscertificate230_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate243  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate243_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate243	= { FOLLOW_sequenceTag_in_tbscertificate243_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate245  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate245	= { FOLLOW_subjectPKinfo_in_tbscertificate245_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate248  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate248	= { FOLLOW_issueruniqueId_in_tbscertificate248_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate253  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate253	= { FOLLOW_subjectuniqueId_in_tbscertificate253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate257  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate257	= { FOLLOW_constructedTag3_in_tbscertificate257_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate259  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate259	= { FOLLOW_sequenceTag_in_tbscertificate259_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate261  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate261	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate261_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md5_alg_id_in_tbscertificate265  */
static	ANTLR3_BITWORD FOLLOW_rsa_md5_alg_id_in_tbscertificate265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md5_alg_id_in_tbscertificate265	= { FOLLOW_rsa_md5_alg_id_in_tbscertificate265_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate267  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate267	= { FOLLOW_signature_in_tbscertificate267_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha1_alg_id_in_tbscertificate270  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha1_alg_id_in_tbscertificate270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha1_alg_id_in_tbscertificate270	= { FOLLOW_rsa_sha1_alg_id_in_tbscertificate270_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate272  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate272	= { FOLLOW_issuer_in_tbscertificate272_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate274  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate274	= { FOLLOW_validity_in_tbscertificate274_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate277  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate277	= { FOLLOW_subject_in_tbscertificate277_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate279  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate279	= { FOLLOW_subjectPKinfo_in_tbscertificate279_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate282  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate282	= { FOLLOW_issueruniqueId_in_tbscertificate282_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate287  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate287	= { FOLLOW_subjectuniqueId_in_tbscertificate287_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate292  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate292	= { FOLLOW_constructedTag3_in_tbscertificate292_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate294  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate294	= { FOLLOW_sequenceTag_in_tbscertificate294_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate297  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate297	= { FOLLOW_extensions_in_tbscertificate297_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate310  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate310	= { FOLLOW_sequenceTag_in_tbscertificate310_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate312  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate312	= { FOLLOW_subjectPKinfo_in_tbscertificate312_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate315  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate315	= { FOLLOW_issueruniqueId_in_tbscertificate315_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate320  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate320	= { FOLLOW_subjectuniqueId_in_tbscertificate320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate324  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate324	= { FOLLOW_constructedTag3_in_tbscertificate324_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate326  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate326	= { FOLLOW_sequenceTag_in_tbscertificate326_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate328  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate328_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate328	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate328_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha1_alg_id_in_tbscertificate332  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha1_alg_id_in_tbscertificate332_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha1_alg_id_in_tbscertificate332	= { FOLLOW_rsa_sha1_alg_id_in_tbscertificate332_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate334  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate334	= { FOLLOW_signature_in_tbscertificate334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha224_alg_id_in_tbscertificate337  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha224_alg_id_in_tbscertificate337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha224_alg_id_in_tbscertificate337	= { FOLLOW_rsa_sha224_alg_id_in_tbscertificate337_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate339  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate339	= { FOLLOW_issuer_in_tbscertificate339_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate341  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate341_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate341	= { FOLLOW_validity_in_tbscertificate341_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate344  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate344	= { FOLLOW_subject_in_tbscertificate344_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate346  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate346	= { FOLLOW_subjectPKinfo_in_tbscertificate346_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate349  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate349	= { FOLLOW_issueruniqueId_in_tbscertificate349_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate354  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate354	= { FOLLOW_subjectuniqueId_in_tbscertificate354_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate359  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate359	= { FOLLOW_constructedTag3_in_tbscertificate359_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate361  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate361	= { FOLLOW_sequenceTag_in_tbscertificate361_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate364  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate364	= { FOLLOW_extensions_in_tbscertificate364_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate377  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate377	= { FOLLOW_sequenceTag_in_tbscertificate377_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate379  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate379	= { FOLLOW_subjectPKinfo_in_tbscertificate379_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate382  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate382_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate382	= { FOLLOW_issueruniqueId_in_tbscertificate382_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate387  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate387	= { FOLLOW_subjectuniqueId_in_tbscertificate387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate391  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate391	= { FOLLOW_constructedTag3_in_tbscertificate391_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate393  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate393_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate393	= { FOLLOW_sequenceTag_in_tbscertificate393_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate395  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate395	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate395_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha224_alg_id_in_tbscertificate399  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha224_alg_id_in_tbscertificate399_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha224_alg_id_in_tbscertificate399	= { FOLLOW_rsa_sha224_alg_id_in_tbscertificate399_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate401  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate401	= { FOLLOW_signature_in_tbscertificate401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha256_alg_id_in_tbscertificate404  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha256_alg_id_in_tbscertificate404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha256_alg_id_in_tbscertificate404	= { FOLLOW_rsa_sha256_alg_id_in_tbscertificate404_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate406  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate406	= { FOLLOW_issuer_in_tbscertificate406_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate408  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate408	= { FOLLOW_validity_in_tbscertificate408_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate411  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate411	= { FOLLOW_subject_in_tbscertificate411_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate413  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate413	= { FOLLOW_subjectPKinfo_in_tbscertificate413_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate416  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate416	= { FOLLOW_issueruniqueId_in_tbscertificate416_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate421  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate421_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate421	= { FOLLOW_subjectuniqueId_in_tbscertificate421_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate426  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate426_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate426	= { FOLLOW_constructedTag3_in_tbscertificate426_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate428  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate428	= { FOLLOW_sequenceTag_in_tbscertificate428_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate431  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate431	= { FOLLOW_extensions_in_tbscertificate431_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate444  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate444	= { FOLLOW_sequenceTag_in_tbscertificate444_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate446  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate446	= { FOLLOW_subjectPKinfo_in_tbscertificate446_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate449  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate449	= { FOLLOW_issueruniqueId_in_tbscertificate449_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate454  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate454	= { FOLLOW_subjectuniqueId_in_tbscertificate454_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate458  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate458_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate458	= { FOLLOW_constructedTag3_in_tbscertificate458_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate460  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate460	= { FOLLOW_sequenceTag_in_tbscertificate460_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate462  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate462	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate462_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha256_alg_id_in_tbscertificate466  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha256_alg_id_in_tbscertificate466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha256_alg_id_in_tbscertificate466	= { FOLLOW_rsa_sha256_alg_id_in_tbscertificate466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate468  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate468	= { FOLLOW_signature_in_tbscertificate468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha384_alg_id_in_tbscertificate471  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha384_alg_id_in_tbscertificate471_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha384_alg_id_in_tbscertificate471	= { FOLLOW_rsa_sha384_alg_id_in_tbscertificate471_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate473  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate473	= { FOLLOW_issuer_in_tbscertificate473_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate475  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate475	= { FOLLOW_validity_in_tbscertificate475_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate478  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate478	= { FOLLOW_subject_in_tbscertificate478_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate480  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate480	= { FOLLOW_subjectPKinfo_in_tbscertificate480_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate483  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate483_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate483	= { FOLLOW_issueruniqueId_in_tbscertificate483_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate488  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate488_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate488	= { FOLLOW_subjectuniqueId_in_tbscertificate488_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate493  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate493_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate493	= { FOLLOW_constructedTag3_in_tbscertificate493_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate495  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate495	= { FOLLOW_sequenceTag_in_tbscertificate495_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate498  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate498	= { FOLLOW_extensions_in_tbscertificate498_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate511  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate511_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate511	= { FOLLOW_sequenceTag_in_tbscertificate511_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate513  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate513	= { FOLLOW_subjectPKinfo_in_tbscertificate513_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate516  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate516	= { FOLLOW_issueruniqueId_in_tbscertificate516_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate521  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate521	= { FOLLOW_subjectuniqueId_in_tbscertificate521_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate525  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate525	= { FOLLOW_constructedTag3_in_tbscertificate525_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate527  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate527	= { FOLLOW_sequenceTag_in_tbscertificate527_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate529  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate529_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate529	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate529_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha384_alg_id_in_tbscertificate533  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha384_alg_id_in_tbscertificate533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha384_alg_id_in_tbscertificate533	= { FOLLOW_rsa_sha384_alg_id_in_tbscertificate533_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate535  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate535	= { FOLLOW_signature_in_tbscertificate535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha512_alg_id_in_tbscertificate538  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha512_alg_id_in_tbscertificate538_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha512_alg_id_in_tbscertificate538	= { FOLLOW_rsa_sha512_alg_id_in_tbscertificate538_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate540  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate540	= { FOLLOW_issuer_in_tbscertificate540_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate542  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate542_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate542	= { FOLLOW_validity_in_tbscertificate542_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate545  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate545	= { FOLLOW_subject_in_tbscertificate545_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate547  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate547	= { FOLLOW_subjectPKinfo_in_tbscertificate547_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate550  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate550	= { FOLLOW_issueruniqueId_in_tbscertificate550_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate555  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate555_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate555	= { FOLLOW_subjectuniqueId_in_tbscertificate555_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate560  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate560	= { FOLLOW_constructedTag3_in_tbscertificate560_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate562  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate562_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate562	= { FOLLOW_sequenceTag_in_tbscertificate562_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate565  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate565	= { FOLLOW_extensions_in_tbscertificate565_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate578  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate578	= { FOLLOW_sequenceTag_in_tbscertificate578_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate580  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate580	= { FOLLOW_subjectPKinfo_in_tbscertificate580_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate583  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate583	= { FOLLOW_issueruniqueId_in_tbscertificate583_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate588  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate588	= { FOLLOW_subjectuniqueId_in_tbscertificate588_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate592  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate592	= { FOLLOW_constructedTag3_in_tbscertificate592_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate594  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate594_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate594	= { FOLLOW_sequenceTag_in_tbscertificate594_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate596  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate596	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate596_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha512_alg_id_in_tbscertificate600  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha512_alg_id_in_tbscertificate600_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha512_alg_id_in_tbscertificate600	= { FOLLOW_rsa_sha512_alg_id_in_tbscertificate600_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate602  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate602	= { FOLLOW_signature_in_tbscertificate602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha_alg_id_in_tbscertificate605  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha_alg_id_in_tbscertificate605_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha_alg_id_in_tbscertificate605	= { FOLLOW_dsa_sha_alg_id_in_tbscertificate605_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate607  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate607_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate607	= { FOLLOW_issuer_in_tbscertificate607_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate609  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate609	= { FOLLOW_validity_in_tbscertificate609_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate612  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate612	= { FOLLOW_subject_in_tbscertificate612_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate614  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate614_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate614	= { FOLLOW_subjectPKinfo_in_tbscertificate614_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate617  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate617	= { FOLLOW_issueruniqueId_in_tbscertificate617_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate622  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate622	= { FOLLOW_subjectuniqueId_in_tbscertificate622_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate627  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate627	= { FOLLOW_constructedTag3_in_tbscertificate627_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate629  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate629	= { FOLLOW_sequenceTag_in_tbscertificate629_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate632  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate632	= { FOLLOW_extensions_in_tbscertificate632_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate645  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate645_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate645	= { FOLLOW_sequenceTag_in_tbscertificate645_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate647  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate647	= { FOLLOW_subjectPKinfo_in_tbscertificate647_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate650  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate650	= { FOLLOW_issueruniqueId_in_tbscertificate650_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate655  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate655	= { FOLLOW_subjectuniqueId_in_tbscertificate655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate659  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate659	= { FOLLOW_constructedTag3_in_tbscertificate659_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate661  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate661	= { FOLLOW_sequenceTag_in_tbscertificate661_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate663  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate663	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate663_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha_alg_id_in_tbscertificate667  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha_alg_id_in_tbscertificate667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha_alg_id_in_tbscertificate667	= { FOLLOW_dsa_sha_alg_id_in_tbscertificate667_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate669  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate669	= { FOLLOW_dsa_signature_in_tbscertificate669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha_alg_id_in_tbscertificate672  */
static	ANTLR3_BITWORD FOLLOW_ec_sha_alg_id_in_tbscertificate672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha_alg_id_in_tbscertificate672	= { FOLLOW_ec_sha_alg_id_in_tbscertificate672_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate674  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate674	= { FOLLOW_issuer_in_tbscertificate674_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate676  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate676	= { FOLLOW_validity_in_tbscertificate676_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate679  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate679	= { FOLLOW_subject_in_tbscertificate679_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate681  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate681	= { FOLLOW_subjectPKinfo_in_tbscertificate681_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate684  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate684_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate684	= { FOLLOW_issueruniqueId_in_tbscertificate684_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate689  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate689	= { FOLLOW_subjectuniqueId_in_tbscertificate689_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate694  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate694_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate694	= { FOLLOW_constructedTag3_in_tbscertificate694_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate696  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate696_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate696	= { FOLLOW_sequenceTag_in_tbscertificate696_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate699  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate699	= { FOLLOW_extensions_in_tbscertificate699_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate712  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate712_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate712	= { FOLLOW_sequenceTag_in_tbscertificate712_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate714  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate714	= { FOLLOW_subjectPKinfo_in_tbscertificate714_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate717  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate717	= { FOLLOW_issueruniqueId_in_tbscertificate717_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate722  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate722	= { FOLLOW_subjectuniqueId_in_tbscertificate722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate726  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate726_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate726	= { FOLLOW_constructedTag3_in_tbscertificate726_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate728  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate728	= { FOLLOW_sequenceTag_in_tbscertificate728_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate730  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate730	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate730_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha_alg_id_in_tbscertificate734  */
static	ANTLR3_BITWORD FOLLOW_ec_sha_alg_id_in_tbscertificate734_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha_alg_id_in_tbscertificate734	= { FOLLOW_ec_sha_alg_id_in_tbscertificate734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate736  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate736	= { FOLLOW_dsa_signature_in_tbscertificate736_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pss_alg_id_params_in_tbscertificate739  */
static	ANTLR3_BITWORD FOLLOW_pss_alg_id_params_in_tbscertificate739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pss_alg_id_params_in_tbscertificate739	= { FOLLOW_pss_alg_id_params_in_tbscertificate739_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate741  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate741	= { FOLLOW_issuer_in_tbscertificate741_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate743  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate743	= { FOLLOW_validity_in_tbscertificate743_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate746  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate746	= { FOLLOW_subject_in_tbscertificate746_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate748  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate748_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate748	= { FOLLOW_subjectPKinfo_in_tbscertificate748_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate751  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate751	= { FOLLOW_issueruniqueId_in_tbscertificate751_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate756  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate756	= { FOLLOW_subjectuniqueId_in_tbscertificate756_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate761  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate761_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate761	= { FOLLOW_constructedTag3_in_tbscertificate761_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate763  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate763	= { FOLLOW_sequenceTag_in_tbscertificate763_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate766  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate766	= { FOLLOW_extensions_in_tbscertificate766_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate779  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate779_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate779	= { FOLLOW_sequenceTag_in_tbscertificate779_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate781  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate781	= { FOLLOW_subjectPKinfo_in_tbscertificate781_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate784  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate784_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate784	= { FOLLOW_issueruniqueId_in_tbscertificate784_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate789  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate789_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate789	= { FOLLOW_subjectuniqueId_in_tbscertificate789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate793  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate793	= { FOLLOW_constructedTag3_in_tbscertificate793_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate795  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate795_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate795	= { FOLLOW_sequenceTag_in_tbscertificate795_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate797  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate797	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate797_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pss_alg_id_params_in_tbscertificate801  */
static	ANTLR3_BITWORD FOLLOW_pss_alg_id_params_in_tbscertificate801_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_pss_alg_id_params_in_tbscertificate801	= { FOLLOW_pss_alg_id_params_in_tbscertificate801_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate803  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate803_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate803	= { FOLLOW_signature_in_tbscertificate803_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha224_alg_id_in_tbscertificate806  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha224_alg_id_in_tbscertificate806_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha224_alg_id_in_tbscertificate806	= { FOLLOW_dsa_sha224_alg_id_in_tbscertificate806_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate808  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate808_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate808	= { FOLLOW_issuer_in_tbscertificate808_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate810  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate810_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate810	= { FOLLOW_validity_in_tbscertificate810_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate813  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate813	= { FOLLOW_subject_in_tbscertificate813_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate815  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate815_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate815	= { FOLLOW_subjectPKinfo_in_tbscertificate815_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate818  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate818	= { FOLLOW_issueruniqueId_in_tbscertificate818_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate823  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate823	= { FOLLOW_subjectuniqueId_in_tbscertificate823_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate828  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate828	= { FOLLOW_constructedTag3_in_tbscertificate828_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate830  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate830_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate830	= { FOLLOW_sequenceTag_in_tbscertificate830_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate833  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate833	= { FOLLOW_extensions_in_tbscertificate833_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate846  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate846_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate846	= { FOLLOW_sequenceTag_in_tbscertificate846_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate848  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate848	= { FOLLOW_subjectPKinfo_in_tbscertificate848_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate851  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate851	= { FOLLOW_issueruniqueId_in_tbscertificate851_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate856  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate856_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate856	= { FOLLOW_subjectuniqueId_in_tbscertificate856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate860  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate860	= { FOLLOW_constructedTag3_in_tbscertificate860_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate862  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate862	= { FOLLOW_sequenceTag_in_tbscertificate862_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate864  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate864	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate864_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha224_alg_id_in_tbscertificate868  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha224_alg_id_in_tbscertificate868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha224_alg_id_in_tbscertificate868	= { FOLLOW_dsa_sha224_alg_id_in_tbscertificate868_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate870  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate870	= { FOLLOW_dsa_signature_in_tbscertificate870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha256_alg_id_in_tbscertificate873  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha256_alg_id_in_tbscertificate873_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha256_alg_id_in_tbscertificate873	= { FOLLOW_dsa_sha256_alg_id_in_tbscertificate873_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate875  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate875_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate875	= { FOLLOW_issuer_in_tbscertificate875_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate877  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate877_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate877	= { FOLLOW_validity_in_tbscertificate877_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate880  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate880_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate880	= { FOLLOW_subject_in_tbscertificate880_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate882  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate882_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate882	= { FOLLOW_subjectPKinfo_in_tbscertificate882_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate885  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate885_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate885	= { FOLLOW_issueruniqueId_in_tbscertificate885_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate890  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate890_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate890	= { FOLLOW_subjectuniqueId_in_tbscertificate890_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate895  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate895	= { FOLLOW_constructedTag3_in_tbscertificate895_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate897  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate897	= { FOLLOW_sequenceTag_in_tbscertificate897_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate900  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate900_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate900	= { FOLLOW_extensions_in_tbscertificate900_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate913  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate913_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate913	= { FOLLOW_sequenceTag_in_tbscertificate913_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate915  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate915_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate915	= { FOLLOW_subjectPKinfo_in_tbscertificate915_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate918  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate918_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate918	= { FOLLOW_issueruniqueId_in_tbscertificate918_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate923  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate923_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate923	= { FOLLOW_subjectuniqueId_in_tbscertificate923_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate927  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate927_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate927	= { FOLLOW_constructedTag3_in_tbscertificate927_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate929  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate929_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate929	= { FOLLOW_sequenceTag_in_tbscertificate929_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate931  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate931_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate931	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate931_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha256_alg_id_in_tbscertificate935  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha256_alg_id_in_tbscertificate935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha256_alg_id_in_tbscertificate935	= { FOLLOW_dsa_sha256_alg_id_in_tbscertificate935_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate937  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate937	= { FOLLOW_dsa_signature_in_tbscertificate937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha224_alg_id_in_tbscertificate940  */
static	ANTLR3_BITWORD FOLLOW_ec_sha224_alg_id_in_tbscertificate940_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha224_alg_id_in_tbscertificate940	= { FOLLOW_ec_sha224_alg_id_in_tbscertificate940_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate942  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate942_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate942	= { FOLLOW_issuer_in_tbscertificate942_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate944  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate944_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate944	= { FOLLOW_validity_in_tbscertificate944_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate947  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate947_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate947	= { FOLLOW_subject_in_tbscertificate947_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate949  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate949_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate949	= { FOLLOW_subjectPKinfo_in_tbscertificate949_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate952  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate952_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate952	= { FOLLOW_issueruniqueId_in_tbscertificate952_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate957  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate957	= { FOLLOW_subjectuniqueId_in_tbscertificate957_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate962  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate962	= { FOLLOW_constructedTag3_in_tbscertificate962_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate964  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate964_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate964	= { FOLLOW_sequenceTag_in_tbscertificate964_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate967  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate967_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate967	= { FOLLOW_extensions_in_tbscertificate967_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate980  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate980	= { FOLLOW_sequenceTag_in_tbscertificate980_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate982  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate982_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate982	= { FOLLOW_subjectPKinfo_in_tbscertificate982_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate985  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate985	= { FOLLOW_issueruniqueId_in_tbscertificate985_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate990  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate990	= { FOLLOW_subjectuniqueId_in_tbscertificate990_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate994  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate994	= { FOLLOW_constructedTag3_in_tbscertificate994_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate996  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate996_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate996	= { FOLLOW_sequenceTag_in_tbscertificate996_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate998  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate998	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate998_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha224_alg_id_in_tbscertificate1002  */
static	ANTLR3_BITWORD FOLLOW_ec_sha224_alg_id_in_tbscertificate1002_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha224_alg_id_in_tbscertificate1002	= { FOLLOW_ec_sha224_alg_id_in_tbscertificate1002_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1004  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1004_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1004	= { FOLLOW_dsa_signature_in_tbscertificate1004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha256_alg_id_in_tbscertificate1007  */
static	ANTLR3_BITWORD FOLLOW_ec_sha256_alg_id_in_tbscertificate1007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha256_alg_id_in_tbscertificate1007	= { FOLLOW_ec_sha256_alg_id_in_tbscertificate1007_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1009  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1009	= { FOLLOW_issuer_in_tbscertificate1009_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1011  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1011	= { FOLLOW_validity_in_tbscertificate1011_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1014  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1014	= { FOLLOW_subject_in_tbscertificate1014_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1016  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1016_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1016	= { FOLLOW_subjectPKinfo_in_tbscertificate1016_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1019  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1019	= { FOLLOW_issueruniqueId_in_tbscertificate1019_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1024  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1024_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1024	= { FOLLOW_subjectuniqueId_in_tbscertificate1024_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1029  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1029	= { FOLLOW_constructedTag3_in_tbscertificate1029_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1031  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1031	= { FOLLOW_sequenceTag_in_tbscertificate1031_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate1034  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate1034_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate1034	= { FOLLOW_extensions_in_tbscertificate1034_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1047  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1047_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1047	= { FOLLOW_sequenceTag_in_tbscertificate1047_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1049  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1049_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1049	= { FOLLOW_subjectPKinfo_in_tbscertificate1049_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1052  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1052	= { FOLLOW_issueruniqueId_in_tbscertificate1052_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1057  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1057	= { FOLLOW_subjectuniqueId_in_tbscertificate1057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1061  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1061_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1061	= { FOLLOW_constructedTag3_in_tbscertificate1061_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1063  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1063_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1063	= { FOLLOW_sequenceTag_in_tbscertificate1063_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate1065  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate1065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate1065	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate1065_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha256_alg_id_in_tbscertificate1069  */
static	ANTLR3_BITWORD FOLLOW_ec_sha256_alg_id_in_tbscertificate1069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha256_alg_id_in_tbscertificate1069	= { FOLLOW_ec_sha256_alg_id_in_tbscertificate1069_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1071  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1071	= { FOLLOW_dsa_signature_in_tbscertificate1071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha384_alg_id_in_tbscertificate1074  */
static	ANTLR3_BITWORD FOLLOW_ec_sha384_alg_id_in_tbscertificate1074_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha384_alg_id_in_tbscertificate1074	= { FOLLOW_ec_sha384_alg_id_in_tbscertificate1074_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1076  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1076_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1076	= { FOLLOW_issuer_in_tbscertificate1076_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1078  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1078_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1078	= { FOLLOW_validity_in_tbscertificate1078_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1081  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1081_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1081	= { FOLLOW_subject_in_tbscertificate1081_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1083  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1083	= { FOLLOW_subjectPKinfo_in_tbscertificate1083_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1086  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1086_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1086	= { FOLLOW_issueruniqueId_in_tbscertificate1086_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1091  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1091_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1091	= { FOLLOW_subjectuniqueId_in_tbscertificate1091_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1096  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1096_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1096	= { FOLLOW_constructedTag3_in_tbscertificate1096_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1098  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1098	= { FOLLOW_sequenceTag_in_tbscertificate1098_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate1101  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate1101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate1101	= { FOLLOW_extensions_in_tbscertificate1101_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1114  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1114_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1114	= { FOLLOW_sequenceTag_in_tbscertificate1114_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1116  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1116	= { FOLLOW_subjectPKinfo_in_tbscertificate1116_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1119  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1119	= { FOLLOW_issueruniqueId_in_tbscertificate1119_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1124  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1124	= { FOLLOW_subjectuniqueId_in_tbscertificate1124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1128  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1128_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1128	= { FOLLOW_constructedTag3_in_tbscertificate1128_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1130  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1130	= { FOLLOW_sequenceTag_in_tbscertificate1130_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate1132  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate1132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate1132	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate1132_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha384_alg_id_in_tbscertificate1136  */
static	ANTLR3_BITWORD FOLLOW_ec_sha384_alg_id_in_tbscertificate1136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha384_alg_id_in_tbscertificate1136	= { FOLLOW_ec_sha384_alg_id_in_tbscertificate1136_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1138  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1138_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1138	= { FOLLOW_dsa_signature_in_tbscertificate1138_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha512_alg_id_in_tbscertificate1141  */
static	ANTLR3_BITWORD FOLLOW_ec_sha512_alg_id_in_tbscertificate1141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha512_alg_id_in_tbscertificate1141	= { FOLLOW_ec_sha512_alg_id_in_tbscertificate1141_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1143  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1143	= { FOLLOW_issuer_in_tbscertificate1143_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1145  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1145	= { FOLLOW_validity_in_tbscertificate1145_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1148  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1148	= { FOLLOW_subject_in_tbscertificate1148_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1150  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1150	= { FOLLOW_subjectPKinfo_in_tbscertificate1150_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1153  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1153_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1153	= { FOLLOW_issueruniqueId_in_tbscertificate1153_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1158  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1158_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1158	= { FOLLOW_subjectuniqueId_in_tbscertificate1158_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1163  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1163	= { FOLLOW_constructedTag3_in_tbscertificate1163_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1165  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1165	= { FOLLOW_sequenceTag_in_tbscertificate1165_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate1168  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate1168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate1168	= { FOLLOW_extensions_in_tbscertificate1168_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1181  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1181	= { FOLLOW_sequenceTag_in_tbscertificate1181_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1183  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1183	= { FOLLOW_subjectPKinfo_in_tbscertificate1183_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1186  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1186	= { FOLLOW_issueruniqueId_in_tbscertificate1186_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1191  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1191	= { FOLLOW_subjectuniqueId_in_tbscertificate1191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1195  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1195	= { FOLLOW_constructedTag3_in_tbscertificate1195_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1197  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1197	= { FOLLOW_sequenceTag_in_tbscertificate1197_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate1199  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate1199_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate1199	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate1199_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha512_alg_id_in_tbscertificate1203  */
static	ANTLR3_BITWORD FOLLOW_ec_sha512_alg_id_in_tbscertificate1203_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha512_alg_id_in_tbscertificate1203	= { FOLLOW_ec_sha512_alg_id_in_tbscertificate1203_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1205  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1205	= { FOLLOW_dsa_signature_in_tbscertificate1205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_94_alg_id_in_tbscertificate1208  */
static	ANTLR3_BITWORD FOLLOW_gost_94_alg_id_in_tbscertificate1208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_94_alg_id_in_tbscertificate1208	= { FOLLOW_gost_94_alg_id_in_tbscertificate1208_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1210  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1210	= { FOLLOW_issuer_in_tbscertificate1210_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1212  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1212_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1212	= { FOLLOW_validity_in_tbscertificate1212_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1215  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1215	= { FOLLOW_subject_in_tbscertificate1215_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1217  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1217_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1217	= { FOLLOW_subjectPKinfo_in_tbscertificate1217_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1220  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1220	= { FOLLOW_issueruniqueId_in_tbscertificate1220_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1225  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1225	= { FOLLOW_subjectuniqueId_in_tbscertificate1225_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1230  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1230	= { FOLLOW_constructedTag3_in_tbscertificate1230_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1232  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1232	= { FOLLOW_sequenceTag_in_tbscertificate1232_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate1235  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate1235_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate1235	= { FOLLOW_extensions_in_tbscertificate1235_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1248  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1248_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1248	= { FOLLOW_sequenceTag_in_tbscertificate1248_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1250  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1250	= { FOLLOW_subjectPKinfo_in_tbscertificate1250_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1253  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1253	= { FOLLOW_issueruniqueId_in_tbscertificate1253_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1258  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1258	= { FOLLOW_subjectuniqueId_in_tbscertificate1258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1262  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1262	= { FOLLOW_constructedTag3_in_tbscertificate1262_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1264  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1264	= { FOLLOW_sequenceTag_in_tbscertificate1264_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate1266  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate1266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate1266	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate1266_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_94_alg_id_in_tbscertificate1270  */
static	ANTLR3_BITWORD FOLLOW_gost_94_alg_id_in_tbscertificate1270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_94_alg_id_in_tbscertificate1270	= { FOLLOW_gost_94_alg_id_in_tbscertificate1270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1272  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1272	= { FOLLOW_signature_in_tbscertificate1272_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_01_alg_id_in_tbscertificate1275  */
static	ANTLR3_BITWORD FOLLOW_gost_01_alg_id_in_tbscertificate1275_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_01_alg_id_in_tbscertificate1275	= { FOLLOW_gost_01_alg_id_in_tbscertificate1275_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1277  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1277_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1277	= { FOLLOW_issuer_in_tbscertificate1277_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1279  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1279	= { FOLLOW_validity_in_tbscertificate1279_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1282  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1282	= { FOLLOW_subject_in_tbscertificate1282_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1284  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1284_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1284	= { FOLLOW_subjectPKinfo_in_tbscertificate1284_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1287  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1287	= { FOLLOW_issueruniqueId_in_tbscertificate1287_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1292  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1292	= { FOLLOW_subjectuniqueId_in_tbscertificate1292_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1297  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1297	= { FOLLOW_constructedTag3_in_tbscertificate1297_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1299  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1299	= { FOLLOW_sequenceTag_in_tbscertificate1299_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_tbscertificate1302  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_tbscertificate1302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_tbscertificate1302	= { FOLLOW_extensions_in_tbscertificate1302_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1315  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1315	= { FOLLOW_sequenceTag_in_tbscertificate1315_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1317  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1317_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000180) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1317	= { FOLLOW_subjectPKinfo_in_tbscertificate1317_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1320  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1320	= { FOLLOW_issueruniqueId_in_tbscertificate1320_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1325  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1325_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1325	= { FOLLOW_subjectuniqueId_in_tbscertificate1325_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_tbscertificate1329  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_tbscertificate1329_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_tbscertificate1329	= { FOLLOW_constructedTag3_in_tbscertificate1329_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_tbscertificate1331  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_tbscertificate1331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_tbscertificate1331	= { FOLLOW_sequenceTag_in_tbscertificate1331_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_tbscertificate1333  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_tbscertificate1333_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_tbscertificate1333	= { FOLLOW_extensionsWithSubAlt_in_tbscertificate1333_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_01_alg_id_in_tbscertificate1337  */
static	ANTLR3_BITWORD FOLLOW_gost_01_alg_id_in_tbscertificate1337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_01_alg_id_in_tbscertificate1337	= { FOLLOW_gost_01_alg_id_in_tbscertificate1337_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1339  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1339	= { FOLLOW_signature_in_tbscertificate1339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_tbscertificate1349  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_tbscertificate1349_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_tbscertificate1349	= { FOLLOW_constructedTag0_in_tbscertificate1349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_version2_in_tbscertificate1351  */
static	ANTLR3_BITWORD FOLLOW_version2_in_tbscertificate1351_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_version2_in_tbscertificate1351	= { FOLLOW_version2_in_tbscertificate1351_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_serialnumber_in_tbscertificate1353  */
static	ANTLR3_BITWORD FOLLOW_serialnumber_in_tbscertificate1353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_serialnumber_in_tbscertificate1353	= { FOLLOW_serialnumber_in_tbscertificate1353_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md2_alg_id_in_tbscertificate1358  */
static	ANTLR3_BITWORD FOLLOW_rsa_md2_alg_id_in_tbscertificate1358_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md2_alg_id_in_tbscertificate1358	= { FOLLOW_rsa_md2_alg_id_in_tbscertificate1358_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1360  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1360	= { FOLLOW_issuer_in_tbscertificate1360_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1362  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1362	= { FOLLOW_validity_in_tbscertificate1362_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1364  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1364	= { FOLLOW_subject_in_tbscertificate1364_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1366  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1366_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1366	= { FOLLOW_subjectPKinfo_in_tbscertificate1366_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1369  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1369	= { FOLLOW_issueruniqueId_in_tbscertificate1369_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1374  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1374	= { FOLLOW_subjectuniqueId_in_tbscertificate1374_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md2_alg_id_in_tbscertificate1379  */
static	ANTLR3_BITWORD FOLLOW_rsa_md2_alg_id_in_tbscertificate1379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md2_alg_id_in_tbscertificate1379	= { FOLLOW_rsa_md2_alg_id_in_tbscertificate1379_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1381  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1381	= { FOLLOW_signature_in_tbscertificate1381_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md5_alg_id_in_tbscertificate1385  */
static	ANTLR3_BITWORD FOLLOW_rsa_md5_alg_id_in_tbscertificate1385_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md5_alg_id_in_tbscertificate1385	= { FOLLOW_rsa_md5_alg_id_in_tbscertificate1385_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1387  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1387	= { FOLLOW_issuer_in_tbscertificate1387_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1389  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1389	= { FOLLOW_validity_in_tbscertificate1389_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1391  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1391	= { FOLLOW_subject_in_tbscertificate1391_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1393  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1393_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1393	= { FOLLOW_subjectPKinfo_in_tbscertificate1393_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1396  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1396	= { FOLLOW_issueruniqueId_in_tbscertificate1396_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1401  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1401	= { FOLLOW_subjectuniqueId_in_tbscertificate1401_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md5_alg_id_in_tbscertificate1406  */
static	ANTLR3_BITWORD FOLLOW_rsa_md5_alg_id_in_tbscertificate1406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md5_alg_id_in_tbscertificate1406	= { FOLLOW_rsa_md5_alg_id_in_tbscertificate1406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1408  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1408	= { FOLLOW_signature_in_tbscertificate1408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha1_alg_id_in_tbscertificate1412  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha1_alg_id_in_tbscertificate1412_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha1_alg_id_in_tbscertificate1412	= { FOLLOW_rsa_sha1_alg_id_in_tbscertificate1412_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1414  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1414_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1414	= { FOLLOW_issuer_in_tbscertificate1414_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1416  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1416	= { FOLLOW_validity_in_tbscertificate1416_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1418  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1418	= { FOLLOW_subject_in_tbscertificate1418_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1420  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1420	= { FOLLOW_subjectPKinfo_in_tbscertificate1420_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1423  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1423_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1423	= { FOLLOW_issueruniqueId_in_tbscertificate1423_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1428  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1428	= { FOLLOW_subjectuniqueId_in_tbscertificate1428_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha1_alg_id_in_tbscertificate1433  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha1_alg_id_in_tbscertificate1433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha1_alg_id_in_tbscertificate1433	= { FOLLOW_rsa_sha1_alg_id_in_tbscertificate1433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1435  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1435_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1435	= { FOLLOW_signature_in_tbscertificate1435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha224_alg_id_in_tbscertificate1439  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha224_alg_id_in_tbscertificate1439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha224_alg_id_in_tbscertificate1439	= { FOLLOW_rsa_sha224_alg_id_in_tbscertificate1439_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1441  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1441	= { FOLLOW_issuer_in_tbscertificate1441_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1443  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1443	= { FOLLOW_validity_in_tbscertificate1443_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1445  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1445	= { FOLLOW_subject_in_tbscertificate1445_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1447  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1447_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1447	= { FOLLOW_subjectPKinfo_in_tbscertificate1447_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1450  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1450_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1450	= { FOLLOW_issueruniqueId_in_tbscertificate1450_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1455  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1455	= { FOLLOW_subjectuniqueId_in_tbscertificate1455_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha224_alg_id_in_tbscertificate1460  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha224_alg_id_in_tbscertificate1460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha224_alg_id_in_tbscertificate1460	= { FOLLOW_rsa_sha224_alg_id_in_tbscertificate1460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1462  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1462	= { FOLLOW_signature_in_tbscertificate1462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha256_alg_id_in_tbscertificate1466  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha256_alg_id_in_tbscertificate1466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha256_alg_id_in_tbscertificate1466	= { FOLLOW_rsa_sha256_alg_id_in_tbscertificate1466_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1468  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1468	= { FOLLOW_issuer_in_tbscertificate1468_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1470  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1470	= { FOLLOW_validity_in_tbscertificate1470_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1472  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1472	= { FOLLOW_subject_in_tbscertificate1472_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1474  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1474_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1474	= { FOLLOW_subjectPKinfo_in_tbscertificate1474_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1477  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1477	= { FOLLOW_issueruniqueId_in_tbscertificate1477_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1482  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1482	= { FOLLOW_subjectuniqueId_in_tbscertificate1482_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha256_alg_id_in_tbscertificate1487  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha256_alg_id_in_tbscertificate1487_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha256_alg_id_in_tbscertificate1487	= { FOLLOW_rsa_sha256_alg_id_in_tbscertificate1487_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1489  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1489_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1489	= { FOLLOW_signature_in_tbscertificate1489_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha384_alg_id_in_tbscertificate1493  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha384_alg_id_in_tbscertificate1493_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha384_alg_id_in_tbscertificate1493	= { FOLLOW_rsa_sha384_alg_id_in_tbscertificate1493_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1495  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1495	= { FOLLOW_issuer_in_tbscertificate1495_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1497  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1497	= { FOLLOW_validity_in_tbscertificate1497_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1499  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1499	= { FOLLOW_subject_in_tbscertificate1499_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1501  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1501	= { FOLLOW_subjectPKinfo_in_tbscertificate1501_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1504  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1504	= { FOLLOW_issueruniqueId_in_tbscertificate1504_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1509  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1509	= { FOLLOW_subjectuniqueId_in_tbscertificate1509_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha384_alg_id_in_tbscertificate1514  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha384_alg_id_in_tbscertificate1514_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha384_alg_id_in_tbscertificate1514	= { FOLLOW_rsa_sha384_alg_id_in_tbscertificate1514_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1516  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1516	= { FOLLOW_signature_in_tbscertificate1516_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha512_alg_id_in_tbscertificate1520  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha512_alg_id_in_tbscertificate1520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha512_alg_id_in_tbscertificate1520	= { FOLLOW_rsa_sha512_alg_id_in_tbscertificate1520_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1522  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1522	= { FOLLOW_issuer_in_tbscertificate1522_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1524  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1524_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1524	= { FOLLOW_validity_in_tbscertificate1524_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1526  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1526_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1526	= { FOLLOW_subject_in_tbscertificate1526_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1528  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1528	= { FOLLOW_subjectPKinfo_in_tbscertificate1528_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1531  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1531	= { FOLLOW_issueruniqueId_in_tbscertificate1531_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1536  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1536_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1536	= { FOLLOW_subjectuniqueId_in_tbscertificate1536_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha512_alg_id_in_tbscertificate1541  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha512_alg_id_in_tbscertificate1541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha512_alg_id_in_tbscertificate1541	= { FOLLOW_rsa_sha512_alg_id_in_tbscertificate1541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1543  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1543	= { FOLLOW_signature_in_tbscertificate1543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha_alg_id_in_tbscertificate1547  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha_alg_id_in_tbscertificate1547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha_alg_id_in_tbscertificate1547	= { FOLLOW_dsa_sha_alg_id_in_tbscertificate1547_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1549  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1549_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1549	= { FOLLOW_issuer_in_tbscertificate1549_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1551  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1551_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1551	= { FOLLOW_validity_in_tbscertificate1551_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1553  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1553_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1553	= { FOLLOW_subject_in_tbscertificate1553_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1555  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1555_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1555	= { FOLLOW_subjectPKinfo_in_tbscertificate1555_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1558  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1558	= { FOLLOW_issueruniqueId_in_tbscertificate1558_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1563  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1563_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1563	= { FOLLOW_subjectuniqueId_in_tbscertificate1563_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha_alg_id_in_tbscertificate1568  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha_alg_id_in_tbscertificate1568_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha_alg_id_in_tbscertificate1568	= { FOLLOW_dsa_sha_alg_id_in_tbscertificate1568_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1570  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1570_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1570	= { FOLLOW_dsa_signature_in_tbscertificate1570_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha_alg_id_in_tbscertificate1574  */
static	ANTLR3_BITWORD FOLLOW_ec_sha_alg_id_in_tbscertificate1574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha_alg_id_in_tbscertificate1574	= { FOLLOW_ec_sha_alg_id_in_tbscertificate1574_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1576  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1576	= { FOLLOW_issuer_in_tbscertificate1576_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1578  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1578	= { FOLLOW_validity_in_tbscertificate1578_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1580  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1580	= { FOLLOW_subject_in_tbscertificate1580_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1582  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1582_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1582	= { FOLLOW_subjectPKinfo_in_tbscertificate1582_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1585  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1585_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1585	= { FOLLOW_issueruniqueId_in_tbscertificate1585_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1590  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1590	= { FOLLOW_subjectuniqueId_in_tbscertificate1590_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha_alg_id_in_tbscertificate1595  */
static	ANTLR3_BITWORD FOLLOW_ec_sha_alg_id_in_tbscertificate1595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha_alg_id_in_tbscertificate1595	= { FOLLOW_ec_sha_alg_id_in_tbscertificate1595_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1597  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1597_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1597	= { FOLLOW_dsa_signature_in_tbscertificate1597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pss_alg_id_params_in_tbscertificate1602  */
static	ANTLR3_BITWORD FOLLOW_pss_alg_id_params_in_tbscertificate1602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pss_alg_id_params_in_tbscertificate1602	= { FOLLOW_pss_alg_id_params_in_tbscertificate1602_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1604  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1604_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1604	= { FOLLOW_issuer_in_tbscertificate1604_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1606  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1606_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1606	= { FOLLOW_validity_in_tbscertificate1606_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1608  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1608_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1608	= { FOLLOW_subject_in_tbscertificate1608_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1610  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1610_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1610	= { FOLLOW_subjectPKinfo_in_tbscertificate1610_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1613  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1613_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1613	= { FOLLOW_issueruniqueId_in_tbscertificate1613_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1618  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1618	= { FOLLOW_subjectuniqueId_in_tbscertificate1618_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pss_alg_id_params_in_tbscertificate1623  */
static	ANTLR3_BITWORD FOLLOW_pss_alg_id_params_in_tbscertificate1623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_pss_alg_id_params_in_tbscertificate1623	= { FOLLOW_pss_alg_id_params_in_tbscertificate1623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1625  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1625	= { FOLLOW_signature_in_tbscertificate1625_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha224_alg_id_in_tbscertificate1629  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha224_alg_id_in_tbscertificate1629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha224_alg_id_in_tbscertificate1629	= { FOLLOW_dsa_sha224_alg_id_in_tbscertificate1629_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1631  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1631_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1631	= { FOLLOW_issuer_in_tbscertificate1631_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1633  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1633	= { FOLLOW_validity_in_tbscertificate1633_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1635  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1635_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1635	= { FOLLOW_subject_in_tbscertificate1635_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1637  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1637_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1637	= { FOLLOW_subjectPKinfo_in_tbscertificate1637_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1640  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1640_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1640	= { FOLLOW_issueruniqueId_in_tbscertificate1640_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1645  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1645_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1645	= { FOLLOW_subjectuniqueId_in_tbscertificate1645_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha224_alg_id_in_tbscertificate1650  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha224_alg_id_in_tbscertificate1650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha224_alg_id_in_tbscertificate1650	= { FOLLOW_dsa_sha224_alg_id_in_tbscertificate1650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1652  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1652_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1652	= { FOLLOW_dsa_signature_in_tbscertificate1652_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha256_alg_id_in_tbscertificate1656  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha256_alg_id_in_tbscertificate1656_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha256_alg_id_in_tbscertificate1656	= { FOLLOW_dsa_sha256_alg_id_in_tbscertificate1656_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1658  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1658_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1658	= { FOLLOW_issuer_in_tbscertificate1658_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1660  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1660_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1660	= { FOLLOW_validity_in_tbscertificate1660_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1662  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1662_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1662	= { FOLLOW_subject_in_tbscertificate1662_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1664  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1664	= { FOLLOW_subjectPKinfo_in_tbscertificate1664_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1667  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1667	= { FOLLOW_issueruniqueId_in_tbscertificate1667_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1672  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1672_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1672	= { FOLLOW_subjectuniqueId_in_tbscertificate1672_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha256_alg_id_in_tbscertificate1677  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha256_alg_id_in_tbscertificate1677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha256_alg_id_in_tbscertificate1677	= { FOLLOW_dsa_sha256_alg_id_in_tbscertificate1677_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1679  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1679	= { FOLLOW_dsa_signature_in_tbscertificate1679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha224_alg_id_in_tbscertificate1683  */
static	ANTLR3_BITWORD FOLLOW_ec_sha224_alg_id_in_tbscertificate1683_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha224_alg_id_in_tbscertificate1683	= { FOLLOW_ec_sha224_alg_id_in_tbscertificate1683_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1685  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1685	= { FOLLOW_issuer_in_tbscertificate1685_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1687  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1687	= { FOLLOW_validity_in_tbscertificate1687_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1689  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1689	= { FOLLOW_subject_in_tbscertificate1689_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1691  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1691	= { FOLLOW_subjectPKinfo_in_tbscertificate1691_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1694  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1694_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1694	= { FOLLOW_issueruniqueId_in_tbscertificate1694_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1699  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1699	= { FOLLOW_subjectuniqueId_in_tbscertificate1699_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha224_alg_id_in_tbscertificate1704  */
static	ANTLR3_BITWORD FOLLOW_ec_sha224_alg_id_in_tbscertificate1704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha224_alg_id_in_tbscertificate1704	= { FOLLOW_ec_sha224_alg_id_in_tbscertificate1704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1706  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1706_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1706	= { FOLLOW_dsa_signature_in_tbscertificate1706_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha256_alg_id_in_tbscertificate1710  */
static	ANTLR3_BITWORD FOLLOW_ec_sha256_alg_id_in_tbscertificate1710_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha256_alg_id_in_tbscertificate1710	= { FOLLOW_ec_sha256_alg_id_in_tbscertificate1710_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1712  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1712_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1712	= { FOLLOW_issuer_in_tbscertificate1712_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1714  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1714	= { FOLLOW_validity_in_tbscertificate1714_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1716  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1716_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1716	= { FOLLOW_subject_in_tbscertificate1716_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1718  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1718	= { FOLLOW_subjectPKinfo_in_tbscertificate1718_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1721  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1721	= { FOLLOW_issueruniqueId_in_tbscertificate1721_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1726  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1726_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1726	= { FOLLOW_subjectuniqueId_in_tbscertificate1726_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha256_alg_id_in_tbscertificate1731  */
static	ANTLR3_BITWORD FOLLOW_ec_sha256_alg_id_in_tbscertificate1731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha256_alg_id_in_tbscertificate1731	= { FOLLOW_ec_sha256_alg_id_in_tbscertificate1731_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1733  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1733_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1733	= { FOLLOW_dsa_signature_in_tbscertificate1733_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha384_alg_id_in_tbscertificate1737  */
static	ANTLR3_BITWORD FOLLOW_ec_sha384_alg_id_in_tbscertificate1737_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha384_alg_id_in_tbscertificate1737	= { FOLLOW_ec_sha384_alg_id_in_tbscertificate1737_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1739  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1739	= { FOLLOW_issuer_in_tbscertificate1739_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1741  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1741	= { FOLLOW_validity_in_tbscertificate1741_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1743  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1743	= { FOLLOW_subject_in_tbscertificate1743_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1745  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1745	= { FOLLOW_subjectPKinfo_in_tbscertificate1745_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1748  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1748_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1748	= { FOLLOW_issueruniqueId_in_tbscertificate1748_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1753  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1753_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1753	= { FOLLOW_subjectuniqueId_in_tbscertificate1753_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha384_alg_id_in_tbscertificate1758  */
static	ANTLR3_BITWORD FOLLOW_ec_sha384_alg_id_in_tbscertificate1758_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha384_alg_id_in_tbscertificate1758	= { FOLLOW_ec_sha384_alg_id_in_tbscertificate1758_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1760  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1760	= { FOLLOW_dsa_signature_in_tbscertificate1760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha512_alg_id_in_tbscertificate1764  */
static	ANTLR3_BITWORD FOLLOW_ec_sha512_alg_id_in_tbscertificate1764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha512_alg_id_in_tbscertificate1764	= { FOLLOW_ec_sha512_alg_id_in_tbscertificate1764_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1766  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1766	= { FOLLOW_issuer_in_tbscertificate1766_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1768  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1768_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1768	= { FOLLOW_validity_in_tbscertificate1768_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1770  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1770_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1770	= { FOLLOW_subject_in_tbscertificate1770_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1772  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1772_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1772	= { FOLLOW_subjectPKinfo_in_tbscertificate1772_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1775  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1775	= { FOLLOW_issueruniqueId_in_tbscertificate1775_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1780  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1780_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1780	= { FOLLOW_subjectuniqueId_in_tbscertificate1780_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha512_alg_id_in_tbscertificate1785  */
static	ANTLR3_BITWORD FOLLOW_ec_sha512_alg_id_in_tbscertificate1785_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha512_alg_id_in_tbscertificate1785	= { FOLLOW_ec_sha512_alg_id_in_tbscertificate1785_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1787  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1787	= { FOLLOW_dsa_signature_in_tbscertificate1787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_94_alg_id_in_tbscertificate1791  */
static	ANTLR3_BITWORD FOLLOW_gost_94_alg_id_in_tbscertificate1791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_94_alg_id_in_tbscertificate1791	= { FOLLOW_gost_94_alg_id_in_tbscertificate1791_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1793  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1793	= { FOLLOW_issuer_in_tbscertificate1793_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1795  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1795_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1795	= { FOLLOW_validity_in_tbscertificate1795_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1797  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1797_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1797	= { FOLLOW_subject_in_tbscertificate1797_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1799  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1799_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1799	= { FOLLOW_subjectPKinfo_in_tbscertificate1799_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1802  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1802_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1802	= { FOLLOW_issueruniqueId_in_tbscertificate1802_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1807  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1807	= { FOLLOW_subjectuniqueId_in_tbscertificate1807_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_94_alg_id_in_tbscertificate1812  */
static	ANTLR3_BITWORD FOLLOW_gost_94_alg_id_in_tbscertificate1812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_94_alg_id_in_tbscertificate1812	= { FOLLOW_gost_94_alg_id_in_tbscertificate1812_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1814  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1814	= { FOLLOW_signature_in_tbscertificate1814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_01_alg_id_in_tbscertificate1818  */
static	ANTLR3_BITWORD FOLLOW_gost_01_alg_id_in_tbscertificate1818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_01_alg_id_in_tbscertificate1818	= { FOLLOW_gost_01_alg_id_in_tbscertificate1818_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1820  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1820_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1820	= { FOLLOW_issuer_in_tbscertificate1820_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1822  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1822	= { FOLLOW_validity_in_tbscertificate1822_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1824  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1824	= { FOLLOW_subject_in_tbscertificate1824_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1826  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1826_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1826	= { FOLLOW_subjectPKinfo_in_tbscertificate1826_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issueruniqueId_in_tbscertificate1829  */
static	ANTLR3_BITWORD FOLLOW_issueruniqueId_in_tbscertificate1829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_issueruniqueId_in_tbscertificate1829	= { FOLLOW_issueruniqueId_in_tbscertificate1829_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectuniqueId_in_tbscertificate1834  */
static	ANTLR3_BITWORD FOLLOW_subjectuniqueId_in_tbscertificate1834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectuniqueId_in_tbscertificate1834	= { FOLLOW_subjectuniqueId_in_tbscertificate1834_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_01_alg_id_in_tbscertificate1839  */
static	ANTLR3_BITWORD FOLLOW_gost_01_alg_id_in_tbscertificate1839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_01_alg_id_in_tbscertificate1839	= { FOLLOW_gost_01_alg_id_in_tbscertificate1839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1841  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1841_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1841	= { FOLLOW_signature_in_tbscertificate1841_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_tbscertificate1852  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_tbscertificate1852_bits[]	= { ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_tbscertificate1852	= { FOLLOW_constructedTag0_in_tbscertificate1852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_version_in_tbscertificate1854  */
static	ANTLR3_BITWORD FOLLOW_version_in_tbscertificate1854_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_version_in_tbscertificate1854	= { FOLLOW_version_in_tbscertificate1854_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_serialnumber_in_tbscertificate1858  */
static	ANTLR3_BITWORD FOLLOW_serialnumber_in_tbscertificate1858_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_serialnumber_in_tbscertificate1858	= { FOLLOW_serialnumber_in_tbscertificate1858_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md2_alg_id_in_tbscertificate1862  */
static	ANTLR3_BITWORD FOLLOW_rsa_md2_alg_id_in_tbscertificate1862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md2_alg_id_in_tbscertificate1862	= { FOLLOW_rsa_md2_alg_id_in_tbscertificate1862_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1864  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1864	= { FOLLOW_issuer_in_tbscertificate1864_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1866  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1866_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1866	= { FOLLOW_validity_in_tbscertificate1866_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1868  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1868	= { FOLLOW_subject_in_tbscertificate1868_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1870  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1870	= { FOLLOW_subjectPKinfo_in_tbscertificate1870_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md2_alg_id_in_tbscertificate1872  */
static	ANTLR3_BITWORD FOLLOW_rsa_md2_alg_id_in_tbscertificate1872_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md2_alg_id_in_tbscertificate1872	= { FOLLOW_rsa_md2_alg_id_in_tbscertificate1872_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1874  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1874_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1874	= { FOLLOW_signature_in_tbscertificate1874_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md5_alg_id_in_tbscertificate1879  */
static	ANTLR3_BITWORD FOLLOW_rsa_md5_alg_id_in_tbscertificate1879_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md5_alg_id_in_tbscertificate1879	= { FOLLOW_rsa_md5_alg_id_in_tbscertificate1879_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1881  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1881	= { FOLLOW_issuer_in_tbscertificate1881_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1883  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1883	= { FOLLOW_validity_in_tbscertificate1883_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1885  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1885_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1885	= { FOLLOW_subject_in_tbscertificate1885_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1887  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1887_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1887	= { FOLLOW_subjectPKinfo_in_tbscertificate1887_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_md5_alg_id_in_tbscertificate1889  */
static	ANTLR3_BITWORD FOLLOW_rsa_md5_alg_id_in_tbscertificate1889_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_md5_alg_id_in_tbscertificate1889	= { FOLLOW_rsa_md5_alg_id_in_tbscertificate1889_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1891  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1891_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1891	= { FOLLOW_signature_in_tbscertificate1891_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha1_alg_id_in_tbscertificate1895  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha1_alg_id_in_tbscertificate1895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha1_alg_id_in_tbscertificate1895	= { FOLLOW_rsa_sha1_alg_id_in_tbscertificate1895_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1897  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1897	= { FOLLOW_issuer_in_tbscertificate1897_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1899  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1899_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1899	= { FOLLOW_validity_in_tbscertificate1899_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1901  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1901	= { FOLLOW_subject_in_tbscertificate1901_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1903  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1903	= { FOLLOW_subjectPKinfo_in_tbscertificate1903_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha1_alg_id_in_tbscertificate1905  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha1_alg_id_in_tbscertificate1905_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha1_alg_id_in_tbscertificate1905	= { FOLLOW_rsa_sha1_alg_id_in_tbscertificate1905_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1907  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1907_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1907	= { FOLLOW_signature_in_tbscertificate1907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha224_alg_id_in_tbscertificate1911  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha224_alg_id_in_tbscertificate1911_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha224_alg_id_in_tbscertificate1911	= { FOLLOW_rsa_sha224_alg_id_in_tbscertificate1911_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1913  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1913_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1913	= { FOLLOW_issuer_in_tbscertificate1913_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1915  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1915_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1915	= { FOLLOW_validity_in_tbscertificate1915_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1917  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1917	= { FOLLOW_subject_in_tbscertificate1917_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1919  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1919_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1919	= { FOLLOW_subjectPKinfo_in_tbscertificate1919_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha224_alg_id_in_tbscertificate1921  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha224_alg_id_in_tbscertificate1921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha224_alg_id_in_tbscertificate1921	= { FOLLOW_rsa_sha224_alg_id_in_tbscertificate1921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1923  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1923_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1923	= { FOLLOW_signature_in_tbscertificate1923_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha256_alg_id_in_tbscertificate1927  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha256_alg_id_in_tbscertificate1927_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha256_alg_id_in_tbscertificate1927	= { FOLLOW_rsa_sha256_alg_id_in_tbscertificate1927_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1929  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1929_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1929	= { FOLLOW_issuer_in_tbscertificate1929_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1931  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1931_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1931	= { FOLLOW_validity_in_tbscertificate1931_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1933  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1933_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1933	= { FOLLOW_subject_in_tbscertificate1933_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1935  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1935	= { FOLLOW_subjectPKinfo_in_tbscertificate1935_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha256_alg_id_in_tbscertificate1937  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha256_alg_id_in_tbscertificate1937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha256_alg_id_in_tbscertificate1937	= { FOLLOW_rsa_sha256_alg_id_in_tbscertificate1937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1939  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1939	= { FOLLOW_signature_in_tbscertificate1939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha384_alg_id_in_tbscertificate1943  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha384_alg_id_in_tbscertificate1943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha384_alg_id_in_tbscertificate1943	= { FOLLOW_rsa_sha384_alg_id_in_tbscertificate1943_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1945  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1945_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1945	= { FOLLOW_issuer_in_tbscertificate1945_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1947  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1947_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1947	= { FOLLOW_validity_in_tbscertificate1947_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1949  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1949_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1949	= { FOLLOW_subject_in_tbscertificate1949_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1951  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1951_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1951	= { FOLLOW_subjectPKinfo_in_tbscertificate1951_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha384_alg_id_in_tbscertificate1953  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha384_alg_id_in_tbscertificate1953_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha384_alg_id_in_tbscertificate1953	= { FOLLOW_rsa_sha384_alg_id_in_tbscertificate1953_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1955  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1955_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1955	= { FOLLOW_signature_in_tbscertificate1955_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha512_alg_id_in_tbscertificate1959  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha512_alg_id_in_tbscertificate1959_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha512_alg_id_in_tbscertificate1959	= { FOLLOW_rsa_sha512_alg_id_in_tbscertificate1959_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1961  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1961_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1961	= { FOLLOW_issuer_in_tbscertificate1961_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1963  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1963_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1963	= { FOLLOW_validity_in_tbscertificate1963_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1965  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1965_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1965	= { FOLLOW_subject_in_tbscertificate1965_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1967  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1967_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1967	= { FOLLOW_subjectPKinfo_in_tbscertificate1967_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_sha512_alg_id_in_tbscertificate1969  */
static	ANTLR3_BITWORD FOLLOW_rsa_sha512_alg_id_in_tbscertificate1969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_sha512_alg_id_in_tbscertificate1969	= { FOLLOW_rsa_sha512_alg_id_in_tbscertificate1969_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate1971  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate1971_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate1971	= { FOLLOW_signature_in_tbscertificate1971_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha_alg_id_in_tbscertificate1975  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha_alg_id_in_tbscertificate1975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha_alg_id_in_tbscertificate1975	= { FOLLOW_dsa_sha_alg_id_in_tbscertificate1975_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1977  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1977_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1977	= { FOLLOW_issuer_in_tbscertificate1977_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1979  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1979_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1979	= { FOLLOW_validity_in_tbscertificate1979_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1981  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1981_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1981	= { FOLLOW_subject_in_tbscertificate1981_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1983  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1983_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1983	= { FOLLOW_subjectPKinfo_in_tbscertificate1983_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha_alg_id_in_tbscertificate1985  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha_alg_id_in_tbscertificate1985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha_alg_id_in_tbscertificate1985	= { FOLLOW_dsa_sha_alg_id_in_tbscertificate1985_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate1987  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate1987_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate1987	= { FOLLOW_dsa_signature_in_tbscertificate1987_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha_alg_id_in_tbscertificate1991  */
static	ANTLR3_BITWORD FOLLOW_ec_sha_alg_id_in_tbscertificate1991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha_alg_id_in_tbscertificate1991	= { FOLLOW_ec_sha_alg_id_in_tbscertificate1991_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate1993  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate1993_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate1993	= { FOLLOW_issuer_in_tbscertificate1993_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate1995  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate1995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate1995	= { FOLLOW_validity_in_tbscertificate1995_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate1997  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate1997_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate1997	= { FOLLOW_subject_in_tbscertificate1997_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate1999  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate1999_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate1999	= { FOLLOW_subjectPKinfo_in_tbscertificate1999_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha_alg_id_in_tbscertificate2001  */
static	ANTLR3_BITWORD FOLLOW_ec_sha_alg_id_in_tbscertificate2001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha_alg_id_in_tbscertificate2001	= { FOLLOW_ec_sha_alg_id_in_tbscertificate2001_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate2003  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate2003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate2003	= { FOLLOW_dsa_signature_in_tbscertificate2003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pss_alg_id_params_in_tbscertificate2007  */
static	ANTLR3_BITWORD FOLLOW_pss_alg_id_params_in_tbscertificate2007_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pss_alg_id_params_in_tbscertificate2007	= { FOLLOW_pss_alg_id_params_in_tbscertificate2007_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate2009  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate2009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate2009	= { FOLLOW_issuer_in_tbscertificate2009_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate2011  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate2011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate2011	= { FOLLOW_validity_in_tbscertificate2011_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate2013  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate2013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate2013	= { FOLLOW_subject_in_tbscertificate2013_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate2015  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate2015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate2015	= { FOLLOW_subjectPKinfo_in_tbscertificate2015_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pss_alg_id_params_in_tbscertificate2017  */
static	ANTLR3_BITWORD FOLLOW_pss_alg_id_params_in_tbscertificate2017_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_pss_alg_id_params_in_tbscertificate2017	= { FOLLOW_pss_alg_id_params_in_tbscertificate2017_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate2019  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate2019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate2019	= { FOLLOW_signature_in_tbscertificate2019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha224_alg_id_in_tbscertificate2023  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha224_alg_id_in_tbscertificate2023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha224_alg_id_in_tbscertificate2023	= { FOLLOW_dsa_sha224_alg_id_in_tbscertificate2023_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate2025  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate2025_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate2025	= { FOLLOW_issuer_in_tbscertificate2025_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate2027  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate2027_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate2027	= { FOLLOW_validity_in_tbscertificate2027_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate2029  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate2029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate2029	= { FOLLOW_subject_in_tbscertificate2029_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate2031  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate2031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate2031	= { FOLLOW_subjectPKinfo_in_tbscertificate2031_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha224_alg_id_in_tbscertificate2033  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha224_alg_id_in_tbscertificate2033_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha224_alg_id_in_tbscertificate2033	= { FOLLOW_dsa_sha224_alg_id_in_tbscertificate2033_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate2035  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate2035_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate2035	= { FOLLOW_dsa_signature_in_tbscertificate2035_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha256_alg_id_in_tbscertificate2039  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha256_alg_id_in_tbscertificate2039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha256_alg_id_in_tbscertificate2039	= { FOLLOW_dsa_sha256_alg_id_in_tbscertificate2039_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate2041  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate2041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate2041	= { FOLLOW_issuer_in_tbscertificate2041_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate2043  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate2043_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate2043	= { FOLLOW_validity_in_tbscertificate2043_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate2045  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate2045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate2045	= { FOLLOW_subject_in_tbscertificate2045_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate2047  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate2047_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate2047	= { FOLLOW_subjectPKinfo_in_tbscertificate2047_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_sha256_alg_id_in_tbscertificate2049  */
static	ANTLR3_BITWORD FOLLOW_dsa_sha256_alg_id_in_tbscertificate2049_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_sha256_alg_id_in_tbscertificate2049	= { FOLLOW_dsa_sha256_alg_id_in_tbscertificate2049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate2051  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate2051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate2051	= { FOLLOW_dsa_signature_in_tbscertificate2051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha224_alg_id_in_tbscertificate2055  */
static	ANTLR3_BITWORD FOLLOW_ec_sha224_alg_id_in_tbscertificate2055_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha224_alg_id_in_tbscertificate2055	= { FOLLOW_ec_sha224_alg_id_in_tbscertificate2055_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate2057  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate2057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate2057	= { FOLLOW_issuer_in_tbscertificate2057_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate2059  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate2059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate2059	= { FOLLOW_validity_in_tbscertificate2059_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate2061  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate2061_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate2061	= { FOLLOW_subject_in_tbscertificate2061_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate2063  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate2063_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate2063	= { FOLLOW_subjectPKinfo_in_tbscertificate2063_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha224_alg_id_in_tbscertificate2065  */
static	ANTLR3_BITWORD FOLLOW_ec_sha224_alg_id_in_tbscertificate2065_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha224_alg_id_in_tbscertificate2065	= { FOLLOW_ec_sha224_alg_id_in_tbscertificate2065_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate2067  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate2067_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate2067	= { FOLLOW_dsa_signature_in_tbscertificate2067_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha256_alg_id_in_tbscertificate2071  */
static	ANTLR3_BITWORD FOLLOW_ec_sha256_alg_id_in_tbscertificate2071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha256_alg_id_in_tbscertificate2071	= { FOLLOW_ec_sha256_alg_id_in_tbscertificate2071_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate2073  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate2073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate2073	= { FOLLOW_issuer_in_tbscertificate2073_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate2075  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate2075_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate2075	= { FOLLOW_validity_in_tbscertificate2075_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate2077  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate2077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate2077	= { FOLLOW_subject_in_tbscertificate2077_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate2079  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate2079_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate2079	= { FOLLOW_subjectPKinfo_in_tbscertificate2079_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha256_alg_id_in_tbscertificate2081  */
static	ANTLR3_BITWORD FOLLOW_ec_sha256_alg_id_in_tbscertificate2081_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha256_alg_id_in_tbscertificate2081	= { FOLLOW_ec_sha256_alg_id_in_tbscertificate2081_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate2083  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate2083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate2083	= { FOLLOW_dsa_signature_in_tbscertificate2083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha384_alg_id_in_tbscertificate2087  */
static	ANTLR3_BITWORD FOLLOW_ec_sha384_alg_id_in_tbscertificate2087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha384_alg_id_in_tbscertificate2087	= { FOLLOW_ec_sha384_alg_id_in_tbscertificate2087_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate2089  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate2089_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate2089	= { FOLLOW_issuer_in_tbscertificate2089_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate2091  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate2091_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate2091	= { FOLLOW_validity_in_tbscertificate2091_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate2093  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate2093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate2093	= { FOLLOW_subject_in_tbscertificate2093_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate2095  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate2095_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate2095	= { FOLLOW_subjectPKinfo_in_tbscertificate2095_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha384_alg_id_in_tbscertificate2097  */
static	ANTLR3_BITWORD FOLLOW_ec_sha384_alg_id_in_tbscertificate2097_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha384_alg_id_in_tbscertificate2097	= { FOLLOW_ec_sha384_alg_id_in_tbscertificate2097_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate2099  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate2099_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate2099	= { FOLLOW_dsa_signature_in_tbscertificate2099_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha512_alg_id_in_tbscertificate2103  */
static	ANTLR3_BITWORD FOLLOW_ec_sha512_alg_id_in_tbscertificate2103_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha512_alg_id_in_tbscertificate2103	= { FOLLOW_ec_sha512_alg_id_in_tbscertificate2103_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate2105  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate2105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate2105	= { FOLLOW_issuer_in_tbscertificate2105_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate2107  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate2107_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate2107	= { FOLLOW_validity_in_tbscertificate2107_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate2109  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate2109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate2109	= { FOLLOW_subject_in_tbscertificate2109_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate2111  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate2111_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate2111	= { FOLLOW_subjectPKinfo_in_tbscertificate2111_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_sha512_alg_id_in_tbscertificate2113  */
static	ANTLR3_BITWORD FOLLOW_ec_sha512_alg_id_in_tbscertificate2113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_sha512_alg_id_in_tbscertificate2113	= { FOLLOW_ec_sha512_alg_id_in_tbscertificate2113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_signature_in_tbscertificate2115  */
static	ANTLR3_BITWORD FOLLOW_dsa_signature_in_tbscertificate2115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_signature_in_tbscertificate2115	= { FOLLOW_dsa_signature_in_tbscertificate2115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_94_alg_id_in_tbscertificate2119  */
static	ANTLR3_BITWORD FOLLOW_gost_94_alg_id_in_tbscertificate2119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_94_alg_id_in_tbscertificate2119	= { FOLLOW_gost_94_alg_id_in_tbscertificate2119_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate2121  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate2121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate2121	= { FOLLOW_issuer_in_tbscertificate2121_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate2123  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate2123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate2123	= { FOLLOW_validity_in_tbscertificate2123_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate2125  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate2125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate2125	= { FOLLOW_subject_in_tbscertificate2125_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate2127  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate2127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate2127	= { FOLLOW_subjectPKinfo_in_tbscertificate2127_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_94_alg_id_in_tbscertificate2129  */
static	ANTLR3_BITWORD FOLLOW_gost_94_alg_id_in_tbscertificate2129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_94_alg_id_in_tbscertificate2129	= { FOLLOW_gost_94_alg_id_in_tbscertificate2129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate2131  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate2131_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate2131	= { FOLLOW_signature_in_tbscertificate2131_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_01_alg_id_in_tbscertificate2135  */
static	ANTLR3_BITWORD FOLLOW_gost_01_alg_id_in_tbscertificate2135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_01_alg_id_in_tbscertificate2135	= { FOLLOW_gost_01_alg_id_in_tbscertificate2135_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuer_in_tbscertificate2137  */
static	ANTLR3_BITWORD FOLLOW_issuer_in_tbscertificate2137_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuer_in_tbscertificate2137	= { FOLLOW_issuer_in_tbscertificate2137_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_validity_in_tbscertificate2139  */
static	ANTLR3_BITWORD FOLLOW_validity_in_tbscertificate2139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_validity_in_tbscertificate2139	= { FOLLOW_validity_in_tbscertificate2139_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subject_in_tbscertificate2141  */
static	ANTLR3_BITWORD FOLLOW_subject_in_tbscertificate2141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subject_in_tbscertificate2141	= { FOLLOW_subject_in_tbscertificate2141_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectPKinfo_in_tbscertificate2143  */
static	ANTLR3_BITWORD FOLLOW_subjectPKinfo_in_tbscertificate2143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectPKinfo_in_tbscertificate2143	= { FOLLOW_subjectPKinfo_in_tbscertificate2143_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost_01_alg_id_in_tbscertificate2145  */
static	ANTLR3_BITWORD FOLLOW_gost_01_alg_id_in_tbscertificate2145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_gost_01_alg_id_in_tbscertificate2145	= { FOLLOW_gost_01_alg_id_in_tbscertificate2145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_signature_in_tbscertificate2147  */
static	ANTLR3_BITWORD FOLLOW_signature_in_tbscertificate2147_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_signature_in_tbscertificate2147	= { FOLLOW_signature_in_tbscertificate2147_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_algorithm_id2168  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_algorithm_id2168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_algorithm_id2168	= { FOLLOW_sequenceTag_in_algorithm_id2168_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_algorithm_id2172  */
static	ANTLR3_BITWORD FOLLOW_oid_in_algorithm_id2172_bits[]	= { ANTLR3_UINT64_LIT(0x01F702001FF81C02), ANTLR3_UINT64_LIT(0x0000008300000001), ANTLR3_UINT64_LIT(0x00030EFFFFFFFFC6) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_algorithm_id2172	= { FOLLOW_oid_in_algorithm_id2172_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_any_in_algorithm_id2179  */
static	ANTLR3_BITWORD FOLLOW_any_in_algorithm_id2179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_any_in_algorithm_id2179	= { FOLLOW_any_in_algorithm_id2179_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsa_md2_alg_id2200  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsa_md2_alg_id2200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsa_md2_alg_id2200	= { FOLLOW_sequenceTag_in_rsa_md2_alg_id2200_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_md2rsaoid_in_rsa_md2_alg_id2202  */
static	ANTLR3_BITWORD FOLLOW_md2rsaoid_in_rsa_md2_alg_id2202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_md2rsaoid_in_rsa_md2_alg_id2202	= { FOLLOW_md2rsaoid_in_rsa_md2_alg_id2202_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_rsa_md2_alg_id2204  */
static	ANTLR3_BITWORD FOLLOW_null_in_rsa_md2_alg_id2204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_rsa_md2_alg_id2204	= { FOLLOW_null_in_rsa_md2_alg_id2204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsa_md5_alg_id2224  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsa_md5_alg_id2224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsa_md5_alg_id2224	= { FOLLOW_sequenceTag_in_rsa_md5_alg_id2224_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_md5rsaoid_in_rsa_md5_alg_id2226  */
static	ANTLR3_BITWORD FOLLOW_md5rsaoid_in_rsa_md5_alg_id2226_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_md5rsaoid_in_rsa_md5_alg_id2226	= { FOLLOW_md5rsaoid_in_rsa_md5_alg_id2226_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_rsa_md5_alg_id2228  */
static	ANTLR3_BITWORD FOLLOW_null_in_rsa_md5_alg_id2228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_rsa_md5_alg_id2228	= { FOLLOW_null_in_rsa_md5_alg_id2228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsa_sha1_alg_id2247  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsa_sha1_alg_id2247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsa_sha1_alg_id2247	= { FOLLOW_sequenceTag_in_rsa_sha1_alg_id2247_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha1rsaoid_in_rsa_sha1_alg_id2249  */
static	ANTLR3_BITWORD FOLLOW_sha1rsaoid_in_rsa_sha1_alg_id2249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha1rsaoid_in_rsa_sha1_alg_id2249	= { FOLLOW_sha1rsaoid_in_rsa_sha1_alg_id2249_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_rsa_sha1_alg_id2251  */
static	ANTLR3_BITWORD FOLLOW_null_in_rsa_sha1_alg_id2251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_rsa_sha1_alg_id2251	= { FOLLOW_null_in_rsa_sha1_alg_id2251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsa_sha224_alg_id2272  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsa_sha224_alg_id2272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsa_sha224_alg_id2272	= { FOLLOW_sequenceTag_in_rsa_sha224_alg_id2272_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha224rsaoid_in_rsa_sha224_alg_id2274  */
static	ANTLR3_BITWORD FOLLOW_sha224rsaoid_in_rsa_sha224_alg_id2274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha224rsaoid_in_rsa_sha224_alg_id2274	= { FOLLOW_sha224rsaoid_in_rsa_sha224_alg_id2274_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_rsa_sha224_alg_id2276  */
static	ANTLR3_BITWORD FOLLOW_null_in_rsa_sha224_alg_id2276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_rsa_sha224_alg_id2276	= { FOLLOW_null_in_rsa_sha224_alg_id2276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsa_sha256_alg_id2296  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsa_sha256_alg_id2296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsa_sha256_alg_id2296	= { FOLLOW_sequenceTag_in_rsa_sha256_alg_id2296_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha256rsaoid_in_rsa_sha256_alg_id2298  */
static	ANTLR3_BITWORD FOLLOW_sha256rsaoid_in_rsa_sha256_alg_id2298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha256rsaoid_in_rsa_sha256_alg_id2298	= { FOLLOW_sha256rsaoid_in_rsa_sha256_alg_id2298_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_rsa_sha256_alg_id2300  */
static	ANTLR3_BITWORD FOLLOW_null_in_rsa_sha256_alg_id2300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_rsa_sha256_alg_id2300	= { FOLLOW_null_in_rsa_sha256_alg_id2300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsa_sha384_alg_id2319  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsa_sha384_alg_id2319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsa_sha384_alg_id2319	= { FOLLOW_sequenceTag_in_rsa_sha384_alg_id2319_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha384rsaoid_in_rsa_sha384_alg_id2321  */
static	ANTLR3_BITWORD FOLLOW_sha384rsaoid_in_rsa_sha384_alg_id2321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha384rsaoid_in_rsa_sha384_alg_id2321	= { FOLLOW_sha384rsaoid_in_rsa_sha384_alg_id2321_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_rsa_sha384_alg_id2323  */
static	ANTLR3_BITWORD FOLLOW_null_in_rsa_sha384_alg_id2323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_rsa_sha384_alg_id2323	= { FOLLOW_null_in_rsa_sha384_alg_id2323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsa_sha512_alg_id2342  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsa_sha512_alg_id2342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsa_sha512_alg_id2342	= { FOLLOW_sequenceTag_in_rsa_sha512_alg_id2342_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha512rsaoid_in_rsa_sha512_alg_id2344  */
static	ANTLR3_BITWORD FOLLOW_sha512rsaoid_in_rsa_sha512_alg_id2344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha512rsaoid_in_rsa_sha512_alg_id2344	= { FOLLOW_sha512rsaoid_in_rsa_sha512_alg_id2344_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_rsa_sha512_alg_id2346  */
static	ANTLR3_BITWORD FOLLOW_null_in_rsa_sha512_alg_id2346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_rsa_sha512_alg_id2346	= { FOLLOW_null_in_rsa_sha512_alg_id2346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dsa_sha_alg_id2365  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dsa_sha_alg_id2365_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dsa_sha_alg_id2365	= { FOLLOW_sequenceTag_in_dsa_sha_alg_id2365_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha1dsaoid_in_dsa_sha_alg_id2367  */
static	ANTLR3_BITWORD FOLLOW_sha1dsaoid_in_dsa_sha_alg_id2367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sha1dsaoid_in_dsa_sha_alg_id2367	= { FOLLOW_sha1dsaoid_in_dsa_sha_alg_id2367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dsa_sha224_alg_id2387  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dsa_sha224_alg_id2387_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dsa_sha224_alg_id2387	= { FOLLOW_sequenceTag_in_dsa_sha224_alg_id2387_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha224dsaoid_in_dsa_sha224_alg_id2389  */
static	ANTLR3_BITWORD FOLLOW_sha224dsaoid_in_dsa_sha224_alg_id2389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sha224dsaoid_in_dsa_sha224_alg_id2389	= { FOLLOW_sha224dsaoid_in_dsa_sha224_alg_id2389_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dsa_sha224_alg_id2393  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dsa_sha224_alg_id2393_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dsa_sha224_alg_id2393	= { FOLLOW_sequenceTag_in_dsa_sha224_alg_id2393_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_sha224_alg_id2397  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_sha224_alg_id2397_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_sha224_alg_id2397	= { FOLLOW_integer_in_dsa_sha224_alg_id2397_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_sha224_alg_id2401  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_sha224_alg_id2401_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_sha224_alg_id2401	= { FOLLOW_integer_in_dsa_sha224_alg_id2401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_sha224_alg_id2405  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_sha224_alg_id2405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_sha224_alg_id2405	= { FOLLOW_integer_in_dsa_sha224_alg_id2405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dsa_sha256_alg_id2424  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dsa_sha256_alg_id2424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dsa_sha256_alg_id2424	= { FOLLOW_sequenceTag_in_dsa_sha256_alg_id2424_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha256dsaoid_in_dsa_sha256_alg_id2426  */
static	ANTLR3_BITWORD FOLLOW_sha256dsaoid_in_dsa_sha256_alg_id2426_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sha256dsaoid_in_dsa_sha256_alg_id2426	= { FOLLOW_sha256dsaoid_in_dsa_sha256_alg_id2426_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dsa_sha256_alg_id2430  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dsa_sha256_alg_id2430_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dsa_sha256_alg_id2430	= { FOLLOW_sequenceTag_in_dsa_sha256_alg_id2430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_sha256_alg_id2434  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_sha256_alg_id2434_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_sha256_alg_id2434	= { FOLLOW_integer_in_dsa_sha256_alg_id2434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_sha256_alg_id2438  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_sha256_alg_id2438_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_sha256_alg_id2438	= { FOLLOW_integer_in_dsa_sha256_alg_id2438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_sha256_alg_id2442  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_sha256_alg_id2442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_sha256_alg_id2442	= { FOLLOW_integer_in_dsa_sha256_alg_id2442_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_ec_sha_alg_id2462  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_ec_sha_alg_id2462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_ec_sha_alg_id2462	= { FOLLOW_sequenceTag_in_ec_sha_alg_id2462_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha1ecoid_in_ec_sha_alg_id2464  */
static	ANTLR3_BITWORD FOLLOW_sha1ecoid_in_ec_sha_alg_id2464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sha1ecoid_in_ec_sha_alg_id2464	= { FOLLOW_sha1ecoid_in_ec_sha_alg_id2464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_ec_sha224_alg_id2480  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_ec_sha224_alg_id2480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_ec_sha224_alg_id2480	= { FOLLOW_sequenceTag_in_ec_sha224_alg_id2480_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha224ecoid_in_ec_sha224_alg_id2482  */
static	ANTLR3_BITWORD FOLLOW_sha224ecoid_in_ec_sha224_alg_id2482_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sha224ecoid_in_ec_sha224_alg_id2482	= { FOLLOW_sha224ecoid_in_ec_sha224_alg_id2482_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_ec_sha256_alg_id2499  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_ec_sha256_alg_id2499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_ec_sha256_alg_id2499	= { FOLLOW_sequenceTag_in_ec_sha256_alg_id2499_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha256ecoid_in_ec_sha256_alg_id2501  */
static	ANTLR3_BITWORD FOLLOW_sha256ecoid_in_ec_sha256_alg_id2501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sha256ecoid_in_ec_sha256_alg_id2501	= { FOLLOW_sha256ecoid_in_ec_sha256_alg_id2501_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_ec_sha384_alg_id2519  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_ec_sha384_alg_id2519_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_ec_sha384_alg_id2519	= { FOLLOW_sequenceTag_in_ec_sha384_alg_id2519_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha384ecoid_in_ec_sha384_alg_id2521  */
static	ANTLR3_BITWORD FOLLOW_sha384ecoid_in_ec_sha384_alg_id2521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sha384ecoid_in_ec_sha384_alg_id2521	= { FOLLOW_sha384ecoid_in_ec_sha384_alg_id2521_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_ec_sha512_alg_id2539  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_ec_sha512_alg_id2539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_ec_sha512_alg_id2539	= { FOLLOW_sequenceTag_in_ec_sha512_alg_id2539_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha512ecoid_in_ec_sha512_alg_id2541  */
static	ANTLR3_BITWORD FOLLOW_sha512ecoid_in_ec_sha512_alg_id2541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sha512ecoid_in_ec_sha512_alg_id2541	= { FOLLOW_sha512ecoid_in_ec_sha512_alg_id2541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsa_alg_id2560  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsa_alg_id2560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsa_alg_id2560	= { FOLLOW_sequenceTag_in_rsa_alg_id2560_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsapkoid_in_rsa_alg_id2562  */
static	ANTLR3_BITWORD FOLLOW_rsapkoid_in_rsa_alg_id2562_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_rsapkoid_in_rsa_alg_id2562	= { FOLLOW_rsapkoid_in_rsa_alg_id2562_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_rsa_alg_id2564  */
static	ANTLR3_BITWORD FOLLOW_null_in_rsa_alg_id2564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_rsa_alg_id2564	= { FOLLOW_null_in_rsa_alg_id2564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dsa_alg_id2583  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dsa_alg_id2583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dsa_alg_id2583	= { FOLLOW_sequenceTag_in_dsa_alg_id2583_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsapkoid_in_dsa_alg_id2585  */
static	ANTLR3_BITWORD FOLLOW_dsapkoid_in_dsa_alg_id2585_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsapkoid_in_dsa_alg_id2585	= { FOLLOW_dsapkoid_in_dsa_alg_id2585_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dsa_alg_id2589  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dsa_alg_id2589_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dsa_alg_id2589	= { FOLLOW_sequenceTag_in_dsa_alg_id2589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_alg_id2593  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_alg_id2593_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_alg_id2593	= { FOLLOW_integer_in_dsa_alg_id2593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_alg_id2597  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_alg_id2597_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_alg_id2597	= { FOLLOW_integer_in_dsa_alg_id2597_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_alg_id2601  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_alg_id2601_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_alg_id2601	= { FOLLOW_integer_in_dsa_alg_id2601_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dh_alg_id2621  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dh_alg_id2621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dh_alg_id2621	= { FOLLOW_sequenceTag_in_dh_alg_id2621_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dhpkoid_in_dh_alg_id2623  */
static	ANTLR3_BITWORD FOLLOW_dhpkoid_in_dh_alg_id2623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dhpkoid_in_dh_alg_id2623	= { FOLLOW_dhpkoid_in_dh_alg_id2623_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dh_alg_id2627  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dh_alg_id2627_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dh_alg_id2627	= { FOLLOW_sequenceTag_in_dh_alg_id2627_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dh_alg_id2631  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dh_alg_id2631_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dh_alg_id2631	= { FOLLOW_integer_in_dh_alg_id2631_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dh_alg_id2635  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dh_alg_id2635_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dh_alg_id2635	= { FOLLOW_integer_in_dh_alg_id2635_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dh_alg_id2639  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dh_alg_id2639_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dh_alg_id2639	= { FOLLOW_integer_in_dh_alg_id2639_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dh_alg_id2651  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dh_alg_id2651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dh_alg_id2651	= { FOLLOW_integer_in_dh_alg_id2651_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dh_alg_id2657  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dh_alg_id2657_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dh_alg_id2657	= { FOLLOW_sequenceTag_in_dh_alg_id2657_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_dh_alg_id2659  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_dh_alg_id2659_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_dh_alg_id2659	= { FOLLOW_bitstring_in_dh_alg_id2659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dh_alg_id2663  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dh_alg_id2663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dh_alg_id2663	= { FOLLOW_integer_in_dh_alg_id2663_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_kea_alg_id2685  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_kea_alg_id2685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_kea_alg_id2685	= { FOLLOW_sequenceTag_in_kea_alg_id2685_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keapkoid_in_kea_alg_id2687  */
static	ANTLR3_BITWORD FOLLOW_keapkoid_in_kea_alg_id2687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_keapkoid_in_kea_alg_id2687	= { FOLLOW_keapkoid_in_kea_alg_id2687_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_kea_alg_id2689  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_kea_alg_id2689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_kea_alg_id2689	= { FOLLOW_octetstring_in_kea_alg_id2689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_ec_alg_id2707  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_ec_alg_id2707_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_ec_alg_id2707	= { FOLLOW_sequenceTag_in_ec_alg_id2707_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ecpkoid_in_ec_alg_id2710  */
static	ANTLR3_BITWORD FOLLOW_ecpkoid_in_ec_alg_id2710_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ecpkoid_in_ec_alg_id2710	= { FOLLOW_ecpkoid_in_ec_alg_id2710_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ecdhoid_in_ec_alg_id2717  */
static	ANTLR3_BITWORD FOLLOW_ecdhoid_in_ec_alg_id2717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ecdhoid_in_ec_alg_id2717	= { FOLLOW_ecdhoid_in_ec_alg_id2717_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ecmqvoid_in_ec_alg_id2725  */
static	ANTLR3_BITWORD FOLLOW_ecmqvoid_in_ec_alg_id2725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ecmqvoid_in_ec_alg_id2725	= { FOLLOW_ecmqvoid_in_ec_alg_id2725_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_ec_alg_id2730  */
static	ANTLR3_BITWORD FOLLOW_oid_in_ec_alg_id2730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_ec_alg_id2730	= { FOLLOW_oid_in_ec_alg_id2730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_ecParams2749  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_ecParams2749_bits[]	= { ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_ecParams2749	= { FOLLOW_sequenceTag_in_ecParams2749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_int1_in_ecParams2751  */
static	ANTLR3_BITWORD FOLLOW_int1_in_ecParams2751_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_int1_in_ecParams2751	= { FOLLOW_int1_in_ecParams2751_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_field_id_in_ecParams2755  */
static	ANTLR3_BITWORD FOLLOW_field_id_in_ecParams2755_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_field_id_in_ecParams2755	= { FOLLOW_field_id_in_ecParams2755_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_ecParams2759  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_ecParams2759_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_ecParams2759	= { FOLLOW_octetstring_in_ecParams2759_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_ecParams2763  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_ecParams2763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_ecParams2763	= { FOLLOW_octetstring_in_ecParams2763_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_ecParams2766  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_ecParams2766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_ecParams2766	= { FOLLOW_bitstring_in_ecParams2766_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_ecParams2774  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_ecParams2774_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_ecParams2774	= { FOLLOW_octetstring_in_ecParams2774_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_ecParams2778  */
static	ANTLR3_BITWORD FOLLOW_integer_in_ecParams2778_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_ecParams2778	= { FOLLOW_integer_in_ecParams2778_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_ecParams2783  */
static	ANTLR3_BITWORD FOLLOW_integer_in_ecParams2783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_ecParams2783	= { FOLLOW_integer_in_ecParams2783_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_primeoid_in_field_id2812  */
static	ANTLR3_BITWORD FOLLOW_primeoid_in_field_id2812_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_primeoid_in_field_id2812	= { FOLLOW_primeoid_in_field_id2812_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_field_id2814  */
static	ANTLR3_BITWORD FOLLOW_integer_in_field_id2814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_field_id2814	= { FOLLOW_integer_in_field_id2814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basis2oid_in_field_id2820  */
static	ANTLR3_BITWORD FOLLOW_basis2oid_in_field_id2820_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basis2oid_in_field_id2820	= { FOLLOW_basis2oid_in_field_id2820_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_field_id2824  */
static	ANTLR3_BITWORD FOLLOW_integer_in_field_id2824_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_field_id2824	= { FOLLOW_integer_in_field_id2824_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gnoid_in_field_id2829  */
static	ANTLR3_BITWORD FOLLOW_gnoid_in_field_id2829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_gnoid_in_field_id2829	= { FOLLOW_gnoid_in_field_id2829_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_field_id2831  */
static	ANTLR3_BITWORD FOLLOW_null_in_field_id2831_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_field_id2831	= { FOLLOW_null_in_field_id2831_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tpoid_in_field_id2837  */
static	ANTLR3_BITWORD FOLLOW_tpoid_in_field_id2837_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_tpoid_in_field_id2837	= { FOLLOW_tpoid_in_field_id2837_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_field_id2841  */
static	ANTLR3_BITWORD FOLLOW_integer_in_field_id2841_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_field_id2841	= { FOLLOW_integer_in_field_id2841_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ppoid_in_field_id2850  */
static	ANTLR3_BITWORD FOLLOW_ppoid_in_field_id2850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ppoid_in_field_id2850	= { FOLLOW_ppoid_in_field_id2850_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_field_id2852  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_field_id2852_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_field_id2852	= { FOLLOW_sequenceTag_in_field_id2852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_field_id2856  */
static	ANTLR3_BITWORD FOLLOW_integer_in_field_id2856_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_field_id2856	= { FOLLOW_integer_in_field_id2856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_field_id2860  */
static	ANTLR3_BITWORD FOLLOW_integer_in_field_id2860_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_field_id2860	= { FOLLOW_integer_in_field_id2860_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_field_id2864  */
static	ANTLR3_BITWORD FOLLOW_integer_in_field_id2864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_field_id2864	= { FOLLOW_integer_in_field_id2864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_field_id2869  */
static	ANTLR3_BITWORD FOLLOW_oid_in_field_id2869_bits[]	= { ANTLR3_UINT64_LIT(0x01F702001FF81C00), ANTLR3_UINT64_LIT(0x0000008300000001), ANTLR3_UINT64_LIT(0x00030EFFFFFFFFC6) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_field_id2869	= { FOLLOW_oid_in_field_id2869_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_any_in_field_id2871  */
static	ANTLR3_BITWORD FOLLOW_any_in_field_id2871_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_any_in_field_id2871	= { FOLLOW_any_in_field_id2871_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_field_id2878  */
static	ANTLR3_BITWORD FOLLOW_oid_in_field_id2878_bits[]	= { ANTLR3_UINT64_LIT(0x01F702001FF81C00), ANTLR3_UINT64_LIT(0x0000008300000001), ANTLR3_UINT64_LIT(0x00030EFFFFFFFFC6) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_field_id2878	= { FOLLOW_oid_in_field_id2878_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_any_in_field_id2880  */
static	ANTLR3_BITWORD FOLLOW_any_in_field_id2880_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_any_in_field_id2880	= { FOLLOW_any_in_field_id2880_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_pss_alg_id2899  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_pss_alg_id2899_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_pss_alg_id2899	= { FOLLOW_sequenceTag_in_pss_alg_id2899_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsapssoid_in_pss_alg_id2901  */
static	ANTLR3_BITWORD FOLLOW_rsapssoid_in_pss_alg_id2901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsapssoid_in_pss_alg_id2901	= { FOLLOW_rsapssoid_in_pss_alg_id2901_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_pss_alg_id2906  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_pss_alg_id2906_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000F00002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_pss_alg_id2906	= { FOLLOW_sequenceTag_in_pss_alg_id2906_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_pss_alg_id2909  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_pss_alg_id2909_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_pss_alg_id2909	= { FOLLOW_constructedTag0_in_pss_alg_id2909_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hash_alg_in_pss_alg_id2911  */
static	ANTLR3_BITWORD FOLLOW_hash_alg_in_pss_alg_id2911_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000E00002) };
static  ANTLR3_BITSET_LIST FOLLOW_hash_alg_in_pss_alg_id2911	= { FOLLOW_hash_alg_in_pss_alg_id2911_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_pss_alg_id2918  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_pss_alg_id2918_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_pss_alg_id2918	= { FOLLOW_constructedTag1_in_pss_alg_id2918_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mask_gen_alg_in_pss_alg_id2920  */
static	ANTLR3_BITWORD FOLLOW_mask_gen_alg_in_pss_alg_id2920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000C00002) };
static  ANTLR3_BITSET_LIST FOLLOW_mask_gen_alg_in_pss_alg_id2920	= { FOLLOW_mask_gen_alg_in_pss_alg_id2920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag2_in_pss_alg_id2927  */
static	ANTLR3_BITWORD FOLLOW_constructedTag2_in_pss_alg_id2927_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag2_in_pss_alg_id2927	= { FOLLOW_constructedTag2_in_pss_alg_id2927_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_pss_alg_id2931  */
static	ANTLR3_BITWORD FOLLOW_integer_in_pss_alg_id2931_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_pss_alg_id2931	= { FOLLOW_integer_in_pss_alg_id2931_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_pss_alg_id2937  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_pss_alg_id2937_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_pss_alg_id2937	= { FOLLOW_constructedTag3_in_pss_alg_id2937_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_pss_alg_id2941  */
static	ANTLR3_BITWORD FOLLOW_integer_in_pss_alg_id2941_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_pss_alg_id2941	= { FOLLOW_integer_in_pss_alg_id2941_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_pss_alg_id_params2968  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_pss_alg_id_params2968_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_pss_alg_id_params2968	= { FOLLOW_sequenceTag_in_pss_alg_id_params2968_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsapssoid_in_pss_alg_id_params2970  */
static	ANTLR3_BITWORD FOLLOW_rsapssoid_in_pss_alg_id_params2970_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsapssoid_in_pss_alg_id_params2970	= { FOLLOW_rsapssoid_in_pss_alg_id_params2970_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_pss_alg_id_params2973  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_pss_alg_id_params2973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000F00002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_pss_alg_id_params2973	= { FOLLOW_sequenceTag_in_pss_alg_id_params2973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_pss_alg_id_params2976  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_pss_alg_id_params2976_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_pss_alg_id_params2976	= { FOLLOW_constructedTag0_in_pss_alg_id_params2976_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hash_alg_in_pss_alg_id_params2978  */
static	ANTLR3_BITWORD FOLLOW_hash_alg_in_pss_alg_id_params2978_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000E00002) };
static  ANTLR3_BITSET_LIST FOLLOW_hash_alg_in_pss_alg_id_params2978	= { FOLLOW_hash_alg_in_pss_alg_id_params2978_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_pss_alg_id_params2987  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_pss_alg_id_params2987_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_pss_alg_id_params2987	= { FOLLOW_constructedTag1_in_pss_alg_id_params2987_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mask_gen_alg_in_pss_alg_id_params2989  */
static	ANTLR3_BITWORD FOLLOW_mask_gen_alg_in_pss_alg_id_params2989_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000C00002) };
static  ANTLR3_BITSET_LIST FOLLOW_mask_gen_alg_in_pss_alg_id_params2989	= { FOLLOW_mask_gen_alg_in_pss_alg_id_params2989_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag2_in_pss_alg_id_params2997  */
static	ANTLR3_BITWORD FOLLOW_constructedTag2_in_pss_alg_id_params2997_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag2_in_pss_alg_id_params2997	= { FOLLOW_constructedTag2_in_pss_alg_id_params2997_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_pss_alg_id_params3001  */
static	ANTLR3_BITWORD FOLLOW_integer_in_pss_alg_id_params3001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_pss_alg_id_params3001	= { FOLLOW_integer_in_pss_alg_id_params3001_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_pss_alg_id_params3009  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_pss_alg_id_params3009_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_pss_alg_id_params3009	= { FOLLOW_constructedTag3_in_pss_alg_id_params3009_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_pss_alg_id_params3013  */
static	ANTLR3_BITWORD FOLLOW_integer_in_pss_alg_id_params3013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_pss_alg_id_params3013	= { FOLLOW_integer_in_pss_alg_id_params3013_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_oaep_alg_id3038  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_oaep_alg_id3038_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_oaep_alg_id3038	= { FOLLOW_sequenceTag_in_oaep_alg_id3038_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsaoaepoid_in_oaep_alg_id3040  */
static	ANTLR3_BITWORD FOLLOW_rsaoaepoid_in_oaep_alg_id3040_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsaoaepoid_in_oaep_alg_id3040	= { FOLLOW_rsaoaepoid_in_oaep_alg_id3040_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_oaep_alg_id3045  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_oaep_alg_id3045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000700002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_oaep_alg_id3045	= { FOLLOW_sequenceTag_in_oaep_alg_id3045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_oaep_alg_id3048  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_oaep_alg_id3048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_oaep_alg_id3048	= { FOLLOW_constructedTag0_in_oaep_alg_id3048_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hash_alg_in_oaep_alg_id3050  */
static	ANTLR3_BITWORD FOLLOW_hash_alg_in_oaep_alg_id3050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000600002) };
static  ANTLR3_BITSET_LIST FOLLOW_hash_alg_in_oaep_alg_id3050	= { FOLLOW_hash_alg_in_oaep_alg_id3050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_oaep_alg_id3056  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_oaep_alg_id3056_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_oaep_alg_id3056	= { FOLLOW_constructedTag1_in_oaep_alg_id3056_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mask_gen_alg_in_oaep_alg_id3058  */
static	ANTLR3_BITWORD FOLLOW_mask_gen_alg_in_oaep_alg_id3058_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_mask_gen_alg_in_oaep_alg_id3058	= { FOLLOW_mask_gen_alg_in_oaep_alg_id3058_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag2_in_oaep_alg_id3064  */
static	ANTLR3_BITWORD FOLLOW_constructedTag2_in_oaep_alg_id3064_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag2_in_oaep_alg_id3064	= { FOLLOW_constructedTag2_in_oaep_alg_id3064_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_oaep_alg_id3066  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_oaep_alg_id3066_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_oaep_alg_id3066	= { FOLLOW_sequenceTag_in_oaep_alg_id3066_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pspecoid_in_oaep_alg_id3068  */
static	ANTLR3_BITWORD FOLLOW_pspecoid_in_oaep_alg_id3068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_pspecoid_in_oaep_alg_id3068	= { FOLLOW_pspecoid_in_oaep_alg_id3068_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_oaep_alg_id3071  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_oaep_alg_id3071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_oaep_alg_id3071	= { FOLLOW_octetstring_in_oaep_alg_id3071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_hash_alg3113  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_hash_alg3113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_hash_alg3113	= { FOLLOW_sequenceTag_in_hash_alg3113_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha1oid_in_hash_alg3118  */
static	ANTLR3_BITWORD FOLLOW_sha1oid_in_hash_alg3118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha1oid_in_hash_alg3118	= { FOLLOW_sha1oid_in_hash_alg3118_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_hash_alg3121  */
static	ANTLR3_BITWORD FOLLOW_null_in_hash_alg3121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_hash_alg3121	= { FOLLOW_null_in_hash_alg3121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha224oid_in_hash_alg3130  */
static	ANTLR3_BITWORD FOLLOW_sha224oid_in_hash_alg3130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha224oid_in_hash_alg3130	= { FOLLOW_sha224oid_in_hash_alg3130_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_hash_alg3133  */
static	ANTLR3_BITWORD FOLLOW_null_in_hash_alg3133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_hash_alg3133	= { FOLLOW_null_in_hash_alg3133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha256oid_in_hash_alg3142  */
static	ANTLR3_BITWORD FOLLOW_sha256oid_in_hash_alg3142_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha256oid_in_hash_alg3142	= { FOLLOW_sha256oid_in_hash_alg3142_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_hash_alg3145  */
static	ANTLR3_BITWORD FOLLOW_null_in_hash_alg3145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_hash_alg3145	= { FOLLOW_null_in_hash_alg3145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha384oid_in_hash_alg3154  */
static	ANTLR3_BITWORD FOLLOW_sha384oid_in_hash_alg3154_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha384oid_in_hash_alg3154	= { FOLLOW_sha384oid_in_hash_alg3154_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_hash_alg3157  */
static	ANTLR3_BITWORD FOLLOW_null_in_hash_alg3157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_hash_alg3157	= { FOLLOW_null_in_hash_alg3157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sha512oid_in_hash_alg3166  */
static	ANTLR3_BITWORD FOLLOW_sha512oid_in_hash_alg3166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_sha512oid_in_hash_alg3166	= { FOLLOW_sha512oid_in_hash_alg3166_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_hash_alg3169  */
static	ANTLR3_BITWORD FOLLOW_null_in_hash_alg3169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_hash_alg3169	= { FOLLOW_null_in_hash_alg3169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_mask_gen_alg3198  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_mask_gen_alg3198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_mask_gen_alg3198	= { FOLLOW_sequenceTag_in_mask_gen_alg3198_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mgf1oid_in_mask_gen_alg3200  */
static	ANTLR3_BITWORD FOLLOW_mgf1oid_in_mask_gen_alg3200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_mgf1oid_in_mask_gen_alg3200	= { FOLLOW_mgf1oid_in_mask_gen_alg3200_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hash_alg_in_mask_gen_alg3202  */
static	ANTLR3_BITWORD FOLLOW_hash_alg_in_mask_gen_alg3202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hash_alg_in_mask_gen_alg3202	= { FOLLOW_hash_alg_in_mask_gen_alg3202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_gost_94_alg_id3223  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_gost_94_alg_id3223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_gost_94_alg_id3223	= { FOLLOW_sequenceTag_in_gost_94_alg_id3223_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost94signoid_in_gost_94_alg_id3225  */
static	ANTLR3_BITWORD FOLLOW_gost94signoid_in_gost_94_alg_id3225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost94signoid_in_gost_94_alg_id3225	= { FOLLOW_gost94signoid_in_gost_94_alg_id3225_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_gost_94_alg_id3228  */
static	ANTLR3_BITWORD FOLLOW_null_in_gost_94_alg_id3228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_gost_94_alg_id3228	= { FOLLOW_null_in_gost_94_alg_id3228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_gost_94_alg_id3232  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_gost_94_alg_id3232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_gost_94_alg_id3232	= { FOLLOW_sequenceTag_in_gost_94_alg_id3232_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_gost_94_alg_id3236  */
static	ANTLR3_BITWORD FOLLOW_oid_in_gost_94_alg_id3236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_gost_94_alg_id3236	= { FOLLOW_oid_in_gost_94_alg_id3236_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_gost_94_alg_id3240  */
static	ANTLR3_BITWORD FOLLOW_oid_in_gost_94_alg_id3240_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_gost_94_alg_id3240	= { FOLLOW_oid_in_gost_94_alg_id3240_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_gost_94_alg_id3247  */
static	ANTLR3_BITWORD FOLLOW_oid_in_gost_94_alg_id3247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_gost_94_alg_id3247	= { FOLLOW_oid_in_gost_94_alg_id3247_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_gost_01_alg_id3274  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_gost_01_alg_id3274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_gost_01_alg_id3274	= { FOLLOW_sequenceTag_in_gost_01_alg_id3274_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost01signoid_in_gost_01_alg_id3276  */
static	ANTLR3_BITWORD FOLLOW_gost01signoid_in_gost_01_alg_id3276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000001), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost01signoid_in_gost_01_alg_id3276	= { FOLLOW_gost01signoid_in_gost_01_alg_id3276_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_gost_01_alg_id3279  */
static	ANTLR3_BITWORD FOLLOW_null_in_gost_01_alg_id3279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_gost_01_alg_id3279	= { FOLLOW_null_in_gost_01_alg_id3279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_gost_01_alg_id3283  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_gost_01_alg_id3283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_gost_01_alg_id3283	= { FOLLOW_sequenceTag_in_gost_01_alg_id3283_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_gost_01_alg_id3287  */
static	ANTLR3_BITWORD FOLLOW_oid_in_gost_01_alg_id3287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_gost_01_alg_id3287	= { FOLLOW_oid_in_gost_01_alg_id3287_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_gost_01_alg_id3291  */
static	ANTLR3_BITWORD FOLLOW_oid_in_gost_01_alg_id3291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_gost_01_alg_id3291	= { FOLLOW_oid_in_gost_01_alg_id3291_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_gost_01_alg_id3298  */
static	ANTLR3_BITWORD FOLLOW_oid_in_gost_01_alg_id3298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_gost_01_alg_id3298	= { FOLLOW_oid_in_gost_01_alg_id3298_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_int0_in_version3323  */
static	ANTLR3_BITWORD FOLLOW_int0_in_version3323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_int0_in_version3323	= { FOLLOW_int0_in_version3323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_int1_in_version23341  */
static	ANTLR3_BITWORD FOLLOW_int1_in_version23341_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_int1_in_version23341	= { FOLLOW_int1_in_version23341_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_int2_in_version33359  */
static	ANTLR3_BITWORD FOLLOW_int2_in_version33359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_int2_in_version33359	= { FOLLOW_int2_in_version33359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_serialnumber3377  */
static	ANTLR3_BITWORD FOLLOW_integer_in_serialnumber3377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_serialnumber3377	= { FOLLOW_integer_in_serialnumber3377_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notEmptyName_in_issuer3394  */
static	ANTLR3_BITWORD FOLLOW_notEmptyName_in_issuer3394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notEmptyName_in_issuer3394	= { FOLLOW_notEmptyName_in_issuer3394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notEmptyName_in_subject3410  */
static	ANTLR3_BITWORD FOLLOW_notEmptyName_in_subject3410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notEmptyName_in_subject3410	= { FOLLOW_notEmptyName_in_subject3410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_validity3428  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_validity3428_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_validity3428	= { FOLLOW_sequenceTag_in_validity3428_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_time_span_in_validity3432  */
static	ANTLR3_BITWORD FOLLOW_time_span_in_validity3432_bits[]	= { ANTLR3_UINT64_LIT(0x0002000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000020000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_time_span_in_validity3432	= { FOLLOW_time_span_in_validity3432_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_time_span_in_validity3436  */
static	ANTLR3_BITWORD FOLLOW_time_span_in_validity3436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_time_span_in_validity3436	= { FOLLOW_time_span_in_validity3436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_subjectPKinfo3455  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_subjectPKinfo3455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_subjectPKinfo3455	= { FOLLOW_sequenceTag_in_subjectPKinfo3455_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsapk_in_subjectPKinfo3460  */
static	ANTLR3_BITWORD FOLLOW_rsapk_in_subjectPKinfo3460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsapk_in_subjectPKinfo3460	= { FOLLOW_rsapk_in_subjectPKinfo3460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsapk_in_subjectPKinfo3464  */
static	ANTLR3_BITWORD FOLLOW_dsapk_in_subjectPKinfo3464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dsapk_in_subjectPKinfo3464	= { FOLLOW_dsapk_in_subjectPKinfo3464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dhpk_in_subjectPKinfo3468  */
static	ANTLR3_BITWORD FOLLOW_dhpk_in_subjectPKinfo3468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dhpk_in_subjectPKinfo3468	= { FOLLOW_dhpk_in_subjectPKinfo3468_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ecpk_in_subjectPKinfo3472  */
static	ANTLR3_BITWORD FOLLOW_ecpk_in_subjectPKinfo3472_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ecpk_in_subjectPKinfo3472	= { FOLLOW_ecpk_in_subjectPKinfo3472_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keapk_in_subjectPKinfo3476  */
static	ANTLR3_BITWORD FOLLOW_keapk_in_subjectPKinfo3476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_keapk_in_subjectPKinfo3476	= { FOLLOW_keapk_in_subjectPKinfo3476_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsapsspk_in_subjectPKinfo3479  */
static	ANTLR3_BITWORD FOLLOW_rsapsspk_in_subjectPKinfo3479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsapsspk_in_subjectPKinfo3479	= { FOLLOW_rsapsspk_in_subjectPKinfo3479_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsaoaep_in_subjectPKinfo3483  */
static	ANTLR3_BITWORD FOLLOW_rsaoaep_in_subjectPKinfo3483_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rsaoaep_in_subjectPKinfo3483	= { FOLLOW_rsaoaep_in_subjectPKinfo3483_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gostpk_in_subjectPKinfo3487  */
static	ANTLR3_BITWORD FOLLOW_gostpk_in_subjectPKinfo3487_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gostpk_in_subjectPKinfo3487	= { FOLLOW_gostpk_in_subjectPKinfo3487_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rsa_alg_id_in_rsapk3504  */
static	ANTLR3_BITWORD FOLLOW_rsa_alg_id_in_rsapk3504_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_rsa_alg_id_in_rsapk3504	= { FOLLOW_rsa_alg_id_in_rsapk3504_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedBitString_in_rsapk3506  */
static	ANTLR3_BITWORD FOLLOW_constructedBitString_in_rsapk3506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedBitString_in_rsapk3506	= { FOLLOW_constructedBitString_in_rsapk3506_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsapk3508  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsapk3508_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsapk3508	= { FOLLOW_sequenceTag_in_rsapk3508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_rsapk3512  */
static	ANTLR3_BITWORD FOLLOW_integer_in_rsapk3512_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_rsapk3512	= { FOLLOW_integer_in_rsapk3512_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_rsapk3516  */
static	ANTLR3_BITWORD FOLLOW_integer_in_rsapk3516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_rsapk3516	= { FOLLOW_integer_in_rsapk3516_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dsa_alg_id_in_dsapk3533  */
static	ANTLR3_BITWORD FOLLOW_dsa_alg_id_in_dsapk3533_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_dsa_alg_id_in_dsapk3533	= { FOLLOW_dsa_alg_id_in_dsapk3533_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedBitString_in_dsapk3535  */
static	ANTLR3_BITWORD FOLLOW_constructedBitString_in_dsapk3535_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedBitString_in_dsapk3535	= { FOLLOW_constructedBitString_in_dsapk3535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsapk3537  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsapk3537_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsapk3537	= { FOLLOW_integer_in_dsapk3537_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dh_alg_id_in_dhpk3554  */
static	ANTLR3_BITWORD FOLLOW_dh_alg_id_in_dhpk3554_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_dh_alg_id_in_dhpk3554	= { FOLLOW_dh_alg_id_in_dhpk3554_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_dhpk3556  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_dhpk3556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_dhpk3556	= { FOLLOW_bitstring_in_dhpk3556_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_kea_alg_id_in_keapk3574  */
static	ANTLR3_BITWORD FOLLOW_kea_alg_id_in_keapk3574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_kea_alg_id_in_keapk3574	= { FOLLOW_kea_alg_id_in_keapk3574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_keapk3576  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_keapk3576_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_keapk3576	= { FOLLOW_bitstring_in_keapk3576_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ec_alg_id_in_ecpk3593  */
static	ANTLR3_BITWORD FOLLOW_ec_alg_id_in_ecpk3593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_ec_alg_id_in_ecpk3593	= { FOLLOW_ec_alg_id_in_ecpk3593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_ecpk3595  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_ecpk3595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_ecpk3595	= { FOLLOW_bitstring_in_ecpk3595_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_gostpk3615  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_gostpk3615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_gostpk3615	= { FOLLOW_sequenceTag_in_gostpk3615_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost94pkoid_in_gostpk3618  */
static	ANTLR3_BITWORD FOLLOW_gost94pkoid_in_gostpk3618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000), ANTLR3_UINT64_LIT(0x0000000000000001), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost94pkoid_in_gostpk3618	= { FOLLOW_gost94pkoid_in_gostpk3618_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_gost01pkoid_in_gostpk3622  */
static	ANTLR3_BITWORD FOLLOW_gost01pkoid_in_gostpk3622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000), ANTLR3_UINT64_LIT(0x0000000000000001), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_gost01pkoid_in_gostpk3622	= { FOLLOW_gost01pkoid_in_gostpk3622_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_gostpk3626  */
static	ANTLR3_BITWORD FOLLOW_null_in_gostpk3626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_gostpk3626	= { FOLLOW_null_in_gostpk3626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_gostpk3630  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_gostpk3630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_gostpk3630	= { FOLLOW_sequenceTag_in_gostpk3630_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_gostpk3632  */
static	ANTLR3_BITWORD FOLLOW_oid_in_gostpk3632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_gostpk3632	= { FOLLOW_oid_in_gostpk3632_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_gostpk3634  */
static	ANTLR3_BITWORD FOLLOW_oid_in_gostpk3634_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_gostpk3634	= { FOLLOW_oid_in_gostpk3634_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_gostpk3636  */
static	ANTLR3_BITWORD FOLLOW_oid_in_gostpk3636_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_gostpk3636	= { FOLLOW_oid_in_gostpk3636_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedBitString_in_gostpk3641  */
static	ANTLR3_BITWORD FOLLOW_constructedBitString_in_gostpk3641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedBitString_in_gostpk3641	= { FOLLOW_constructedBitString_in_gostpk3641_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_gostpk3643  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_gostpk3643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_gostpk3643	= { FOLLOW_octetstring_in_gostpk3643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pss_alg_id_in_rsapsspk3664  */
static	ANTLR3_BITWORD FOLLOW_pss_alg_id_in_rsapsspk3664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_pss_alg_id_in_rsapsspk3664	= { FOLLOW_pss_alg_id_in_rsapsspk3664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedBitString_in_rsapsspk3666  */
static	ANTLR3_BITWORD FOLLOW_constructedBitString_in_rsapsspk3666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedBitString_in_rsapsspk3666	= { FOLLOW_constructedBitString_in_rsapsspk3666_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsapsspk3668  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsapsspk3668_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsapsspk3668	= { FOLLOW_sequenceTag_in_rsapsspk3668_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_rsapsspk3672  */
static	ANTLR3_BITWORD FOLLOW_integer_in_rsapsspk3672_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_rsapsspk3672	= { FOLLOW_integer_in_rsapsspk3672_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_rsapsspk3676  */
static	ANTLR3_BITWORD FOLLOW_integer_in_rsapsspk3676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_rsapsspk3676	= { FOLLOW_integer_in_rsapsspk3676_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oaep_alg_id_in_rsaoaep3693  */
static	ANTLR3_BITWORD FOLLOW_oaep_alg_id_in_rsaoaep3693_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_oaep_alg_id_in_rsaoaep3693	= { FOLLOW_oaep_alg_id_in_rsaoaep3693_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedBitString_in_rsaoaep3695  */
static	ANTLR3_BITWORD FOLLOW_constructedBitString_in_rsaoaep3695_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedBitString_in_rsaoaep3695	= { FOLLOW_constructedBitString_in_rsaoaep3695_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rsaoaep3697  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rsaoaep3697_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rsaoaep3697	= { FOLLOW_sequenceTag_in_rsaoaep3697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_rsaoaep3701  */
static	ANTLR3_BITWORD FOLLOW_integer_in_rsaoaep3701_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_rsaoaep3701	= { FOLLOW_integer_in_rsaoaep3701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_rsaoaep3705  */
static	ANTLR3_BITWORD FOLLOW_integer_in_rsaoaep3705_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_rsaoaep3705	= { FOLLOW_integer_in_rsaoaep3705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag2_in_subjectuniqueId3723  */
static	ANTLR3_BITWORD FOLLOW_tag2_in_subjectuniqueId3723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag2_in_subjectuniqueId3723	= { FOLLOW_tag2_in_subjectuniqueId3723_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_issueruniqueId3741  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_issueruniqueId3741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_issueruniqueId3741	= { FOLLOW_tag1_in_issueruniqueId3741_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsWithSubAlt3762  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsWithSubAlt3762_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsWithSubAlt3762	= { FOLLOW_extensionNoSubAlt_in_extensionsWithSubAlt3762_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsWithSubAlt_in_extensionsWithSubAlt3764  */
static	ANTLR3_BITWORD FOLLOW_extensionsWithSubAlt_in_extensionsWithSubAlt3764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsWithSubAlt_in_extensionsWithSubAlt3764	= { FOLLOW_extensionsWithSubAlt_in_extensionsWithSubAlt3764_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraintsNotCritical_in_extensionsWithSubAlt3769  */
static	ANTLR3_BITWORD FOLLOW_basicConstraintsNotCritical_in_extensionsWithSubAlt3769_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraintsNotCritical_in_extensionsWithSubAlt3769	= { FOLLOW_basicConstraintsNotCritical_in_extensionsWithSubAlt3769_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsWithSubAlt3773  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsWithSubAlt3773_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsWithSubAlt3773	= { FOLLOW_truevalue_in_extensionsWithSubAlt3773_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsWithSubAlt3777  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsWithSubAlt3777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsWithSubAlt3777	= { FOLLOW_constructedOctetString_in_extensionsWithSubAlt3777_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsWithSubAlt3779  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsWithSubAlt3779_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsWithSubAlt3779	= { FOLLOW_sequenceTag_in_extensionsWithSubAlt3779_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsWithSubAlt3783  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsWithSubAlt3783_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsWithSubAlt3783	= { FOLLOW_falsevalue_in_extensionsWithSubAlt3783_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3786  */
static	ANTLR3_BITWORD FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3786	= { FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3786_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsWithSubAlt3790  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsWithSubAlt3790_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsWithSubAlt3790	= { FOLLOW_truevalue_in_extensionsWithSubAlt3790_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCSubAlt_in_extensionsWithSubAlt3796  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCSubAlt_in_extensionsWithSubAlt3796_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCSubAlt_in_extensionsWithSubAlt3796	= { FOLLOW_extensionsNotBCSubAlt_in_extensionsWithSubAlt3796_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionsWithSubAlt3800  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionsWithSubAlt3800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionsWithSubAlt3800	= { FOLLOW_integer_in_extensionsWithSubAlt3800_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsWithSubAlt3804  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsWithSubAlt3804_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsWithSubAlt3804	= { FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsWithSubAlt3804_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsWithSubAlt3814  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsWithSubAlt3814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsWithSubAlt3814	= { FOLLOW_falsevalue_in_extensionsWithSubAlt3814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsWithSubAlt3817  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsWithSubAlt3817_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsWithSubAlt3817	= { FOLLOW_constructedOctetString_in_extensionsWithSubAlt3817_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsWithSubAlt3819  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsWithSubAlt3819_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsWithSubAlt3819	= { FOLLOW_sequenceTag_in_extensionsWithSubAlt3819_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsWithSubAlt3823  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsWithSubAlt3823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsWithSubAlt3823	= { FOLLOW_falsevalue_in_extensionsWithSubAlt3823_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3826  */
static	ANTLR3_BITWORD FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3826_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3826	= { FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3826_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsWithSubAlt3830  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsWithSubAlt3830_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsWithSubAlt3830	= { FOLLOW_truevalue_in_extensionsWithSubAlt3830_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsWithSubAlt3834  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsWithSubAlt3834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsWithSubAlt3834	= { FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsWithSubAlt3834_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsWithSubAlt3843  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsWithSubAlt3843_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsWithSubAlt3843	= { FOLLOW_keyUsageCommon_in_extensionsWithSubAlt3843_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsWithSubAlt3846  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsWithSubAlt3846_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsWithSubAlt3846	= { FOLLOW_bitstring_in_extensionsWithSubAlt3846_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLenSubAlt_in_extensionsWithSubAlt3850  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLenSubAlt_in_extensionsWithSubAlt3850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLenSubAlt_in_extensionsWithSubAlt3850	= { FOLLOW_extensionsNoPathLenSubAlt_in_extensionsWithSubAlt3850_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsWithSubAlt3854  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsWithSubAlt3854_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsWithSubAlt3854	= { FOLLOW_bitstringCertSign_in_extensionsWithSubAlt3854_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsWithSubAlt3856  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsWithSubAlt3856_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsWithSubAlt3856	= { FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsWithSubAlt3856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsWithSubAlt3862  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsWithSubAlt3862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsWithSubAlt3862	= { FOLLOW_dependentExtension_in_extensionsWithSubAlt3862_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsWithSubAlt3864  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsWithSubAlt3864_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsWithSubAlt3864	= { FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsWithSubAlt3864_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsWithSubAlt3869  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsWithSubAlt3869_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsWithSubAlt3869	= { FOLLOW_subjectKeyId_in_extensionsWithSubAlt3869_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoSkiSubAlt_in_extensionsWithSubAlt3871  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoSkiSubAlt_in_extensionsWithSubAlt3871_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoSkiSubAlt_in_extensionsWithSubAlt3871	= { FOLLOW_extensionsNoSkiSubAlt_in_extensionsWithSubAlt3871_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsWithSubAlt3876  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsWithSubAlt3876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsWithSubAlt3876	= { FOLLOW_subAltNameCritical_in_extensionsWithSubAlt3876_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_extensionsWithSubAlt3878  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_extensionsWithSubAlt3878_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_extensionsWithSubAlt3878	= { FOLLOW_extensions_in_extensionsWithSubAlt3878_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNoSkiSubAlt3902  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNoSkiSubAlt3902_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNoSkiSubAlt3902	= { FOLLOW_extensionNoSubAlt_in_extensionsNoSkiSubAlt3902_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoSkiSubAlt_in_extensionsNoSkiSubAlt3904  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoSkiSubAlt_in_extensionsNoSkiSubAlt3904_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoSkiSubAlt_in_extensionsNoSkiSubAlt3904	= { FOLLOW_extensionsNoSkiSubAlt_in_extensionsNoSkiSubAlt3904_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraintsNotCritical_in_extensionsNoSkiSubAlt3909  */
static	ANTLR3_BITWORD FOLLOW_basicConstraintsNotCritical_in_extensionsNoSkiSubAlt3909_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraintsNotCritical_in_extensionsNoSkiSubAlt3909	= { FOLLOW_basicConstraintsNotCritical_in_extensionsNoSkiSubAlt3909_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoSkiSubAlt3913  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoSkiSubAlt3913_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoSkiSubAlt3913	= { FOLLOW_truevalue_in_extensionsNoSkiSubAlt3913_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3917  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3917_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3917	= { FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3917_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3919  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3919_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3919	= { FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3919_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3923  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3923_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3923	= { FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3923_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3926  */
static	ANTLR3_BITWORD FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3926	= { FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoSkiSubAlt3930  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoSkiSubAlt3930_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoSkiSubAlt3930	= { FOLLOW_truevalue_in_extensionsNoSkiSubAlt3930_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNoSkiSubAlt3936  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNoSkiSubAlt3936_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNoSkiSubAlt3936	= { FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNoSkiSubAlt3936_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionsNoSkiSubAlt3940  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionsNoSkiSubAlt3940_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionsNoSkiSubAlt3940	= { FOLLOW_integer_in_extensionsNoSkiSubAlt3940_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignSubAlt_in_extensionsNoSkiSubAlt3944  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignSubAlt_in_extensionsNoSkiSubAlt3944_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignSubAlt_in_extensionsNoSkiSubAlt3944	= { FOLLOW_extensionsCertSignSubAlt_in_extensionsNoSkiSubAlt3944_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3954  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3954_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3954	= { FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3954_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3957  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3957_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3957	= { FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3957_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3959  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3959_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3959	= { FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3959_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3963  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3963_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3963	= { FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3963_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3966  */
static	ANTLR3_BITWORD FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3966_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3966	= { FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3966_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoSkiSubAlt3970  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoSkiSubAlt3970_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoSkiSubAlt3970	= { FOLLOW_truevalue_in_extensionsNoSkiSubAlt3970_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNoSkiSubAlt3974  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNoSkiSubAlt3974_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNoSkiSubAlt3974	= { FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNoSkiSubAlt3974_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNoSkiSubAlt3983  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNoSkiSubAlt3983_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNoSkiSubAlt3983	= { FOLLOW_keyUsageCommon_in_extensionsNoSkiSubAlt3983_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNoSkiSubAlt3986  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNoSkiSubAlt3986_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNoSkiSubAlt3986	= { FOLLOW_bitstring_in_extensionsNoSkiSubAlt3986_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoSkiSubAlt3990  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoSkiSubAlt3990_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoSkiSubAlt3990	= { FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoSkiSubAlt3990_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsNoSkiSubAlt3994  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsNoSkiSubAlt3994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsNoSkiSubAlt3994	= { FOLLOW_bitstringCertSign_in_extensionsNoSkiSubAlt3994_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCASubAlt_in_extensionsNoSkiSubAlt3996  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCASubAlt_in_extensionsNoSkiSubAlt3996_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCASubAlt_in_extensionsNoSkiSubAlt3996	= { FOLLOW_extensionsMustBeCASubAlt_in_extensionsNoSkiSubAlt3996_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNoSkiSubAlt4002  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNoSkiSubAlt4002_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNoSkiSubAlt4002	= { FOLLOW_dependentExtension_in_extensionsNoSkiSubAlt4002_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaSubAlt_in_extensionsNoSkiSubAlt4004  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaSubAlt_in_extensionsNoSkiSubAlt4004_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaSubAlt_in_extensionsNoSkiSubAlt4004	= { FOLLOW_extensionsMustBeCaSubAlt_in_extensionsNoSkiSubAlt4004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsNoSkiSubAlt4009  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsNoSkiSubAlt4009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsNoSkiSubAlt4009	= { FOLLOW_subAltNameCritical_in_extensionsNoSkiSubAlt4009_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoSki_in_extensionsNoSkiSubAlt4014  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoSki_in_extensionsNoSkiSubAlt4014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoSki_in_extensionsNoSkiSubAlt4014	= { FOLLOW_extensionsNoSki_in_extensionsNoSkiSubAlt4014_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensions4036  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensions4036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensions4036	= { FOLLOW_extension_in_extensions4036_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensions_in_extensions4041  */
static	ANTLR3_BITWORD FOLLOW_extensions_in_extensions4041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensions_in_extensions4041	= { FOLLOW_extensions_in_extensions4041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraintsNotCritical_in_extensions4047  */
static	ANTLR3_BITWORD FOLLOW_basicConstraintsNotCritical_in_extensions4047_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraintsNotCritical_in_extensions4047	= { FOLLOW_basicConstraintsNotCritical_in_extensions4047_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensions4051  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensions4051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensions4051	= { FOLLOW_truevalue_in_extensions4051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensions4055  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensions4055_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensions4055	= { FOLLOW_constructedOctetString_in_extensions4055_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensions4057  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensions4057_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensions4057	= { FOLLOW_sequenceTag_in_extensions4057_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensions4061  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensions4061_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensions4061	= { FOLLOW_falsevalue_in_extensions4061_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExts_in_extensions4067  */
static	ANTLR3_BITWORD FOLLOW_notDependentExts_in_extensions4067_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExts_in_extensions4067	= { FOLLOW_notDependentExts_in_extensions4067_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensions4072  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensions4072_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensions4072	= { FOLLOW_truevalue_in_extensions4072_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBC_in_extensions4078  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBC_in_extensions4078_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBC_in_extensions4078	= { FOLLOW_extensionsNotBC_in_extensions4078_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensions4082  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensions4082_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensions4082	= { FOLLOW_integer_in_extensions4082_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignAndSki_in_extensions4086  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignAndSki_in_extensions4086_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignAndSki_in_extensions4086	= { FOLLOW_extensionsCertSignAndSki_in_extensions4086_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensions4096  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensions4096_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensions4096	= { FOLLOW_falsevalue_in_extensions4096_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensions4099  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensions4099_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensions4099	= { FOLLOW_constructedOctetString_in_extensions4099_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensions4101  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensions4101_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensions4101	= { FOLLOW_sequenceTag_in_extensions4101_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensions4105  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensions4105_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensions4105	= { FOLLOW_falsevalue_in_extensions4105_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExts_in_extensions4111  */
static	ANTLR3_BITWORD FOLLOW_notDependentExts_in_extensions4111_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExts_in_extensions4111	= { FOLLOW_notDependentExts_in_extensions4111_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensions4116  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensions4116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensions4116	= { FOLLOW_truevalue_in_extensions4116_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignAndSki_in_extensions4120  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignAndSki_in_extensions4120_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignAndSki_in_extensions4120	= { FOLLOW_extensionsNotCertSignAndSki_in_extensions4120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensions4129  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensions4129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensions4129	= { FOLLOW_keyUsageCommon_in_extensions4129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensions4132  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensions4132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensions4132	= { FOLLOW_bitstring_in_extensions4132_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLen_in_extensions4139  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLen_in_extensions4139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLen_in_extensions4139	= { FOLLOW_extensionsNoPathLen_in_extensions4139_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensions4144  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensions4144_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensions4144	= { FOLLOW_bitstringCertSign_in_extensions4144_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCAandSki_in_extensions4146  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCAandSki_in_extensions4146_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCAandSki_in_extensions4146	= { FOLLOW_extensionsMustBeCAandSki_in_extensions4146_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensions4152  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensions4152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensions4152	= { FOLLOW_dependentExtension_in_extensions4152_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSki_in_extensions4154  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSki_in_extensions4154_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSki_in_extensions4154	= { FOLLOW_extensionsMustBeCaAndSki_in_extensions4154_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensions4159  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensions4159_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensions4159	= { FOLLOW_subjectKeyId_in_extensions4159_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoSki_in_extensions4161  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoSki_in_extensions4161_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoSki_in_extensions4161	= { FOLLOW_extensionsNoSki_in_extensions4161_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsNoSki4185  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsNoSki4185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsNoSki4185	= { FOLLOW_extension_in_extensionsNoSki4185_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoSki_in_extensionsNoSki4190  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoSki_in_extensionsNoSki4190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoSki_in_extensionsNoSki4190	= { FOLLOW_extensionsNoSki_in_extensionsNoSki4190_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraintsNotCritical_in_extensionsNoSki4196  */
static	ANTLR3_BITWORD FOLLOW_basicConstraintsNotCritical_in_extensionsNoSki4196_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraintsNotCritical_in_extensionsNoSki4196	= { FOLLOW_basicConstraintsNotCritical_in_extensionsNoSki4196_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoSki4200  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoSki4200_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoSki4200	= { FOLLOW_truevalue_in_extensionsNoSki4200_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsNoSki4204  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsNoSki4204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsNoSki4204	= { FOLLOW_constructedOctetString_in_extensionsNoSki4204_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsNoSki4206  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsNoSki4206_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsNoSki4206	= { FOLLOW_sequenceTag_in_extensionsNoSki4206_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoSki4210  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoSki4210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoSki4210	= { FOLLOW_falsevalue_in_extensionsNoSki4210_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExts_in_extensionsNoSki4216  */
static	ANTLR3_BITWORD FOLLOW_notDependentExts_in_extensionsNoSki4216_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExts_in_extensionsNoSki4216	= { FOLLOW_notDependentExts_in_extensionsNoSki4216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoSki4221  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoSki4221_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoSki4221	= { FOLLOW_truevalue_in_extensionsNoSki4221_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSki_in_extensionsNoSki4227  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSki_in_extensionsNoSki4227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSki_in_extensionsNoSki4227	= { FOLLOW_extensionsNotBCNotSki_in_extensionsNoSki4227_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionsNoSki4232  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionsNoSki4232_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionsNoSki4232	= { FOLLOW_integer_in_extensionsNoSki4232_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSign_in_extensionsNoSki4236  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSign_in_extensionsNoSki4236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSign_in_extensionsNoSki4236	= { FOLLOW_extensionsCertSign_in_extensionsNoSki4236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoSki4246  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoSki4246_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoSki4246	= { FOLLOW_falsevalue_in_extensionsNoSki4246_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsNoSki4249  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsNoSki4249_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsNoSki4249	= { FOLLOW_constructedOctetString_in_extensionsNoSki4249_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsNoSki4251  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsNoSki4251_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsNoSki4251	= { FOLLOW_sequenceTag_in_extensionsNoSki4251_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoSki4255  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoSki4255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoSki4255	= { FOLLOW_falsevalue_in_extensionsNoSki4255_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExts_in_extensionsNoSki4261  */
static	ANTLR3_BITWORD FOLLOW_notDependentExts_in_extensionsNoSki4261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExts_in_extensionsNoSki4261	= { FOLLOW_notDependentExts_in_extensionsNoSki4261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoSki4266  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoSki4266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoSki4266	= { FOLLOW_truevalue_in_extensionsNoSki4266_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSign_in_extensionsNoSki4270  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSign_in_extensionsNoSki4270_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSign_in_extensionsNoSki4270	= { FOLLOW_extensionsNotCertSign_in_extensionsNoSki4270_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNoSki4280  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNoSki4280_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNoSki4280	= { FOLLOW_keyUsageCommon_in_extensionsNoSki4280_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNoSki4283  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNoSki4283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNoSki4283	= { FOLLOW_bitstring_in_extensionsNoSki4283_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoSki4290  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoSki4290_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoSki4290	= { FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoSki4290_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsNoSki4295  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsNoSki4295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsNoSki4295	= { FOLLOW_bitstringCertSign_in_extensionsNoSki4295_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCA_in_extensionsNoSki4297  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCA_in_extensionsNoSki4297_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCA_in_extensionsNoSki4297	= { FOLLOW_extensionsMustBeCA_in_extensionsNoSki4297_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNoSki4303  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNoSki4303_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNoSki4303	= { FOLLOW_dependentExtension_in_extensionsNoSki4303_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCa_in_extensionsNoSki4305  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCa_in_extensionsNoSki4305_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCa_in_extensionsNoSki4305	= { FOLLOW_extensionsMustBeCa_in_extensionsNoSki4305_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenSubAlt4330  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenSubAlt4330_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenSubAlt4330	= { FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenSubAlt4330_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4332  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4332_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4332	= { FOLLOW_extensionsNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4332_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraints_in_extensionsNoPathLenSubAlt4337  */
static	ANTLR3_BITWORD FOLLOW_basicConstraints_in_extensionsNoPathLenSubAlt4337_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraints_in_extensionsNoPathLenSubAlt4337	= { FOLLOW_basicConstraints_in_extensionsNoPathLenSubAlt4337_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoPathLenSubAlt4341  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoPathLenSubAlt4341_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoPathLenSubAlt4341	= { FOLLOW_falsevalue_in_extensionsNoPathLenSubAlt4341_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenSubAlt4344  */
static	ANTLR3_BITWORD FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenSubAlt4344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenSubAlt4344	= { FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenSubAlt4344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoPathLenSubAlt4348  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoPathLenSubAlt4348_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoPathLenSubAlt4348	= { FOLLOW_truevalue_in_extensionsNoPathLenSubAlt4348_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNoPathLenSubAlt4352  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNoPathLenSubAlt4352_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNoPathLenSubAlt4352	= { FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNoPathLenSubAlt4352_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNoPathLenSubAlt4359  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNoPathLenSubAlt4359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNoPathLenSubAlt4359	= { FOLLOW_dependentExtension_in_extensionsNoPathLenSubAlt4359_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4361  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4361	= { FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4361_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsNoPathLenSubAlt4366  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsNoPathLenSubAlt4366_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsNoPathLenSubAlt4366	= { FOLLOW_subjectKeyId_in_extensionsNoPathLenSubAlt4366_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenSubAlt4368  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenSubAlt4368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenSubAlt4368	= { FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenSubAlt4368_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsNoPathLenSubAlt4373  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsNoPathLenSubAlt4373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsNoPathLenSubAlt4373	= { FOLLOW_subAltNameCritical_in_extensionsNoPathLenSubAlt4373_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLen_in_extensionsNoPathLenSubAlt4378  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLen_in_extensionsNoPathLenSubAlt4378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLen_in_extensionsNoPathLenSubAlt4378	= { FOLLOW_extensionsNoPathLen_in_extensionsNoPathLenSubAlt4378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsNoPathLen4405  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsNoPathLen4405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsNoPathLen4405	= { FOLLOW_extension_in_extensionsNoPathLen4405_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLen_in_extensionsNoPathLen4410  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLen_in_extensionsNoPathLen4410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLen_in_extensionsNoPathLen4410	= { FOLLOW_extensionsNoPathLen_in_extensionsNoPathLen4410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraints_in_extensionsNoPathLen4416  */
static	ANTLR3_BITWORD FOLLOW_basicConstraints_in_extensionsNoPathLen4416_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraints_in_extensionsNoPathLen4416	= { FOLLOW_basicConstraints_in_extensionsNoPathLen4416_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoPathLen4420  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoPathLen4420_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoPathLen4420	= { FOLLOW_falsevalue_in_extensionsNoPathLen4420_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExts_in_extensionsNoPathLen4426  */
static	ANTLR3_BITWORD FOLLOW_notDependentExts_in_extensionsNoPathLen4426_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExts_in_extensionsNoPathLen4426	= { FOLLOW_notDependentExts_in_extensionsNoPathLen4426_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoPathLen4431  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoPathLen4431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoPathLen4431	= { FOLLOW_truevalue_in_extensionsNoPathLen4431_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNoPathLen4435  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNoPathLen4435_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNoPathLen4435	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNoPathLen4435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNoPathLen4442  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNoPathLen4442_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNoPathLen4442	= { FOLLOW_dependentExtension_in_extensionsNoPathLen4442_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsNoPathLen4444  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsNoPathLen4444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsNoPathLen4444	= { FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsNoPathLen4444_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsNoPathLen4449  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsNoPathLen4449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsNoPathLen4449	= { FOLLOW_subjectKeyId_in_extensionsNoPathLen4449_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLen4454  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLen4454_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLen4454	= { FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLen4454_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenNoSkiSubAlt4479  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenNoSkiSubAlt4479_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenNoSkiSubAlt4479	= { FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenNoSkiSubAlt4479_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4481  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4481_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4481	= { FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4481_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraints_in_extensionsNoPathLenNoSkiSubAlt4486  */
static	ANTLR3_BITWORD FOLLOW_basicConstraints_in_extensionsNoPathLenNoSkiSubAlt4486_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraints_in_extensionsNoPathLenNoSkiSubAlt4486	= { FOLLOW_basicConstraints_in_extensionsNoPathLenNoSkiSubAlt4486_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoPathLenNoSkiSubAlt4490  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoPathLenNoSkiSubAlt4490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoPathLenNoSkiSubAlt4490	= { FOLLOW_falsevalue_in_extensionsNoPathLenNoSkiSubAlt4490_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenNoSkiSubAlt4493  */
static	ANTLR3_BITWORD FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenNoSkiSubAlt4493_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenNoSkiSubAlt4493	= { FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenNoSkiSubAlt4493_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoPathLenNoSkiSubAlt4497  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoPathLenNoSkiSubAlt4497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoPathLenNoSkiSubAlt4497	= { FOLLOW_truevalue_in_extensionsNoPathLenNoSkiSubAlt4497_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4501  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4501	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4501_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNoPathLenNoSkiSubAlt4508  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNoPathLenNoSkiSubAlt4508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNoPathLenNoSkiSubAlt4508	= { FOLLOW_dependentExtension_in_extensionsNoPathLenNoSkiSubAlt4508_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsNoPathLenNoSkiSubAlt4510  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsNoPathLenNoSkiSubAlt4510_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsNoPathLenNoSkiSubAlt4510	= { FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsNoPathLenNoSkiSubAlt4510_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsNoPathLenNoSkiSubAlt4515  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsNoPathLenNoSkiSubAlt4515_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsNoPathLenNoSkiSubAlt4515	= { FOLLOW_subAltNameCritical_in_extensionsNoPathLenNoSkiSubAlt4515_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSkiSubAlt4520  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSkiSubAlt4520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSkiSubAlt4520	= { FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSkiSubAlt4520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsNoPathLenNoSki4545  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsNoPathLenNoSki4545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsNoPathLenNoSki4545	= { FOLLOW_extension_in_extensionsNoPathLenNoSki4545_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSki4550  */
static	ANTLR3_BITWORD FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSki4550_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSki4550	= { FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSki4550_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraints_in_extensionsNoPathLenNoSki4556  */
static	ANTLR3_BITWORD FOLLOW_basicConstraints_in_extensionsNoPathLenNoSki4556_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraints_in_extensionsNoPathLenNoSki4556	= { FOLLOW_basicConstraints_in_extensionsNoPathLenNoSki4556_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_extensionsNoPathLenNoSki4560  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_extensionsNoPathLenNoSki4560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_extensionsNoPathLenNoSki4560	= { FOLLOW_falsevalue_in_extensionsNoPathLenNoSki4560_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExts_in_extensionsNoPathLenNoSki4566  */
static	ANTLR3_BITWORD FOLLOW_notDependentExts_in_extensionsNoPathLenNoSki4566_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExts_in_extensionsNoPathLenNoSki4566	= { FOLLOW_notDependentExts_in_extensionsNoPathLenNoSki4566_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsNoPathLenNoSki4571  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsNoPathLenNoSki4571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsNoPathLenNoSki4571	= { FOLLOW_truevalue_in_extensionsNoPathLenNoSki4571_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNoPathLenNoSki4578  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNoPathLenNoSki4578_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNoPathLenNoSki4578	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNoPathLenNoSki4578_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNoPathLenNoSki4586  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNoPathLenNoSki4586_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNoPathLenNoSki4586	= { FOLLOW_dependentExtension_in_extensionsNoPathLenNoSki4586_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsNoPathLenNoSki4588  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsNoPathLenNoSki4588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsNoPathLenNoSki4588	= { FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsNoPathLenNoSki4588_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_notDependentExtsSubAlt4611  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_notDependentExtsSubAlt4611_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_notDependentExtsSubAlt4611	= { FOLLOW_extensionNoSubAlt_in_notDependentExtsSubAlt4611_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsage_in_notDependentExtsSubAlt4615  */
static	ANTLR3_BITWORD FOLLOW_keyUsage_in_notDependentExtsSubAlt4615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsage_in_notDependentExtsSubAlt4615	= { FOLLOW_keyUsage_in_notDependentExtsSubAlt4615_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_notDependentExtsSubAlt4619  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_notDependentExtsSubAlt4619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_notDependentExtsSubAlt4619	= { FOLLOW_subjectKeyId_in_notDependentExtsSubAlt4619_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExtsSubAlt_in_notDependentExtsSubAlt4622  */
static	ANTLR3_BITWORD FOLLOW_notDependentExtsSubAlt_in_notDependentExtsSubAlt4622_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExtsSubAlt_in_notDependentExtsSubAlt4622	= { FOLLOW_notDependentExtsSubAlt_in_notDependentExtsSubAlt4622_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_notDependentExtsSubAlt4627  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_notDependentExtsSubAlt4627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_notDependentExtsSubAlt4627	= { FOLLOW_subAltNameCritical_in_notDependentExtsSubAlt4627_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExts_in_notDependentExtsSubAlt4632  */
static	ANTLR3_BITWORD FOLLOW_notDependentExts_in_notDependentExtsSubAlt4632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExts_in_notDependentExtsSubAlt4632	= { FOLLOW_notDependentExts_in_notDependentExtsSubAlt4632_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_notDependentExts4655  */
static	ANTLR3_BITWORD FOLLOW_extension_in_notDependentExts4655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_notDependentExts4655	= { FOLLOW_extension_in_notDependentExts4655_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsage_in_notDependentExts4659  */
static	ANTLR3_BITWORD FOLLOW_keyUsage_in_notDependentExts4659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsage_in_notDependentExts4659	= { FOLLOW_keyUsage_in_notDependentExts4659_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_notDependentExts4663  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_notDependentExts4663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_notDependentExts4663	= { FOLLOW_subjectKeyId_in_notDependentExts4663_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notDependentExts_in_notDependentExts4669  */
static	ANTLR3_BITWORD FOLLOW_notDependentExts_in_notDependentExts4669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notDependentExts_in_notDependentExts4669	= { FOLLOW_notDependentExts_in_notDependentExts4669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsCertSignSubAlt4692  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsCertSignSubAlt4692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsCertSignSubAlt4692	= { FOLLOW_extensionNoSubAlt_in_extensionsCertSignSubAlt4692_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4694  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4694_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4694	= { FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4694_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsCertSignSubAlt4699  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsCertSignSubAlt4699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsCertSignSubAlt4699	= { FOLLOW_dependentExtension_in_extensionsCertSignSubAlt4699_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4701  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4701	= { FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4701_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsCertSignSubAlt4706  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsCertSignSubAlt4706_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsCertSignSubAlt4706	= { FOLLOW_keyUsageCommon_in_extensionsCertSignSubAlt4706_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsCertSignSubAlt4708  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsCertSignSubAlt4708_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsCertSignSubAlt4708	= { FOLLOW_bitstringCertSign_in_extensionsCertSignSubAlt4708_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsCertSignSubAlt4710  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsCertSignSubAlt4710_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsCertSignSubAlt4710	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsCertSignSubAlt4710_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsCertSignSubAlt4715  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsCertSignSubAlt4715_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsCertSignSubAlt4715	= { FOLLOW_subAltNameCritical_in_extensionsCertSignSubAlt4715_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSign_in_extensionsCertSignSubAlt4717  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSign_in_extensionsCertSignSubAlt4717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSign_in_extensionsCertSignSubAlt4717	= { FOLLOW_extensionsCertSign_in_extensionsCertSignSubAlt4717_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsCertSign4740  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsCertSign4740_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsCertSign4740	= { FOLLOW_extension_in_extensionsCertSign4740_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSign_in_extensionsCertSign4742  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSign_in_extensionsCertSign4742_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSign_in_extensionsCertSign4742	= { FOLLOW_extensionsCertSign_in_extensionsCertSign4742_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsCertSign4747  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsCertSign4747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsCertSign4747	= { FOLLOW_dependentExtension_in_extensionsCertSign4747_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSign_in_extensionsCertSign4749  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSign_in_extensionsCertSign4749_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSign_in_extensionsCertSign4749	= { FOLLOW_extensionsCertSign_in_extensionsCertSign4749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsCertSign4754  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsCertSign4754_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsCertSign4754	= { FOLLOW_keyUsageCommon_in_extensionsCertSign4754_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsCertSign4756  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsCertSign4756_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsCertSign4756	= { FOLLOW_bitstringCertSign_in_extensionsCertSign4756_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsCertSign4758  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsCertSign4758_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsCertSign4758	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsCertSign4758_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsCertSignAndSkiSubAlt4782  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsCertSignAndSkiSubAlt4782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsCertSignAndSkiSubAlt4782	= { FOLLOW_extensionNoSubAlt_in_extensionsCertSignAndSkiSubAlt4782_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4784  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4784_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4784	= { FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4784_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsCertSignAndSkiSubAlt4789  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsCertSignAndSkiSubAlt4789_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsCertSignAndSkiSubAlt4789	= { FOLLOW_dependentExtension_in_extensionsCertSignAndSkiSubAlt4789_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4791  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4791	= { FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsCertSignAndSkiSubAlt4796  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsCertSignAndSkiSubAlt4796_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsCertSignAndSkiSubAlt4796	= { FOLLOW_keyUsageCommon_in_extensionsCertSignAndSkiSubAlt4796_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsCertSignAndSkiSubAlt4798  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsCertSignAndSkiSubAlt4798_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsCertSignAndSkiSubAlt4798	= { FOLLOW_bitstringCertSign_in_extensionsCertSignAndSkiSubAlt4798_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSkiSubAlt4800  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSkiSubAlt4800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSkiSubAlt4800	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSkiSubAlt4800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsCertSignAndSkiSubAlt4805  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsCertSignAndSkiSubAlt4805_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsCertSignAndSkiSubAlt4805	= { FOLLOW_subjectKeyId_in_extensionsCertSignAndSkiSubAlt4805_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignAndSkiSubAlt4807  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignAndSkiSubAlt4807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignAndSkiSubAlt4807	= { FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignAndSkiSubAlt4807_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsCertSignAndSkiSubAlt4812  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsCertSignAndSkiSubAlt4812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsCertSignAndSkiSubAlt4812	= { FOLLOW_subAltNameCritical_in_extensionsCertSignAndSkiSubAlt4812_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSkiSubAlt4814  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSkiSubAlt4814_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSkiSubAlt4814	= { FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSkiSubAlt4814_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsCertSignAndSki4837  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsCertSignAndSki4837_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsCertSignAndSki4837	= { FOLLOW_extension_in_extensionsCertSignAndSki4837_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4839  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4839_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4839	= { FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4839_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsCertSignAndSki4844  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsCertSignAndSki4844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsCertSignAndSki4844	= { FOLLOW_dependentExtension_in_extensionsCertSignAndSki4844_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4846  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4846_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4846	= { FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4846_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsCertSignAndSki4851  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsCertSignAndSki4851_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsCertSignAndSki4851	= { FOLLOW_keyUsageCommon_in_extensionsCertSignAndSki4851_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsCertSignAndSki4853  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsCertSignAndSki4853_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsCertSignAndSki4853	= { FOLLOW_bitstringCertSign_in_extensionsCertSignAndSki4853_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSki4855  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSki4855_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSki4855	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSki4855_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsCertSignAndSki4860  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsCertSignAndSki4860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsCertSignAndSki4860	= { FOLLOW_subjectKeyId_in_extensionsCertSignAndSki4860_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSign_in_extensionsCertSignAndSki4862  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSign_in_extensionsCertSignAndSki4862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSign_in_extensionsCertSignAndSki4862	= { FOLLOW_extensionsCertSign_in_extensionsCertSignAndSki4862_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignSubAlt4883  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignSubAlt4883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignSubAlt4883	= { FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignSubAlt4883_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4885  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4885_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4885	= { FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4885_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotCertSignSubAlt4890  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotCertSignSubAlt4890_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotCertSignSubAlt4890	= { FOLLOW_dependentExtension_in_extensionsNotCertSignSubAlt4890_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4892  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4892_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4892	= { FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4892_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNotCertSignSubAlt4897  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNotCertSignSubAlt4897_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNotCertSignSubAlt4897	= { FOLLOW_keyUsageCommon_in_extensionsNotCertSignSubAlt4897_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNotCertSignSubAlt4899  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNotCertSignSubAlt4899_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNotCertSignSubAlt4899	= { FOLLOW_bitstring_in_extensionsNotCertSignSubAlt4899_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotCertSignSubAlt4903  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotCertSignSubAlt4903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotCertSignSubAlt4903	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotCertSignSubAlt4903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsNotCertSignSubAlt4908  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsNotCertSignSubAlt4908_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsNotCertSignSubAlt4908	= { FOLLOW_subAltNameCritical_in_extensionsNotCertSignSubAlt4908_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignSubAlt4910  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignSubAlt4910_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignSubAlt4910	= { FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignSubAlt4910_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsNotCertSign4934  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsNotCertSign4934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsNotCertSign4934	= { FOLLOW_extension_in_extensionsNotCertSign4934_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4939  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4939	= { FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotCertSign4945  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotCertSign4945_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotCertSign4945	= { FOLLOW_dependentExtension_in_extensionsNotCertSign4945_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4950  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4950_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4950	= { FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4950_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNotCertSign4956  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNotCertSign4956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNotCertSign4956	= { FOLLOW_keyUsageCommon_in_extensionsNotCertSign4956_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNotCertSign4958  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNotCertSign4958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNotCertSign4958	= { FOLLOW_bitstring_in_extensionsNotCertSign4958_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotCertSign4962  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotCertSign4962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotCertSign4962	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotCertSign4962_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignAndSkiSubAlt4985  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignAndSkiSubAlt4985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignAndSkiSubAlt4985	= { FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignAndSkiSubAlt4985_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4987  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4987_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4987	= { FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4987_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotCertSignAndSkiSubAlt4992  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotCertSignAndSkiSubAlt4992_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotCertSignAndSkiSubAlt4992	= { FOLLOW_dependentExtension_in_extensionsNotCertSignAndSkiSubAlt4992_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4994  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4994	= { FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4994_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSkiSubAlt4999  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSkiSubAlt4999_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSkiSubAlt4999	= { FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSkiSubAlt4999_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNotCertSignAndSkiSubAlt5001  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNotCertSignAndSkiSubAlt5001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNotCertSignAndSkiSubAlt5001	= { FOLLOW_bitstring_in_extensionsNotCertSignAndSkiSubAlt5001_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotCertSignAndSkiSubAlt5005  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotCertSignAndSkiSubAlt5005_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotCertSignAndSkiSubAlt5005	= { FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotCertSignAndSkiSubAlt5005_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSkiSubAlt5010  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSkiSubAlt5010_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSkiSubAlt5010	= { FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSkiSubAlt5010_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignAndSkiSubAlt5012  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignAndSkiSubAlt5012_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignAndSkiSubAlt5012	= { FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignAndSkiSubAlt5012_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsNotCertSignAndSkiSubAlt5017  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsNotCertSignAndSkiSubAlt5017_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsNotCertSignAndSkiSubAlt5017	= { FOLLOW_subAltNameCritical_in_extensionsNotCertSignAndSkiSubAlt5017_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSkiSubAlt5019  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSkiSubAlt5019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSkiSubAlt5019	= { FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSkiSubAlt5019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsNotCertSignAndSki5043  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsNotCertSignAndSki5043_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsNotCertSignAndSki5043	= { FOLLOW_extension_in_extensionsNotCertSignAndSki5043_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5045  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5045	= { FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5045_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotCertSignAndSki5050  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotCertSignAndSki5050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotCertSignAndSki5050	= { FOLLOW_dependentExtension_in_extensionsNotCertSignAndSki5050_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5052  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5052	= { FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSki5057  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSki5057_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSki5057	= { FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSki5057_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNotCertSignAndSki5059  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNotCertSignAndSki5059_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNotCertSignAndSki5059	= { FOLLOW_bitstring_in_extensionsNotCertSignAndSki5059_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotCertSignAndSki5063  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotCertSignAndSki5063_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotCertSignAndSki5063	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotCertSignAndSki5063_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSki5068  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSki5068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSki5068	= { FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSki5068_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignAndSki5070  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignAndSki5070_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignAndSki5070	= { FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignAndSki5070_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extension5089  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extension5089_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extension5089	= { FOLLOW_sequenceTag_in_extension5089_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authKeyId_in_extension5093  */
static	ANTLR3_BITWORD FOLLOW_authKeyId_in_extension5093_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_authKeyId_in_extension5093	= { FOLLOW_authKeyId_in_extension5093_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_certPolicies_in_extension5098  */
static	ANTLR3_BITWORD FOLLOW_certPolicies_in_extension5098_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_certPolicies_in_extension5098	= { FOLLOW_certPolicies_in_extension5098_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltName_in_extension5102  */
static	ANTLR3_BITWORD FOLLOW_subAltName_in_extension5102_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltName_in_extension5102	= { FOLLOW_subAltName_in_extension5102_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuerAltName_in_extension5106  */
static	ANTLR3_BITWORD FOLLOW_issuerAltName_in_extension5106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuerAltName_in_extension5106	= { FOLLOW_issuerAltName_in_extension5106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subDirAttr_in_extension5110  */
static	ANTLR3_BITWORD FOLLOW_subDirAttr_in_extension5110_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subDirAttr_in_extension5110	= { FOLLOW_subDirAttr_in_extension5110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extendKeyUsage_in_extension5113  */
static	ANTLR3_BITWORD FOLLOW_extendKeyUsage_in_extension5113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extendKeyUsage_in_extension5113	= { FOLLOW_extendKeyUsage_in_extension5113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_crldp_in_extension5117  */
static	ANTLR3_BITWORD FOLLOW_crldp_in_extension5117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_crldp_in_extension5117	= { FOLLOW_crldp_in_extension5117_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sia_in_extension5121  */
static	ANTLR3_BITWORD FOLLOW_sia_in_extension5121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sia_in_extension5121	= { FOLLOW_sia_in_extension5121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_aia_in_extension5125  */
static	ANTLR3_BITWORD FOLLOW_aia_in_extension5125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_aia_in_extension5125	= { FOLLOW_aia_in_extension5125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_freshcrl_in_extension5129  */
static	ANTLR3_BITWORD FOLLOW_freshcrl_in_extension5129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_freshcrl_in_extension5129	= { FOLLOW_freshcrl_in_extension5129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_genericExt_in_extension5133  */
static	ANTLR3_BITWORD FOLLOW_genericExt_in_extension5133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_genericExt_in_extension5133	= { FOLLOW_genericExt_in_extension5133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionNoSubAlt5153  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionNoSubAlt5153_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionNoSubAlt5153	= { FOLLOW_sequenceTag_in_extensionNoSubAlt5153_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_authKeyId_in_extensionNoSubAlt5157  */
static	ANTLR3_BITWORD FOLLOW_authKeyId_in_extensionNoSubAlt5157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_authKeyId_in_extensionNoSubAlt5157	= { FOLLOW_authKeyId_in_extensionNoSubAlt5157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_certPolicies_in_extensionNoSubAlt5162  */
static	ANTLR3_BITWORD FOLLOW_certPolicies_in_extensionNoSubAlt5162_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_certPolicies_in_extensionNoSubAlt5162	= { FOLLOW_certPolicies_in_extensionNoSubAlt5162_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issuerAltName_in_extensionNoSubAlt5166  */
static	ANTLR3_BITWORD FOLLOW_issuerAltName_in_extensionNoSubAlt5166_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_issuerAltName_in_extensionNoSubAlt5166	= { FOLLOW_issuerAltName_in_extensionNoSubAlt5166_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subDirAttr_in_extensionNoSubAlt5170  */
static	ANTLR3_BITWORD FOLLOW_subDirAttr_in_extensionNoSubAlt5170_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subDirAttr_in_extensionNoSubAlt5170	= { FOLLOW_subDirAttr_in_extensionNoSubAlt5170_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extendKeyUsage_in_extensionNoSubAlt5173  */
static	ANTLR3_BITWORD FOLLOW_extendKeyUsage_in_extensionNoSubAlt5173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extendKeyUsage_in_extensionNoSubAlt5173	= { FOLLOW_extendKeyUsage_in_extensionNoSubAlt5173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_crldp_in_extensionNoSubAlt5177  */
static	ANTLR3_BITWORD FOLLOW_crldp_in_extensionNoSubAlt5177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_crldp_in_extensionNoSubAlt5177	= { FOLLOW_crldp_in_extensionNoSubAlt5177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sia_in_extensionNoSubAlt5181  */
static	ANTLR3_BITWORD FOLLOW_sia_in_extensionNoSubAlt5181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sia_in_extensionNoSubAlt5181	= { FOLLOW_sia_in_extensionNoSubAlt5181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_aia_in_extensionNoSubAlt5185  */
static	ANTLR3_BITWORD FOLLOW_aia_in_extensionNoSubAlt5185_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_aia_in_extensionNoSubAlt5185	= { FOLLOW_aia_in_extensionNoSubAlt5185_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_freshcrl_in_extensionNoSubAlt5189  */
static	ANTLR3_BITWORD FOLLOW_freshcrl_in_extensionNoSubAlt5189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_freshcrl_in_extensionNoSubAlt5189	= { FOLLOW_freshcrl_in_extensionNoSubAlt5189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_genericExt_in_extensionNoSubAlt5193  */
static	ANTLR3_BITWORD FOLLOW_genericExt_in_extensionNoSubAlt5193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_genericExt_in_extensionNoSubAlt5193	= { FOLLOW_genericExt_in_extensionNoSubAlt5193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_genericExt5218  */
static	ANTLR3_BITWORD FOLLOW_oid_in_genericExt5218_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000000000), ANTLR3_UINT64_LIT(0x0000000200000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_genericExt5218	= { FOLLOW_oid_in_genericExt5218_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_genericExt5224  */
static	ANTLR3_BITWORD FOLLOW_critical_in_genericExt5224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_genericExt5224	= { FOLLOW_critical_in_genericExt5224_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_genericExt5230  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_genericExt5230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_genericExt5230	= { FOLLOW_octetstring_in_genericExt5230_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_akioid_in_authKeyId5254  */
static	ANTLR3_BITWORD FOLLOW_akioid_in_authKeyId5254_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_akioid_in_authKeyId5254	= { FOLLOW_akioid_in_authKeyId5254_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_authKeyId5256  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_authKeyId5256_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_authKeyId5256	= { FOLLOW_falsevalue_in_authKeyId5256_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_authKeyId5259  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_authKeyId5259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_authKeyId5259	= { FOLLOW_constructedOctetString_in_authKeyId5259_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_authKeyId5261  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_authKeyId5261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF8140) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_authKeyId5261	= { FOLLOW_sequenceTag_in_authKeyId5261_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag0_in_authKeyId5269  */
static	ANTLR3_BITWORD FOLLOW_tag0_in_authKeyId5269_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_tag0_in_authKeyId5269	= { FOLLOW_tag0_in_authKeyId5269_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_authKeyId5279  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_authKeyId5279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_authKeyId5279	= { FOLLOW_constructedTag1_in_authKeyId5279_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalNames_in_authKeyId5281  */
static	ANTLR3_BITWORD FOLLOW_generalNames_in_authKeyId5281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_generalNames_in_authKeyId5281	= { FOLLOW_generalNames_in_authKeyId5281_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag2_in_authKeyId5291  */
static	ANTLR3_BITWORD FOLLOW_tag2_in_authKeyId5291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag2_in_authKeyId5291	= { FOLLOW_tag2_in_authKeyId5291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_subjectKeyId5315  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_subjectKeyId5315_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_subjectKeyId5315	= { FOLLOW_sequenceTag_in_subjectKeyId5315_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_skioid_in_subjectKeyId5317  */
static	ANTLR3_BITWORD FOLLOW_skioid_in_subjectKeyId5317_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_skioid_in_subjectKeyId5317	= { FOLLOW_skioid_in_subjectKeyId5317_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_subjectKeyId5319  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_subjectKeyId5319_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_subjectKeyId5319	= { FOLLOW_falsevalue_in_subjectKeyId5319_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_subjectKeyId5322  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_subjectKeyId5322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_subjectKeyId5322	= { FOLLOW_constructedOctetString_in_subjectKeyId5322_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_subjectKeyId5324  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_subjectKeyId5324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_subjectKeyId5324	= { FOLLOW_octetstring_in_subjectKeyId5324_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_keyUsage5342  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_keyUsage5342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_keyUsage5342	= { FOLLOW_sequenceTag_in_keyUsage5342_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyusageoid_in_keyUsage5344  */
static	ANTLR3_BITWORD FOLLOW_keyusageoid_in_keyUsage5344_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_keyusageoid_in_keyUsage5344	= { FOLLOW_keyusageoid_in_keyUsage5344_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_keyUsage5351  */
static	ANTLR3_BITWORD FOLLOW_critical_in_keyUsage5351_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_keyUsage5351	= { FOLLOW_critical_in_keyUsage5351_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_keyUsage5357  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_keyUsage5357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_keyUsage5357	= { FOLLOW_constructedOctetString_in_keyUsage5357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_keyUsage5359  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_keyUsage5359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_keyUsage5359	= { FOLLOW_bitstring_in_keyUsage5359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_keyUsageCommon5378  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_keyUsageCommon5378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_keyUsageCommon5378	= { FOLLOW_sequenceTag_in_keyUsageCommon5378_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyusageoid_in_keyUsageCommon5380  */
static	ANTLR3_BITWORD FOLLOW_keyusageoid_in_keyUsageCommon5380_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_keyusageoid_in_keyUsageCommon5380	= { FOLLOW_keyusageoid_in_keyUsageCommon5380_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_keyUsageCommon5388  */
static	ANTLR3_BITWORD FOLLOW_critical_in_keyUsageCommon5388_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_keyUsageCommon5388	= { FOLLOW_critical_in_keyUsageCommon5388_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_keyUsageCommon5394  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_keyUsageCommon5394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_keyUsageCommon5394	= { FOLLOW_constructedOctetString_in_keyUsageCommon5394_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_certpolioid_in_certPolicies5416  */
static	ANTLR3_BITWORD FOLLOW_certpolioid_in_certPolicies5416_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_certpolioid_in_certPolicies5416	= { FOLLOW_certpolioid_in_certPolicies5416_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_certPolicies5424  */
static	ANTLR3_BITWORD FOLLOW_critical_in_certPolicies5424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_certPolicies5424	= { FOLLOW_critical_in_certPolicies5424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_certPolicies5432  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_certPolicies5432_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_certPolicies5432	= { FOLLOW_constructedOctetString_in_certPolicies5432_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_certPolicies5434  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_certPolicies5434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_certPolicies5434	= { FOLLOW_sequenceTag_in_certPolicies5434_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_policies_in_certPolicies5436  */
static	ANTLR3_BITWORD FOLLOW_policies_in_certPolicies5436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_policies_in_certPolicies5436	= { FOLLOW_policies_in_certPolicies5436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_policyInfo_in_policies5464  */
static	ANTLR3_BITWORD FOLLOW_policyInfo_in_policies5464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_policyInfo_in_policies5464	= { FOLLOW_policyInfo_in_policies5464_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_policyInfo5490  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_policyInfo5490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_policyInfo5490	= { FOLLOW_sequenceTag_in_policyInfo5490_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_policyInfo5495  */
static	ANTLR3_BITWORD FOLLOW_oid_in_policyInfo5495_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_policyInfo5495	= { FOLLOW_oid_in_policyInfo5495_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_policyInfo5499  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_policyInfo5499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_policyInfo5499	= { FOLLOW_sequenceTag_in_policyInfo5499_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_policyQualifiers_in_policyInfo5501  */
static	ANTLR3_BITWORD FOLLOW_policyQualifiers_in_policyInfo5501_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_policyQualifiers_in_policyInfo5501	= { FOLLOW_policyQualifiers_in_policyInfo5501_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anypolicyoid_in_policyInfo5509  */
static	ANTLR3_BITWORD FOLLOW_anypolicyoid_in_policyInfo5509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anypolicyoid_in_policyInfo5509	= { FOLLOW_anypolicyoid_in_policyInfo5509_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_policyInfo5513  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_policyInfo5513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_policyInfo5513	= { FOLLOW_sequenceTag_in_policyInfo5513_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_policyQualifiersAnyPolicy_in_policyInfo5515  */
static	ANTLR3_BITWORD FOLLOW_policyQualifiersAnyPolicy_in_policyInfo5515_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_policyQualifiersAnyPolicy_in_policyInfo5515	= { FOLLOW_policyQualifiersAnyPolicy_in_policyInfo5515_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualifier_in_policyQualifiers5545  */
static	ANTLR3_BITWORD FOLLOW_qualifier_in_policyQualifiers5545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualifier_in_policyQualifiers5545	= { FOLLOW_qualifier_in_policyQualifiers5545_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_qualifier5580  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_qualifier5580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_qualifier5580	= { FOLLOW_sequenceTag_in_qualifier5580_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cps_in_qualifier5588  */
static	ANTLR3_BITWORD FOLLOW_cps_in_qualifier5588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cps_in_qualifier5588	= { FOLLOW_cps_in_qualifier5588_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unotice_in_qualifier5594  */
static	ANTLR3_BITWORD FOLLOW_unotice_in_qualifier5594_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unotice_in_qualifier5594	= { FOLLOW_unotice_in_qualifier5594_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_qualifier5602  */
static	ANTLR3_BITWORD FOLLOW_oid_in_qualifier5602_bits[]	= { ANTLR3_UINT64_LIT(0x01F702001FF81C00), ANTLR3_UINT64_LIT(0x0000008300000001), ANTLR3_UINT64_LIT(0x00030EFFFFFFFFC6) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_qualifier5602	= { FOLLOW_oid_in_qualifier5602_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_any_in_qualifier5604  */
static	ANTLR3_BITWORD FOLLOW_any_in_qualifier5604_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_any_in_qualifier5604	= { FOLLOW_any_in_qualifier5604_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_qualifierAnyPolicy_in_policyQualifiersAnyPolicy5632  */
static	ANTLR3_BITWORD FOLLOW_qualifierAnyPolicy_in_policyQualifiersAnyPolicy5632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_qualifierAnyPolicy_in_policyQualifiersAnyPolicy5632	= { FOLLOW_qualifierAnyPolicy_in_policyQualifiersAnyPolicy5632_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_qualifierAnyPolicy5667  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_qualifierAnyPolicy5667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_qualifierAnyPolicy5667	= { FOLLOW_sequenceTag_in_qualifierAnyPolicy5667_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cps_in_qualifierAnyPolicy5675  */
static	ANTLR3_BITWORD FOLLOW_cps_in_qualifierAnyPolicy5675_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_cps_in_qualifierAnyPolicy5675	= { FOLLOW_cps_in_qualifierAnyPolicy5675_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unotice_in_qualifierAnyPolicy5681  */
static	ANTLR3_BITWORD FOLLOW_unotice_in_qualifierAnyPolicy5681_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unotice_in_qualifierAnyPolicy5681	= { FOLLOW_unotice_in_qualifierAnyPolicy5681_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cpsoid_in_cps5705  */
static	ANTLR3_BITWORD FOLLOW_cpsoid_in_cps5705_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_cpsoid_in_cps5705	= { FOLLOW_cpsoid_in_cps5705_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ia5String_in_cps5707  */
static	ANTLR3_BITWORD FOLLOW_ia5String_in_cps5707_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ia5String_in_cps5707	= { FOLLOW_ia5String_in_cps5707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unoticeoid_in_unotice5730  */
static	ANTLR3_BITWORD FOLLOW_unoticeoid_in_unotice5730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unoticeoid_in_unotice5730	= { FOLLOW_unoticeoid_in_unotice5730_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_unotice5732  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_unotice5732_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000402), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0002040000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_unotice5732	= { FOLLOW_sequenceTag_in_unotice5732_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_noticeref_in_unotice5740  */
static	ANTLR3_BITWORD FOLLOW_noticeref_in_unotice5740_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000402), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0002040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_noticeref_in_unotice5740	= { FOLLOW_noticeref_in_unotice5740_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_displayTextString_in_unotice5747  */
static	ANTLR3_BITWORD FOLLOW_displayTextString_in_unotice5747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_displayTextString_in_unotice5747	= { FOLLOW_displayTextString_in_unotice5747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ia5String_in_displayTextString5775  */
static	ANTLR3_BITWORD FOLLOW_ia5String_in_displayTextString5775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ia5String_in_displayTextString5775	= { FOLLOW_ia5String_in_displayTextString5775_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_visibleString_in_displayTextString5782  */
static	ANTLR3_BITWORD FOLLOW_visibleString_in_displayTextString5782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_visibleString_in_displayTextString5782	= { FOLLOW_visibleString_in_displayTextString5782_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bmpString_in_displayTextString5789  */
static	ANTLR3_BITWORD FOLLOW_bmpString_in_displayTextString5789_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bmpString_in_displayTextString5789	= { FOLLOW_bmpString_in_displayTextString5789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_utf8String_in_displayTextString5796  */
static	ANTLR3_BITWORD FOLLOW_utf8String_in_displayTextString5796_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_utf8String_in_displayTextString5796	= { FOLLOW_utf8String_in_displayTextString5796_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_noticeref5827  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_noticeref5827_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0002040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_noticeref5827	= { FOLLOW_sequenceTag_in_noticeref5827_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_displayTextString_in_noticeref5829  */
static	ANTLR3_BITWORD FOLLOW_displayTextString_in_noticeref5829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_displayTextString_in_noticeref5829	= { FOLLOW_displayTextString_in_noticeref5829_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_noticeref5831  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_noticeref5831_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_noticeref5831	= { FOLLOW_sequenceTag_in_noticeref5831_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_noticeNumbers_in_noticeref5833  */
static	ANTLR3_BITWORD FOLLOW_noticeNumbers_in_noticeref5833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_noticeNumbers_in_noticeref5833	= { FOLLOW_noticeNumbers_in_noticeref5833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_noticeNumbers5861  */
static	ANTLR3_BITWORD FOLLOW_integer_in_noticeNumbers5861_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_noticeNumbers5861	= { FOLLOW_integer_in_noticeNumbers5861_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subaltoid_in_subAltName5886  */
static	ANTLR3_BITWORD FOLLOW_subaltoid_in_subAltName5886_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_subaltoid_in_subAltName5886	= { FOLLOW_subaltoid_in_subAltName5886_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_subAltName5890  */
static	ANTLR3_BITWORD FOLLOW_critical_in_subAltName5890_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_subAltName5890	= { FOLLOW_critical_in_subAltName5890_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_subAltName5898  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_subAltName5898_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_subAltName5898	= { FOLLOW_constructedOctetString_in_subAltName5898_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_subAltName5900  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_subAltName5900_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_subAltName5900	= { FOLLOW_sequenceTag_in_subAltName5900_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalNames_in_subAltName5902  */
static	ANTLR3_BITWORD FOLLOW_generalNames_in_subAltName5902_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalNames_in_subAltName5902	= { FOLLOW_generalNames_in_subAltName5902_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_subAltNameCritical5924  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_subAltNameCritical5924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_subAltNameCritical5924	= { FOLLOW_sequenceTag_in_subAltNameCritical5924_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subaltoid_in_subAltNameCritical5926  */
static	ANTLR3_BITWORD FOLLOW_subaltoid_in_subAltNameCritical5926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_subaltoid_in_subAltNameCritical5926	= { FOLLOW_subaltoid_in_subAltNameCritical5926_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_subAltNameCritical5928  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_subAltNameCritical5928_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_subAltNameCritical5928	= { FOLLOW_truevalue_in_subAltNameCritical5928_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_subAltNameCritical5930  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_subAltNameCritical5930_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_subAltNameCritical5930	= { FOLLOW_constructedOctetString_in_subAltNameCritical5930_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_subAltNameCritical5932  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_subAltNameCritical5932_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_subAltNameCritical5932	= { FOLLOW_sequenceTag_in_subAltNameCritical5932_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalNames_in_subAltNameCritical5934  */
static	ANTLR3_BITWORD FOLLOW_generalNames_in_subAltNameCritical5934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalNames_in_subAltNameCritical5934	= { FOLLOW_generalNames_in_subAltNameCritical5934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_issaltoid_in_issuerAltName5958  */
static	ANTLR3_BITWORD FOLLOW_issaltoid_in_issuerAltName5958_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_issaltoid_in_issuerAltName5958	= { FOLLOW_issaltoid_in_issuerAltName5958_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_issuerAltName5962  */
static	ANTLR3_BITWORD FOLLOW_critical_in_issuerAltName5962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_issuerAltName5962	= { FOLLOW_critical_in_issuerAltName5962_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_issuerAltName5970  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_issuerAltName5970_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_issuerAltName5970	= { FOLLOW_constructedOctetString_in_issuerAltName5970_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_issuerAltName5972  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_issuerAltName5972_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_issuerAltName5972	= { FOLLOW_sequenceTag_in_issuerAltName5972_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalNames_in_issuerAltName5974  */
static	ANTLR3_BITWORD FOLLOW_generalNames_in_issuerAltName5974_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalNames_in_issuerAltName5974	= { FOLLOW_generalNames_in_issuerAltName5974_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subdiroid_in_subDirAttr5999  */
static	ANTLR3_BITWORD FOLLOW_subdiroid_in_subDirAttr5999_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_subdiroid_in_subDirAttr5999	= { FOLLOW_subdiroid_in_subDirAttr5999_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_subDirAttr6004  */
static	ANTLR3_BITWORD FOLLOW_critical_in_subDirAttr6004_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_subDirAttr6004	= { FOLLOW_critical_in_subDirAttr6004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_subDirAttr6009  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_subDirAttr6009_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_subDirAttr6009	= { FOLLOW_constructedOctetString_in_subDirAttr6009_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_subDirAttr6011  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_subDirAttr6011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_subDirAttr6011	= { FOLLOW_sequenceTag_in_subDirAttr6011_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attributes_in_subDirAttr6018  */
static	ANTLR3_BITWORD FOLLOW_attributes_in_subDirAttr6018_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_attributes_in_subDirAttr6018	= { FOLLOW_attributes_in_subDirAttr6018_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_attributes6045  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_attributes6045_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_attributes6045	= { FOLLOW_attribute_in_attributes6045_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_attribute6077  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_attribute6077_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_attribute6077	= { FOLLOW_sequenceTag_in_attribute6077_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnoid_in_attribute6081  */
static	ANTLR3_BITWORD FOLLOW_cnoid_in_attribute6081_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_cnoid_in_attribute6081	= { FOLLOW_cnoid_in_attribute6081_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oidon_in_attribute6087  */
static	ANTLR3_BITWORD FOLLOW_oidon_in_attribute6087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_oidon_in_attribute6087	= { FOLLOW_oidon_in_attribute6087_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oidname_in_attribute6092  */
static	ANTLR3_BITWORD FOLLOW_oidname_in_attribute6092_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_oidname_in_attribute6092	= { FOLLOW_oidname_in_attribute6092_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_surnameoid_in_attribute6097  */
static	ANTLR3_BITWORD FOLLOW_surnameoid_in_attribute6097_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_surnameoid_in_attribute6097	= { FOLLOW_surnameoid_in_attribute6097_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_givenoid_in_attribute6102  */
static	ANTLR3_BITWORD FOLLOW_givenoid_in_attribute6102_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_givenoid_in_attribute6102	= { FOLLOW_givenoid_in_attribute6102_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initoid_in_attribute6109  */
static	ANTLR3_BITWORD FOLLOW_initoid_in_attribute6109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_initoid_in_attribute6109	= { FOLLOW_initoid_in_attribute6109_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_genqualifieroid_in_attribute6114  */
static	ANTLR3_BITWORD FOLLOW_genqualifieroid_in_attribute6114_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_genqualifieroid_in_attribute6114	= { FOLLOW_genqualifieroid_in_attribute6114_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_localoid_in_attribute6119  */
static	ANTLR3_BITWORD FOLLOW_localoid_in_attribute6119_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_localoid_in_attribute6119	= { FOLLOW_localoid_in_attribute6119_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ouoid_in_attribute6124  */
static	ANTLR3_BITWORD FOLLOW_ouoid_in_attribute6124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_ouoid_in_attribute6124	= { FOLLOW_ouoid_in_attribute6124_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sorpoid_in_attribute6131  */
static	ANTLR3_BITWORD FOLLOW_sorpoid_in_attribute6131_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_sorpoid_in_attribute6131	= { FOLLOW_sorpoid_in_attribute6131_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_titleoid_in_attribute6136  */
static	ANTLR3_BITWORD FOLLOW_titleoid_in_attribute6136_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_titleoid_in_attribute6136	= { FOLLOW_titleoid_in_attribute6136_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pseudooid_in_attribute6141  */
static	ANTLR3_BITWORD FOLLOW_pseudooid_in_attribute6141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_pseudooid_in_attribute6141	= { FOLLOW_pseudooid_in_attribute6141_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_attribute6150  */
static	ANTLR3_BITWORD FOLLOW_set_in_attribute6150_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_attribute6150	= { FOLLOW_set_in_attribute6150_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_directoryString_in_attribute6153  */
static	ANTLR3_BITWORD FOLLOW_directoryString_in_attribute6153_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000402), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_directoryString_in_attribute6153	= { FOLLOW_directoryString_in_attribute6153_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_attribute6163  */
static	ANTLR3_BITWORD FOLLOW_oid_in_attribute6163_bits[]	= { ANTLR3_UINT64_LIT(0x01F702001FF81C00), ANTLR3_UINT64_LIT(0x0000008300000001), ANTLR3_UINT64_LIT(0x00030EFFFFFFFFC6) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_attribute6163	= { FOLLOW_oid_in_attribute6163_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_any_in_attribute6165  */
static	ANTLR3_BITWORD FOLLOW_any_in_attribute6165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_any_in_attribute6165	= { FOLLOW_any_in_attribute6165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dnoid_in_attribute6173  */
static	ANTLR3_BITWORD FOLLOW_dnoid_in_attribute6173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_dnoid_in_attribute6173	= { FOLLOW_dnoid_in_attribute6173_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_countryoid_in_attribute6179  */
static	ANTLR3_BITWORD FOLLOW_countryoid_in_attribute6179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_countryoid_in_attribute6179	= { FOLLOW_countryoid_in_attribute6179_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_serialoid_in_attribute6184  */
static	ANTLR3_BITWORD FOLLOW_serialoid_in_attribute6184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_serialoid_in_attribute6184	= { FOLLOW_serialoid_in_attribute6184_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_attribute6193  */
static	ANTLR3_BITWORD FOLLOW_set_in_attribute6193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_attribute6193	= { FOLLOW_set_in_attribute6193_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_attribute6196  */
static	ANTLR3_BITWORD FOLLOW_printString_in_attribute6196_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_attribute6196	= { FOLLOW_printString_in_attribute6196_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraints6224  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraints6224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraints6224	= { FOLLOW_sequenceTag_in_basicConstraints6224_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_basicConstraints6226  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_basicConstraints6226_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_basicConstraints6226	= { FOLLOW_bcoid_in_basicConstraints6226_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_basicConstraints6233  */
static	ANTLR3_BITWORD FOLLOW_critical_in_basicConstraints6233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_basicConstraints6233	= { FOLLOW_critical_in_basicConstraints6233_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_basicConstraints6239  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_basicConstraints6239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_basicConstraints6239	= { FOLLOW_constructedOctetString_in_basicConstraints6239_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraints6241  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraints6241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraints6241	= { FOLLOW_sequenceTag_in_basicConstraints6241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsNotCritical6260  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsNotCritical6260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsNotCritical6260	= { FOLLOW_sequenceTag_in_basicConstraintsNotCritical6260_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_basicConstraintsNotCritical6262  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_basicConstraintsNotCritical6262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_basicConstraintsNotCritical6262	= { FOLLOW_bcoid_in_basicConstraintsNotCritical6262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ekuoid_in_extendKeyUsage6286  */
static	ANTLR3_BITWORD FOLLOW_ekuoid_in_extendKeyUsage6286_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ekuoid_in_extendKeyUsage6286	= { FOLLOW_ekuoid_in_extendKeyUsage6286_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_extendKeyUsage6291  */
static	ANTLR3_BITWORD FOLLOW_critical_in_extendKeyUsage6291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_extendKeyUsage6291	= { FOLLOW_critical_in_extendKeyUsage6291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extendKeyUsage6296  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extendKeyUsage6296_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extendKeyUsage6296	= { FOLLOW_constructedOctetString_in_extendKeyUsage6296_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extendKeyUsage6298  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extendKeyUsage6298_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extendKeyUsage6298	= { FOLLOW_sequenceTag_in_extendKeyUsage6298_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_usages_in_extendKeyUsage6300  */
static	ANTLR3_BITWORD FOLLOW_usages_in_extendKeyUsage6300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_usages_in_extendKeyUsage6300	= { FOLLOW_usages_in_extendKeyUsage6300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_usage_in_usages6332  */
static	ANTLR3_BITWORD FOLLOW_usage_in_usages6332_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_usage_in_usages6332	= { FOLLOW_usage_in_usages6332_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_usage6362  */
static	ANTLR3_BITWORD FOLLOW_oid_in_usage6362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_usage6362	= { FOLLOW_oid_in_usage6362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_serverauthoid_in_usage6368  */
static	ANTLR3_BITWORD FOLLOW_serverauthoid_in_usage6368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_serverauthoid_in_usage6368	= { FOLLOW_serverauthoid_in_usage6368_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_clientauthoid_in_usage6377  */
static	ANTLR3_BITWORD FOLLOW_clientauthoid_in_usage6377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_clientauthoid_in_usage6377	= { FOLLOW_clientauthoid_in_usage6377_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_codesignoid_in_usage6382  */
static	ANTLR3_BITWORD FOLLOW_codesignoid_in_usage6382_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_codesignoid_in_usage6382	= { FOLLOW_codesignoid_in_usage6382_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_emailprotectoid_in_usage6390  */
static	ANTLR3_BITWORD FOLLOW_emailprotectoid_in_usage6390_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_emailprotectoid_in_usage6390	= { FOLLOW_emailprotectoid_in_usage6390_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_timestampoid_in_usage6395  */
static	ANTLR3_BITWORD FOLLOW_timestampoid_in_usage6395_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_timestampoid_in_usage6395	= { FOLLOW_timestampoid_in_usage6395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ocspsignoid_in_usage6403  */
static	ANTLR3_BITWORD FOLLOW_ocspsignoid_in_usage6403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ocspsignoid_in_usage6403	= { FOLLOW_ocspsignoid_in_usage6403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyusageoid_in_usage6408  */
static	ANTLR3_BITWORD FOLLOW_anyusageoid_in_usage6408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_anyusageoid_in_usage6408	= { FOLLOW_anyusageoid_in_usage6408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_crldpoid_in_crldp6432  */
static	ANTLR3_BITWORD FOLLOW_crldpoid_in_crldp6432_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_crldpoid_in_crldp6432	= { FOLLOW_crldpoid_in_crldp6432_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_crldp6436  */
static	ANTLR3_BITWORD FOLLOW_critical_in_crldp6436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_crldp6436	= { FOLLOW_critical_in_crldp6436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_crldp6444  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_crldp6444_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_crldp6444	= { FOLLOW_constructedOctetString_in_crldp6444_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_crldp6446  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_crldp6446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_crldp6446	= { FOLLOW_sequenceTag_in_crldp6446_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dps_in_crldp6448  */
static	ANTLR3_BITWORD FOLLOW_dps_in_crldp6448_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dps_in_crldp6448	= { FOLLOW_dps_in_crldp6448_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dp_in_dps6475  */
static	ANTLR3_BITWORD FOLLOW_dp_in_dps6475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dp_in_dps6475	= { FOLLOW_dp_in_dps6475_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dp6505  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dp6505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000500000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dp6505	= { FOLLOW_sequenceTag_in_dp6505_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_dp6508  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_dp6508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000300000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_dp6508	= { FOLLOW_constructedTag0_in_dp6508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_dp6512  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_dp6512_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_dp6512	= { FOLLOW_constructedTag0_in_dp6512_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalNames_in_dp6516  */
static	ANTLR3_BITWORD FOLLOW_generalNames_in_dp6516_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_generalNames_in_dp6516	= { FOLLOW_generalNames_in_dp6516_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_dp6525  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_dp6525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_dp6525	= { FOLLOW_tag1_in_dp6525_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag2_in_dp6531  */
static	ANTLR3_BITWORD FOLLOW_constructedTag2_in_dp6531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag2_in_dp6531	= { FOLLOW_constructedTag2_in_dp6531_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalNames_in_dp6535  */
static	ANTLR3_BITWORD FOLLOW_generalNames_in_dp6535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalNames_in_dp6535	= { FOLLOW_generalNames_in_dp6535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_dp6544  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_dp6544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_dp6544	= { FOLLOW_constructedTag1_in_dp6544_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rdn_in_dp6547  */
static	ANTLR3_BITWORD FOLLOW_rdn_in_dp6547_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_rdn_in_dp6547	= { FOLLOW_rdn_in_dp6547_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_dp6556  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_dp6556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_dp6556	= { FOLLOW_tag1_in_dp6556_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag2_in_dp6565  */
static	ANTLR3_BITWORD FOLLOW_constructedTag2_in_dp6565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag2_in_dp6565	= { FOLLOW_constructedTag2_in_dp6565_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalName_in_dp6567  */
static	ANTLR3_BITWORD FOLLOW_generalName_in_dp6567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalName_in_dp6567	= { FOLLOW_generalName_in_dp6567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_dp6581  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_dp6581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_dp6581	= { FOLLOW_tag1_in_dp6581_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag2_in_dp6587  */
static	ANTLR3_BITWORD FOLLOW_constructedTag2_in_dp6587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag2_in_dp6587	= { FOLLOW_constructedTag2_in_dp6587_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalNames_in_dp6591  */
static	ANTLR3_BITWORD FOLLOW_generalNames_in_dp6591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalNames_in_dp6591	= { FOLLOW_generalNames_in_dp6591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_freshcrloid_in_freshcrl6612  */
static	ANTLR3_BITWORD FOLLOW_freshcrloid_in_freshcrl6612_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_freshcrloid_in_freshcrl6612	= { FOLLOW_freshcrloid_in_freshcrl6612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_freshcrl6614  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_freshcrl6614_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_freshcrl6614	= { FOLLOW_falsevalue_in_freshcrl6614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_freshcrl6617  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_freshcrl6617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_freshcrl6617	= { FOLLOW_constructedOctetString_in_freshcrl6617_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_freshcrl6619  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_freshcrl6619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_freshcrl6619	= { FOLLOW_sequenceTag_in_freshcrl6619_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dps_in_freshcrl6621  */
static	ANTLR3_BITWORD FOLLOW_dps_in_freshcrl6621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dps_in_freshcrl6621	= { FOLLOW_dps_in_freshcrl6621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_aiaoid_in_aia6645  */
static	ANTLR3_BITWORD FOLLOW_aiaoid_in_aia6645_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_aiaoid_in_aia6645	= { FOLLOW_aiaoid_in_aia6645_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_aia6647  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_aia6647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_aia6647	= { FOLLOW_falsevalue_in_aia6647_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_aia6650  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_aia6650_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_aia6650	= { FOLLOW_constructedOctetString_in_aia6650_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_aia6652  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_aia6652_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_aia6652	= { FOLLOW_sequenceTag_in_aia6652_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ads_in_aia6654  */
static	ANTLR3_BITWORD FOLLOW_ads_in_aia6654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ads_in_aia6654	= { FOLLOW_ads_in_aia6654_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ad_in_ads6677  */
static	ANTLR3_BITWORD FOLLOW_ad_in_ads6677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ad_in_ads6677	= { FOLLOW_ad_in_ads6677_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_ad6706  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_ad6706_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_ad6706	= { FOLLOW_sequenceTag_in_ad6706_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_caissueroid_in_ad6709  */
static	ANTLR3_BITWORD FOLLOW_caissueroid_in_ad6709_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_caissueroid_in_ad6709	= { FOLLOW_caissueroid_in_ad6709_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalName_in_ad6711  */
static	ANTLR3_BITWORD FOLLOW_generalName_in_ad6711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalName_in_ad6711	= { FOLLOW_generalName_in_ad6711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ocspoid_in_ad6718  */
static	ANTLR3_BITWORD FOLLOW_ocspoid_in_ad6718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_ocspoid_in_ad6718	= { FOLLOW_ocspoid_in_ad6718_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalName_in_ad6720  */
static	ANTLR3_BITWORD FOLLOW_generalName_in_ad6720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalName_in_ad6720	= { FOLLOW_generalName_in_ad6720_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_ad6725  */
static	ANTLR3_BITWORD FOLLOW_oid_in_ad6725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_ad6725	= { FOLLOW_oid_in_ad6725_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalName_in_ad6727  */
static	ANTLR3_BITWORD FOLLOW_generalName_in_ad6727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalName_in_ad6727	= { FOLLOW_generalName_in_ad6727_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_siaoid_in_sia6756  */
static	ANTLR3_BITWORD FOLLOW_siaoid_in_sia6756_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_siaoid_in_sia6756	= { FOLLOW_siaoid_in_sia6756_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_sia6758  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_sia6758_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_sia6758	= { FOLLOW_falsevalue_in_sia6758_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_sia6761  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_sia6761_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_sia6761	= { FOLLOW_constructedOctetString_in_sia6761_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_sia6763  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_sia6763_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_sia6763	= { FOLLOW_sequenceTag_in_sia6763_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_siaads_in_sia6765  */
static	ANTLR3_BITWORD FOLLOW_siaads_in_sia6765_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_siaads_in_sia6765	= { FOLLOW_siaads_in_sia6765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_adsia_in_siaads6788  */
static	ANTLR3_BITWORD FOLLOW_adsia_in_siaads6788_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_adsia_in_siaads6788	= { FOLLOW_adsia_in_siaads6788_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_adsia6817  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_adsia6817_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_adsia6817	= { FOLLOW_sequenceTag_in_adsia6817_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_carepooid_in_adsia6820  */
static	ANTLR3_BITWORD FOLLOW_carepooid_in_adsia6820_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_carepooid_in_adsia6820	= { FOLLOW_carepooid_in_adsia6820_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalName_in_adsia6822  */
static	ANTLR3_BITWORD FOLLOW_generalName_in_adsia6822_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalName_in_adsia6822	= { FOLLOW_generalName_in_adsia6822_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tspoid_in_adsia6829  */
static	ANTLR3_BITWORD FOLLOW_tspoid_in_adsia6829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_tspoid_in_adsia6829	= { FOLLOW_tspoid_in_adsia6829_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalName_in_adsia6831  */
static	ANTLR3_BITWORD FOLLOW_generalName_in_adsia6831_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalName_in_adsia6831	= { FOLLOW_generalName_in_adsia6831_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_adsia6836  */
static	ANTLR3_BITWORD FOLLOW_oid_in_adsia6836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_adsia6836	= { FOLLOW_oid_in_adsia6836_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalName_in_adsia6838  */
static	ANTLR3_BITWORD FOLLOW_generalName_in_adsia6838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalName_in_adsia6838	= { FOLLOW_generalName_in_adsia6838_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dependentExtension6868  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dependentExtension6868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dependentExtension6868	= { FOLLOW_sequenceTag_in_dependentExtension6868_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_policyMappings_in_dependentExtension6871  */
static	ANTLR3_BITWORD FOLLOW_policyMappings_in_dependentExtension6871_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_policyMappings_in_dependentExtension6871	= { FOLLOW_policyMappings_in_dependentExtension6871_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameConstraints_in_dependentExtension6875  */
static	ANTLR3_BITWORD FOLLOW_nameConstraints_in_dependentExtension6875_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_nameConstraints_in_dependentExtension6875	= { FOLLOW_nameConstraints_in_dependentExtension6875_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_policyConstraints_in_dependentExtension6879  */
static	ANTLR3_BITWORD FOLLOW_policyConstraints_in_dependentExtension6879_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_policyConstraints_in_dependentExtension6879	= { FOLLOW_policyConstraints_in_dependentExtension6879_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_inhibitAnyPolicy_in_dependentExtension6883  */
static	ANTLR3_BITWORD FOLLOW_inhibitAnyPolicy_in_dependentExtension6883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_inhibitAnyPolicy_in_dependentExtension6883	= { FOLLOW_inhibitAnyPolicy_in_dependentExtension6883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_inhibitanyoid_in_inhibitAnyPolicy6901  */
static	ANTLR3_BITWORD FOLLOW_inhibitanyoid_in_inhibitAnyPolicy6901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_inhibitanyoid_in_inhibitAnyPolicy6901	= { FOLLOW_inhibitanyoid_in_inhibitAnyPolicy6901_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_inhibitAnyPolicy6903  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_inhibitAnyPolicy6903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_inhibitAnyPolicy6903	= { FOLLOW_truevalue_in_inhibitAnyPolicy6903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_inhibitAnyPolicy6905  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_inhibitAnyPolicy6905_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_inhibitAnyPolicy6905	= { FOLLOW_constructedOctetString_in_inhibitAnyPolicy6905_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_inhibitAnyPolicy6907  */
static	ANTLR3_BITWORD FOLLOW_integer_in_inhibitAnyPolicy6907_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_inhibitAnyPolicy6907	= { FOLLOW_integer_in_inhibitAnyPolicy6907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_polconstraintsoid_in_policyConstraints6929  */
static	ANTLR3_BITWORD FOLLOW_polconstraintsoid_in_policyConstraints6929_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_polconstraintsoid_in_policyConstraints6929	= { FOLLOW_polconstraintsoid_in_policyConstraints6929_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_policyConstraints6931  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_policyConstraints6931_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_policyConstraints6931	= { FOLLOW_truevalue_in_policyConstraints6931_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_policyConstraints6933  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_policyConstraints6933_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_policyConstraints6933	= { FOLLOW_constructedOctetString_in_policyConstraints6933_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_policyConstraints6935  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_policyConstraints6935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF80C0) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_policyConstraints6935	= { FOLLOW_sequenceTag_in_policyConstraints6935_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag0_in_policyConstraints6939  */
static	ANTLR3_BITWORD FOLLOW_tag0_in_policyConstraints6939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_tag0_in_policyConstraints6939	= { FOLLOW_tag0_in_policyConstraints6939_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_policyConstraints6945  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_policyConstraints6945_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_policyConstraints6945	= { FOLLOW_tag1_in_policyConstraints6945_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_policyConstraints6954  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_policyConstraints6954_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_policyConstraints6954	= { FOLLOW_tag1_in_policyConstraints6954_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nameoid_in_nameConstraints6983  */
static	ANTLR3_BITWORD FOLLOW_nameoid_in_nameConstraints6983_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_nameoid_in_nameConstraints6983	= { FOLLOW_nameoid_in_nameConstraints6983_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_nameConstraints6985  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_nameConstraints6985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_nameConstraints6985	= { FOLLOW_truevalue_in_nameConstraints6985_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_nameConstraints6987  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_nameConstraints6987_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_nameConstraints6987	= { FOLLOW_constructedOctetString_in_nameConstraints6987_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_nameConstraints6989  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_nameConstraints6989_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000300000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_nameConstraints6989	= { FOLLOW_sequenceTag_in_nameConstraints6989_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_nameConstraints6994  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_nameConstraints6994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_nameConstraints6994	= { FOLLOW_constructedTag0_in_nameConstraints6994_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalSubtrees_in_nameConstraints6998  */
static	ANTLR3_BITWORD FOLLOW_generalSubtrees_in_nameConstraints6998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalSubtrees_in_nameConstraints6998	= { FOLLOW_generalSubtrees_in_nameConstraints6998_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_nameConstraints7002  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_nameConstraints7002_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_nameConstraints7002	= { FOLLOW_constructedTag1_in_nameConstraints7002_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalSubtrees_in_nameConstraints7006  */
static	ANTLR3_BITWORD FOLLOW_generalSubtrees_in_nameConstraints7006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalSubtrees_in_nameConstraints7006	= { FOLLOW_generalSubtrees_in_nameConstraints7006_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_nameConstraints7014  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_nameConstraints7014_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_nameConstraints7014	= { FOLLOW_constructedTag1_in_nameConstraints7014_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalSubtrees_in_nameConstraints7018  */
static	ANTLR3_BITWORD FOLLOW_generalSubtrees_in_nameConstraints7018_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalSubtrees_in_nameConstraints7018	= { FOLLOW_generalSubtrees_in_nameConstraints7018_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subtree_in_generalSubtrees7048  */
static	ANTLR3_BITWORD FOLLOW_subtree_in_generalSubtrees7048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subtree_in_generalSubtrees7048	= { FOLLOW_subtree_in_generalSubtrees7048_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_subtree7073  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_subtree7073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_subtree7073	= { FOLLOW_sequenceTag_in_subtree7073_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalName_in_subtree7075  */
static	ANTLR3_BITWORD FOLLOW_generalName_in_subtree7075_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF80C0) };
static  ANTLR3_BITSET_LIST FOLLOW_generalName_in_subtree7075	= { FOLLOW_generalName_in_subtree7075_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag0_in_subtree7079  */
static	ANTLR3_BITWORD FOLLOW_tag0_in_subtree7079_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_tag0_in_subtree7079	= { FOLLOW_tag0_in_subtree7079_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_subtree7085  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_subtree7085_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_subtree7085	= { FOLLOW_tag1_in_subtree7085_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_polmapoid_in_policyMappings7110  */
static	ANTLR3_BITWORD FOLLOW_polmapoid_in_policyMappings7110_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_polmapoid_in_policyMappings7110	= { FOLLOW_polmapoid_in_policyMappings7110_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_policyMappings7115  */
static	ANTLR3_BITWORD FOLLOW_critical_in_policyMappings7115_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_policyMappings7115	= { FOLLOW_critical_in_policyMappings7115_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_policyMappings7123  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_policyMappings7123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_policyMappings7123	= { FOLLOW_constructedOctetString_in_policyMappings7123_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_policyMappings7125  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_policyMappings7125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_policyMappings7125	= { FOLLOW_sequenceTag_in_policyMappings7125_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_mappings_in_policyMappings7127  */
static	ANTLR3_BITWORD FOLLOW_mappings_in_policyMappings7127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_mappings_in_policyMappings7127	= { FOLLOW_mappings_in_policyMappings7127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_mappings7155  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_mappings7155_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_mappings7155	= { FOLLOW_sequenceTag_in_mappings7155_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_mappings7159  */
static	ANTLR3_BITWORD FOLLOW_oid_in_mappings7159_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_mappings7159	= { FOLLOW_oid_in_mappings7159_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_mappings7163  */
static	ANTLR3_BITWORD FOLLOW_oid_in_mappings7163_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_mappings7163	= { FOLLOW_oid_in_mappings7163_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCA7186  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCA7186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCA7186	= { FOLLOW_sequenceTag_in_basicConstraintsCA7186_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_basicConstraintsCA7188  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_basicConstraintsCA7188_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_basicConstraintsCA7188	= { FOLLOW_bcoid_in_basicConstraintsCA7188_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCA7195  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCA7195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCA7195	= { FOLLOW_truevalue_in_basicConstraintsCA7195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_basicConstraintsCA7197  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_basicConstraintsCA7197_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_basicConstraintsCA7197	= { FOLLOW_constructedOctetString_in_basicConstraintsCA7197_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCA7199  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCA7199_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCA7199	= { FOLLOW_sequenceTag_in_basicConstraintsCA7199_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCA7201  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCA7201_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCA7201	= { FOLLOW_truevalue_in_basicConstraintsCA7201_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBC_in_basicConstraintsCA7207  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBC_in_basicConstraintsCA7207_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBC_in_basicConstraintsCA7207	= { FOLLOW_extensionsNotBC_in_basicConstraintsCA7207_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_basicConstraintsCA7210  */
static	ANTLR3_BITWORD FOLLOW_integer_in_basicConstraintsCA7210_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_basicConstraintsCA7210	= { FOLLOW_integer_in_basicConstraintsCA7210_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignAndSki_in_basicConstraintsCA7214  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignAndSki_in_basicConstraintsCA7214_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignAndSki_in_basicConstraintsCA7214	= { FOLLOW_extensionsCertSignAndSki_in_basicConstraintsCA7214_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_basicConstraintsCA7220  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_basicConstraintsCA7220_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_basicConstraintsCA7220	= { FOLLOW_falsevalue_in_basicConstraintsCA7220_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_basicConstraintsCA7223  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_basicConstraintsCA7223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_basicConstraintsCA7223	= { FOLLOW_constructedOctetString_in_basicConstraintsCA7223_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCA7225  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCA7225_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCA7225	= { FOLLOW_sequenceTag_in_basicConstraintsCA7225_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCA7227  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCA7227_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCA7227	= { FOLLOW_truevalue_in_basicConstraintsCA7227_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignAndSki_in_basicConstraintsCA7231  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignAndSki_in_basicConstraintsCA7231_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignAndSki_in_basicConstraintsCA7231	= { FOLLOW_extensionsNotCertSignAndSki_in_basicConstraintsCA7231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCANoSki7253  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCANoSki7253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCANoSki7253	= { FOLLOW_sequenceTag_in_basicConstraintsCANoSki7253_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_basicConstraintsCANoSki7255  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_basicConstraintsCANoSki7255_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_basicConstraintsCANoSki7255	= { FOLLOW_bcoid_in_basicConstraintsCANoSki7255_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCANoSki7262  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCANoSki7262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCANoSki7262	= { FOLLOW_truevalue_in_basicConstraintsCANoSki7262_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7264  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7264	= { FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7264_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCANoSki7266  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCANoSki7266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCANoSki7266	= { FOLLOW_sequenceTag_in_basicConstraintsCANoSki7266_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCANoSki7268  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCANoSki7268_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCANoSki7268	= { FOLLOW_truevalue_in_basicConstraintsCANoSki7268_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSki_in_basicConstraintsCANoSki7274  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSki_in_basicConstraintsCANoSki7274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSki_in_basicConstraintsCANoSki7274	= { FOLLOW_extensionsNotBCNotSki_in_basicConstraintsCANoSki7274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_basicConstraintsCANoSki7278  */
static	ANTLR3_BITWORD FOLLOW_integer_in_basicConstraintsCANoSki7278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_basicConstraintsCANoSki7278	= { FOLLOW_integer_in_basicConstraintsCANoSki7278_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSign_in_basicConstraintsCANoSki7282  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSign_in_basicConstraintsCANoSki7282_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSign_in_basicConstraintsCANoSki7282	= { FOLLOW_extensionsCertSign_in_basicConstraintsCANoSki7282_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_basicConstraintsCANoSki7288  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_basicConstraintsCANoSki7288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_basicConstraintsCANoSki7288	= { FOLLOW_falsevalue_in_basicConstraintsCANoSki7288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7291  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7291	= { FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7291_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCANoSki7293  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCANoSki7293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCANoSki7293	= { FOLLOW_sequenceTag_in_basicConstraintsCANoSki7293_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCANoSki7295  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCANoSki7295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCANoSki7295	= { FOLLOW_truevalue_in_basicConstraintsCANoSki7295_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSign_in_basicConstraintsCANoSki7299  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSign_in_basicConstraintsCANoSki7299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSign_in_basicConstraintsCANoSki7299	= { FOLLOW_extensionsNotCertSign_in_basicConstraintsCANoSki7299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7323  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7323	= { FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7323_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_basicConstraintsCANoSkiSubAlt7325  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_basicConstraintsCANoSkiSubAlt7325_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_basicConstraintsCANoSkiSubAlt7325	= { FOLLOW_bcoid_in_basicConstraintsCANoSkiSubAlt7325_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7331  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7331_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7331	= { FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7331_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7333  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7333_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7333	= { FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7333_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7335  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7335	= { FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7335_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7337  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7337_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7337	= { FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7337_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSkiSubAlt_in_basicConstraintsCANoSkiSubAlt7343  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSkiSubAlt_in_basicConstraintsCANoSkiSubAlt7343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSkiSubAlt_in_basicConstraintsCANoSkiSubAlt7343	= { FOLLOW_extensionsNotBCNotSkiSubAlt_in_basicConstraintsCANoSkiSubAlt7343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_basicConstraintsCANoSkiSubAlt7346  */
static	ANTLR3_BITWORD FOLLOW_integer_in_basicConstraintsCANoSkiSubAlt7346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_basicConstraintsCANoSkiSubAlt7346	= { FOLLOW_integer_in_basicConstraintsCANoSkiSubAlt7346_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7350  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7350_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7350	= { FOLLOW_extensionsCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7350_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_basicConstraintsCANoSkiSubAlt7356  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_basicConstraintsCANoSkiSubAlt7356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_basicConstraintsCANoSkiSubAlt7356	= { FOLLOW_falsevalue_in_basicConstraintsCANoSkiSubAlt7356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7359  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7359	= { FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7359_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7361  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7361_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7361	= { FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7361_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7363  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7363_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7363	= { FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7363_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7367  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7367_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7367	= { FOLLOW_extensionsNotCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7367_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7389  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7389	= { FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7389_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_basicConstraintsCASubAlt7391  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_basicConstraintsCASubAlt7391_bits[]	= { ANTLR3_UINT64_LIT(0x0000020000080000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_basicConstraintsCASubAlt7391	= { FOLLOW_bcoid_in_basicConstraintsCASubAlt7391_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCASubAlt7398  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCASubAlt7398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCASubAlt7398	= { FOLLOW_truevalue_in_basicConstraintsCASubAlt7398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7400  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7400_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7400	= { FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7400_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7402  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7402_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7402	= { FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7402_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCASubAlt7404  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCASubAlt7404_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCASubAlt7404	= { FOLLOW_truevalue_in_basicConstraintsCASubAlt7404_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCSubAlt_in_basicConstraintsCASubAlt7410  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCSubAlt_in_basicConstraintsCASubAlt7410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCSubAlt_in_basicConstraintsCASubAlt7410	= { FOLLOW_extensionsNotBCSubAlt_in_basicConstraintsCASubAlt7410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_basicConstraintsCASubAlt7413  */
static	ANTLR3_BITWORD FOLLOW_integer_in_basicConstraintsCASubAlt7413_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_basicConstraintsCASubAlt7413	= { FOLLOW_integer_in_basicConstraintsCASubAlt7413_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7418  */
static	ANTLR3_BITWORD FOLLOW_extensionsCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7418	= { FOLLOW_extensionsCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7418_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_basicConstraintsCASubAlt7424  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_basicConstraintsCASubAlt7424_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_basicConstraintsCASubAlt7424	= { FOLLOW_falsevalue_in_basicConstraintsCASubAlt7424_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7427  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7427	= { FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7427_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7429  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7429	= { FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7429_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_basicConstraintsCASubAlt7431  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_basicConstraintsCASubAlt7431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_basicConstraintsCASubAlt7431	= { FOLLOW_truevalue_in_basicConstraintsCASubAlt7431_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7435  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7435_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7435	= { FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCAandSkiSubAlt7456  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCAandSkiSubAlt7456_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCAandSkiSubAlt7456	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCAandSkiSubAlt7456_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7461  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7461_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7461	= { FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7461_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_extensionsMustBeCAandSkiSubAlt7463  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_extensionsMustBeCAandSkiSubAlt7463_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_extensionsMustBeCAandSkiSubAlt7463	= { FOLLOW_bcoid_in_extensionsMustBeCAandSkiSubAlt7463_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7465  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7465_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7465	= { FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7465_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsMustBeCAandSkiSubAlt7471  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsMustBeCAandSkiSubAlt7471_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsMustBeCAandSkiSubAlt7471	= { FOLLOW_constructedOctetString_in_extensionsMustBeCAandSkiSubAlt7471_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7473  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7473	= { FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7473_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7475  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7475_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7475	= { FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7475_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionsMustBeCAandSkiSubAlt7480  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionsMustBeCAandSkiSubAlt7480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionsMustBeCAandSkiSubAlt7480	= { FOLLOW_integer_in_extensionsMustBeCAandSkiSubAlt7480_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCAandSkiSubAlt7485  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCAandSkiSubAlt7485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCAandSkiSubAlt7485	= { FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCAandSkiSubAlt7485_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsMustBeCAandSkiSubAlt7490  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsMustBeCAandSkiSubAlt7490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsMustBeCAandSkiSubAlt7490	= { FOLLOW_subAltNameCritical_in_extensionsMustBeCAandSkiSubAlt7490_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCAandSkiSubAlt7492  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCAandSkiSubAlt7492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCAandSkiSubAlt7492	= { FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCAandSkiSubAlt7492_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsMustBeCAandSkiSubAlt7497  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsMustBeCAandSkiSubAlt7497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsMustBeCAandSkiSubAlt7497	= { FOLLOW_subjectKeyId_in_extensionsMustBeCAandSkiSubAlt7497_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCAandSkiSubAlt7499  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCAandSkiSubAlt7499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCAandSkiSubAlt7499	= { FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCAandSkiSubAlt7499_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7523  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7523_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7523	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7523_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7528  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7528	= { FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7528_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_extensionsMustBeCAandSki7532  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_extensionsMustBeCAandSki7532_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_extensionsMustBeCAandSki7532	= { FOLLOW_bcoid_in_extensionsMustBeCAandSki7532_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCAandSki7534  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCAandSki7534_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCAandSki7534	= { FOLLOW_truevalue_in_extensionsMustBeCAandSki7534_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7540  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7540	= { FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7540_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7542  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7542_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7542	= { FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7542_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCAandSki7544  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCAandSki7544_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCAandSki7544	= { FOLLOW_truevalue_in_extensionsMustBeCAandSki7544_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionsMustBeCAandSki7551  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionsMustBeCAandSki7551_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionsMustBeCAandSki7551	= { FOLLOW_integer_in_extensionsMustBeCAandSki7551_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCAandSki7556  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCAandSki7556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCAandSki7556	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCAandSki7556_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsMustBeCAandSki7561  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsMustBeCAandSki7561_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsMustBeCAandSki7561	= { FOLLOW_subjectKeyId_in_extensionsMustBeCAandSki7561_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7564  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7564	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7564_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7568  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7568_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7568	= { FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7568_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_extensionsMustBeCAandSki7572  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_extensionsMustBeCAandSki7572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_extensionsMustBeCAandSki7572	= { FOLLOW_bcoid_in_extensionsMustBeCAandSki7572_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCAandSki7574  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCAandSki7574_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCAandSki7574	= { FOLLOW_truevalue_in_extensionsMustBeCAandSki7574_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7579  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7579_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7579	= { FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7579_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7581  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7581_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7581	= { FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7581_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCAandSki7583  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCAandSki7583_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCAandSki7583	= { FOLLOW_truevalue_in_extensionsMustBeCAandSki7583_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionsMustBeCAandSki7590  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionsMustBeCAandSki7590_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionsMustBeCAandSki7590	= { FOLLOW_integer_in_extensionsMustBeCAandSki7590_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7596  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7596	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCASubAlt7619  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCASubAlt7619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCASubAlt7619	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCASubAlt7619_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7624  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7624_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7624	= { FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7624_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_extensionsMustBeCASubAlt7628  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_extensionsMustBeCASubAlt7628_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_extensionsMustBeCASubAlt7628	= { FOLLOW_bcoid_in_extensionsMustBeCASubAlt7628_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCASubAlt7630  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCASubAlt7630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCASubAlt7630	= { FOLLOW_truevalue_in_extensionsMustBeCASubAlt7630_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7635  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7635_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7635	= { FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7635_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7637  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7637_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7637	= { FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7637_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCASubAlt7639  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCASubAlt7639_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCASubAlt7639	= { FOLLOW_truevalue_in_extensionsMustBeCASubAlt7639_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionsMustBeCASubAlt7646  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionsMustBeCASubAlt7646_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionsMustBeCASubAlt7646	= { FOLLOW_integer_in_extensionsMustBeCASubAlt7646_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCASubAlt7651  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCASubAlt7651_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCASubAlt7651	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCASubAlt7651_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsMustBeCASubAlt7656  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsMustBeCASubAlt7656_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsMustBeCASubAlt7656	= { FOLLOW_subAltNameCritical_in_extensionsMustBeCASubAlt7656_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7659  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7659	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7659_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7663  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7663_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7663	= { FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7663_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_extensionsMustBeCASubAlt7667  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_extensionsMustBeCASubAlt7667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_extensionsMustBeCASubAlt7667	= { FOLLOW_bcoid_in_extensionsMustBeCASubAlt7667_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCASubAlt7669  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCASubAlt7669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCASubAlt7669	= { FOLLOW_truevalue_in_extensionsMustBeCASubAlt7669_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7674  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7674_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7674	= { FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7674_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7676  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7676_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7676	= { FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7676_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCASubAlt7678  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCASubAlt7678_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCASubAlt7678	= { FOLLOW_truevalue_in_extensionsMustBeCASubAlt7678_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionsMustBeCASubAlt7685  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionsMustBeCASubAlt7685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionsMustBeCASubAlt7685	= { FOLLOW_integer_in_extensionsMustBeCASubAlt7685_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7692  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7692	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7692_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7714  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7714_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7714	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7714_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCA7718  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCA7718_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCA7718	= { FOLLOW_sequenceTag_in_extensionsMustBeCA7718_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bcoid_in_extensionsMustBeCA7720  */
static	ANTLR3_BITWORD FOLLOW_bcoid_in_extensionsMustBeCA7720_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_bcoid_in_extensionsMustBeCA7720	= { FOLLOW_bcoid_in_extensionsMustBeCA7720_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCA7722  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCA7722_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCA7722	= { FOLLOW_truevalue_in_extensionsMustBeCA7722_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_extensionsMustBeCA7727  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_extensionsMustBeCA7727_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_extensionsMustBeCA7727	= { FOLLOW_constructedOctetString_in_extensionsMustBeCA7727_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionsMustBeCA7729  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionsMustBeCA7729_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionsMustBeCA7729	= { FOLLOW_sequenceTag_in_extensionsMustBeCA7729_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCA7731  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCA7731_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCA7731	= { FOLLOW_truevalue_in_extensionsMustBeCA7731_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionsMustBeCA7736  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionsMustBeCA7736_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionsMustBeCA7736	= { FOLLOW_integer_in_extensionsMustBeCA7736_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7742  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7742_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7742	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7742_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7770  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7770_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7770	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7770_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7775  */
static	ANTLR3_BITWORD FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7775_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7775	= { FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7775_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7777  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7777_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7777	= { FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7777_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7781  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7781_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7781	= { FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7781_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7786  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7786_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7786	= { FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7786_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7788  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7788_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7788	= { FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7788_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7793  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7793	= { FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7793_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7795  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7795_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7795	= { FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7795_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7818  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7818_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7818	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7818_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7823  */
static	ANTLR3_BITWORD FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7823	= { FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7823_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7825  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7825_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7825	= { FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7825_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCaAndSkiNoPathLen7829  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCaAndSkiNoPathLen7829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCaAndSkiNoPathLen7829	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCaAndSkiNoPathLen7829_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLen7834  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLen7834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLen7834	= { FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLen7834_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7837  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7837_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7837	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7837_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7841  */
static	ANTLR3_BITWORD FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7841_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7841	= { FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7841_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7843  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7843_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7843	= { FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7843_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7848  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7848	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaSubAlt7874  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaSubAlt7874_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaSubAlt7874	= { FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaSubAlt7874_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7876  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7876	= { FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7876_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsMustBeCaSubAlt7881  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsMustBeCaSubAlt7881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsMustBeCaSubAlt7881	= { FOLLOW_dependentExtension_in_extensionsMustBeCaSubAlt7881_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7883  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7883	= { FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsMustBeCaSubAlt7888  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsMustBeCaSubAlt7888_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsMustBeCaSubAlt7888	= { FOLLOW_keyUsageCommon_in_extensionsMustBeCaSubAlt7888_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsMustBeCaSubAlt7891  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsMustBeCaSubAlt7891_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsMustBeCaSubAlt7891	= { FOLLOW_bitstring_in_extensionsMustBeCaSubAlt7891_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaSubAlt7895  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaSubAlt7895_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaSubAlt7895	= { FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaSubAlt7895_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsMustBeCaSubAlt7899  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsMustBeCaSubAlt7899_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsMustBeCaSubAlt7899	= { FOLLOW_bitstringCertSign_in_extensionsMustBeCaSubAlt7899_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCaSubAlt7901  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCaSubAlt7901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCaSubAlt7901	= { FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCaSubAlt7901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraintsCANoSkiSubAlt_in_extensionsMustBeCaSubAlt7907  */
static	ANTLR3_BITWORD FOLLOW_basicConstraintsCANoSkiSubAlt_in_extensionsMustBeCaSubAlt7907_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraintsCANoSkiSubAlt_in_extensionsMustBeCaSubAlt7907	= { FOLLOW_basicConstraintsCANoSkiSubAlt_in_extensionsMustBeCaSubAlt7907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsMustBeCaSubAlt7912  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsMustBeCaSubAlt7912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsMustBeCaSubAlt7912	= { FOLLOW_subAltNameCritical_in_extensionsMustBeCaSubAlt7912_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaSubAlt7914  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaSubAlt7914_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaSubAlt7914	= { FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaSubAlt7914_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsMustBeCa7937  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsMustBeCa7937_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsMustBeCa7937	= { FOLLOW_extension_in_extensionsMustBeCa7937_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7939  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7939	= { FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsMustBeCa7944  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsMustBeCa7944_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsMustBeCa7944	= { FOLLOW_dependentExtension_in_extensionsMustBeCa7944_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7946  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7946_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7946	= { FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7946_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsMustBeCa7951  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsMustBeCa7951_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsMustBeCa7951	= { FOLLOW_keyUsageCommon_in_extensionsMustBeCa7951_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsMustBeCa7954  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsMustBeCa7954_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsMustBeCa7954	= { FOLLOW_bitstring_in_extensionsMustBeCa7954_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCa7958  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCa7958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCa7958	= { FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCa7958_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsMustBeCa7962  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsMustBeCa7962_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsMustBeCa7962	= { FOLLOW_bitstringCertSign_in_extensionsMustBeCa7962_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCA_in_extensionsMustBeCa7964  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCA_in_extensionsMustBeCa7964_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCA_in_extensionsMustBeCa7964	= { FOLLOW_extensionsMustBeCA_in_extensionsMustBeCa7964_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraintsCANoSki_in_extensionsMustBeCa7970  */
static	ANTLR3_BITWORD FOLLOW_basicConstraintsCANoSki_in_extensionsMustBeCa7970_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraintsCANoSki_in_extensionsMustBeCa7970	= { FOLLOW_basicConstraintsCANoSki_in_extensionsMustBeCa7970_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaAndSkiSubAlt7991  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaAndSkiSubAlt7991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaAndSkiSubAlt7991	= { FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaAndSkiSubAlt7991_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt7993  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt7993_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt7993	= { FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt7993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsMustBeCaAndSkiSubAlt7998  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsMustBeCaAndSkiSubAlt7998_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsMustBeCaAndSkiSubAlt7998	= { FOLLOW_dependentExtension_in_extensionsMustBeCaAndSkiSubAlt7998_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8000  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8000_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8000	= { FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8000_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSkiSubAlt8005  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSkiSubAlt8005_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSkiSubAlt8005	= { FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSkiSubAlt8005_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsMustBeCaAndSkiSubAlt8008  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsMustBeCaAndSkiSubAlt8008_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsMustBeCaAndSkiSubAlt8008	= { FOLLOW_bitstring_in_extensionsMustBeCaAndSkiSubAlt8008_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsMustBeCaAndSkiSubAlt8012  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsMustBeCaAndSkiSubAlt8012_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsMustBeCaAndSkiSubAlt8012	= { FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsMustBeCaAndSkiSubAlt8012_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSkiSubAlt8016  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSkiSubAlt8016_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSkiSubAlt8016	= { FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSkiSubAlt8016_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8018  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8018_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8018	= { FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8018_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraintsCASubAlt_in_extensionsMustBeCaAndSkiSubAlt8024  */
static	ANTLR3_BITWORD FOLLOW_basicConstraintsCASubAlt_in_extensionsMustBeCaAndSkiSubAlt8024_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraintsCASubAlt_in_extensionsMustBeCaAndSkiSubAlt8024	= { FOLLOW_basicConstraintsCASubAlt_in_extensionsMustBeCaAndSkiSubAlt8024_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiSubAlt8029  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiSubAlt8029_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiSubAlt8029	= { FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiSubAlt8029_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaAndSkiSubAlt8031  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaAndSkiSubAlt8031_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaAndSkiSubAlt8031	= { FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaAndSkiSubAlt8031_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiSubAlt8036  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiSubAlt8036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiSubAlt8036	= { FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiSubAlt8036_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSkiSubAlt8038  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSkiSubAlt8038_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSkiSubAlt8038	= { FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSkiSubAlt8038_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsMustBeCaAndSki8061  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsMustBeCaAndSki8061_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsMustBeCaAndSki8061	= { FOLLOW_extension_in_extensionsMustBeCaAndSki8061_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8063  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8063_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8063	= { FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8063_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsMustBeCaAndSki8068  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsMustBeCaAndSki8068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsMustBeCaAndSki8068	= { FOLLOW_dependentExtension_in_extensionsMustBeCaAndSki8068_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8070  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8070_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8070	= { FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8070_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSki8075  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSki8075_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSki8075	= { FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSki8075_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsMustBeCaAndSki8078  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsMustBeCaAndSki8078_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsMustBeCaAndSki8078	= { FOLLOW_bitstring_in_extensionsMustBeCaAndSki8078_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSki8082  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSki8082_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSki8082	= { FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSki8082_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSki8086  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSki8086_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSki8086	= { FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSki8086_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCaAndSki8088  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCaAndSki8088_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCaAndSki8088	= { FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCaAndSki8088_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraintsCA_in_extensionsMustBeCaAndSki8094  */
static	ANTLR3_BITWORD FOLLOW_basicConstraintsCA_in_extensionsMustBeCaAndSki8094_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraintsCA_in_extensionsMustBeCaAndSki8094	= { FOLLOW_basicConstraintsCA_in_extensionsMustBeCaAndSki8094_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSki8099  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSki8099_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSki8099	= { FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSki8099_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaAndSki8101  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaAndSki8101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaAndSki8101	= { FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaAndSki8101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8123  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8123	= { FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8123_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8125  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8125	= { FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLenSubAlt8130  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLenSubAlt8130_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLenSubAlt8130	= { FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLenSubAlt8130_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8132  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8132	= { FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLenSubAlt8137  */
static	ANTLR3_BITWORD FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLenSubAlt8137_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLenSubAlt8137	= { FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLenSubAlt8137_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCaNoPathLenSubAlt8139  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCaNoPathLenSubAlt8139_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCaNoPathLenSubAlt8139	= { FOLLOW_truevalue_in_extensionsMustBeCaNoPathLenSubAlt8139_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8143  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8143	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsMustBeCaNoPathLenSubAlt8148  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsMustBeCaNoPathLenSubAlt8148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsMustBeCaNoPathLenSubAlt8148	= { FOLLOW_subAltNameCritical_in_extensionsMustBeCaNoPathLenSubAlt8148_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLenSubAlt8150  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLenSubAlt8150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLenSubAlt8150	= { FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLenSubAlt8150_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsMustBeCaNoPathLen8174  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsMustBeCaNoPathLen8174_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsMustBeCaNoPathLen8174	= { FOLLOW_extension_in_extensionsMustBeCaNoPathLen8174_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8176  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8176	= { FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLen8181  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLen8181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLen8181	= { FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLen8181_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8183  */
static	ANTLR3_BITWORD FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8183	= { FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8183_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLen8188  */
static	ANTLR3_BITWORD FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLen8188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLen8188	= { FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLen8188_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_extensionsMustBeCaNoPathLen8190  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_extensionsMustBeCaNoPathLen8190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_extensionsMustBeCaNoPathLen8190	= { FOLLOW_truevalue_in_extensionsMustBeCaNoPathLen8190_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaNoPathLen8195  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaNoPathLen8195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaNoPathLen8195	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaNoPathLen8195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8222  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8222	= { FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8222_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8224  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8224	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8224_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8229  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8229	= { FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8229_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8231  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8231_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8231	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8231_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8237  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8237	= { FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8237_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8239  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8239_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8239	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8239_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsNotBCNotKeyUsageNotSki8262  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsNotBCNotKeyUsageNotSki8262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsNotBCNotKeyUsageNotSki8262	= { FOLLOW_extension_in_extensionsNotBCNotKeyUsageNotSki8262_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8268  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8268_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8268	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSki8274  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSki8274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSki8274	= { FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSki8274_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8280  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8280_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8280	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8280_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8305  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8305_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8305	= { FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8305_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8311  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8311_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8311	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8311_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8317  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8317_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8317	= { FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8317_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8323  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8323_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8323	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8323_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8347  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8347	= { FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8347_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8349  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8349	= { FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageSubAlt8354  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageSubAlt8354_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageSubAlt8354	= { FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageSubAlt8354_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8356  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8356	= { FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsageSubAlt8362  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsageSubAlt8362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsageSubAlt8362	= { FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsageSubAlt8362_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8364  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8364	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageSubAlt8369  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageSubAlt8369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageSubAlt8369	= { FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageSubAlt8369_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsageSubAlt8371  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsageSubAlt8371_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsageSubAlt8371	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsageSubAlt8371_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsNotBCNotKeyUsage8394  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsNotBCNotKeyUsage8394_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsNotBCNotKeyUsage8394	= { FOLLOW_extension_in_extensionsNotBCNotKeyUsage8394_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8396  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8396	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsage8401  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsage8401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsage8401	= { FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsage8401_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8403  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8403	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8403_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsage8409  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsage8409_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsage8409	= { FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsage8409_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsage8414  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsage8414_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsage8414	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsage8414_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNotBCSubAlt8438  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNotBCSubAlt8438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNotBCSubAlt8438	= { FOLLOW_extensionNoSubAlt_in_extensionsNotBCSubAlt8438_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8440  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8440	= { FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8440_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotBCSubAlt8445  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotBCSubAlt8445_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotBCSubAlt8445	= { FOLLOW_dependentExtension_in_extensionsNotBCSubAlt8445_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8447  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8447_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8447	= { FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8447_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNotBCSubAlt8452  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNotBCSubAlt8452_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNotBCSubAlt8452	= { FOLLOW_keyUsageCommon_in_extensionsNotBCSubAlt8452_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNotBCSubAlt8455  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNotBCSubAlt8455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNotBCSubAlt8455	= { FOLLOW_bitstring_in_extensionsNotBCSubAlt8455_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsNotBCSubAlt8460  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsNotBCSubAlt8460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsNotBCSubAlt8460	= { FOLLOW_bitstringCertSign_in_extensionsNotBCSubAlt8460_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCSubAlt8463  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCSubAlt8463_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCSubAlt8463	= { FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCSubAlt8463_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsNotBCSubAlt8468  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsNotBCSubAlt8468_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsNotBCSubAlt8468	= { FOLLOW_subjectKeyId_in_extensionsNotBCSubAlt8468_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCSubAlt8470  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCSubAlt8470_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCSubAlt8470	= { FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCSubAlt8470_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsNotBCSubAlt8475  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsNotBCSubAlt8475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsNotBCSubAlt8475	= { FOLLOW_subAltNameCritical_in_extensionsNotBCSubAlt8475_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBC_in_extensionsNotBCSubAlt8477  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBC_in_extensionsNotBCSubAlt8477_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBC_in_extensionsNotBCSubAlt8477	= { FOLLOW_extensionsNotBC_in_extensionsNotBCSubAlt8477_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsNotBC8500  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsNotBC8500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsNotBC8500	= { FOLLOW_extension_in_extensionsNotBC8500_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBC_in_extensionsNotBC8502  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBC_in_extensionsNotBC8502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBC_in_extensionsNotBC8502	= { FOLLOW_extensionsNotBC_in_extensionsNotBC8502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotBC8507  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotBC8507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotBC8507	= { FOLLOW_dependentExtension_in_extensionsNotBC8507_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBC_in_extensionsNotBC8509  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBC_in_extensionsNotBC8509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBC_in_extensionsNotBC8509	= { FOLLOW_extensionsNotBC_in_extensionsNotBC8509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNotBC8514  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNotBC8514_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNotBC8514	= { FOLLOW_keyUsageCommon_in_extensionsNotBC8514_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNotBC8517  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNotBC8517_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNotBC8517	= { FOLLOW_bitstring_in_extensionsNotBC8517_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsNotBC8522  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsNotBC8522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsNotBC8522	= { FOLLOW_bitstringCertSign_in_extensionsNotBC8522_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBC8525  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBC8525_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBC8525	= { FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBC8525_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subjectKeyId_in_extensionsNotBC8530  */
static	ANTLR3_BITWORD FOLLOW_subjectKeyId_in_extensionsNotBC8530_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subjectKeyId_in_extensionsNotBC8530	= { FOLLOW_subjectKeyId_in_extensionsNotBC8530_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSki_in_extensionsNotBC8535  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSki_in_extensionsNotBC8535_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSki_in_extensionsNotBC8535	= { FOLLOW_extensionsNotBCNotSki_in_extensionsNotBC8535_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotSkiSubAlt8558  */
static	ANTLR3_BITWORD FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotSkiSubAlt8558_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotSkiSubAlt8558	= { FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotSkiSubAlt8558_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8560  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8560	= { FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8560_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotBCNotSkiSubAlt8565  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotBCNotSkiSubAlt8565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotBCNotSkiSubAlt8565	= { FOLLOW_dependentExtension_in_extensionsNotBCNotSkiSubAlt8565_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8567  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8567	= { FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8567_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNotBCNotSkiSubAlt8572  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNotBCNotSkiSubAlt8572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNotBCNotSkiSubAlt8572	= { FOLLOW_keyUsageCommon_in_extensionsNotBCNotSkiSubAlt8572_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNotBCNotSkiSubAlt8575  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNotBCNotSkiSubAlt8575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNotBCNotSkiSubAlt8575	= { FOLLOW_bitstring_in_extensionsNotBCNotSkiSubAlt8575_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsNotBCNotSkiSubAlt8580  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsNotBCNotSkiSubAlt8580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsNotBCNotSkiSubAlt8580	= { FOLLOW_bitstringCertSign_in_extensionsNotBCNotSkiSubAlt8580_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8583  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8583	= { FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8583_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_subAltNameCritical_in_extensionsNotBCNotSkiSubAlt8588  */
static	ANTLR3_BITWORD FOLLOW_subAltNameCritical_in_extensionsNotBCNotSkiSubAlt8588_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_subAltNameCritical_in_extensionsNotBCNotSkiSubAlt8588	= { FOLLOW_subAltNameCritical_in_extensionsNotBCNotSkiSubAlt8588_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSkiSubAlt8593  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSkiSubAlt8593_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSkiSubAlt8593	= { FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSkiSubAlt8593_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extension_in_extensionsNotBCNotSki8615  */
static	ANTLR3_BITWORD FOLLOW_extension_in_extensionsNotBCNotSki8615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extension_in_extensionsNotBCNotSki8615	= { FOLLOW_extension_in_extensionsNotBCNotSki8615_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8621  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8621	= { FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8621_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dependentExtension_in_extensionsNotBCNotSki8627  */
static	ANTLR3_BITWORD FOLLOW_dependentExtension_in_extensionsNotBCNotSki8627_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dependentExtension_in_extensionsNotBCNotSki8627	= { FOLLOW_dependentExtension_in_extensionsNotBCNotSki8627_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8633  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8633	= { FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8633_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_keyUsageCommon_in_extensionsNotBCNotSki8639  */
static	ANTLR3_BITWORD FOLLOW_keyUsageCommon_in_extensionsNotBCNotSki8639_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001800) };
static  ANTLR3_BITSET_LIST FOLLOW_keyUsageCommon_in_extensionsNotBCNotSki8639	= { FOLLOW_keyUsageCommon_in_extensionsNotBCNotSki8639_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_extensionsNotBCNotSki8642  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_extensionsNotBCNotSki8642_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_extensionsNotBCNotSki8642	= { FOLLOW_bitstring_in_extensionsNotBCNotSki8642_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstringCertSign_in_extensionsNotBCNotSki8647  */
static	ANTLR3_BITWORD FOLLOW_bitstringCertSign_in_extensionsNotBCNotSki8647_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstringCertSign_in_extensionsNotBCNotSki8647	= { FOLLOW_bitstringCertSign_in_extensionsNotBCNotSki8647_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotSki8653  */
static	ANTLR3_BITWORD FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotSki8653_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotSki8653	= { FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotSki8653_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalName_in_generalNames8678  */
static	ANTLR3_BITWORD FOLLOW_generalName_in_generalNames8678_bits[]	= { ANTLR3_UINT64_LIT(0x0000000003900002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000007180) };
static  ANTLR3_BITSET_LIST FOLLOW_generalName_in_generalNames8678	= { FOLLOW_generalName_in_generalNames8678_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_generalName8700  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_generalName8700_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_generalName8700	= { FOLLOW_constructedTag0_in_generalName8700_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_othername_in_generalName8702  */
static	ANTLR3_BITWORD FOLLOW_othername_in_generalName8702_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_othername_in_generalName8702	= { FOLLOW_othername_in_generalName8702_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_generalName8709  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_generalName8709_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_generalName8709	= { FOLLOW_tag1_in_generalName8709_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag2_in_generalName8716  */
static	ANTLR3_BITWORD FOLLOW_tag2_in_generalName8716_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag2_in_generalName8716	= { FOLLOW_tag2_in_generalName8716_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_generalName8723  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_generalName8723_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_generalName8723	= { FOLLOW_constructedTag3_in_generalName8723_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_standardAttrs_in_generalName8730  */
static	ANTLR3_BITWORD FOLLOW_standardAttrs_in_generalName8730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000006) };
static  ANTLR3_BITSET_LIST FOLLOW_standardAttrs_in_generalName8730	= { FOLLOW_standardAttrs_in_generalName8730_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedAttrs_in_generalName8732  */
static	ANTLR3_BITWORD FOLLOW_definedAttrs_in_generalName8732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_definedAttrs_in_generalName8732	= { FOLLOW_definedAttrs_in_generalName8732_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAttrs_in_generalName8735  */
static	ANTLR3_BITWORD FOLLOW_extensionAttrs_in_generalName8735_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAttrs_in_generalName8735	= { FOLLOW_extensionAttrs_in_generalName8735_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag4_in_generalName8741  */
static	ANTLR3_BITWORD FOLLOW_constructedTag4_in_generalName8741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag4_in_generalName8741	= { FOLLOW_constructedTag4_in_generalName8741_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_notEmptyName_in_generalName8743  */
static	ANTLR3_BITWORD FOLLOW_notEmptyName_in_generalName8743_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_notEmptyName_in_generalName8743	= { FOLLOW_notEmptyName_in_generalName8743_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag5_in_generalName8750  */
static	ANTLR3_BITWORD FOLLOW_constructedTag5_in_generalName8750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF80C0) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag5_in_generalName8750	= { FOLLOW_constructedTag5_in_generalName8750_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_edipartyname_in_generalName8752  */
static	ANTLR3_BITWORD FOLLOW_edipartyname_in_generalName8752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_edipartyname_in_generalName8752	= { FOLLOW_edipartyname_in_generalName8752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag6_in_generalName8759  */
static	ANTLR3_BITWORD FOLLOW_tag6_in_generalName8759_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag6_in_generalName8759	= { FOLLOW_tag6_in_generalName8759_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag7_in_generalName8766  */
static	ANTLR3_BITWORD FOLLOW_tag7_in_generalName8766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag7_in_generalName8766	= { FOLLOW_tag7_in_generalName8766_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag8_in_generalName8773  */
static	ANTLR3_BITWORD FOLLOW_tag8_in_generalName8773_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag8_in_generalName8773	= { FOLLOW_tag8_in_generalName8773_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_othername8796  */
static	ANTLR3_BITWORD FOLLOW_oid_in_othername8796_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_othername8796	= { FOLLOW_oid_in_othername8796_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_othername8798  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_othername8798_bits[]	= { ANTLR3_UINT64_LIT(0x01F702001FF81C00), ANTLR3_UINT64_LIT(0x0000008300000001), ANTLR3_UINT64_LIT(0x00030EFFFFFFFFC6) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_othername8798	= { FOLLOW_constructedTag0_in_othername8798_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_any_in_othername8800  */
static	ANTLR3_BITWORD FOLLOW_any_in_othername8800_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_any_in_othername8800	= { FOLLOW_any_in_othername8800_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag0_in_edipartyname8828  */
static	ANTLR3_BITWORD FOLLOW_tag0_in_edipartyname8828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_tag0_in_edipartyname8828	= { FOLLOW_tag0_in_edipartyname8828_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_edipartyname8833  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_edipartyname8833_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_edipartyname8833	= { FOLLOW_tag1_in_edipartyname8833_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_standardAttrs8854  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_standardAttrs8854_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006400182), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF86C0) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_standardAttrs8854	= { FOLLOW_sequenceTag_in_standardAttrs8854_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_countryName_in_standardAttrs8857  */
static	ANTLR3_BITWORD FOLLOW_countryName_in_standardAttrs8857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006400102), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF86C0) };
static  ANTLR3_BITSET_LIST FOLLOW_countryName_in_standardAttrs8857	= { FOLLOW_countryName_in_standardAttrs8857_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_adName_in_standardAttrs8862  */
static	ANTLR3_BITWORD FOLLOW_adName_in_standardAttrs8862_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006400002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF86C0) };
static  ANTLR3_BITSET_LIST FOLLOW_adName_in_standardAttrs8862	= { FOLLOW_adName_in_standardAttrs8862_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag0_in_standardAttrs8873  */
static	ANTLR3_BITWORD FOLLOW_tag0_in_standardAttrs8873_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006400002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000680) };
static  ANTLR3_BITSET_LIST FOLLOW_tag0_in_standardAttrs8873	= { FOLLOW_tag0_in_standardAttrs8873_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_standardAttrs8888  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_standardAttrs8888_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006400002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000600) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_standardAttrs8888	= { FOLLOW_tag1_in_standardAttrs8888_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag2_in_standardAttrs8898  */
static	ANTLR3_BITWORD FOLLOW_constructedTag2_in_standardAttrs8898_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag2_in_standardAttrs8898	= { FOLLOW_constructedTag2_in_standardAttrs8898_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericString_in_standardAttrs8901  */
static	ANTLR3_BITWORD FOLLOW_numericString_in_standardAttrs8901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000600) };
static  ANTLR3_BITSET_LIST FOLLOW_numericString_in_standardAttrs8901	= { FOLLOW_numericString_in_standardAttrs8901_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_standardAttrs8909  */
static	ANTLR3_BITWORD FOLLOW_printString_in_standardAttrs8909_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000600) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_standardAttrs8909	= { FOLLOW_printString_in_standardAttrs8909_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag3_in_standardAttrs8924  */
static	ANTLR3_BITWORD FOLLOW_tag3_in_standardAttrs8924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_tag3_in_standardAttrs8924	= { FOLLOW_tag3_in_standardAttrs8924_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag4_in_standardAttrs8934  */
static	ANTLR3_BITWORD FOLLOW_tag4_in_standardAttrs8934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag4_in_standardAttrs8934	= { FOLLOW_tag4_in_standardAttrs8934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag5_in_standardAttrs8949  */
static	ANTLR3_BITWORD FOLLOW_constructedTag5_in_standardAttrs8949_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF8040) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag5_in_standardAttrs8949	= { FOLLOW_constructedTag5_in_standardAttrs8949_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag0_in_standardAttrs8954  */
static	ANTLR3_BITWORD FOLLOW_tag0_in_standardAttrs8954_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000380) };
static  ANTLR3_BITSET_LIST FOLLOW_tag0_in_standardAttrs8954	= { FOLLOW_tag0_in_standardAttrs8954_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_standardAttrs8969  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_standardAttrs8969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000300) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_standardAttrs8969	= { FOLLOW_tag1_in_standardAttrs8969_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag2_in_standardAttrs8984  */
static	ANTLR3_BITWORD FOLLOW_tag2_in_standardAttrs8984_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_tag2_in_standardAttrs8984	= { FOLLOW_tag2_in_standardAttrs8984_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag3_in_standardAttrs8996  */
static	ANTLR3_BITWORD FOLLOW_tag3_in_standardAttrs8996_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag3_in_standardAttrs8996	= { FOLLOW_tag3_in_standardAttrs8996_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag6_in_standardAttrs9008  */
static	ANTLR3_BITWORD FOLLOW_constructedTag6_in_standardAttrs9008_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag6_in_standardAttrs9008	= { FOLLOW_constructedTag6_in_standardAttrs9008_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_standardAttrs9015  */
static	ANTLR3_BITWORD FOLLOW_printString_in_standardAttrs9015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_standardAttrs9015	= { FOLLOW_printString_in_standardAttrs9015_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_appTag1_in_countryName9047  */
static	ANTLR3_BITWORD FOLLOW_appTag1_in_countryName9047_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_appTag1_in_countryName9047	= { FOLLOW_appTag1_in_countryName9047_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericString_in_countryName9050  */
static	ANTLR3_BITWORD FOLLOW_numericString_in_countryName9050_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numericString_in_countryName9050	= { FOLLOW_numericString_in_countryName9050_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_countryName9056  */
static	ANTLR3_BITWORD FOLLOW_printString_in_countryName9056_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_countryName9056	= { FOLLOW_printString_in_countryName9056_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_appTag2_in_adName9083  */
static	ANTLR3_BITWORD FOLLOW_appTag2_in_adName9083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_appTag2_in_adName9083	= { FOLLOW_appTag2_in_adName9083_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericString_in_adName9086  */
static	ANTLR3_BITWORD FOLLOW_numericString_in_adName9086_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numericString_in_adName9086	= { FOLLOW_numericString_in_adName9086_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_adName9092  */
static	ANTLR3_BITWORD FOLLOW_printString_in_adName9092_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_adName9092	= { FOLLOW_printString_in_adName9092_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_definedAttrs9117  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_definedAttrs9117_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_definedAttrs9117	= { FOLLOW_sequenceTag_in_definedAttrs9117_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_definedAttr_in_definedAttrs9122  */
static	ANTLR3_BITWORD FOLLOW_definedAttr_in_definedAttrs9122_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_definedAttr_in_definedAttrs9122	= { FOLLOW_definedAttr_in_definedAttrs9122_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_definedAttr9152  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_definedAttr9152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_definedAttr9152	= { FOLLOW_sequenceTag_in_definedAttr9152_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_definedAttr9156  */
static	ANTLR3_BITWORD FOLLOW_printString_in_definedAttr9156_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_definedAttr9156	= { FOLLOW_printString_in_definedAttr9156_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_definedAttr9160  */
static	ANTLR3_BITWORD FOLLOW_printString_in_definedAttr9160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_definedAttr9160	= { FOLLOW_printString_in_definedAttr9160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_extensionAttrs9179  */
static	ANTLR3_BITWORD FOLLOW_set_in_extensionAttrs9179_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_extensionAttrs9179	= { FOLLOW_set_in_extensionAttrs9179_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_extensionAttr_in_extensionAttrs9183  */
static	ANTLR3_BITWORD FOLLOW_extensionAttr_in_extensionAttrs9183_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_extensionAttr_in_extensionAttrs9183	= { FOLLOW_extensionAttr_in_extensionAttrs9183_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionAttr9215  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionAttr9215_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF8040) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionAttr9215	= { FOLLOW_sequenceTag_in_extensionAttr9215_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt1_in_extensionAttr9222  */
static	ANTLR3_BITWORD FOLLOW_tagInt1_in_extensionAttr9222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt1_in_extensionAttr9222	= { FOLLOW_tagInt1_in_extensionAttr9222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9224  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9224_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9224	= { FOLLOW_constructedTag1_in_extensionAttr9224_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_extensionAttr9228  */
static	ANTLR3_BITWORD FOLLOW_printString_in_extensionAttr9228_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_extensionAttr9228	= { FOLLOW_printString_in_extensionAttr9228_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt2_in_extensionAttr9234  */
static	ANTLR3_BITWORD FOLLOW_tagInt2_in_extensionAttr9234_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt2_in_extensionAttr9234	= { FOLLOW_tagInt2_in_extensionAttr9234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9236  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9236	= { FOLLOW_constructedTag1_in_extensionAttr9236_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_teletexString_in_extensionAttr9240  */
static	ANTLR3_BITWORD FOLLOW_teletexString_in_extensionAttr9240_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_teletexString_in_extensionAttr9240	= { FOLLOW_teletexString_in_extensionAttr9240_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt3_in_extensionAttr9245  */
static	ANTLR3_BITWORD FOLLOW_tagInt3_in_extensionAttr9245_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt3_in_extensionAttr9245	= { FOLLOW_tagInt3_in_extensionAttr9245_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9247  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9247_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9247	= { FOLLOW_constructedTag1_in_extensionAttr9247_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_teletexString_in_extensionAttr9251  */
static	ANTLR3_BITWORD FOLLOW_teletexString_in_extensionAttr9251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_teletexString_in_extensionAttr9251	= { FOLLOW_teletexString_in_extensionAttr9251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt4_in_extensionAttr9258  */
static	ANTLR3_BITWORD FOLLOW_tagInt4_in_extensionAttr9258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt4_in_extensionAttr9258	= { FOLLOW_tagInt4_in_extensionAttr9258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9260  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9260_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9260	= { FOLLOW_constructedTag1_in_extensionAttr9260_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_extensionAttr9262  */
static	ANTLR3_BITWORD FOLLOW_set_in_extensionAttr9262_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF8040) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_extensionAttr9262	= { FOLLOW_set_in_extensionAttr9262_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag0_in_extensionAttr9267  */
static	ANTLR3_BITWORD FOLLOW_tag0_in_extensionAttr9267_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000380) };
static  ANTLR3_BITSET_LIST FOLLOW_tag0_in_extensionAttr9267	= { FOLLOW_tag0_in_extensionAttr9267_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_extensionAttr9280  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_extensionAttr9280_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000300) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_extensionAttr9280	= { FOLLOW_tag1_in_extensionAttr9280_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag2_in_extensionAttr9290  */
static	ANTLR3_BITWORD FOLLOW_tag2_in_extensionAttr9290_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_tag2_in_extensionAttr9290	= { FOLLOW_tag2_in_extensionAttr9290_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag3_in_extensionAttr9295  */
static	ANTLR3_BITWORD FOLLOW_tag3_in_extensionAttr9295_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag3_in_extensionAttr9295	= { FOLLOW_tag3_in_extensionAttr9295_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt5_in_extensionAttr9302  */
static	ANTLR3_BITWORD FOLLOW_tagInt5_in_extensionAttr9302_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt5_in_extensionAttr9302	= { FOLLOW_tagInt5_in_extensionAttr9302_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9304  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9304_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9304	= { FOLLOW_constructedTag1_in_extensionAttr9304_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionAttr9306  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionAttr9306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionAttr9306	= { FOLLOW_sequenceTag_in_extensionAttr9306_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_teletexString_in_extensionAttr9314  */
static	ANTLR3_BITWORD FOLLOW_teletexString_in_extensionAttr9314_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_teletexString_in_extensionAttr9314	= { FOLLOW_teletexString_in_extensionAttr9314_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt7_in_extensionAttr9327  */
static	ANTLR3_BITWORD FOLLOW_tagInt7_in_extensionAttr9327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt7_in_extensionAttr9327	= { FOLLOW_tagInt7_in_extensionAttr9327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9329  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9329_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9329	= { FOLLOW_constructedTag1_in_extensionAttr9329_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_extensionAttr9333  */
static	ANTLR3_BITWORD FOLLOW_printString_in_extensionAttr9333_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_extensionAttr9333	= { FOLLOW_printString_in_extensionAttr9333_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt8_in_extensionAttr9340  */
static	ANTLR3_BITWORD FOLLOW_tagInt8_in_extensionAttr9340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt8_in_extensionAttr9340	= { FOLLOW_tagInt8_in_extensionAttr9340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9342  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9342	= { FOLLOW_constructedTag1_in_extensionAttr9342_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericString_in_extensionAttr9347  */
static	ANTLR3_BITWORD FOLLOW_numericString_in_extensionAttr9347_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numericString_in_extensionAttr9347	= { FOLLOW_numericString_in_extensionAttr9347_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_extensionAttr9356  */
static	ANTLR3_BITWORD FOLLOW_printString_in_extensionAttr9356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_extensionAttr9356	= { FOLLOW_printString_in_extensionAttr9356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt9_in_extensionAttr9366  */
static	ANTLR3_BITWORD FOLLOW_tagInt9_in_extensionAttr9366_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt9_in_extensionAttr9366	= { FOLLOW_tagInt9_in_extensionAttr9366_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9368  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9368_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9368	= { FOLLOW_constructedTag1_in_extensionAttr9368_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_numericString_in_extensionAttr9373  */
static	ANTLR3_BITWORD FOLLOW_numericString_in_extensionAttr9373_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_numericString_in_extensionAttr9373	= { FOLLOW_numericString_in_extensionAttr9373_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_extensionAttr9380  */
static	ANTLR3_BITWORD FOLLOW_printString_in_extensionAttr9380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_extensionAttr9380	= { FOLLOW_printString_in_extensionAttr9380_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt10_in_extensionAttr9391  */
static	ANTLR3_BITWORD FOLLOW_tagInt10_in_extensionAttr9391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt10_in_extensionAttr9391	= { FOLLOW_tagInt10_in_extensionAttr9391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt11_in_extensionAttr9396  */
static	ANTLR3_BITWORD FOLLOW_tagInt11_in_extensionAttr9396_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt11_in_extensionAttr9396	= { FOLLOW_tagInt11_in_extensionAttr9396_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt12_in_extensionAttr9401  */
static	ANTLR3_BITWORD FOLLOW_tagInt12_in_extensionAttr9401_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt12_in_extensionAttr9401	= { FOLLOW_tagInt12_in_extensionAttr9401_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt13_in_extensionAttr9406  */
static	ANTLR3_BITWORD FOLLOW_tagInt13_in_extensionAttr9406_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt13_in_extensionAttr9406	= { FOLLOW_tagInt13_in_extensionAttr9406_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt14_in_extensionAttr9411  */
static	ANTLR3_BITWORD FOLLOW_tagInt14_in_extensionAttr9411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt14_in_extensionAttr9411	= { FOLLOW_tagInt14_in_extensionAttr9411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt15_in_extensionAttr9416  */
static	ANTLR3_BITWORD FOLLOW_tagInt15_in_extensionAttr9416_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt15_in_extensionAttr9416	= { FOLLOW_tagInt15_in_extensionAttr9416_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt17_in_extensionAttr9423  */
static	ANTLR3_BITWORD FOLLOW_tagInt17_in_extensionAttr9423_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt17_in_extensionAttr9423	= { FOLLOW_tagInt17_in_extensionAttr9423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt18_in_extensionAttr9428  */
static	ANTLR3_BITWORD FOLLOW_tagInt18_in_extensionAttr9428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt18_in_extensionAttr9428	= { FOLLOW_tagInt18_in_extensionAttr9428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt19_in_extensionAttr9433  */
static	ANTLR3_BITWORD FOLLOW_tagInt19_in_extensionAttr9433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt19_in_extensionAttr9433	= { FOLLOW_tagInt19_in_extensionAttr9433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt20_in_extensionAttr9438  */
static	ANTLR3_BITWORD FOLLOW_tagInt20_in_extensionAttr9438_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt20_in_extensionAttr9438	= { FOLLOW_tagInt20_in_extensionAttr9438_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt21_in_extensionAttr9443  */
static	ANTLR3_BITWORD FOLLOW_tagInt21_in_extensionAttr9443_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt21_in_extensionAttr9443	= { FOLLOW_tagInt21_in_extensionAttr9443_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9449  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9449	= { FOLLOW_constructedTag1_in_extensionAttr9449_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_extensionAttr9451  */
static	ANTLR3_BITWORD FOLLOW_set_in_extensionAttr9451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_extensionAttr9451	= { FOLLOW_set_in_extensionAttr9451_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_extensionAttr9459  */
static	ANTLR3_BITWORD FOLLOW_printString_in_extensionAttr9459_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_extensionAttr9459	= { FOLLOW_printString_in_extensionAttr9459_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_teletexString_in_extensionAttr9467  */
static	ANTLR3_BITWORD FOLLOW_teletexString_in_extensionAttr9467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_teletexString_in_extensionAttr9467	= { FOLLOW_teletexString_in_extensionAttr9467_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt16_in_extensionAttr9476  */
static	ANTLR3_BITWORD FOLLOW_tagInt16_in_extensionAttr9476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt16_in_extensionAttr9476	= { FOLLOW_tagInt16_in_extensionAttr9476_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9478  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9478	= { FOLLOW_constructedTag1_in_extensionAttr9478_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_extensionAttr9480  */
static	ANTLR3_BITWORD FOLLOW_set_in_extensionAttr9480_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_extensionAttr9480	= { FOLLOW_set_in_extensionAttr9480_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionAttr9485  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionAttr9485_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionAttr9485	= { FOLLOW_sequenceTag_in_extensionAttr9485_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_extensionAttr9492  */
static	ANTLR3_BITWORD FOLLOW_printString_in_extensionAttr9492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_extensionAttr9492	= { FOLLOW_printString_in_extensionAttr9492_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_teletexString_in_extensionAttr9508  */
static	ANTLR3_BITWORD FOLLOW_teletexString_in_extensionAttr9508_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_teletexString_in_extensionAttr9508	= { FOLLOW_teletexString_in_extensionAttr9508_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt22_in_extensionAttr9518  */
static	ANTLR3_BITWORD FOLLOW_tagInt22_in_extensionAttr9518_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt22_in_extensionAttr9518	= { FOLLOW_tagInt22_in_extensionAttr9518_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9520  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000003FFFFF8040) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9520	= { FOLLOW_constructedTag1_in_extensionAttr9520_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag0_in_extensionAttr9527  */
static	ANTLR3_BITWORD FOLLOW_tag0_in_extensionAttr9527_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_tag0_in_extensionAttr9527	= { FOLLOW_tag0_in_extensionAttr9527_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_extensionAttr9537  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_extensionAttr9537_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_extensionAttr9537	= { FOLLOW_tag1_in_extensionAttr9537_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_extensionAttr9545  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_extensionAttr9545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000F00002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_extensionAttr9545	= { FOLLOW_constructedTag0_in_extensionAttr9545_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_extensionAttr9549  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_extensionAttr9549_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_extensionAttr9549	= { FOLLOW_constructedTag0_in_extensionAttr9549_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_extensionAttr9553  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_extensionAttr9553_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000E00002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_extensionAttr9553	= { FOLLOW_octetstring_in_extensionAttr9553_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9560  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9560_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9560	= { FOLLOW_constructedTag1_in_extensionAttr9560_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_extensionAttr9564  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_extensionAttr9564_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000C00002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_extensionAttr9564	= { FOLLOW_octetstring_in_extensionAttr9564_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag2_in_extensionAttr9573  */
static	ANTLR3_BITWORD FOLLOW_constructedTag2_in_extensionAttr9573_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag2_in_extensionAttr9573	= { FOLLOW_constructedTag2_in_extensionAttr9573_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_extensionAttr9577  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_extensionAttr9577_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000800002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_extensionAttr9577	= { FOLLOW_octetstring_in_extensionAttr9577_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_extensionAttr9584  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_extensionAttr9584_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_extensionAttr9584	= { FOLLOW_constructedTag3_in_extensionAttr9584_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_extensionAttr9586  */
static	ANTLR3_BITWORD FOLLOW_set_in_extensionAttr9586_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_extensionAttr9586	= { FOLLOW_set_in_extensionAttr9586_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_extensionAttr9595  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_extensionAttr9595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_extensionAttr9595	= { FOLLOW_octetstring_in_extensionAttr9595_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt23_in_extensionAttr9606  */
static	ANTLR3_BITWORD FOLLOW_tagInt23_in_extensionAttr9606_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt23_in_extensionAttr9606	= { FOLLOW_tagInt23_in_extensionAttr9606_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9608  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9608_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9608	= { FOLLOW_constructedTag1_in_extensionAttr9608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_extensionAttr9612  */
static	ANTLR3_BITWORD FOLLOW_integer_in_extensionAttr9612_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_extensionAttr9612	= { FOLLOW_integer_in_extensionAttr9612_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt6_in_extensionAttr9617  */
static	ANTLR3_BITWORD FOLLOW_tagInt6_in_extensionAttr9617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt6_in_extensionAttr9617	= { FOLLOW_tagInt6_in_extensionAttr9617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_extensionAttr9619  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_extensionAttr9619_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_extensionAttr9619	= { FOLLOW_constructedTag1_in_extensionAttr9619_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionAttr9621  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionAttr9621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionAttr9621	= { FOLLOW_sequenceTag_in_extensionAttr9621_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_extensionAttr9625  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_extensionAttr9625_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_extensionAttr9625	= { FOLLOW_sequenceTag_in_extensionAttr9625_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_teletexString_in_extensionAttr9629  */
static	ANTLR3_BITWORD FOLLOW_teletexString_in_extensionAttr9629_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_teletexString_in_extensionAttr9629	= { FOLLOW_teletexString_in_extensionAttr9629_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_teletexString_in_extensionAttr9633  */
static	ANTLR3_BITWORD FOLLOW_teletexString_in_extensionAttr9633_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_teletexString_in_extensionAttr9633	= { FOLLOW_teletexString_in_extensionAttr9633_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onlyTag0_in_extensionAttr9647  */
static	ANTLR3_BITWORD FOLLOW_onlyTag0_in_extensionAttr9647_bits[]	= { ANTLR3_UINT64_LIT(0x01F702001FF81C00), ANTLR3_UINT64_LIT(0x0000008300000001), ANTLR3_UINT64_LIT(0x00030EFFFFFFFFC6) };
static  ANTLR3_BITSET_LIST FOLLOW_onlyTag0_in_extensionAttr9647	= { FOLLOW_onlyTag0_in_extensionAttr9647_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_any_in_extensionAttr9649  */
static	ANTLR3_BITWORD FOLLOW_any_in_extensionAttr9649_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_any_in_extensionAttr9649	= { FOLLOW_any_in_extensionAttr9649_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_name9669  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_name9669_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_name9669	= { FOLLOW_sequenceTag_in_name9669_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rdns_in_name9671  */
static	ANTLR3_BITWORD FOLLOW_rdns_in_name9671_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rdns_in_name9671	= { FOLLOW_rdns_in_name9671_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_rdns9692  */
static	ANTLR3_BITWORD FOLLOW_set_in_rdns9692_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_rdns9692	= { FOLLOW_set_in_rdns9692_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rdn_in_rdns9695  */
static	ANTLR3_BITWORD FOLLOW_rdn_in_rdns9695_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_rdn_in_rdns9695	= { FOLLOW_rdn_in_rdns9695_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rdns_in_rdns9697  */
static	ANTLR3_BITWORD FOLLOW_rdns_in_rdns9697_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rdns_in_rdns9697	= { FOLLOW_rdns_in_rdns9697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_notEmptyName9719  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_notEmptyName9719_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_notEmptyName9719	= { FOLLOW_sequenceTag_in_notEmptyName9719_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rdnsNotEmpty_in_notEmptyName9721  */
static	ANTLR3_BITWORD FOLLOW_rdnsNotEmpty_in_notEmptyName9721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rdnsNotEmpty_in_notEmptyName9721	= { FOLLOW_rdnsNotEmpty_in_notEmptyName9721_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_rdnsNotEmpty9738  */
static	ANTLR3_BITWORD FOLLOW_set_in_rdnsNotEmpty9738_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_rdnsNotEmpty9738	= { FOLLOW_set_in_rdnsNotEmpty9738_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rdn_in_rdnsNotEmpty9741  */
static	ANTLR3_BITWORD FOLLOW_rdn_in_rdnsNotEmpty9741_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_rdn_in_rdnsNotEmpty9741	= { FOLLOW_rdn_in_rdnsNotEmpty9741_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rdnsNotEmpty_in_rdnsNotEmpty9744  */
static	ANTLR3_BITWORD FOLLOW_rdnsNotEmpty_in_rdnsNotEmpty9744_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rdnsNotEmpty_in_rdnsNotEmpty9744	= { FOLLOW_rdnsNotEmpty_in_rdnsNotEmpty9744_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_rdn9762  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_rdn9762_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_rdn9762	= { FOLLOW_sequenceTag_in_rdn9762_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dn_in_rdn9764  */
static	ANTLR3_BITWORD FOLLOW_dn_in_rdn9764_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dn_in_rdn9764	= { FOLLOW_dn_in_rdn9764_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rdn_in_rdn9769  */
static	ANTLR3_BITWORD FOLLOW_rdn_in_rdn9769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rdn_in_rdn9769	= { FOLLOW_rdn_in_rdn9769_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_cnoid_in_dn9795  */
static	ANTLR3_BITWORD FOLLOW_cnoid_in_dn9795_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_cnoid_in_dn9795	= { FOLLOW_cnoid_in_dn9795_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oidon_in_dn9800  */
static	ANTLR3_BITWORD FOLLOW_oidon_in_dn9800_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oidon_in_dn9800	= { FOLLOW_oidon_in_dn9800_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oidname_in_dn9805  */
static	ANTLR3_BITWORD FOLLOW_oidname_in_dn9805_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_oidname_in_dn9805	= { FOLLOW_oidname_in_dn9805_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_surnameoid_in_dn9810  */
static	ANTLR3_BITWORD FOLLOW_surnameoid_in_dn9810_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_surnameoid_in_dn9810	= { FOLLOW_surnameoid_in_dn9810_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_givenoid_in_dn9818  */
static	ANTLR3_BITWORD FOLLOW_givenoid_in_dn9818_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_givenoid_in_dn9818	= { FOLLOW_givenoid_in_dn9818_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_initoid_in_dn9823  */
static	ANTLR3_BITWORD FOLLOW_initoid_in_dn9823_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_initoid_in_dn9823	= { FOLLOW_initoid_in_dn9823_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_genqualifieroid_in_dn9828  */
static	ANTLR3_BITWORD FOLLOW_genqualifieroid_in_dn9828_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_genqualifieroid_in_dn9828	= { FOLLOW_genqualifieroid_in_dn9828_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_localoid_in_dn9833  */
static	ANTLR3_BITWORD FOLLOW_localoid_in_dn9833_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_localoid_in_dn9833	= { FOLLOW_localoid_in_dn9833_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ouoid_in_dn9838  */
static	ANTLR3_BITWORD FOLLOW_ouoid_in_dn9838_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_ouoid_in_dn9838	= { FOLLOW_ouoid_in_dn9838_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sorpoid_in_dn9846  */
static	ANTLR3_BITWORD FOLLOW_sorpoid_in_dn9846_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sorpoid_in_dn9846	= { FOLLOW_sorpoid_in_dn9846_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_titleoid_in_dn9850  */
static	ANTLR3_BITWORD FOLLOW_titleoid_in_dn9850_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_titleoid_in_dn9850	= { FOLLOW_titleoid_in_dn9850_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pseudooid_in_dn9855  */
static	ANTLR3_BITWORD FOLLOW_pseudooid_in_dn9855_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000400), ANTLR3_UINT64_LIT(0x0000008000000000), ANTLR3_UINT64_LIT(0x00000C4000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_pseudooid_in_dn9855	= { FOLLOW_pseudooid_in_dn9855_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_directoryString_in_dn9860  */
static	ANTLR3_BITWORD FOLLOW_directoryString_in_dn9860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_directoryString_in_dn9860	= { FOLLOW_directoryString_in_dn9860_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dnoid_in_dn9876  */
static	ANTLR3_BITWORD FOLLOW_dnoid_in_dn9876_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_dnoid_in_dn9876	= { FOLLOW_dnoid_in_dn9876_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_countryoid_in_dn9882  */
static	ANTLR3_BITWORD FOLLOW_countryoid_in_dn9882_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_countryoid_in_dn9882	= { FOLLOW_countryoid_in_dn9882_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_serialoid_in_dn9887  */
static	ANTLR3_BITWORD FOLLOW_serialoid_in_dn9887_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000), ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_serialoid_in_dn9887	= { FOLLOW_serialoid_in_dn9887_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_dn9893  */
static	ANTLR3_BITWORD FOLLOW_printString_in_dn9893_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_dn9893	= { FOLLOW_printString_in_dn9893_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ia5String_in_dn9901  */
static	ANTLR3_BITWORD FOLLOW_ia5String_in_dn9901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ia5String_in_dn9901	= { FOLLOW_ia5String_in_dn9901_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_legacyemailoid_in_dn9916  */
static	ANTLR3_BITWORD FOLLOW_legacyemailoid_in_dn9916_bits[]	= { ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_legacyemailoid_in_dn9916	= { FOLLOW_legacyemailoid_in_dn9916_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ia5String_in_dn9920  */
static	ANTLR3_BITWORD FOLLOW_ia5String_in_dn9920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ia5String_in_dn9920	= { FOLLOW_ia5String_in_dn9920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_dn9932  */
static	ANTLR3_BITWORD FOLLOW_oid_in_dn9932_bits[]	= { ANTLR3_UINT64_LIT(0x01F702001FF81C00), ANTLR3_UINT64_LIT(0x0000008300000001), ANTLR3_UINT64_LIT(0x00030EFFFFFFFFC6) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_dn9932	= { FOLLOW_oid_in_dn9932_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_any_in_dn9934  */
static	ANTLR3_BITWORD FOLLOW_any_in_dn9934_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_any_in_dn9934	= { FOLLOW_any_in_dn9934_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_teletexString_in_directoryString9966  */
static	ANTLR3_BITWORD FOLLOW_teletexString_in_directoryString9966_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_teletexString_in_directoryString9966	= { FOLLOW_teletexString_in_directoryString9966_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_directoryString9973  */
static	ANTLR3_BITWORD FOLLOW_printString_in_directoryString9973_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_directoryString9973	= { FOLLOW_printString_in_directoryString9973_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_utf8String_in_directoryString9980  */
static	ANTLR3_BITWORD FOLLOW_utf8String_in_directoryString9980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_utf8String_in_directoryString9980	= { FOLLOW_utf8String_in_directoryString9980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_univerString_in_directoryString9987  */
static	ANTLR3_BITWORD FOLLOW_univerString_in_directoryString9987_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_univerString_in_directoryString9987	= { FOLLOW_univerString_in_directoryString9987_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bmpString_in_directoryString9994  */
static	ANTLR3_BITWORD FOLLOW_bmpString_in_directoryString9994_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bmpString_in_directoryString9994	= { FOLLOW_bmpString_in_directoryString9994_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ia5String_in_directoryString10001  */
static	ANTLR3_BITWORD FOLLOW_ia5String_in_directoryString10001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ia5String_in_directoryString10001	= { FOLLOW_ia5String_in_directoryString10001_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_signature10020  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_signature10020_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_signature10020	= { FOLLOW_bitstring_in_signature10020_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedBitString_in_dsa_signature10042  */
static	ANTLR3_BITWORD FOLLOW_constructedBitString_in_dsa_signature10042_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedBitString_in_dsa_signature10042	= { FOLLOW_constructedBitString_in_dsa_signature10042_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_dsa_signature10044  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_dsa_signature10044_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_dsa_signature10044	= { FOLLOW_sequenceTag_in_dsa_signature10044_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_signature10048  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_signature10048_bits[]	= { ANTLR3_UINT64_LIT(0x01E0000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_signature10048	= { FOLLOW_integer_in_dsa_signature10048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_dsa_signature10052  */
static	ANTLR3_BITWORD FOLLOW_integer_in_dsa_signature10052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_dsa_signature10052	= { FOLLOW_integer_in_dsa_signature10052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_truevalue_in_critical10084  */
static	ANTLR3_BITWORD FOLLOW_truevalue_in_critical10084_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_truevalue_in_critical10084	= { FOLLOW_truevalue_in_critical10084_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_falsevalue_in_critical10090  */
static	ANTLR3_BITWORD FOLLOW_falsevalue_in_critical10090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_falsevalue_in_critical10090	= { FOLLOW_falsevalue_in_critical10090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_utc_in_time_span10118  */
static	ANTLR3_BITWORD FOLLOW_utc_in_time_span10118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_utc_in_time_span10118	= { FOLLOW_utc_in_time_span10118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_genTime_in_time_span10124  */
static	ANTLR3_BITWORD FOLLOW_genTime_in_time_span10124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_genTime_in_time_span10124	= { FOLLOW_genTime_in_time_span10124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_anyToken_in_any10152  */
static	ANTLR3_BITWORD FOLLOW_anyToken_in_any10152_bits[]	= { ANTLR3_UINT64_LIT(0x01F702001FF81C02), ANTLR3_UINT64_LIT(0x0000008300000001), ANTLR3_UINT64_LIT(0x00030EFFFFFFFFC6) };
static  ANTLR3_BITSET_LIST FOLLOW_anyToken_in_any10152	= { FOLLOW_anyToken_in_any10152_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_teletexString_in_anyToken10181  */
static	ANTLR3_BITWORD FOLLOW_teletexString_in_anyToken10181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_teletexString_in_anyToken10181	= { FOLLOW_teletexString_in_anyToken10181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ia5String_in_anyToken10188  */
static	ANTLR3_BITWORD FOLLOW_ia5String_in_anyToken10188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ia5String_in_anyToken10188	= { FOLLOW_ia5String_in_anyToken10188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bmpString_in_anyToken10195  */
static	ANTLR3_BITWORD FOLLOW_bmpString_in_anyToken10195_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bmpString_in_anyToken10195	= { FOLLOW_bmpString_in_anyToken10195_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_utf8String_in_anyToken10202  */
static	ANTLR3_BITWORD FOLLOW_utf8String_in_anyToken10202_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_utf8String_in_anyToken10202	= { FOLLOW_utf8String_in_anyToken10202_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printString_in_anyToken10209  */
static	ANTLR3_BITWORD FOLLOW_printString_in_anyToken10209_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printString_in_anyToken10209	= { FOLLOW_printString_in_anyToken10209_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_univerString_in_anyToken10216  */
static	ANTLR3_BITWORD FOLLOW_univerString_in_anyToken10216_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_univerString_in_anyToken10216	= { FOLLOW_univerString_in_anyToken10216_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_visibleString_in_anyToken10223  */
static	ANTLR3_BITWORD FOLLOW_visibleString_in_anyToken10223_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_visibleString_in_anyToken10223	= { FOLLOW_visibleString_in_anyToken10223_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_generalString_in_anyToken10230  */
static	ANTLR3_BITWORD FOLLOW_generalString_in_anyToken10230_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_generalString_in_anyToken10230	= { FOLLOW_generalString_in_anyToken10230_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_graphicString_in_anyToken10237  */
static	ANTLR3_BITWORD FOLLOW_graphicString_in_anyToken10237_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_graphicString_in_anyToken10237	= { FOLLOW_graphicString_in_anyToken10237_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_videoString_in_anyToken10244  */
static	ANTLR3_BITWORD FOLLOW_videoString_in_anyToken10244_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_videoString_in_anyToken10244	= { FOLLOW_videoString_in_anyToken10244_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_anyToken10251  */
static	ANTLR3_BITWORD FOLLOW_integer_in_anyToken10251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_anyToken10251	= { FOLLOW_integer_in_anyToken10251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bitstring_in_anyToken10258  */
static	ANTLR3_BITWORD FOLLOW_bitstring_in_anyToken10258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bitstring_in_anyToken10258	= { FOLLOW_bitstring_in_anyToken10258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedOctetString_in_anyToken10265  */
static	ANTLR3_BITWORD FOLLOW_constructedOctetString_in_anyToken10265_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedOctetString_in_anyToken10265	= { FOLLOW_constructedOctetString_in_anyToken10265_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_time_span_in_anyToken10272  */
static	ANTLR3_BITWORD FOLLOW_time_span_in_anyToken10272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_time_span_in_anyToken10272	= { FOLLOW_time_span_in_anyToken10272_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_critical_in_anyToken10279  */
static	ANTLR3_BITWORD FOLLOW_critical_in_anyToken10279_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_critical_in_anyToken10279	= { FOLLOW_critical_in_anyToken10279_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_anyToken10286  */
static	ANTLR3_BITWORD FOLLOW_set_in_anyToken10286_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_anyToken10286	= { FOLLOW_set_in_anyToken10286_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_null_in_anyToken10293  */
static	ANTLR3_BITWORD FOLLOW_null_in_anyToken10293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_null_in_anyToken10293	= { FOLLOW_null_in_anyToken10293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_octetstring_in_anyToken10300  */
static	ANTLR3_BITWORD FOLLOW_octetstring_in_anyToken10300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_octetstring_in_anyToken10300	= { FOLLOW_octetstring_in_anyToken10300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sequenceTag_in_anyToken10307  */
static	ANTLR3_BITWORD FOLLOW_sequenceTag_in_anyToken10307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_sequenceTag_in_anyToken10307	= { FOLLOW_sequenceTag_in_anyToken10307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_oid_in_anyToken10314  */
static	ANTLR3_BITWORD FOLLOW_oid_in_anyToken10314_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_oid_in_anyToken10314	= { FOLLOW_oid_in_anyToken10314_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag0_in_anyToken10321  */
static	ANTLR3_BITWORD FOLLOW_constructedTag0_in_anyToken10321_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag0_in_anyToken10321	= { FOLLOW_constructedTag0_in_anyToken10321_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag0_in_anyToken10328  */
static	ANTLR3_BITWORD FOLLOW_tag0_in_anyToken10328_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag0_in_anyToken10328	= { FOLLOW_tag0_in_anyToken10328_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag1_in_anyToken10335  */
static	ANTLR3_BITWORD FOLLOW_constructedTag1_in_anyToken10335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag1_in_anyToken10335	= { FOLLOW_constructedTag1_in_anyToken10335_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag1_in_anyToken10342  */
static	ANTLR3_BITWORD FOLLOW_tag1_in_anyToken10342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag1_in_anyToken10342	= { FOLLOW_tag1_in_anyToken10342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag2_in_anyToken10349  */
static	ANTLR3_BITWORD FOLLOW_constructedTag2_in_anyToken10349_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag2_in_anyToken10349	= { FOLLOW_constructedTag2_in_anyToken10349_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag2_in_anyToken10356  */
static	ANTLR3_BITWORD FOLLOW_tag2_in_anyToken10356_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag2_in_anyToken10356	= { FOLLOW_tag2_in_anyToken10356_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag3_in_anyToken10363  */
static	ANTLR3_BITWORD FOLLOW_constructedTag3_in_anyToken10363_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag3_in_anyToken10363	= { FOLLOW_constructedTag3_in_anyToken10363_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag3_in_anyToken10370  */
static	ANTLR3_BITWORD FOLLOW_tag3_in_anyToken10370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag3_in_anyToken10370	= { FOLLOW_tag3_in_anyToken10370_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag4_in_anyToken10377  */
static	ANTLR3_BITWORD FOLLOW_constructedTag4_in_anyToken10377_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag4_in_anyToken10377	= { FOLLOW_constructedTag4_in_anyToken10377_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag4_in_anyToken10384  */
static	ANTLR3_BITWORD FOLLOW_tag4_in_anyToken10384_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag4_in_anyToken10384	= { FOLLOW_tag4_in_anyToken10384_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag5_in_anyToken10391  */
static	ANTLR3_BITWORD FOLLOW_constructedTag5_in_anyToken10391_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag5_in_anyToken10391	= { FOLLOW_constructedTag5_in_anyToken10391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag5_in_anyToken10398  */
static	ANTLR3_BITWORD FOLLOW_tag5_in_anyToken10398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag5_in_anyToken10398	= { FOLLOW_tag5_in_anyToken10398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag6_in_anyToken10405  */
static	ANTLR3_BITWORD FOLLOW_constructedTag6_in_anyToken10405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag6_in_anyToken10405	= { FOLLOW_constructedTag6_in_anyToken10405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag6_in_anyToken10412  */
static	ANTLR3_BITWORD FOLLOW_tag6_in_anyToken10412_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag6_in_anyToken10412	= { FOLLOW_tag6_in_anyToken10412_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag7_in_anyToken10419  */
static	ANTLR3_BITWORD FOLLOW_constructedTag7_in_anyToken10419_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag7_in_anyToken10419	= { FOLLOW_constructedTag7_in_anyToken10419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag7_in_anyToken10426  */
static	ANTLR3_BITWORD FOLLOW_tag7_in_anyToken10426_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag7_in_anyToken10426	= { FOLLOW_tag7_in_anyToken10426_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_constructedTag8_in_anyToken10433  */
static	ANTLR3_BITWORD FOLLOW_constructedTag8_in_anyToken10433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_constructedTag8_in_anyToken10433	= { FOLLOW_constructedTag8_in_anyToken10433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tag8_in_anyToken10440  */
static	ANTLR3_BITWORD FOLLOW_tag8_in_anyToken10440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tag8_in_anyToken10440	= { FOLLOW_tag8_in_anyToken10440_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OctetTag_in_octetstring10467  */
static	ANTLR3_BITWORD FOLLOW_OctetTag_in_octetstring10467_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OctetTag_in_octetstring10467	= { FOLLOW_OctetTag_in_octetstring10467_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_octetstring10469  */
static	ANTLR3_BITWORD FOLLOW_val_in_octetstring10469_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_octetstring10469	= { FOLLOW_val_in_octetstring10469_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integerAbove3_in_integer10499  */
static	ANTLR3_BITWORD FOLLOW_integerAbove3_in_integer10499_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integerAbove3_in_integer10499	= { FOLLOW_integerAbove3_in_integer10499_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_int0_in_integer10506  */
static	ANTLR3_BITWORD FOLLOW_int0_in_integer10506_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_int0_in_integer10506	= { FOLLOW_int0_in_integer10506_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_int1_in_integer10513  */
static	ANTLR3_BITWORD FOLLOW_int1_in_integer10513_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_int1_in_integer10513	= { FOLLOW_int1_in_integer10513_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_int2_in_integer10520  */
static	ANTLR3_BITWORD FOLLOW_int2_in_integer10520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_int2_in_integer10520	= { FOLLOW_int2_in_integer10520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IntTag_in_integerAbove310543  */
static	ANTLR3_BITWORD FOLLOW_IntTag_in_integerAbove310543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IntTag_in_integerAbove310543	= { FOLLOW_IntTag_in_integerAbove310543_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_integerAbove310545  */
static	ANTLR3_BITWORD FOLLOW_val_in_integerAbove310545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_integerAbove310545	= { FOLLOW_val_in_integerAbove310545_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Int0_in_int010565  */
static	ANTLR3_BITWORD FOLLOW_Int0_in_int010565_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Int0_in_int010565	= { FOLLOW_Int0_in_int010565_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Int1_in_int110580  */
static	ANTLR3_BITWORD FOLLOW_Int1_in_int110580_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Int1_in_int110580	= { FOLLOW_Int1_in_int110580_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Int2_in_int210595  */
static	ANTLR3_BITWORD FOLLOW_Int2_in_int210595_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Int2_in_int210595	= { FOLLOW_Int2_in_int210595_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BitStringTag_in_bitstring10621  */
static	ANTLR3_BITWORD FOLLOW_BitStringTag_in_bitstring10621_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BitStringTag_in_bitstring10621	= { FOLLOW_BitStringTag_in_bitstring10621_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_bitstring10623  */
static	ANTLR3_BITWORD FOLLOW_val_in_bitstring10623_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_bitstring10623	= { FOLLOW_val_in_bitstring10623_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BitStringKeyCert_in_bitstring10630  */
static	ANTLR3_BITWORD FOLLOW_BitStringKeyCert_in_bitstring10630_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BitStringKeyCert_in_bitstring10630	= { FOLLOW_BitStringKeyCert_in_bitstring10630_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_bitstring10632  */
static	ANTLR3_BITWORD FOLLOW_val_in_bitstring10632_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_bitstring10632	= { FOLLOW_val_in_bitstring10632_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BitStringKeyCert_in_bitstringCertSign10652  */
static	ANTLR3_BITWORD FOLLOW_BitStringKeyCert_in_bitstringCertSign10652_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BitStringKeyCert_in_bitstringCertSign10652	= { FOLLOW_BitStringKeyCert_in_bitstringCertSign10652_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_oid10677  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_oid10677_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_oid10677	= { FOLLOW_OIDTag_in_oid10677_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_oid10679  */
static	ANTLR3_BITWORD FOLLOW_val_in_oid10679_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_oid10679	= { FOLLOW_val_in_oid10679_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_cnoid10702  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_cnoid10702_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_cnoid10702	= { FOLLOW_OIDTag_in_cnoid10702_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDCN_in_cnoid10704  */
static	ANTLR3_BITWORD FOLLOW_OIDCN_in_cnoid10704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDCN_in_cnoid10704	= { FOLLOW_OIDCN_in_cnoid10704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_oidon10726  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_oidon10726_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000200000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_oidon10726	= { FOLLOW_OIDTag_in_oidon10726_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDON_in_oidon10728  */
static	ANTLR3_BITWORD FOLLOW_OIDON_in_oidon10728_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDON_in_oidon10728	= { FOLLOW_OIDON_in_oidon10728_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_aiaoid10747  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_aiaoid10747_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_aiaoid10747	= { FOLLOW_OIDTag_in_aiaoid10747_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AIAOID_in_aiaoid10749  */
static	ANTLR3_BITWORD FOLLOW_AIAOID_in_aiaoid10749_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AIAOID_in_aiaoid10749	= { FOLLOW_AIAOID_in_aiaoid10749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_siaoid10769  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_siaoid10769_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x8000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_siaoid10769	= { FOLLOW_OIDTag_in_siaoid10769_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SIAOID_in_siaoid10771  */
static	ANTLR3_BITWORD FOLLOW_SIAOID_in_siaoid10771_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SIAOID_in_siaoid10771	= { FOLLOW_SIAOID_in_siaoid10771_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_akioid10791  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_akioid10791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_akioid10791	= { FOLLOW_OIDTag_in_akioid10791_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDAKI_in_akioid10793  */
static	ANTLR3_BITWORD FOLLOW_OIDAKI_in_akioid10793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDAKI_in_akioid10793	= { FOLLOW_OIDAKI_in_akioid10793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_skioid10813  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_skioid10813_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_skioid10813	= { FOLLOW_OIDTag_in_skioid10813_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDSKI_in_skioid10815  */
static	ANTLR3_BITWORD FOLLOW_OIDSKI_in_skioid10815_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDSKI_in_skioid10815	= { FOLLOW_OIDSKI_in_skioid10815_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_bcoid10834  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_bcoid10834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_bcoid10834	= { FOLLOW_OIDTag_in_bcoid10834_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDBC_in_bcoid10836  */
static	ANTLR3_BITWORD FOLLOW_OIDBC_in_bcoid10836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDBC_in_bcoid10836	= { FOLLOW_OIDBC_in_bcoid10836_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_polconstraintsoid10856  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_polconstraintsoid10856_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000800000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_polconstraintsoid10856	= { FOLLOW_OIDTag_in_polconstraintsoid10856_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDPOLCONST_in_polconstraintsoid10858  */
static	ANTLR3_BITWORD FOLLOW_OIDPOLCONST_in_polconstraintsoid10858_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDPOLCONST_in_polconstraintsoid10858	= { FOLLOW_OIDPOLCONST_in_polconstraintsoid10858_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_certpolioid10881  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_certpolioid10881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_certpolioid10881	= { FOLLOW_OIDTag_in_certpolioid10881_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDCERTPOL_in_certpolioid10883  */
static	ANTLR3_BITWORD FOLLOW_OIDCERTPOL_in_certpolioid10883_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDCERTPOL_in_certpolioid10883	= { FOLLOW_OIDCERTPOL_in_certpolioid10883_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_polmapoid10905  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_polmapoid10905_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_polmapoid10905	= { FOLLOW_OIDTag_in_polmapoid10905_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDPOLMAP_in_polmapoid10907  */
static	ANTLR3_BITWORD FOLLOW_OIDPOLMAP_in_polmapoid10907_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDPOLMAP_in_polmapoid10907	= { FOLLOW_OIDPOLMAP_in_polmapoid10907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_keyusageoid10929  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_keyusageoid10929_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_keyusageoid10929	= { FOLLOW_OIDTag_in_keyusageoid10929_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDKEYUS_in_keyusageoid10931  */
static	ANTLR3_BITWORD FOLLOW_OIDKEYUS_in_keyusageoid10931_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDKEYUS_in_keyusageoid10931	= { FOLLOW_OIDKEYUS_in_keyusageoid10931_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_subaltoid10952  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_subaltoid10952_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_subaltoid10952	= { FOLLOW_OIDTag_in_subaltoid10952_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDSUBALT_in_subaltoid10954  */
static	ANTLR3_BITWORD FOLLOW_OIDSUBALT_in_subaltoid10954_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDSUBALT_in_subaltoid10954	= { FOLLOW_OIDSUBALT_in_subaltoid10954_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_issaltoid10978  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_issaltoid10978_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_issaltoid10978	= { FOLLOW_OIDTag_in_issaltoid10978_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDISSALT_in_issaltoid10980  */
static	ANTLR3_BITWORD FOLLOW_OIDISSALT_in_issaltoid10980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDISSALT_in_issaltoid10980	= { FOLLOW_OIDISSALT_in_issaltoid10980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_subdiroid11001  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_subdiroid11001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_subdiroid11001	= { FOLLOW_OIDTag_in_subdiroid11001_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDSUBDIR_in_subdiroid11003  */
static	ANTLR3_BITWORD FOLLOW_OIDSUBDIR_in_subdiroid11003_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDSUBDIR_in_subdiroid11003	= { FOLLOW_OIDSUBDIR_in_subdiroid11003_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_nameoid11023  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_nameoid11023_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_nameoid11023	= { FOLLOW_OIDTag_in_nameoid11023_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDNAME_in_nameoid11025  */
static	ANTLR3_BITWORD FOLLOW_OIDNAME_in_nameoid11025_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDNAME_in_nameoid11025	= { FOLLOW_OIDNAME_in_nameoid11025_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_ekuoid11047  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_ekuoid11047_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_ekuoid11047	= { FOLLOW_OIDTag_in_ekuoid11047_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDEXTKEY_in_ekuoid11049  */
static	ANTLR3_BITWORD FOLLOW_OIDEXTKEY_in_ekuoid11049_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDEXTKEY_in_ekuoid11049	= { FOLLOW_OIDEXTKEY_in_ekuoid11049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_crldpoid11069  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_crldpoid11069_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_crldpoid11069	= { FOLLOW_OIDTag_in_crldpoid11069_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDCRL_in_crldpoid11071  */
static	ANTLR3_BITWORD FOLLOW_OIDCRL_in_crldpoid11071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDCRL_in_crldpoid11071	= { FOLLOW_OIDCRL_in_crldpoid11071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_inhibitanyoid11092  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_inhibitanyoid11092_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_inhibitanyoid11092	= { FOLLOW_OIDTag_in_inhibitanyoid11092_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDINHIBIT_in_inhibitanyoid11094  */
static	ANTLR3_BITWORD FOLLOW_OIDINHIBIT_in_inhibitanyoid11094_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDINHIBIT_in_inhibitanyoid11094	= { FOLLOW_OIDINHIBIT_in_inhibitanyoid11094_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_freshcrloid11116  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_freshcrloid11116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000001000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_freshcrloid11116	= { FOLLOW_OIDTag_in_freshcrloid11116_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDFRESHCRL_in_freshcrloid11118  */
static	ANTLR3_BITWORD FOLLOW_OIDFRESHCRL_in_freshcrloid11118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDFRESHCRL_in_freshcrloid11118	= { FOLLOW_OIDFRESHCRL_in_freshcrloid11118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_caissueroid11141  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_caissueroid11141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_caissueroid11141	= { FOLLOW_OIDTag_in_caissueroid11141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CAISSUEROID_in_caissueroid11143  */
static	ANTLR3_BITWORD FOLLOW_CAISSUEROID_in_caissueroid11143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CAISSUEROID_in_caissueroid11143	= { FOLLOW_CAISSUEROID_in_caissueroid11143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_ocspoid11167  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_ocspoid11167_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000004) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_ocspoid11167	= { FOLLOW_OIDTag_in_ocspoid11167_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OCSPOID_in_ocspoid11169  */
static	ANTLR3_BITWORD FOLLOW_OCSPOID_in_ocspoid11169_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OCSPOID_in_ocspoid11169	= { FOLLOW_OCSPOID_in_ocspoid11169_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_carepooid11189  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_carepooid11189_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_carepooid11189	= { FOLLOW_OIDTag_in_carepooid11189_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CAREPOOID_in_carepooid11191  */
static	ANTLR3_BITWORD FOLLOW_CAREPOOID_in_carepooid11191_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CAREPOOID_in_carepooid11191	= { FOLLOW_CAREPOOID_in_carepooid11191_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_tspoid11211  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_tspoid11211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_tspoid11211	= { FOLLOW_OIDTag_in_tspoid11211_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TSPOID_in_tspoid11213  */
static	ANTLR3_BITWORD FOLLOW_TSPOID_in_tspoid11213_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TSPOID_in_tspoid11213	= { FOLLOW_TSPOID_in_tspoid11213_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_cpsoid11234  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_cpsoid11234_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_cpsoid11234	= { FOLLOW_OIDTag_in_cpsoid11234_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CPSOID_in_cpsoid11236  */
static	ANTLR3_BITWORD FOLLOW_CPSOID_in_cpsoid11236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CPSOID_in_cpsoid11236	= { FOLLOW_CPSOID_in_cpsoid11236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_unoticeoid11259  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_unoticeoid11259_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_unoticeoid11259	= { FOLLOW_OIDTag_in_unoticeoid11259_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UNOTICEOID_in_unoticeoid11261  */
static	ANTLR3_BITWORD FOLLOW_UNOTICEOID_in_unoticeoid11261_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_UNOTICEOID_in_unoticeoid11261	= { FOLLOW_UNOTICEOID_in_unoticeoid11261_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_oidname11285  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_oidname11285_bits[]	= { ANTLR3_UINT64_LIT(0x8000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_oidname11285	= { FOLLOW_OIDTag_in_oidname11285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NAMEOID_in_oidname11287  */
static	ANTLR3_BITWORD FOLLOW_NAMEOID_in_oidname11287_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NAMEOID_in_oidname11287	= { FOLLOW_NAMEOID_in_oidname11287_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_surnameoid11310  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_surnameoid11310_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000001) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_surnameoid11310	= { FOLLOW_OIDTag_in_surnameoid11310_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SURNAMEOID_in_surnameoid11312  */
static	ANTLR3_BITWORD FOLLOW_SURNAMEOID_in_surnameoid11312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SURNAMEOID_in_surnameoid11312	= { FOLLOW_SURNAMEOID_in_surnameoid11312_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_givenoid11334  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_givenoid11334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000004000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_givenoid11334	= { FOLLOW_OIDTag_in_givenoid11334_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDGIVENAME_in_givenoid11336  */
static	ANTLR3_BITWORD FOLLOW_OIDGIVENAME_in_givenoid11336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDGIVENAME_in_givenoid11336	= { FOLLOW_OIDGIVENAME_in_givenoid11336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_initoid11355  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_initoid11355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_initoid11355	= { FOLLOW_OIDTag_in_initoid11355_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDINIT_in_initoid11357  */
static	ANTLR3_BITWORD FOLLOW_OIDINIT_in_initoid11357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDINIT_in_initoid11357	= { FOLLOW_OIDINIT_in_initoid11357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_genqualifieroid11379  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_genqualifieroid11379_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_genqualifieroid11379	= { FOLLOW_OIDTag_in_genqualifieroid11379_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDGENQUALIFIER_in_genqualifieroid11381  */
static	ANTLR3_BITWORD FOLLOW_OIDGENQUALIFIER_in_genqualifieroid11381_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDGENQUALIFIER_in_genqualifieroid11381	= { FOLLOW_OIDGENQUALIFIER_in_genqualifieroid11381_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_localoid11403  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_localoid11403_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_localoid11403	= { FOLLOW_OIDTag_in_localoid11403_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDLOCAL_in_localoid11405  */
static	ANTLR3_BITWORD FOLLOW_OIDLOCAL_in_localoid11405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDLOCAL_in_localoid11405	= { FOLLOW_OIDLOCAL_in_localoid11405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sorpoid11427  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sorpoid11427_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000010000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sorpoid11427	= { FOLLOW_OIDTag_in_sorpoid11427_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDSORP_in_sorpoid11429  */
static	ANTLR3_BITWORD FOLLOW_OIDSORP_in_sorpoid11429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDSORP_in_sorpoid11429	= { FOLLOW_OIDSORP_in_sorpoid11429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_ouoid11451  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_ouoid11451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_ouoid11451	= { FOLLOW_OIDTag_in_ouoid11451_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDOU_in_ouoid11453  */
static	ANTLR3_BITWORD FOLLOW_OIDOU_in_ouoid11453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDOU_in_ouoid11453	= { FOLLOW_OIDOU_in_ouoid11453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_titleoid11473  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_titleoid11473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_titleoid11473	= { FOLLOW_OIDTag_in_titleoid11473_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTITLE_in_titleoid11475  */
static	ANTLR3_BITWORD FOLLOW_OIDTITLE_in_titleoid11475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTITLE_in_titleoid11475	= { FOLLOW_OIDTITLE_in_titleoid11475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_dnoid11496  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_dnoid11496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_dnoid11496	= { FOLLOW_OIDTag_in_dnoid11496_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDDNQUALIFIER_in_dnoid11498  */
static	ANTLR3_BITWORD FOLLOW_OIDDNQUALIFIER_in_dnoid11498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDDNQUALIFIER_in_dnoid11498	= { FOLLOW_OIDDNQUALIFIER_in_dnoid11498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_countryoid11520  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_countryoid11520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000100) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_countryoid11520	= { FOLLOW_OIDTag_in_countryoid11520_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDCOUNTRY_in_countryoid11522  */
static	ANTLR3_BITWORD FOLLOW_OIDCOUNTRY_in_countryoid11522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDCOUNTRY_in_countryoid11522	= { FOLLOW_OIDCOUNTRY_in_countryoid11522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_serialoid11544  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_serialoid11544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_serialoid11544	= { FOLLOW_OIDTag_in_serialoid11544_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDSERIAL_in_serialoid11546  */
static	ANTLR3_BITWORD FOLLOW_OIDSERIAL_in_serialoid11546_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDSERIAL_in_serialoid11546	= { FOLLOW_OIDSERIAL_in_serialoid11546_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_pseudooid11568  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_pseudooid11568_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_pseudooid11568	= { FOLLOW_OIDTag_in_pseudooid11568_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDPSEUDO_in_pseudooid11570  */
static	ANTLR3_BITWORD FOLLOW_OIDPSEUDO_in_pseudooid11570_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDPSEUDO_in_pseudooid11570	= { FOLLOW_OIDPSEUDO_in_pseudooid11570_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_rsapkoid11592  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_rsapkoid11592_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_rsapkoid11592	= { FOLLOW_OIDTag_in_rsapkoid11592_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSAPKOID_in_rsapkoid11594  */
static	ANTLR3_BITWORD FOLLOW_RSAPKOID_in_rsapkoid11594_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RSAPKOID_in_rsapkoid11594	= { FOLLOW_RSAPKOID_in_rsapkoid11594_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_dsapkoid11616  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_dsapkoid11616_bits[]	= { ANTLR3_UINT64_LIT(0x0000000100000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_dsapkoid11616	= { FOLLOW_OIDTag_in_dsapkoid11616_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DSAPKOID_in_dsapkoid11618  */
static	ANTLR3_BITWORD FOLLOW_DSAPKOID_in_dsapkoid11618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DSAPKOID_in_dsapkoid11618	= { FOLLOW_DSAPKOID_in_dsapkoid11618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_dhpkoid11641  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_dhpkoid11641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_dhpkoid11641	= { FOLLOW_OIDTag_in_dhpkoid11641_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DHPKOID_in_dhpkoid11643  */
static	ANTLR3_BITWORD FOLLOW_DHPKOID_in_dhpkoid11643_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DHPKOID_in_dhpkoid11643	= { FOLLOW_DHPKOID_in_dhpkoid11643_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_keapkoid11665  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_keapkoid11665_bits[]	= { ANTLR3_UINT64_LIT(0x0200000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_keapkoid11665	= { FOLLOW_OIDTag_in_keapkoid11665_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_KEAPKOID_in_keapkoid11667  */
static	ANTLR3_BITWORD FOLLOW_KEAPKOID_in_keapkoid11667_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_KEAPKOID_in_keapkoid11667	= { FOLLOW_KEAPKOID_in_keapkoid11667_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_ecpkoid11689  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_ecpkoid11689_bits[]	= { ANTLR3_UINT64_LIT(0x0000002000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_ecpkoid11689	= { FOLLOW_OIDTag_in_ecpkoid11689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ECPKOID_in_ecpkoid11691  */
static	ANTLR3_BITWORD FOLLOW_ECPKOID_in_ecpkoid11691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ECPKOID_in_ecpkoid11691	= { FOLLOW_ECPKOID_in_ecpkoid11691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_primeoid11715  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_primeoid11715_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_primeoid11715	= { FOLLOW_OIDTag_in_primeoid11715_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRIMEOID_in_primeoid11717  */
static	ANTLR3_BITWORD FOLLOW_PRIMEOID_in_primeoid11717_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PRIMEOID_in_primeoid11717	= { FOLLOW_PRIMEOID_in_primeoid11717_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_basis2oid11740  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_basis2oid11740_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_basis2oid11740	= { FOLLOW_OIDTag_in_basis2oid11740_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BASIS2OID_in_basis2oid11742  */
static	ANTLR3_BITWORD FOLLOW_BASIS2OID_in_basis2oid11742_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_BASIS2OID_in_basis2oid11742	= { FOLLOW_BASIS2OID_in_basis2oid11742_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_gnoid11765  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_gnoid11765_bits[]	= { ANTLR3_UINT64_LIT(0x0000040000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_gnoid11765	= { FOLLOW_OIDTag_in_gnoid11765_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GNBASISOID_in_gnoid11767  */
static	ANTLR3_BITWORD FOLLOW_GNBASISOID_in_gnoid11767_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GNBASISOID_in_gnoid11767	= { FOLLOW_GNBASISOID_in_gnoid11767_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_tpoid11787  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_tpoid11787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_tpoid11787	= { FOLLOW_OIDTag_in_tpoid11787_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TPBASISOID_in_tpoid11789  */
static	ANTLR3_BITWORD FOLLOW_TPBASISOID_in_tpoid11789_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TPBASISOID_in_tpoid11789	= { FOLLOW_TPBASISOID_in_tpoid11789_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_ppoid11809  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_ppoid11809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000400000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_ppoid11809	= { FOLLOW_OIDTag_in_ppoid11809_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PPBASISOID_in_ppoid11811  */
static	ANTLR3_BITWORD FOLLOW_PPBASISOID_in_ppoid11811_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PPBASISOID_in_ppoid11811	= { FOLLOW_PPBASISOID_in_ppoid11811_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha1oid11834  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha1oid11834_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha1oid11834	= { FOLLOW_OIDTag_in_sha1oid11834_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA1OID_in_sha1oid11836  */
static	ANTLR3_BITWORD FOLLOW_SHA1OID_in_sha1oid11836_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA1OID_in_sha1oid11836	= { FOLLOW_SHA1OID_in_sha1oid11836_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha224oid11855  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha224oid11855_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0008000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha224oid11855	= { FOLLOW_OIDTag_in_sha224oid11855_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA224OID_in_sha224oid11857  */
static	ANTLR3_BITWORD FOLLOW_SHA224OID_in_sha224oid11857_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA224OID_in_sha224oid11857	= { FOLLOW_SHA224OID_in_sha224oid11857_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha256oid11879  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha256oid11879_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0080000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha256oid11879	= { FOLLOW_OIDTag_in_sha256oid11879_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA256OID_in_sha256oid11881  */
static	ANTLR3_BITWORD FOLLOW_SHA256OID_in_sha256oid11881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA256OID_in_sha256oid11881	= { FOLLOW_SHA256OID_in_sha256oid11881_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha384oid11901  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha384oid11901_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha384oid11901	= { FOLLOW_OIDTag_in_sha384oid11901_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA384OID_in_sha384oid11903  */
static	ANTLR3_BITWORD FOLLOW_SHA384OID_in_sha384oid11903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA384OID_in_sha384oid11903	= { FOLLOW_SHA384OID_in_sha384oid11903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha512oid11923  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha512oid11923_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha512oid11923	= { FOLLOW_OIDTag_in_sha512oid11923_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA512OID_in_sha512oid11925  */
static	ANTLR3_BITWORD FOLLOW_SHA512OID_in_sha512oid11925_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA512OID_in_sha512oid11925	= { FOLLOW_SHA512OID_in_sha512oid11925_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_mgf1oid11945  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_mgf1oid11945_bits[]	= { ANTLR3_UINT64_LIT(0x4000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_mgf1oid11945	= { FOLLOW_OIDTag_in_mgf1oid11945_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MGF1OID_in_mgf1oid11947  */
static	ANTLR3_BITWORD FOLLOW_MGF1OID_in_mgf1oid11947_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MGF1OID_in_mgf1oid11947	= { FOLLOW_MGF1OID_in_mgf1oid11947_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_rsapssoid11967  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_rsapssoid11967_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000080000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_rsapssoid11967	= { FOLLOW_OIDTag_in_rsapssoid11967_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSAPSSOID_in_rsapssoid11969  */
static	ANTLR3_BITWORD FOLLOW_RSAPSSOID_in_rsapssoid11969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RSAPSSOID_in_rsapssoid11969	= { FOLLOW_RSAPSSOID_in_rsapssoid11969_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_rsaoaepoid11989  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_rsaoaepoid11989_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000010000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_rsaoaepoid11989	= { FOLLOW_OIDTag_in_rsaoaepoid11989_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RSAOAEPOID_in_rsaoaepoid11991  */
static	ANTLR3_BITWORD FOLLOW_RSAOAEPOID_in_rsaoaepoid11991_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RSAOAEPOID_in_rsaoaepoid11991	= { FOLLOW_RSAOAEPOID_in_rsaoaepoid11991_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_pspecoid12013  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_pspecoid12013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_pspecoid12013	= { FOLLOW_OIDTag_in_pspecoid12013_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PSPECOID_in_pspecoid12015  */
static	ANTLR3_BITWORD FOLLOW_PSPECOID_in_pspecoid12015_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_PSPECOID_in_pspecoid12015	= { FOLLOW_PSPECOID_in_pspecoid12015_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_md2rsaoid12036  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_md2rsaoid12036_bits[]	= { ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_md2rsaoid12036	= { FOLLOW_OIDTag_in_md2rsaoid12036_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MD2RSAOID_in_md2rsaoid12038  */
static	ANTLR3_BITWORD FOLLOW_MD2RSAOID_in_md2rsaoid12038_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MD2RSAOID_in_md2rsaoid12038	= { FOLLOW_MD2RSAOID_in_md2rsaoid12038_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_md5rsaoid12059  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_md5rsaoid12059_bits[]	= { ANTLR3_UINT64_LIT(0x2000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_md5rsaoid12059	= { FOLLOW_OIDTag_in_md5rsaoid12059_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_MD5RSAOID_in_md5rsaoid12061  */
static	ANTLR3_BITWORD FOLLOW_MD5RSAOID_in_md5rsaoid12061_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_MD5RSAOID_in_md5rsaoid12061	= { FOLLOW_MD5RSAOID_in_md5rsaoid12061_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha1rsaoid12081  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha1rsaoid12081_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0001000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha1rsaoid12081	= { FOLLOW_OIDTag_in_sha1rsaoid12081_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA1RSAOID_in_sha1rsaoid12083  */
static	ANTLR3_BITWORD FOLLOW_SHA1RSAOID_in_sha1rsaoid12083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA1RSAOID_in_sha1rsaoid12083	= { FOLLOW_SHA1RSAOID_in_sha1rsaoid12083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha224rsaoid12104  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha224rsaoid12104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0010000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha224rsaoid12104	= { FOLLOW_OIDTag_in_sha224rsaoid12104_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA224RSAOID_in_sha224rsaoid12106  */
static	ANTLR3_BITWORD FOLLOW_SHA224RSAOID_in_sha224rsaoid12106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA224RSAOID_in_sha224rsaoid12106	= { FOLLOW_SHA224RSAOID_in_sha224rsaoid12106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha256rsaoid12127  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha256rsaoid12127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0100000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha256rsaoid12127	= { FOLLOW_OIDTag_in_sha256rsaoid12127_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA256RSAOID_in_sha256rsaoid12129  */
static	ANTLR3_BITWORD FOLLOW_SHA256RSAOID_in_sha256rsaoid12129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA256RSAOID_in_sha256rsaoid12129	= { FOLLOW_SHA256RSAOID_in_sha256rsaoid12129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha384rsaoid12150  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha384rsaoid12150_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0800000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha384rsaoid12150	= { FOLLOW_OIDTag_in_sha384rsaoid12150_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA384RSAOID_in_sha384rsaoid12152  */
static	ANTLR3_BITWORD FOLLOW_SHA384RSAOID_in_sha384rsaoid12152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA384RSAOID_in_sha384rsaoid12152	= { FOLLOW_SHA384RSAOID_in_sha384rsaoid12152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha512rsaoid12173  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha512rsaoid12173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x4000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha512rsaoid12173	= { FOLLOW_OIDTag_in_sha512rsaoid12173_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA512RSAOID_in_sha512rsaoid12175  */
static	ANTLR3_BITWORD FOLLOW_SHA512RSAOID_in_sha512rsaoid12175_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA512RSAOID_in_sha512rsaoid12175	= { FOLLOW_SHA512RSAOID_in_sha512rsaoid12175_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha1dsaoid12194  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha1dsaoid12194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000200000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha1dsaoid12194	= { FOLLOW_OIDTag_in_sha1dsaoid12194_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA1DSAOID_in_sha1dsaoid12196  */
static	ANTLR3_BITWORD FOLLOW_SHA1DSAOID_in_sha1dsaoid12196_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA1DSAOID_in_sha1dsaoid12196	= { FOLLOW_SHA1DSAOID_in_sha1dsaoid12196_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha224dsaoid12219  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha224dsaoid12219_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0002000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha224dsaoid12219	= { FOLLOW_OIDTag_in_sha224dsaoid12219_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA224DSAOID_in_sha224dsaoid12221  */
static	ANTLR3_BITWORD FOLLOW_SHA224DSAOID_in_sha224dsaoid12221_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA224DSAOID_in_sha224dsaoid12221	= { FOLLOW_SHA224DSAOID_in_sha224dsaoid12221_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha256dsaoid12244  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha256dsaoid12244_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0020000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha256dsaoid12244	= { FOLLOW_OIDTag_in_sha256dsaoid12244_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA256DSAOID_in_sha256dsaoid12246  */
static	ANTLR3_BITWORD FOLLOW_SHA256DSAOID_in_sha256dsaoid12246_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA256DSAOID_in_sha256dsaoid12246	= { FOLLOW_SHA256DSAOID_in_sha256dsaoid12246_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha1ecoid12266  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha1ecoid12266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha1ecoid12266	= { FOLLOW_OIDTag_in_sha1ecoid12266_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA1ECOID_in_sha1ecoid12268  */
static	ANTLR3_BITWORD FOLLOW_SHA1ECOID_in_sha1ecoid12268_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA1ECOID_in_sha1ecoid12268	= { FOLLOW_SHA1ECOID_in_sha1ecoid12268_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha224ecoid12289  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha224ecoid12289_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0004000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha224ecoid12289	= { FOLLOW_OIDTag_in_sha224ecoid12289_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA224ECOID_in_sha224ecoid12291  */
static	ANTLR3_BITWORD FOLLOW_SHA224ECOID_in_sha224ecoid12291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA224ECOID_in_sha224ecoid12291	= { FOLLOW_SHA224ECOID_in_sha224ecoid12291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha256ecoid12312  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha256ecoid12312_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0040000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha256ecoid12312	= { FOLLOW_OIDTag_in_sha256ecoid12312_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA256ECOID_in_sha256ecoid12314  */
static	ANTLR3_BITWORD FOLLOW_SHA256ECOID_in_sha256ecoid12314_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA256ECOID_in_sha256ecoid12314	= { FOLLOW_SHA256ECOID_in_sha256ecoid12314_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha384ecoid12334  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha384ecoid12334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0200000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha384ecoid12334	= { FOLLOW_OIDTag_in_sha384ecoid12334_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA384ECOID_in_sha384ecoid12336  */
static	ANTLR3_BITWORD FOLLOW_SHA384ECOID_in_sha384ecoid12336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA384ECOID_in_sha384ecoid12336	= { FOLLOW_SHA384ECOID_in_sha384ecoid12336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_sha512ecoid12358  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_sha512ecoid12358_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x1000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_sha512ecoid12358	= { FOLLOW_OIDTag_in_sha512ecoid12358_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SHA512ECOID_in_sha512ecoid12360  */
static	ANTLR3_BITWORD FOLLOW_SHA512ECOID_in_sha512ecoid12360_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SHA512ECOID_in_sha512ecoid12360	= { FOLLOW_SHA512ECOID_in_sha512ecoid12360_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_gost94pkoid12383  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_gost94pkoid12383_bits[]	= { ANTLR3_UINT64_LIT(0x0000200000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_gost94pkoid12383	= { FOLLOW_OIDTag_in_gost94pkoid12383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GOST94PK_in_gost94pkoid12385  */
static	ANTLR3_BITWORD FOLLOW_GOST94PK_in_gost94pkoid12385_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GOST94PK_in_gost94pkoid12385	= { FOLLOW_GOST94PK_in_gost94pkoid12385_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_gost01pkoid12407  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_gost01pkoid12407_bits[]	= { ANTLR3_UINT64_LIT(0x0000080000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_gost01pkoid12407	= { FOLLOW_OIDTag_in_gost01pkoid12407_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GOST01PK_in_gost01pkoid12409  */
static	ANTLR3_BITWORD FOLLOW_GOST01PK_in_gost01pkoid12409_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GOST01PK_in_gost01pkoid12409	= { FOLLOW_GOST01PK_in_gost01pkoid12409_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_gost94signoid12429  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_gost94signoid12429_bits[]	= { ANTLR3_UINT64_LIT(0x0000400000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_gost94signoid12429	= { FOLLOW_OIDTag_in_gost94signoid12429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GOST94SIGN_in_gost94signoid12431  */
static	ANTLR3_BITWORD FOLLOW_GOST94SIGN_in_gost94signoid12431_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GOST94SIGN_in_gost94signoid12431	= { FOLLOW_GOST94SIGN_in_gost94signoid12431_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_gost01signoid12451  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_gost01signoid12451_bits[]	= { ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_gost01signoid12451	= { FOLLOW_OIDTag_in_gost01signoid12451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GOST01SIGN_in_gost01signoid12453  */
static	ANTLR3_BITWORD FOLLOW_GOST01SIGN_in_gost01signoid12453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_GOST01SIGN_in_gost01signoid12453	= { FOLLOW_GOST01SIGN_in_gost01signoid12453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_serverauthoid12476  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_serverauthoid12476_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000100000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_serverauthoid12476	= { FOLLOW_OIDTag_in_serverauthoid12476_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SERVERAUTHOID_in_serverauthoid12478  */
static	ANTLR3_BITWORD FOLLOW_SERVERAUTHOID_in_serverauthoid12478_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SERVERAUTHOID_in_serverauthoid12478	= { FOLLOW_SERVERAUTHOID_in_serverauthoid12478_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_clientauthoid12498  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_clientauthoid12498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_clientauthoid12498	= { FOLLOW_OIDTag_in_clientauthoid12498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CLIENTAUTHOID_in_clientauthoid12500  */
static	ANTLR3_BITWORD FOLLOW_CLIENTAUTHOID_in_clientauthoid12500_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CLIENTAUTHOID_in_clientauthoid12500	= { FOLLOW_CLIENTAUTHOID_in_clientauthoid12500_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_codesignoid12520  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_codesignoid12520_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_codesignoid12520	= { FOLLOW_OIDTag_in_codesignoid12520_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CODESIGNOID_in_codesignoid12522  */
static	ANTLR3_BITWORD FOLLOW_CODESIGNOID_in_codesignoid12522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_CODESIGNOID_in_codesignoid12522	= { FOLLOW_CODESIGNOID_in_codesignoid12522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_emailprotectoid12542  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_emailprotectoid12542_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_emailprotectoid12542	= { FOLLOW_OIDTag_in_emailprotectoid12542_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EMAILPROTECTOID_in_emailprotectoid12544  */
static	ANTLR3_BITWORD FOLLOW_EMAILPROTECTOID_in_emailprotectoid12544_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EMAILPROTECTOID_in_emailprotectoid12544	= { FOLLOW_EMAILPROTECTOID_in_emailprotectoid12544_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_timestampoid12567  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_timestampoid12567_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_timestampoid12567	= { FOLLOW_OIDTag_in_timestampoid12567_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TIMESTAMPOID_in_timestampoid12569  */
static	ANTLR3_BITWORD FOLLOW_TIMESTAMPOID_in_timestampoid12569_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TIMESTAMPOID_in_timestampoid12569	= { FOLLOW_TIMESTAMPOID_in_timestampoid12569_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_ocspsignoid12589  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_ocspsignoid12589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000000000000008) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_ocspsignoid12589	= { FOLLOW_OIDTag_in_ocspsignoid12589_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OCSPSIGNOID_in_ocspsignoid12591  */
static	ANTLR3_BITWORD FOLLOW_OCSPSIGNOID_in_ocspsignoid12591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_OCSPSIGNOID_in_ocspsignoid12591	= { FOLLOW_OCSPSIGNOID_in_ocspsignoid12591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_anyusageoid12615  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_anyusageoid12615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000040) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_anyusageoid12615	= { FOLLOW_OIDTag_in_anyusageoid12615_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ANYUSAGEOID_in_anyusageoid12617  */
static	ANTLR3_BITWORD FOLLOW_ANYUSAGEOID_in_anyusageoid12617_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ANYUSAGEOID_in_anyusageoid12617	= { FOLLOW_ANYUSAGEOID_in_anyusageoid12617_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_anypolicyoid12639  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_anypolicyoid12639_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000020) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_anypolicyoid12639	= { FOLLOW_OIDTag_in_anypolicyoid12639_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ANYPOLICYOID_in_anypolicyoid12641  */
static	ANTLR3_BITWORD FOLLOW_ANYPOLICYOID_in_anypolicyoid12641_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ANYPOLICYOID_in_anypolicyoid12641	= { FOLLOW_ANYPOLICYOID_in_anypolicyoid12641_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_legacyemailoid12664  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_legacyemailoid12664_bits[]	= { ANTLR3_UINT64_LIT(0x0400000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_legacyemailoid12664	= { FOLLOW_OIDTag_in_legacyemailoid12664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LEGACYEMAILOID_in_legacyemailoid12666  */
static	ANTLR3_BITWORD FOLLOW_LEGACYEMAILOID_in_legacyemailoid12666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LEGACYEMAILOID_in_legacyemailoid12666	= { FOLLOW_LEGACYEMAILOID_in_legacyemailoid12666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_ecdhoid12687  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_ecdhoid12687_bits[]	= { ANTLR3_UINT64_LIT(0x0000000200000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_ecdhoid12687	= { FOLLOW_OIDTag_in_ecdhoid12687_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ECDHOID_in_ecdhoid12689  */
static	ANTLR3_BITWORD FOLLOW_ECDHOID_in_ecdhoid12689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ECDHOID_in_ecdhoid12689	= { FOLLOW_ECDHOID_in_ecdhoid12689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OIDTag_in_ecmqvoid12711  */
static	ANTLR3_BITWORD FOLLOW_OIDTag_in_ecmqvoid12711_bits[]	= { ANTLR3_UINT64_LIT(0x0000000800000000) };
static  ANTLR3_BITSET_LIST FOLLOW_OIDTag_in_ecmqvoid12711	= { FOLLOW_OIDTag_in_ecmqvoid12711_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ECMQVOID_in_ecmqvoid12713  */
static	ANTLR3_BITWORD FOLLOW_ECMQVOID_in_ecmqvoid12713_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ECMQVOID_in_ecmqvoid12713	= { FOLLOW_ECMQVOID_in_ecmqvoid12713_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PrintStringTag_in_printString12732  */
static	ANTLR3_BITWORD FOLLOW_PrintStringTag_in_printString12732_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PrintStringTag_in_printString12732	= { FOLLOW_PrintStringTag_in_printString12732_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printable_in_printString12734  */
static	ANTLR3_BITWORD FOLLOW_printable_in_printString12734_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printable_in_printString12734	= { FOLLOW_printable_in_printString12734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IA5StringTag_in_ia5String12757  */
static	ANTLR3_BITWORD FOLLOW_IA5StringTag_in_ia5String12757_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IA5StringTag_in_ia5String12757	= { FOLLOW_IA5StringTag_in_ia5String12757_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printable_in_ia5String12759  */
static	ANTLR3_BITWORD FOLLOW_printable_in_ia5String12759_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printable_in_ia5String12759	= { FOLLOW_printable_in_ia5String12759_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UTCTag_in_utc12782  */
static	ANTLR3_BITWORD FOLLOW_UTCTag_in_utc12782_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_UTCTag_in_utc12782	= { FOLLOW_UTCTag_in_utc12782_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printable_in_utc12784  */
static	ANTLR3_BITWORD FOLLOW_printable_in_utc12784_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printable_in_utc12784	= { FOLLOW_printable_in_utc12784_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GeneralTimeTag_in_genTime12807  */
static	ANTLR3_BITWORD FOLLOW_GeneralTimeTag_in_genTime12807_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GeneralTimeTag_in_genTime12807	= { FOLLOW_GeneralTimeTag_in_genTime12807_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printable_in_genTime12809  */
static	ANTLR3_BITWORD FOLLOW_printable_in_genTime12809_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printable_in_genTime12809	= { FOLLOW_printable_in_genTime12809_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TrueTag_in_truevalue12829  */
static	ANTLR3_BITWORD FOLLOW_TrueTag_in_truevalue12829_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TrueTag_in_truevalue12829	= { FOLLOW_TrueTag_in_truevalue12829_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_FalseTag_in_falsevalue12848  */
static	ANTLR3_BITWORD FOLLOW_FalseTag_in_falsevalue12848_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_FalseTag_in_falsevalue12848	= { FOLLOW_FalseTag_in_falsevalue12848_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UTF8Tag_in_utf8String12868  */
static	ANTLR3_BITWORD FOLLOW_UTF8Tag_in_utf8String12868_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_UTF8Tag_in_utf8String12868	= { FOLLOW_UTF8Tag_in_utf8String12868_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printable_in_utf8String12870  */
static	ANTLR3_BITWORD FOLLOW_printable_in_utf8String12870_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printable_in_utf8String12870	= { FOLLOW_printable_in_utf8String12870_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TeletexTag_in_teletexString12894  */
static	ANTLR3_BITWORD FOLLOW_TeletexTag_in_teletexString12894_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_TeletexTag_in_teletexString12894	= { FOLLOW_TeletexTag_in_teletexString12894_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printable_in_teletexString12896  */
static	ANTLR3_BITWORD FOLLOW_printable_in_teletexString12896_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printable_in_teletexString12896	= { FOLLOW_printable_in_teletexString12896_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BMPTag_in_bmpString12919  */
static	ANTLR3_BITWORD FOLLOW_BMPTag_in_bmpString12919_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BMPTag_in_bmpString12919	= { FOLLOW_BMPTag_in_bmpString12919_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_bmpString12921  */
static	ANTLR3_BITWORD FOLLOW_val_in_bmpString12921_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_bmpString12921	= { FOLLOW_val_in_bmpString12921_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_UniverStringTag_in_univerString12944  */
static	ANTLR3_BITWORD FOLLOW_UniverStringTag_in_univerString12944_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_UniverStringTag_in_univerString12944	= { FOLLOW_UniverStringTag_in_univerString12944_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printable_in_univerString12946  */
static	ANTLR3_BITWORD FOLLOW_printable_in_univerString12946_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printable_in_univerString12946	= { FOLLOW_printable_in_univerString12946_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VisibleStringTag_in_visibleString12969  */
static	ANTLR3_BITWORD FOLLOW_VisibleStringTag_in_visibleString12969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_VisibleStringTag_in_visibleString12969	= { FOLLOW_VisibleStringTag_in_visibleString12969_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printable_in_visibleString12971  */
static	ANTLR3_BITWORD FOLLOW_printable_in_visibleString12971_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printable_in_visibleString12971	= { FOLLOW_printable_in_visibleString12971_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NumericStringTag_in_numericString12995  */
static	ANTLR3_BITWORD FOLLOW_NumericStringTag_in_numericString12995_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_NumericStringTag_in_numericString12995	= { FOLLOW_NumericStringTag_in_numericString12995_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_printable_in_numericString12997  */
static	ANTLR3_BITWORD FOLLOW_printable_in_numericString12997_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_printable_in_numericString12997	= { FOLLOW_printable_in_numericString12997_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GeneralStringTag_in_generalString13017  */
static	ANTLR3_BITWORD FOLLOW_GeneralStringTag_in_generalString13017_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GeneralStringTag_in_generalString13017	= { FOLLOW_GeneralStringTag_in_generalString13017_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_generalString13019  */
static	ANTLR3_BITWORD FOLLOW_val_in_generalString13019_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_generalString13019	= { FOLLOW_val_in_generalString13019_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GraphicalStringTag_in_graphicString13039  */
static	ANTLR3_BITWORD FOLLOW_GraphicalStringTag_in_graphicString13039_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GraphicalStringTag_in_graphicString13039	= { FOLLOW_GraphicalStringTag_in_graphicString13039_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_graphicString13041  */
static	ANTLR3_BITWORD FOLLOW_val_in_graphicString13041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_graphicString13041	= { FOLLOW_val_in_graphicString13041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VideoStringTag_in_videoString13060  */
static	ANTLR3_BITWORD FOLLOW_VideoStringTag_in_videoString13060_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_VideoStringTag_in_videoString13060	= { FOLLOW_VideoStringTag_in_videoString13060_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_videoString13062  */
static	ANTLR3_BITWORD FOLLOW_val_in_videoString13062_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_videoString13062	= { FOLLOW_val_in_videoString13062_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Null_in_null13080  */
static	ANTLR3_BITWORD FOLLOW_Null_in_null13080_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_Null_in_null13080	= { FOLLOW_Null_in_null13080_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SequenceTag_in_sequenceTag13102  */
static	ANTLR3_BITWORD FOLLOW_SequenceTag_in_sequenceTag13102_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SequenceTag_in_sequenceTag13102	= { FOLLOW_SequenceTag_in_sequenceTag13102_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SetTag_in_set13123  */
static	ANTLR3_BITWORD FOLLOW_SetTag_in_set13123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SetTag_in_set13123	= { FOLLOW_SetTag_in_set13123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedOctetTag_in_constructedOctetString13145  */
static	ANTLR3_BITWORD FOLLOW_ConstructedOctetTag_in_constructedOctetString13145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedOctetTag_in_constructedOctetString13145	= { FOLLOW_ConstructedOctetTag_in_constructedOctetString13145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedBitStringTag_in_constructedBitString13168  */
static	ANTLR3_BITWORD FOLLOW_ConstructedBitStringTag_in_constructedBitString13168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedBitStringTag_in_constructedBitString13168	= { FOLLOW_ConstructedBitStringTag_in_constructedBitString13168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedTag0_in_constructedTag013193  */
static	ANTLR3_BITWORD FOLLOW_ConstructedTag0_in_constructedTag013193_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedTag0_in_constructedTag013193	= { FOLLOW_ConstructedTag0_in_constructedTag013193_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_onlyTag0_in_tag013218  */
static	ANTLR3_BITWORD FOLLOW_onlyTag0_in_tag013218_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_onlyTag0_in_tag013218	= { FOLLOW_onlyTag0_in_tag013218_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt1_in_tag013229  */
static	ANTLR3_BITWORD FOLLOW_tagInt1_in_tag013229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt1_in_tag013229	= { FOLLOW_tagInt1_in_tag013229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt2_in_tag013236  */
static	ANTLR3_BITWORD FOLLOW_tagInt2_in_tag013236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt2_in_tag013236	= { FOLLOW_tagInt2_in_tag013236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt3_in_tag013243  */
static	ANTLR3_BITWORD FOLLOW_tagInt3_in_tag013243_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt3_in_tag013243	= { FOLLOW_tagInt3_in_tag013243_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt4_in_tag013250  */
static	ANTLR3_BITWORD FOLLOW_tagInt4_in_tag013250_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt4_in_tag013250	= { FOLLOW_tagInt4_in_tag013250_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt5_in_tag013257  */
static	ANTLR3_BITWORD FOLLOW_tagInt5_in_tag013257_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt5_in_tag013257	= { FOLLOW_tagInt5_in_tag013257_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt6_in_tag013264  */
static	ANTLR3_BITWORD FOLLOW_tagInt6_in_tag013264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt6_in_tag013264	= { FOLLOW_tagInt6_in_tag013264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt7_in_tag013271  */
static	ANTLR3_BITWORD FOLLOW_tagInt7_in_tag013271_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt7_in_tag013271	= { FOLLOW_tagInt7_in_tag013271_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt8_in_tag013278  */
static	ANTLR3_BITWORD FOLLOW_tagInt8_in_tag013278_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt8_in_tag013278	= { FOLLOW_tagInt8_in_tag013278_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt9_in_tag013285  */
static	ANTLR3_BITWORD FOLLOW_tagInt9_in_tag013285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt9_in_tag013285	= { FOLLOW_tagInt9_in_tag013285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt10_in_tag013292  */
static	ANTLR3_BITWORD FOLLOW_tagInt10_in_tag013292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt10_in_tag013292	= { FOLLOW_tagInt10_in_tag013292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt11_in_tag013299  */
static	ANTLR3_BITWORD FOLLOW_tagInt11_in_tag013299_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt11_in_tag013299	= { FOLLOW_tagInt11_in_tag013299_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt12_in_tag013306  */
static	ANTLR3_BITWORD FOLLOW_tagInt12_in_tag013306_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt12_in_tag013306	= { FOLLOW_tagInt12_in_tag013306_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt13_in_tag013313  */
static	ANTLR3_BITWORD FOLLOW_tagInt13_in_tag013313_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt13_in_tag013313	= { FOLLOW_tagInt13_in_tag013313_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt14_in_tag013320  */
static	ANTLR3_BITWORD FOLLOW_tagInt14_in_tag013320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt14_in_tag013320	= { FOLLOW_tagInt14_in_tag013320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt15_in_tag013327  */
static	ANTLR3_BITWORD FOLLOW_tagInt15_in_tag013327_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt15_in_tag013327	= { FOLLOW_tagInt15_in_tag013327_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt16_in_tag013334  */
static	ANTLR3_BITWORD FOLLOW_tagInt16_in_tag013334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt16_in_tag013334	= { FOLLOW_tagInt16_in_tag013334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt17_in_tag013341  */
static	ANTLR3_BITWORD FOLLOW_tagInt17_in_tag013341_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt17_in_tag013341	= { FOLLOW_tagInt17_in_tag013341_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt18_in_tag013348  */
static	ANTLR3_BITWORD FOLLOW_tagInt18_in_tag013348_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt18_in_tag013348	= { FOLLOW_tagInt18_in_tag013348_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt19_in_tag013355  */
static	ANTLR3_BITWORD FOLLOW_tagInt19_in_tag013355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt19_in_tag013355	= { FOLLOW_tagInt19_in_tag013355_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt20_in_tag013362  */
static	ANTLR3_BITWORD FOLLOW_tagInt20_in_tag013362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt20_in_tag013362	= { FOLLOW_tagInt20_in_tag013362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt21_in_tag013369  */
static	ANTLR3_BITWORD FOLLOW_tagInt21_in_tag013369_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt21_in_tag013369	= { FOLLOW_tagInt21_in_tag013369_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt22_in_tag013376  */
static	ANTLR3_BITWORD FOLLOW_tagInt22_in_tag013376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt22_in_tag013376	= { FOLLOW_tagInt22_in_tag013376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_tagInt23_in_tag013383  */
static	ANTLR3_BITWORD FOLLOW_tagInt23_in_tag013383_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_tagInt23_in_tag013383	= { FOLLOW_tagInt23_in_tag013383_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Tag0_in_onlyTag013409  */
static	ANTLR3_BITWORD FOLLOW_Tag0_in_onlyTag013409_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Tag0_in_onlyTag013409	= { FOLLOW_Tag0_in_onlyTag013409_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_onlyTag013411  */
static	ANTLR3_BITWORD FOLLOW_val_in_onlyTag013411_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_onlyTag013411	= { FOLLOW_val_in_onlyTag013411_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedTag1_in_constructedTag113429  */
static	ANTLR3_BITWORD FOLLOW_ConstructedTag1_in_constructedTag113429_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedTag1_in_constructedTag113429	= { FOLLOW_ConstructedTag1_in_constructedTag113429_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Tag1_in_tag113448  */
static	ANTLR3_BITWORD FOLLOW_Tag1_in_tag113448_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Tag1_in_tag113448	= { FOLLOW_Tag1_in_tag113448_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_tag113451  */
static	ANTLR3_BITWORD FOLLOW_val_in_tag113451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_tag113451	= { FOLLOW_val_in_tag113451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AppTag1_in_appTag113474  */
static	ANTLR3_BITWORD FOLLOW_AppTag1_in_appTag113474_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AppTag1_in_appTag113474	= { FOLLOW_AppTag1_in_appTag113474_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AppTag2_in_appTag213491  */
static	ANTLR3_BITWORD FOLLOW_AppTag2_in_appTag213491_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AppTag2_in_appTag213491	= { FOLLOW_AppTag2_in_appTag213491_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedTag2_in_constructedTag213509  */
static	ANTLR3_BITWORD FOLLOW_ConstructedTag2_in_constructedTag213509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedTag2_in_constructedTag213509	= { FOLLOW_ConstructedTag2_in_constructedTag213509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Tag2_in_tag213528  */
static	ANTLR3_BITWORD FOLLOW_Tag2_in_tag213528_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Tag2_in_tag213528	= { FOLLOW_Tag2_in_tag213528_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_tag213531  */
static	ANTLR3_BITWORD FOLLOW_val_in_tag213531_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_tag213531	= { FOLLOW_val_in_tag213531_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedTag3_in_constructedTag313553  */
static	ANTLR3_BITWORD FOLLOW_ConstructedTag3_in_constructedTag313553_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedTag3_in_constructedTag313553	= { FOLLOW_ConstructedTag3_in_constructedTag313553_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Tag3_in_tag313572  */
static	ANTLR3_BITWORD FOLLOW_Tag3_in_tag313572_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Tag3_in_tag313572	= { FOLLOW_Tag3_in_tag313572_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_tag313575  */
static	ANTLR3_BITWORD FOLLOW_val_in_tag313575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_tag313575	= { FOLLOW_val_in_tag313575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedTag4_in_constructedTag413596  */
static	ANTLR3_BITWORD FOLLOW_ConstructedTag4_in_constructedTag413596_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedTag4_in_constructedTag413596	= { FOLLOW_ConstructedTag4_in_constructedTag413596_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Tag4_in_tag413615  */
static	ANTLR3_BITWORD FOLLOW_Tag4_in_tag413615_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Tag4_in_tag413615	= { FOLLOW_Tag4_in_tag413615_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_tag413618  */
static	ANTLR3_BITWORD FOLLOW_val_in_tag413618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_tag413618	= { FOLLOW_val_in_tag413618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedTag5_in_constructedTag513639  */
static	ANTLR3_BITWORD FOLLOW_ConstructedTag5_in_constructedTag513639_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedTag5_in_constructedTag513639	= { FOLLOW_ConstructedTag5_in_constructedTag513639_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Tag5_in_tag513658  */
static	ANTLR3_BITWORD FOLLOW_Tag5_in_tag513658_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Tag5_in_tag513658	= { FOLLOW_Tag5_in_tag513658_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_tag513661  */
static	ANTLR3_BITWORD FOLLOW_val_in_tag513661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_tag513661	= { FOLLOW_val_in_tag513661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedTag6_in_constructedTag613682  */
static	ANTLR3_BITWORD FOLLOW_ConstructedTag6_in_constructedTag613682_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedTag6_in_constructedTag613682	= { FOLLOW_ConstructedTag6_in_constructedTag613682_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Tag6_in_tag613701  */
static	ANTLR3_BITWORD FOLLOW_Tag6_in_tag613701_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Tag6_in_tag613701	= { FOLLOW_Tag6_in_tag613701_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_tag613704  */
static	ANTLR3_BITWORD FOLLOW_val_in_tag613704_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_tag613704	= { FOLLOW_val_in_tag613704_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedTag7_in_constructedTag713725  */
static	ANTLR3_BITWORD FOLLOW_ConstructedTag7_in_constructedTag713725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedTag7_in_constructedTag713725	= { FOLLOW_ConstructedTag7_in_constructedTag713725_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Tag7_in_tag713746  */
static	ANTLR3_BITWORD FOLLOW_Tag7_in_tag713746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Tag7_in_tag713746	= { FOLLOW_Tag7_in_tag713746_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_tag713749  */
static	ANTLR3_BITWORD FOLLOW_val_in_tag713749_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_tag713749	= { FOLLOW_val_in_tag713749_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ConstructedTag8_in_constructedTag813770  */
static	ANTLR3_BITWORD FOLLOW_ConstructedTag8_in_constructedTag813770_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ConstructedTag8_in_constructedTag813770	= { FOLLOW_ConstructedTag8_in_constructedTag813770_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_Tag8_in_tag813789  */
static	ANTLR3_BITWORD FOLLOW_Tag8_in_tag813789_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_Tag8_in_tag813789	= { FOLLOW_Tag8_in_tag813789_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_val_in_tag813792  */
static	ANTLR3_BITWORD FOLLOW_val_in_tag813792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_val_in_tag813792	= { FOLLOW_val_in_tag813792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt1_in_tagInt113812  */
static	ANTLR3_BITWORD FOLLOW_TagInt1_in_tagInt113812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt1_in_tagInt113812	= { FOLLOW_TagInt1_in_tagInt113812_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt2_in_tagInt213828  */
static	ANTLR3_BITWORD FOLLOW_TagInt2_in_tagInt213828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt2_in_tagInt213828	= { FOLLOW_TagInt2_in_tagInt213828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt3_in_tagInt313844  */
static	ANTLR3_BITWORD FOLLOW_TagInt3_in_tagInt313844_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt3_in_tagInt313844	= { FOLLOW_TagInt3_in_tagInt313844_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt4_in_tagInt413860  */
static	ANTLR3_BITWORD FOLLOW_TagInt4_in_tagInt413860_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt4_in_tagInt413860	= { FOLLOW_TagInt4_in_tagInt413860_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt5_in_tagInt513876  */
static	ANTLR3_BITWORD FOLLOW_TagInt5_in_tagInt513876_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt5_in_tagInt513876	= { FOLLOW_TagInt5_in_tagInt513876_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt6_in_tagInt613892  */
static	ANTLR3_BITWORD FOLLOW_TagInt6_in_tagInt613892_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt6_in_tagInt613892	= { FOLLOW_TagInt6_in_tagInt613892_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt7_in_tagInt713908  */
static	ANTLR3_BITWORD FOLLOW_TagInt7_in_tagInt713908_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt7_in_tagInt713908	= { FOLLOW_TagInt7_in_tagInt713908_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt8_in_tagInt813924  */
static	ANTLR3_BITWORD FOLLOW_TagInt8_in_tagInt813924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt8_in_tagInt813924	= { FOLLOW_TagInt8_in_tagInt813924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt9_in_tagInt913940  */
static	ANTLR3_BITWORD FOLLOW_TagInt9_in_tagInt913940_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt9_in_tagInt913940	= { FOLLOW_TagInt9_in_tagInt913940_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt10_in_tagInt1013956  */
static	ANTLR3_BITWORD FOLLOW_TagInt10_in_tagInt1013956_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt10_in_tagInt1013956	= { FOLLOW_TagInt10_in_tagInt1013956_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt11_in_tagInt1113972  */
static	ANTLR3_BITWORD FOLLOW_TagInt11_in_tagInt1113972_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt11_in_tagInt1113972	= { FOLLOW_TagInt11_in_tagInt1113972_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt12_in_tagInt1213988  */
static	ANTLR3_BITWORD FOLLOW_TagInt12_in_tagInt1213988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt12_in_tagInt1213988	= { FOLLOW_TagInt12_in_tagInt1213988_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt13_in_tagInt1314004  */
static	ANTLR3_BITWORD FOLLOW_TagInt13_in_tagInt1314004_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt13_in_tagInt1314004	= { FOLLOW_TagInt13_in_tagInt1314004_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt14_in_tagInt1414020  */
static	ANTLR3_BITWORD FOLLOW_TagInt14_in_tagInt1414020_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt14_in_tagInt1414020	= { FOLLOW_TagInt14_in_tagInt1414020_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt15_in_tagInt1514036  */
static	ANTLR3_BITWORD FOLLOW_TagInt15_in_tagInt1514036_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt15_in_tagInt1514036	= { FOLLOW_TagInt15_in_tagInt1514036_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt16_in_tagInt1614052  */
static	ANTLR3_BITWORD FOLLOW_TagInt16_in_tagInt1614052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt16_in_tagInt1614052	= { FOLLOW_TagInt16_in_tagInt1614052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt17_in_tagInt1714068  */
static	ANTLR3_BITWORD FOLLOW_TagInt17_in_tagInt1714068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt17_in_tagInt1714068	= { FOLLOW_TagInt17_in_tagInt1714068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt18_in_tagInt1814084  */
static	ANTLR3_BITWORD FOLLOW_TagInt18_in_tagInt1814084_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt18_in_tagInt1814084	= { FOLLOW_TagInt18_in_tagInt1814084_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt19_in_tagInt1914100  */
static	ANTLR3_BITWORD FOLLOW_TagInt19_in_tagInt1914100_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt19_in_tagInt1914100	= { FOLLOW_TagInt19_in_tagInt1914100_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt20_in_tagInt2014116  */
static	ANTLR3_BITWORD FOLLOW_TagInt20_in_tagInt2014116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt20_in_tagInt2014116	= { FOLLOW_TagInt20_in_tagInt2014116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt21_in_tagInt2114132  */
static	ANTLR3_BITWORD FOLLOW_TagInt21_in_tagInt2114132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt21_in_tagInt2114132	= { FOLLOW_TagInt21_in_tagInt2114132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt22_in_tagInt2214148  */
static	ANTLR3_BITWORD FOLLOW_TagInt22_in_tagInt2214148_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt22_in_tagInt2214148	= { FOLLOW_TagInt22_in_tagInt2214148_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_TagInt23_in_tagInt2314164  */
static	ANTLR3_BITWORD FOLLOW_TagInt23_in_tagInt2314164_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_TagInt23_in_tagInt2314164	= { FOLLOW_TagInt23_in_tagInt2314164_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRINTABLE_in_printable14198  */
static	ANTLR3_BITWORD FOLLOW_PRINTABLE_in_printable14198_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000001000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PRINTABLE_in_printable14198	= { FOLLOW_PRINTABLE_in_printable14198_bits, 2	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_VALUE_in_val14233  */
static	ANTLR3_BITWORD FOLLOW_VALUE_in_val14233_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_VALUE_in_val14233	= { FOLLOW_VALUE_in_val14233_bits, 3	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_PRINTABLE_in_val14238  */
static	ANTLR3_BITWORD FOLLOW_PRINTABLE_in_val14238_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002), ANTLR3_UINT64_LIT(0x0000001000000000), ANTLR3_UINT64_LIT(0x0000800000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_PRINTABLE_in_val14238	= { FOLLOW_PRINTABLE_in_val14238_bits, 3	};



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 2546:3: ( policyInfo )+
 */
static const ANTLR3_INT32 dfa294_eot[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa294_eof[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa294_min[7] =
    {
	129, 96, 4, -1, -1, 41, 41
    };
static const ANTLR3_INT32 dfa294_max[7] =
    {
	129, 96, 175, -1, -1, 175, 175
    };
static const ANTLR3_INT32 dfa294_accept[7] =
    {
	-1, -1, -1, 2, 1, -1, -1
    };
static const ANTLR3_INT32 dfa294_special[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa294_T_empty	    NULL

static const ANTLR3_INT32 dfa294_T0[] =
    {
	3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 3, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, 3, -1, -1, -1, -1, -1, -1, 3, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, 3, 
	-1, 3, 3, -1, 3, -1, -1, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, -1, -1, -1, 
	6, -1, -1, -1, -1, -1, -1, 3, -1, 3, 3, -1, 3, 3, 3, -1, 3, 3, 3, -1, 3, 
	3, -1, 3, 3, -1, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };
static const ANTLR3_INT32 dfa294_T1[] =
    {
	1
    };
static const ANTLR3_INT32 dfa294_T2[] =
    {
	2
    };
static const ANTLR3_INT32 dfa294_T3[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 
	-1, -1, -1, -1, -1, -1, -1, 5
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa294_transitions[] =
{
    dfa294_T1, dfa294_T2, dfa294_T0, _empty, _empty, dfa294_T3, dfa294_T3
};


/* Declare tracking structure for Cyclic DFA 294
 */
static
ANTLR3_CYCLIC_DFA cdfa294
    =	{
	    294,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()+ loopback of 2546:3: ( policyInfo )+",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa294_eot,	    /* EOT table			    */
	    dfa294_eof,	    /* EOF table			    */
	    dfa294_min,	    /* Minimum tokens for each state    */
	    dfa294_max,	    /* Maximum tokens for each state    */
	    dfa294_accept,	/* Accept table			    */
	    dfa294_special,	/* Special transition states	    */
	    dfa294_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 294
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 2575:42: ( qualifier )+
 */
static const ANTLR3_INT32 dfa298_eot[14] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa298_eof[14] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa298_min[14] =
    {
	129, 96, 4, -1, -1, 10, 10, 10, 10, 100, 0, 0, 0, 0
    };
static const ANTLR3_INT32 dfa298_max[14] =
    {
	129, 96, 175, -1, -1, 177, 177, 177, 177, 175, 0, 0, 0, 0
    };
static const ANTLR3_INT32 dfa298_accept[14] =
    {
	-1, -1, -1, 2, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa298_special[14] =
    {
	-1, -1, 2, -1, -1, 7, 1, 8, 5, -1, 3, 4, 0, 6
    };

/** Used when there is no transition table entry for a particular state */
#define dfa298_T_empty	    NULL

static const ANTLR3_INT32 dfa298_T0[] =
    {
	-1
    };
static const ANTLR3_INT32 dfa298_T1[] =
    {
	4, 4, 4, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, 4, 4, 
	4, -1, 4, 4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 4, 9, -1, -1, 6, -1, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 11, 4, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, -1, 4, 
	4, 4, -1, -1, -1, 5, 4, 4
    };
static const ANTLR3_INT32 dfa298_T2[] =
    {
	3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 3, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, 3, -1, -1, -1, -1, -1, -1, 3, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, 3, 
	-1, 3, 3, -1, 3, -1, -1, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, -1, -1, -1, 
	6, -1, -1, -1, -1, -1, -1, 3, -1, 3, 3, -1, 3, 3, 3, -1, 3, 3, 3, -1, 3, 
	3, -1, 3, 3, -1, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, 5
    };
static const ANTLR3_INT32 dfa298_T3[] =
    {
	13, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 12
    };
static const ANTLR3_INT32 dfa298_T4[] =
    {
	4, 4, 4, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, 4, 4, 
	4, -1, 4, 4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 4, 9, -1, -1, -1, -1, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, 4, 4, 
	4, -1, -1, -1, -1, 4, 4
    };
static const ANTLR3_INT32 dfa298_T5[] =
    {
	2
    };
static const ANTLR3_INT32 dfa298_T6[] =
    {
	1
    };
static const ANTLR3_INT32 dfa298_T7[] =
    {
	4, 4, 4, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, 4, 4, 
	4, -1, 4, 4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 4, 9, -1, -1, 6, -1, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 10, 4, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, -1, 4, 
	4, 4, -1, -1, -1, 5, 4, 4
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa298_transitions[] =
{
    dfa298_T6, dfa298_T5, dfa298_T2, _empty, _empty, dfa298_T7, dfa298_T1, 
    dfa298_T4, dfa298_T4, dfa298_T3, dfa298_T0, dfa298_T0, dfa298_T0, dfa298_T0
};

static ANTLR3_INT32 dfa298_sst(pRFC5280Parser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA298_12;

    	    ANTLR3_MARKER index298_12;


    		LA298_12 = LA(1);

    	     
    	        index298_12 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((sequence_pointer != NULL)) )
    	    {
    	        s = 4;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index298_12);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA298_6;

    	    ANTLR3_MARKER index298_6;


    		LA298_6 = LA(1);

    	     
    	        index298_6 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA298_6 == TrueTag) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA298_6 == FalseTag) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA298_6 == OctetTag) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA298_6 == VALUE) )
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA298_6 == PRINTABLE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA298_6 == SequenceTag) )
    	    {
    	        s = 11;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA298_6 >= BMPTag) && (LA298_6 <= BitStringTag)) || ((LA298_6 >= ConstructedOctetTag) && (LA298_6 <= ConstructedTag8)) || ((LA298_6 >= GeneralStringTag) && (LA298_6 <= GraphicalStringTag)) || ((LA298_6 >= IA5StringTag) && (LA298_6 <= IntTag)) || LA298_6 == Null || LA298_6 == OIDTag || LA298_6 == PrintStringTag || LA298_6 == SetTag || ((LA298_6 >= Tag0) && (LA298_6 <= TeletexTag)) || ((LA298_6 >= UTCTag) && (LA298_6 <= UniverStringTag)) || ((LA298_6 >= VideoStringTag) && (LA298_6 <= VisibleStringTag))) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index298_6);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA298_2;

    	    ANTLR3_MARKER index298_2;


    		LA298_2 = LA(1);

    	     
    	        index298_2 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (((LA298_2 >= AIAOID) && (LA298_2 <= ANYPOLICYOID)) || LA298_2 == GOST01SIGN || LA298_2 == GOST94SIGN || ((LA298_2 >= MD2RSAOID) && (LA298_2 <= MD5RSAOID)) || ((LA298_2 >= OIDAKI) && (LA298_2 <= OIDCERTPOL)) || LA298_2 == OIDCRL || ((LA298_2 >= OIDEXTKEY) && (LA298_2 <= OIDFRESHCRL)) || LA298_2 == OIDINHIBIT || ((LA298_2 >= OIDISSALT) && (LA298_2 <= OIDKEYUS)) || LA298_2 == OIDNAME || ((LA298_2 >= OIDPOLCONST) && (LA298_2 <= OIDPOLMAP)) || LA298_2 == OIDSKI || ((LA298_2 >= OIDSUBALT) && (LA298_2 <= OIDSUBDIR)) || LA298_2 == RSAPSSOID || ((LA298_2 >= SHA1DSAOID) && (LA298_2 <= SHA1ECOID)) || ((LA298_2 >= SHA1RSAOID) && (LA298_2 <= SHA224ECOID)) || ((LA298_2 >= SHA224RSAOID) && (LA298_2 <= SHA256ECOID)) || ((LA298_2 >= SHA256RSAOID) && (LA298_2 <= SHA384ECOID)) || ((LA298_2 >= SHA384RSAOID) && (LA298_2 <= SHA512ECOID)) || ((LA298_2 >= SHA512RSAOID) && (LA298_2 <= SIAOID))) )
    	    {
    	        s = 3;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (LA298_2 == CPSOID || LA298_2 == UNOTICEOID) )
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA298_2 == VALUE) )
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA298_2 == PRINTABLE) )
    	    {
    	        s = 6;
    	    }

    		 
    			SEEK(index298_2);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA298_10;

    	    ANTLR3_MARKER index298_10;


    		LA298_10 = LA(1);

    	     
    	        index298_10 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((sequence_pointer != NULL)) )
    	    {
    	        s = 4;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index298_10);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 4:

    	{
    	    ANTLR3_UINT32 LA298_11;

    	    ANTLR3_MARKER index298_11;


    		LA298_11 = LA(1);

    	     
    	        index298_11 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((sequence_pointer != NULL)) )
    	    {
    	        s = 4;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index298_11);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 5:

    	{
    	    ANTLR3_UINT32 LA298_8;

    	    ANTLR3_MARKER index298_8;


    		LA298_8 = LA(1);

    	     
    	        index298_8 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA298_8 == OctetTag) )
    	    {
    	        s = 9;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA298_8 >= BMPTag) && (LA298_8 <= BitStringTag)) || ((LA298_8 >= ConstructedOctetTag) && (LA298_8 <= ConstructedTag8)) || LA298_8 == FalseTag || ((LA298_8 >= GeneralStringTag) && (LA298_8 <= GraphicalStringTag)) || ((LA298_8 >= IA5StringTag) && (LA298_8 <= IntTag)) || LA298_8 == Null || LA298_8 == OIDTag || LA298_8 == PrintStringTag || ((LA298_8 >= SequenceTag) && (LA298_8 <= SetTag)) || ((LA298_8 >= Tag0) && (LA298_8 <= TrueTag)) || ((LA298_8 >= UTCTag) && (LA298_8 <= UniverStringTag)) || ((LA298_8 >= VideoStringTag) && (LA298_8 <= VisibleStringTag))) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index298_8);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 6:

    	{
    	    ANTLR3_UINT32 LA298_13;

    	    ANTLR3_MARKER index298_13;


    		LA298_13 = LA(1);

    	     
    	        index298_13 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((sequence_pointer != NULL)) )
    	    {
    	        s = 4;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index298_13);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 7:

    	{
    	    ANTLR3_UINT32 LA298_5;

    	    ANTLR3_MARKER index298_5;


    		LA298_5 = LA(1);

    	     
    	        index298_5 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA298_5 == TrueTag) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA298_5 == FalseTag) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA298_5 == OctetTag) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA298_5 == VALUE) )
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA298_5 == PRINTABLE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (LA298_5 == SequenceTag) )
    	    {
    	        s = 10;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA298_5 >= BMPTag) && (LA298_5 <= BitStringTag)) || ((LA298_5 >= ConstructedOctetTag) && (LA298_5 <= ConstructedTag8)) || ((LA298_5 >= GeneralStringTag) && (LA298_5 <= GraphicalStringTag)) || ((LA298_5 >= IA5StringTag) && (LA298_5 <= IntTag)) || LA298_5 == Null || LA298_5 == OIDTag || LA298_5 == PrintStringTag || LA298_5 == SetTag || ((LA298_5 >= Tag0) && (LA298_5 <= TeletexTag)) || ((LA298_5 >= UTCTag) && (LA298_5 <= UniverStringTag)) || ((LA298_5 >= VideoStringTag) && (LA298_5 <= VisibleStringTag))) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index298_5);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 8:

    	{
    	    ANTLR3_UINT32 LA298_7;

    	    ANTLR3_MARKER index298_7;


    		LA298_7 = LA(1);

    	     
    	        index298_7 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA298_7 == OctetTag) )
    	    {
    	        s = 9;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA298_7 >= BMPTag) && (LA298_7 <= BitStringTag)) || ((LA298_7 >= ConstructedOctetTag) && (LA298_7 <= ConstructedTag8)) || LA298_7 == FalseTag || ((LA298_7 >= GeneralStringTag) && (LA298_7 <= GraphicalStringTag)) || ((LA298_7 >= IA5StringTag) && (LA298_7 <= IntTag)) || LA298_7 == Null || LA298_7 == OIDTag || LA298_7 == PrintStringTag || ((LA298_7 >= SequenceTag) && (LA298_7 <= SetTag)) || ((LA298_7 >= Tag0) && (LA298_7 <= TrueTag)) || ((LA298_7 >= UTCTag) && (LA298_7 <= UniverStringTag)) || ((LA298_7 >= VideoStringTag) && (LA298_7 <= VisibleStringTag))) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index298_7);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"()+ loopback of 2575:42: ( qualifier )+";
    EXCEPTION->decisionNum  = 298;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 298
 */
static
ANTLR3_CYCLIC_DFA cdfa298
    =	{
	    298,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()+ loopback of 2575:42: ( qualifier )+",
	    (CDFA_SPECIAL_FUNC) dfa298_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa298_eot,	    /* EOT table			    */
	    dfa298_eof,	    /* EOF table			    */
	    dfa298_min,	    /* Minimum tokens for each state    */
	    dfa298_max,	    /* Maximum tokens for each state    */
	    dfa298_accept,	/* Accept table			    */
	    dfa298_special,	/* Special transition states	    */
	    dfa298_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 298
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 2737:3: ( attribute )+
 */
static const ANTLR3_INT32 dfa309_eot[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa309_eof[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa309_min[12] =
    {
	129, 96, 4, -1, -1, 10, 10, 10, 10, 100, 0, 0
    };
static const ANTLR3_INT32 dfa309_max[12] =
    {
	129, 96, 175, -1, -1, 177, 177, 177, 177, 175, 0, 0
    };
static const ANTLR3_INT32 dfa309_accept[12] =
    {
	-1, -1, -1, 2, 1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa309_special[12] =
    {
	-1, -1, 0, -1, -1, 1, 2, 3, 4, -1, 5, 6
    };

/** Used when there is no transition table entry for a particular state */
#define dfa309_T_empty	    NULL

static const ANTLR3_INT32 dfa309_T0[] =
    {
	11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 10
    };
static const ANTLR3_INT32 dfa309_T1[] =
    {
	1
    };
static const ANTLR3_INT32 dfa309_T2[] =
    {
	2
    };
static const ANTLR3_INT32 dfa309_T3[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 3, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3, 3, -1, 4, -1, -1, -1, -1, 3, 3, 3, 4, 4, 3, 4, 3, 3, 4, 4, 3, 4, 
	3, 3, 4, 3, 4, 4, 3, 3, 4, 4, 3, 4, 3, 3, 4, -1, -1, -1, -1, 6, -1, -1, 
	-1, -1, -1, -1, 3, -1, 3, 3, -1, 3, 3, 3, -1, 3, 3, 3, -1, 3, 3, -1, 3, 
	3, -1, 3, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };
static const ANTLR3_INT32 dfa309_T4[] =
    {
	4, 4, 4, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, 4, 4, 
	4, -1, 4, 4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 4, 9, -1, -1, 6, -1, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, -1, 4, 4, 
	4, -1, -1, -1, 5, 4, 4
    };
static const ANTLR3_INT32 dfa309_T5[] =
    {
	4, 4, 4, -1, -1, -1, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, 4, 4, 
	4, -1, 4, 4, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 4, 9, -1, -1, -1, -1, -1, 4, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, -1, 4, 4, 
	4, -1, -1, -1, -1, 4, 4
    };
static const ANTLR3_INT32 dfa309_T6[] =
    {
	-1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa309_transitions[] =
{
    dfa309_T1, dfa309_T2, dfa309_T3, _empty, _empty, dfa309_T4, dfa309_T4, 
    dfa309_T5, dfa309_T5, dfa309_T0, dfa309_T6, dfa309_T6
};

static ANTLR3_INT32 dfa309_sst(pRFC5280Parser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA309_2;

    	    ANTLR3_MARKER index309_2;


    		LA309_2 = LA(1);

    	     
    	        index309_2 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA309_2 == AIAOID || LA309_2 == GOST01SIGN || LA309_2 == GOST94SIGN || ((LA309_2 >= MD2RSAOID) && (LA309_2 <= MD5RSAOID)) || ((LA309_2 >= OIDAKI) && (LA309_2 <= OIDCERTPOL)) || LA309_2 == OIDCRL || ((LA309_2 >= OIDEXTKEY) && (LA309_2 <= OIDFRESHCRL)) || LA309_2 == OIDINHIBIT || ((LA309_2 >= OIDISSALT) && (LA309_2 <= OIDKEYUS)) || LA309_2 == OIDNAME || ((LA309_2 >= OIDPOLCONST) && (LA309_2 <= OIDPOLMAP)) || LA309_2 == OIDSKI || ((LA309_2 >= OIDSUBALT) && (LA309_2 <= OIDSUBDIR)) || LA309_2 == RSAPSSOID || ((LA309_2 >= SHA1DSAOID) && (LA309_2 <= SHA1ECOID)) || ((LA309_2 >= SHA1RSAOID) && (LA309_2 <= SHA224ECOID)) || ((LA309_2 >= SHA224RSAOID) && (LA309_2 <= SHA256ECOID)) || ((LA309_2 >= SHA256RSAOID) && (LA309_2 <= SHA384ECOID)) || ((LA309_2 >= SHA384RSAOID) && (LA309_2 <= SHA512ECOID)) || ((LA309_2 >= SHA512RSAOID) && (LA309_2 <= SIAOID))) )
    	    {
    	        s = 3;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (LA309_2 == NAMEOID || ((LA309_2 >= OIDCN) && (LA309_2 <= OIDCOUNTRY)) || LA309_2 == OIDDNQUALIFIER || ((LA309_2 >= OIDGENQUALIFIER) && (LA309_2 <= OIDGIVENAME)) || LA309_2 == OIDINIT || LA309_2 == OIDLOCAL || ((LA309_2 >= OIDON) && (LA309_2 <= OIDOU)) || ((LA309_2 >= OIDPSEUDO) && (LA309_2 <= OIDSERIAL)) || LA309_2 == OIDSORP || LA309_2 == OIDTITLE || LA309_2 == SURNAMEOID) )
    	    {
    	        s = 4;
    	    }

    	    else if ( (LA309_2 == VALUE) )
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA309_2 == PRINTABLE) )
    	    {
    	        s = 6;
    	    }

    		 
    			SEEK(index309_2);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA309_5;

    	    ANTLR3_MARKER index309_5;


    		LA309_5 = LA(1);

    	     
    	        index309_5 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA309_5 == TrueTag) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA309_5 == FalseTag) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA309_5 == OctetTag) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA309_5 == VALUE) )
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA309_5 == PRINTABLE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA309_5 >= BMPTag) && (LA309_5 <= BitStringTag)) || ((LA309_5 >= ConstructedOctetTag) && (LA309_5 <= ConstructedTag8)) || ((LA309_5 >= GeneralStringTag) && (LA309_5 <= GraphicalStringTag)) || ((LA309_5 >= IA5StringTag) && (LA309_5 <= IntTag)) || LA309_5 == Null || LA309_5 == OIDTag || LA309_5 == PrintStringTag || ((LA309_5 >= SequenceTag) && (LA309_5 <= SetTag)) || ((LA309_5 >= Tag0) && (LA309_5 <= TeletexTag)) || ((LA309_5 >= UTCTag) && (LA309_5 <= UniverStringTag)) || ((LA309_5 >= VideoStringTag) && (LA309_5 <= VisibleStringTag))) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index309_5);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA309_6;

    	    ANTLR3_MARKER index309_6;


    		LA309_6 = LA(1);

    	     
    	        index309_6 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA309_6 == TrueTag) )
    	    {
    	        s = 7;
    	    }

    	    else if ( (LA309_6 == FalseTag) )
    	    {
    	        s = 8;
    	    }

    	    else if ( (LA309_6 == OctetTag) )
    	    {
    	        s = 9;
    	    }

    	    else if ( (LA309_6 == VALUE) )
    	    {
    	        s = 5;
    	    }

    	    else if ( (LA309_6 == PRINTABLE) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA309_6 >= BMPTag) && (LA309_6 <= BitStringTag)) || ((LA309_6 >= ConstructedOctetTag) && (LA309_6 <= ConstructedTag8)) || ((LA309_6 >= GeneralStringTag) && (LA309_6 <= GraphicalStringTag)) || ((LA309_6 >= IA5StringTag) && (LA309_6 <= IntTag)) || LA309_6 == Null || LA309_6 == OIDTag || LA309_6 == PrintStringTag || ((LA309_6 >= SequenceTag) && (LA309_6 <= SetTag)) || ((LA309_6 >= Tag0) && (LA309_6 <= TeletexTag)) || ((LA309_6 >= UTCTag) && (LA309_6 <= UniverStringTag)) || ((LA309_6 >= VideoStringTag) && (LA309_6 <= VisibleStringTag))) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index309_6);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA309_7;

    	    ANTLR3_MARKER index309_7;


    		LA309_7 = LA(1);

    	     
    	        index309_7 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA309_7 == OctetTag) )
    	    {
    	        s = 9;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA309_7 >= BMPTag) && (LA309_7 <= BitStringTag)) || ((LA309_7 >= ConstructedOctetTag) && (LA309_7 <= ConstructedTag8)) || LA309_7 == FalseTag || ((LA309_7 >= GeneralStringTag) && (LA309_7 <= GraphicalStringTag)) || ((LA309_7 >= IA5StringTag) && (LA309_7 <= IntTag)) || LA309_7 == Null || LA309_7 == OIDTag || LA309_7 == PrintStringTag || ((LA309_7 >= SequenceTag) && (LA309_7 <= SetTag)) || ((LA309_7 >= Tag0) && (LA309_7 <= TrueTag)) || ((LA309_7 >= UTCTag) && (LA309_7 <= UniverStringTag)) || ((LA309_7 >= VideoStringTag) && (LA309_7 <= VisibleStringTag))) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index309_7);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 4:

    	{
    	    ANTLR3_UINT32 LA309_8;

    	    ANTLR3_MARKER index309_8;


    		LA309_8 = LA(1);

    	     
    	        index309_8 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA309_8 == OctetTag) )
    	    {
    	        s = 9;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA309_8 >= BMPTag) && (LA309_8 <= BitStringTag)) || ((LA309_8 >= ConstructedOctetTag) && (LA309_8 <= ConstructedTag8)) || LA309_8 == FalseTag || ((LA309_8 >= GeneralStringTag) && (LA309_8 <= GraphicalStringTag)) || ((LA309_8 >= IA5StringTag) && (LA309_8 <= IntTag)) || LA309_8 == Null || LA309_8 == OIDTag || LA309_8 == PrintStringTag || ((LA309_8 >= SequenceTag) && (LA309_8 <= SetTag)) || ((LA309_8 >= Tag0) && (LA309_8 <= TrueTag)) || ((LA309_8 >= UTCTag) && (LA309_8 <= UniverStringTag)) || ((LA309_8 >= VideoStringTag) && (LA309_8 <= VisibleStringTag))) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index309_8);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 5:

    	{
    	    ANTLR3_UINT32 LA309_10;

    	    ANTLR3_MARKER index309_10;


    		LA309_10 = LA(1);

    	     
    	        index309_10 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((sequence_pointer != NULL)) )
    	    {
    	        s = 4;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index309_10);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 6:

    	{
    	    ANTLR3_UINT32 LA309_11;

    	    ANTLR3_MARKER index309_11;


    		LA309_11 = LA(1);

    	     
    	        index309_11 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((sequence_pointer != NULL)) )
    	    {
    	        s = 4;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index309_11);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"()+ loopback of 2737:3: ( attribute )+";
    EXCEPTION->decisionNum  = 309;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 309
 */
static
ANTLR3_CYCLIC_DFA cdfa309
    =	{
	    309,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()+ loopback of 2737:3: ( attribute )+",
	    (CDFA_SPECIAL_FUNC) dfa309_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa309_eot,	    /* EOT table			    */
	    dfa309_eof,	    /* EOF table			    */
	    dfa309_min,	    /* Minimum tokens for each state    */
	    dfa309_max,	    /* Maximum tokens for each state    */
	    dfa309_accept,	/* Accept table			    */
	    dfa309_special,	/* Special transition states	    */
	    dfa309_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 309
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 2913:10: ( ad )+
 */
static const ANTLR3_INT32 dfa330_eot[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa330_eof[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa330_min[7] =
    {
	129, 96, 4, -1, -1, 20, 20
    };
static const ANTLR3_INT32 dfa330_max[7] =
    {
	129, 96, 175, -1, -1, 175, 175
    };
static const ANTLR3_INT32 dfa330_accept[7] =
    {
	-1, -1, -1, 2, 1, -1, -1
    };
static const ANTLR3_INT32 dfa330_special[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa330_T_empty	    NULL

static const ANTLR3_INT32 dfa330_T0[] =
    {
	4, -1, -1, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 3, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, -1, -1, -1, -1, -1, -1, -1, 5
    };
static const ANTLR3_INT32 dfa330_T1[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 3, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, 3, -1, -1, -1, -1, 4, -1, 3, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, 3, -1, 
	3, 3, -1, 3, -1, -1, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, -1, -1, -1, 6, 
	-1, -1, -1, -1, -1, -1, 3, -1, 3, 3, -1, 3, 3, 3, -1, 3, 3, 3, -1, 3, 3, 
	-1, 3, 3, -1, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };
static const ANTLR3_INT32 dfa330_T2[] =
    {
	2
    };
static const ANTLR3_INT32 dfa330_T3[] =
    {
	1
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa330_transitions[] =
{
    dfa330_T3, dfa330_T2, dfa330_T1, _empty, _empty, dfa330_T0, dfa330_T0
};


/* Declare tracking structure for Cyclic DFA 330
 */
static
ANTLR3_CYCLIC_DFA cdfa330
    =	{
	    330,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()+ loopback of 2913:10: ( ad )+",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa330_eot,	    /* EOT table			    */
	    dfa330_eof,	    /* EOF table			    */
	    dfa330_min,	    /* Minimum tokens for each state    */
	    dfa330_max,	    /* Maximum tokens for each state    */
	    dfa330_accept,	/* Accept table			    */
	    dfa330_special,	/* Special transition states	    */
	    dfa330_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 330
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 2946:10: ( adsia )+
 */
static const ANTLR3_INT32 dfa333_eot[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa333_eof[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa333_min[7] =
    {
	129, 96, 4, -1, -1, 20, 20
    };
static const ANTLR3_INT32 dfa333_max[7] =
    {
	129, 96, 175, -1, -1, 175, 175
    };
static const ANTLR3_INT32 dfa333_accept[7] =
    {
	-1, -1, -1, 2, 1, -1, -1
    };
static const ANTLR3_INT32 dfa333_special[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa333_T_empty	    NULL

static const ANTLR3_INT32 dfa333_T0[] =
    {
	4, -1, -1, 4, 4, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 3, -1, -1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 4, 4, -1, -1, -1, 4, 4, 4, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, -1, -1, -1, -1, -1, -1, -1, 5
    };
static const ANTLR3_INT32 dfa333_T1[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 3, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, 3, -1, -1, -1, -1, -1, -1, 3, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, 3, 
	-1, 3, 3, -1, 3, -1, -1, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, -1, -1, -1, 
	6, -1, -1, -1, -1, -1, -1, 3, -1, 3, 3, -1, 3, 3, 3, -1, 3, 3, 3, -1, 3, 
	3, -1, 3, 3, -1, 3, 3, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 5
    };
static const ANTLR3_INT32 dfa333_T2[] =
    {
	1
    };
static const ANTLR3_INT32 dfa333_T3[] =
    {
	2
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa333_transitions[] =
{
    dfa333_T2, dfa333_T3, dfa333_T1, _empty, _empty, dfa333_T0, dfa333_T0
};


/* Declare tracking structure for Cyclic DFA 333
 */
static
ANTLR3_CYCLIC_DFA cdfa333
    =	{
	    333,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()+ loopback of 2946:10: ( adsia )+",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa333_eot,	    /* EOT table			    */
	    dfa333_eof,	    /* EOF table			    */
	    dfa333_min,	    /* Minimum tokens for each state    */
	    dfa333_max,	    /* Maximum tokens for each state    */
	    dfa333_accept,	/* Accept table			    */
	    dfa333_special,	/* Special transition states	    */
	    dfa333_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 333
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()+ loopback of 3061:3: ( sequenceTag iss= oid subj= oid )+
 */
static const ANTLR3_INT32 dfa344_eot[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa344_eof[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa344_min[7] =
    {
	129, 96, 4, -1, 41, 41, -1
    };
static const ANTLR3_INT32 dfa344_max[7] =
    {
	129, 96, 175, -1, 175, 175, -1
    };
static const ANTLR3_INT32 dfa344_accept[7] =
    {
	-1, -1, -1, 2, -1, -1, 1
    };
static const ANTLR3_INT32 dfa344_special[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa344_T_empty	    NULL

static const ANTLR3_INT32 dfa344_T0[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 6, 3, -1, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, 
	-1, -1, -1, -1, -1, -1, -1, 4
    };
static const ANTLR3_INT32 dfa344_T1[] =
    {
	1
    };
static const ANTLR3_INT32 dfa344_T2[] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 3, -1, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 3, 3, -1, -1, -1, -1, -1, -1, 3, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, 
	3, -1, 3, 3, -1, 3, -1, -1, 3, 3, -1, -1, 3, -1, 3, 3, -1, -1, -1, -1, 
	-1, 5, -1, -1, -1, -1, -1, -1, 3, -1, 3, 3, -1, 3, 3, 3, -1, 3, 3, 3, -1, 
	3, 3, -1, 3, 3, -1, 3, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4
    };
static const ANTLR3_INT32 dfa344_T3[] =
    {
	2
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa344_transitions[] =
{
    dfa344_T1, dfa344_T3, dfa344_T2, _empty, dfa344_T0, dfa344_T0, _empty
};


/* Declare tracking structure for Cyclic DFA 344
 */
static
ANTLR3_CYCLIC_DFA cdfa344
    =	{
	    344,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()+ loopback of 3061:3: ( sequenceTag iss= oid subj= oid )+",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa344_eot,	    /* EOT table			    */
	    dfa344_eof,	    /* EOF table			    */
	    dfa344_min,	    /* Minimum tokens for each state    */
	    dfa344_max,	    /* Maximum tokens for each state    */
	    dfa344_accept,	/* Accept table			    */
	    dfa344_special,	/* Special transition states	    */
	    dfa344_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 344
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    3513:2: ({...}? => constructedTag5 (t0= tag0 ) ({...}? =>t1= tag1 |) ({...}? =>t2= tag2 |) (t3= tag3 )? |)
 */
static const ANTLR3_INT32 dfa434_eot[33] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa434_eof[33] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa434_min[33] =
    {
	20, 134, -1, 100, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 
	20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 100, -1, 0, 0
    };
static const ANTLR3_INT32 dfa434_max[33] =
    {
	165, 165, -1, 175, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 
	165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 175, 175, 175, 
	-1, 0, 0
    };
static const ANTLR3_INT32 dfa434_accept[33] =
    {
	-1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1
    };
static const ANTLR3_INT32 dfa434_special[33] =
    {
	-1, -1, -1, -1, 24, 15, 5, 10, 2, 22, 13, 18, 9, 1, 21, 26, 17, 7, 0, 4, 
	25, 16, 6, 11, 3, 23, 14, 20, 12, -1, -1, 8, 19
    };

/** Used when there is no transition table entry for a particular state */
#define dfa434_T_empty	    NULL

static const ANTLR3_INT32 dfa434_T0[] =
    {
	30, 30, 30, 30, 30, 30, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 30, 30, -1, -1, -1, 30, 29, 30, 30, -1, -1, 30, 30, 30, 30, 30, 30, 
	30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 
	30, 30
    };
static const ANTLR3_INT32 dfa434_T1[] =
    {
	2, 2, 2, 2, 2, 1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 
	2, -1, -1, -1, 2, 2, 2, -1, -1, -1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 
	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
    };
static const ANTLR3_INT32 dfa434_T2[] =
    {
	-1
    };
static const ANTLR3_INT32 dfa434_T3[] =
    {
	30, 30, 30, 30, 30, 30, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 28, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, 30, 30, -1, -1, -1, 30, 29, 30, 30, -1, -1, 30, 30, 30, 30, 30, 30, 
	30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 
	30, 30, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27
    };
static const ANTLR3_INT32 dfa434_T4[] =
    {
	32, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 31
    };
static const ANTLR3_INT32 dfa434_T5[] =
    {
	3, 2, -1, -1, -1, -1, -1, -1, -1, 4, 13, 14, 15, 16, 17, 18, 19, 20, 21, 
	22, 5, 23, 24, 25, 26, 6, 7, 8, 9, 10, 11, 12
    };
static const ANTLR3_INT32 dfa434_T6[] =
    {
	28, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 27
    };

/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa434_transitions[] =
{
    dfa434_T1, dfa434_T5, _empty, dfa434_T6, dfa434_T0, dfa434_T0, dfa434_T0, 
    dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, 
    dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, 
    dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T0, dfa434_T3, 
    dfa434_T3, dfa434_T4, _empty, dfa434_T2, dfa434_T2
};

static ANTLR3_INT32 dfa434_sst(pRFC5280Parser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA434_18;

    	    ANTLR3_MARKER index434_18;


    		LA434_18 = LA(1);

    	     
    	        index434_18 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_18 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_18 >= ConstructedTag0) && (LA434_18 <= ConstructedTag6)) || ((LA434_18 >= SequenceTag) && (LA434_18 <= SetTag)) || LA434_18 == Tag0 || ((LA434_18 >= Tag2) && (LA434_18 <= Tag3)) || ((LA434_18 >= Tag6) && (LA434_18 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_18);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA434_13;

    	    ANTLR3_MARKER index434_13;


    		LA434_13 = LA(1);

    	     
    	        index434_13 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_13 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_13 >= ConstructedTag0) && (LA434_13 <= ConstructedTag6)) || ((LA434_13 >= SequenceTag) && (LA434_13 <= SetTag)) || LA434_13 == Tag0 || ((LA434_13 >= Tag2) && (LA434_13 <= Tag3)) || ((LA434_13 >= Tag6) && (LA434_13 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_13);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA434_8;

    	    ANTLR3_MARKER index434_8;


    		LA434_8 = LA(1);

    	     
    	        index434_8 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_8 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_8 >= ConstructedTag0) && (LA434_8 <= ConstructedTag6)) || ((LA434_8 >= SequenceTag) && (LA434_8 <= SetTag)) || LA434_8 == Tag0 || ((LA434_8 >= Tag2) && (LA434_8 <= Tag3)) || ((LA434_8 >= Tag6) && (LA434_8 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_8);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA434_24;

    	    ANTLR3_MARKER index434_24;


    		LA434_24 = LA(1);

    	     
    	        index434_24 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_24 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_24 >= ConstructedTag0) && (LA434_24 <= ConstructedTag6)) || ((LA434_24 >= SequenceTag) && (LA434_24 <= SetTag)) || LA434_24 == Tag0 || ((LA434_24 >= Tag2) && (LA434_24 <= Tag3)) || ((LA434_24 >= Tag6) && (LA434_24 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_24);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 4:

    	{
    	    ANTLR3_UINT32 LA434_19;

    	    ANTLR3_MARKER index434_19;


    		LA434_19 = LA(1);

    	     
    	        index434_19 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_19 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_19 >= ConstructedTag0) && (LA434_19 <= ConstructedTag6)) || ((LA434_19 >= SequenceTag) && (LA434_19 <= SetTag)) || LA434_19 == Tag0 || ((LA434_19 >= Tag2) && (LA434_19 <= Tag3)) || ((LA434_19 >= Tag6) && (LA434_19 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_19);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 5:

    	{
    	    ANTLR3_UINT32 LA434_6;

    	    ANTLR3_MARKER index434_6;


    		LA434_6 = LA(1);

    	     
    	        index434_6 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_6 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_6 >= ConstructedTag0) && (LA434_6 <= ConstructedTag6)) || ((LA434_6 >= SequenceTag) && (LA434_6 <= SetTag)) || LA434_6 == Tag0 || ((LA434_6 >= Tag2) && (LA434_6 <= Tag3)) || ((LA434_6 >= Tag6) && (LA434_6 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_6);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 6:

    	{
    	    ANTLR3_UINT32 LA434_22;

    	    ANTLR3_MARKER index434_22;


    		LA434_22 = LA(1);

    	     
    	        index434_22 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_22 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_22 >= ConstructedTag0) && (LA434_22 <= ConstructedTag6)) || ((LA434_22 >= SequenceTag) && (LA434_22 <= SetTag)) || LA434_22 == Tag0 || ((LA434_22 >= Tag2) && (LA434_22 <= Tag3)) || ((LA434_22 >= Tag6) && (LA434_22 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_22);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 7:

    	{
    	    ANTLR3_UINT32 LA434_17;

    	    ANTLR3_MARKER index434_17;


    		LA434_17 = LA(1);

    	     
    	        index434_17 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_17 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_17 >= ConstructedTag0) && (LA434_17 <= ConstructedTag6)) || ((LA434_17 >= SequenceTag) && (LA434_17 <= SetTag)) || LA434_17 == Tag0 || ((LA434_17 >= Tag2) && (LA434_17 <= Tag3)) || ((LA434_17 >= Tag6) && (LA434_17 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_17);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 8:

    	{
    	    ANTLR3_UINT32 LA434_31;

    	    ANTLR3_MARKER index434_31;


    		LA434_31 = LA(1);

    	     
    	        index434_31 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((sequence_pointer != NULL)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 2;
    	    }

    		 
    			SEEK(index434_31);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 9:

    	{
    	    ANTLR3_UINT32 LA434_12;

    	    ANTLR3_MARKER index434_12;


    		LA434_12 = LA(1);

    	     
    	        index434_12 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_12 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_12 >= ConstructedTag0) && (LA434_12 <= ConstructedTag6)) || ((LA434_12 >= SequenceTag) && (LA434_12 <= SetTag)) || LA434_12 == Tag0 || ((LA434_12 >= Tag2) && (LA434_12 <= Tag3)) || ((LA434_12 >= Tag6) && (LA434_12 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_12);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 10:

    	{
    	    ANTLR3_UINT32 LA434_7;

    	    ANTLR3_MARKER index434_7;


    		LA434_7 = LA(1);

    	     
    	        index434_7 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_7 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_7 >= ConstructedTag0) && (LA434_7 <= ConstructedTag6)) || ((LA434_7 >= SequenceTag) && (LA434_7 <= SetTag)) || LA434_7 == Tag0 || ((LA434_7 >= Tag2) && (LA434_7 <= Tag3)) || ((LA434_7 >= Tag6) && (LA434_7 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_7);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 11:

    	{
    	    ANTLR3_UINT32 LA434_23;

    	    ANTLR3_MARKER index434_23;


    		LA434_23 = LA(1);

    	     
    	        index434_23 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_23 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_23 >= ConstructedTag0) && (LA434_23 <= ConstructedTag6)) || ((LA434_23 >= SequenceTag) && (LA434_23 <= SetTag)) || LA434_23 == Tag0 || ((LA434_23 >= Tag2) && (LA434_23 <= Tag3)) || ((LA434_23 >= Tag6) && (LA434_23 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_23);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 12:

    	{
    	    ANTLR3_UINT32 LA434_28;

    	    ANTLR3_MARKER index434_28;


    		LA434_28 = LA(1);

    	     
    	        index434_28 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_28 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_28 >= ConstructedTag0) && (LA434_28 <= ConstructedTag6)) || ((LA434_28 >= SequenceTag) && (LA434_28 <= SetTag)) || LA434_28 == Tag0 || ((LA434_28 >= Tag2) && (LA434_28 <= Tag3)) || ((LA434_28 >= Tag6) && (LA434_28 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA434_28 == VALUE) )
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA434_28 == PRINTABLE) )
    	    {
    	        s = 28;
    	    }

    		 
    			SEEK(index434_28);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 13:

    	{
    	    ANTLR3_UINT32 LA434_10;

    	    ANTLR3_MARKER index434_10;


    		LA434_10 = LA(1);

    	     
    	        index434_10 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_10 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_10 >= ConstructedTag0) && (LA434_10 <= ConstructedTag6)) || ((LA434_10 >= SequenceTag) && (LA434_10 <= SetTag)) || LA434_10 == Tag0 || ((LA434_10 >= Tag2) && (LA434_10 <= Tag3)) || ((LA434_10 >= Tag6) && (LA434_10 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_10);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 14:

    	{
    	    ANTLR3_UINT32 LA434_26;

    	    ANTLR3_MARKER index434_26;


    		LA434_26 = LA(1);

    	     
    	        index434_26 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_26 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_26 >= ConstructedTag0) && (LA434_26 <= ConstructedTag6)) || ((LA434_26 >= SequenceTag) && (LA434_26 <= SetTag)) || LA434_26 == Tag0 || ((LA434_26 >= Tag2) && (LA434_26 <= Tag3)) || ((LA434_26 >= Tag6) && (LA434_26 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_26);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 15:

    	{
    	    ANTLR3_UINT32 LA434_5;

    	    ANTLR3_MARKER index434_5;


    		LA434_5 = LA(1);

    	     
    	        index434_5 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_5 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_5 >= ConstructedTag0) && (LA434_5 <= ConstructedTag6)) || ((LA434_5 >= SequenceTag) && (LA434_5 <= SetTag)) || LA434_5 == Tag0 || ((LA434_5 >= Tag2) && (LA434_5 <= Tag3)) || ((LA434_5 >= Tag6) && (LA434_5 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_5);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 16:

    	{
    	    ANTLR3_UINT32 LA434_21;

    	    ANTLR3_MARKER index434_21;


    		LA434_21 = LA(1);

    	     
    	        index434_21 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_21 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_21 >= ConstructedTag0) && (LA434_21 <= ConstructedTag6)) || ((LA434_21 >= SequenceTag) && (LA434_21 <= SetTag)) || LA434_21 == Tag0 || ((LA434_21 >= Tag2) && (LA434_21 <= Tag3)) || ((LA434_21 >= Tag6) && (LA434_21 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_21);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 17:

    	{
    	    ANTLR3_UINT32 LA434_16;

    	    ANTLR3_MARKER index434_16;


    		LA434_16 = LA(1);

    	     
    	        index434_16 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_16 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_16 >= ConstructedTag0) && (LA434_16 <= ConstructedTag6)) || ((LA434_16 >= SequenceTag) && (LA434_16 <= SetTag)) || LA434_16 == Tag0 || ((LA434_16 >= Tag2) && (LA434_16 <= Tag3)) || ((LA434_16 >= Tag6) && (LA434_16 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_16);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 18:

    	{
    	    ANTLR3_UINT32 LA434_11;

    	    ANTLR3_MARKER index434_11;


    		LA434_11 = LA(1);

    	     
    	        index434_11 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_11 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_11 >= ConstructedTag0) && (LA434_11 <= ConstructedTag6)) || ((LA434_11 >= SequenceTag) && (LA434_11 <= SetTag)) || LA434_11 == Tag0 || ((LA434_11 >= Tag2) && (LA434_11 <= Tag3)) || ((LA434_11 >= Tag6) && (LA434_11 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_11);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 19:

    	{
    	    ANTLR3_UINT32 LA434_32;

    	    ANTLR3_MARKER index434_32;


    		LA434_32 = LA(1);

    	     
    	        index434_32 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((sequence_pointer != NULL)) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 2;
    	    }

    		 
    			SEEK(index434_32);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 20:

    	{
    	    ANTLR3_UINT32 LA434_27;

    	    ANTLR3_MARKER index434_27;


    		LA434_27 = LA(1);

    	     
    	        index434_27 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_27 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_27 >= ConstructedTag0) && (LA434_27 <= ConstructedTag6)) || ((LA434_27 >= SequenceTag) && (LA434_27 <= SetTag)) || LA434_27 == Tag0 || ((LA434_27 >= Tag2) && (LA434_27 <= Tag3)) || ((LA434_27 >= Tag6) && (LA434_27 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    	    else if ( (LA434_27 == VALUE) )
    	    {
    	        s = 27;
    	    }

    	    else if ( (LA434_27 == PRINTABLE) )
    	    {
    	        s = 28;
    	    }

    		 
    			SEEK(index434_27);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 21:

    	{
    	    ANTLR3_UINT32 LA434_14;

    	    ANTLR3_MARKER index434_14;


    		LA434_14 = LA(1);

    	     
    	        index434_14 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_14 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_14 >= ConstructedTag0) && (LA434_14 <= ConstructedTag6)) || ((LA434_14 >= SequenceTag) && (LA434_14 <= SetTag)) || LA434_14 == Tag0 || ((LA434_14 >= Tag2) && (LA434_14 <= Tag3)) || ((LA434_14 >= Tag6) && (LA434_14 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_14);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 22:

    	{
    	    ANTLR3_UINT32 LA434_9;

    	    ANTLR3_MARKER index434_9;


    		LA434_9 = LA(1);

    	     
    	        index434_9 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_9 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_9 >= ConstructedTag0) && (LA434_9 <= ConstructedTag6)) || ((LA434_9 >= SequenceTag) && (LA434_9 <= SetTag)) || LA434_9 == Tag0 || ((LA434_9 >= Tag2) && (LA434_9 <= Tag3)) || ((LA434_9 >= Tag6) && (LA434_9 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_9);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 23:

    	{
    	    ANTLR3_UINT32 LA434_25;

    	    ANTLR3_MARKER index434_25;


    		LA434_25 = LA(1);

    	     
    	        index434_25 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_25 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_25 >= ConstructedTag0) && (LA434_25 <= ConstructedTag6)) || ((LA434_25 >= SequenceTag) && (LA434_25 <= SetTag)) || LA434_25 == Tag0 || ((LA434_25 >= Tag2) && (LA434_25 <= Tag3)) || ((LA434_25 >= Tag6) && (LA434_25 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_25);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 24:

    	{
    	    ANTLR3_UINT32 LA434_4;

    	    ANTLR3_MARKER index434_4;


    		LA434_4 = LA(1);

    	     
    	        index434_4 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_4 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_4 >= ConstructedTag0) && (LA434_4 <= ConstructedTag6)) || ((LA434_4 >= SequenceTag) && (LA434_4 <= SetTag)) || LA434_4 == Tag0 || ((LA434_4 >= Tag2) && (LA434_4 <= Tag3)) || ((LA434_4 >= Tag6) && (LA434_4 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_4);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 25:

    	{
    	    ANTLR3_UINT32 LA434_20;

    	    ANTLR3_MARKER index434_20;


    		LA434_20 = LA(1);

    	     
    	        index434_20 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_20 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_20 >= ConstructedTag0) && (LA434_20 <= ConstructedTag6)) || ((LA434_20 >= SequenceTag) && (LA434_20 <= SetTag)) || LA434_20 == Tag0 || ((LA434_20 >= Tag2) && (LA434_20 <= Tag3)) || ((LA434_20 >= Tag6) && (LA434_20 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_20);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 26:

    	{
    	    ANTLR3_UINT32 LA434_15;

    	    ANTLR3_MARKER index434_15;


    		LA434_15 = LA(1);

    	     
    	        index434_15 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA434_15 == Tag1) )
    	    {
    	        s = 29;
    	    }

    	    else if ( ((sequence_pointer != NULL)) && (((LA434_15 >= ConstructedTag0) && (LA434_15 <= ConstructedTag6)) || ((LA434_15 >= SequenceTag) && (LA434_15 <= SetTag)) || LA434_15 == Tag0 || ((LA434_15 >= Tag2) && (LA434_15 <= Tag3)) || ((LA434_15 >= Tag6) && (LA434_15 <= TagInt9))) )
    	    {
    	        s = 30;
    	    }

    		 
    			SEEK(index434_15);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"3513:2: ({...}? => constructedTag5 (t0= tag0 ) ({...}? =>t1= tag1 |) ({...}? =>t2= tag2 |) (t3= tag3 )? |)";
    EXCEPTION->decisionNum  = 434;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 434
 */
static
ANTLR3_CYCLIC_DFA cdfa434
    =	{
	    434,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"3513:2: ({...}? => constructedTag5 (t0= tag0 ) ({...}? =>t1= tag1 |) ({...}? =>t2= tag2 |) (t3= tag3 )? |)",
	    (CDFA_SPECIAL_FUNC) dfa434_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa434_eot,	    /* EOT table			    */
	    dfa434_eof,	    /* EOF table			    */
	    dfa434_min,	    /* Minimum tokens for each state    */
	    dfa434_max,	    /* Maximum tokens for each state    */
	    dfa434_accept,	/* Accept table			    */
	    dfa434_special,	/* Special transition states	    */
	    dfa434_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 434
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start prog
 * Grammar/RFC5280.g:1206:1: prog : certificate EOF ;
 */
static RFC5280Parser_prog_return
prog(pRFC5280Parser ctx)
{
    RFC5280Parser_prog_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EOF2;
    RFC5280Parser_certificate_return certificate1;
    #undef	RETURN_TYPE_certificate1
    #define	RETURN_TYPE_certificate1 RFC5280Parser_certificate_return

    pANTLR3_BASE_TREE EOF2_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EOF2       = NULL;
    certificate1.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EOF2_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1206:7: ( certificate EOF )
        // Grammar/RFC5280.g:1206:9: certificate EOF
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                		push_rule(__func__);
                		parser_ctx = ctx; 
                		#endif
                	cert = malloc(sizeof(cert_info));*cert= cert_init;cert->extensions=NULL;populate_string_table();ASN1_STRING_TABLE *tbl = ASN1_STRING_TABLE_get(NID_pseudonym);printf("tbl min is %d and max is %d \n",tbl->minsize,tbl->maxsize);
            }


            FOLLOWPUSH(FOLLOW_certificate_in_prog77);
            certificate1=certificate(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprogEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, certificate1.tree);

            EOF2 = (pANTLR3_COMMON_TOKEN) MATCHT(EOF, &FOLLOW_EOF_in_prog79);
            if  (HASEXCEPTION())
            {
                goto ruleprogEx;
            }

            EOF2_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EOF2));
            ADAPTOR->addChild(ADAPTOR, root_0, EOF2_tree);


            {

                	if(!bc_ext)
                		cert->is_ca=0;
                	else
                	{
                		sk_x509_EXTENSION_push(cert->extensions,bc_ext);
                		cert->is_ca = bc_ext->value->basic_constraints->is_ca;
                		if(bc_ext->value->basic_constraints->pathlen != NULL)
                		{
                		mpz_t value,length;
                		mpz_init_set_ui(value,0);
                		mpz_init_set_ui(length,bc_ext->value->basic_constraints->pathlen->length);
                		compute_integer(bc_ext->value->basic_constraints->pathlen->data,length,value);
                		if(mpz_sgn(value) == -1)
                			exit(NEGATIVE_PATHLEN_ERROR);
                		}
                	}
                	final_check();
                	//compute_names();
                	#ifdef DEBUG
                	printf("rule is %s \n",rule_list->fname);
                	pop_rule(); 
                	#endif
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprogEx; /* Prevent compiler warnings */
    ruleprogEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end prog */

/**
 * $ANTLR start certificate
 * Grammar/RFC5280.g:1235:1: certificate : sequenceTag tbscertificate ;
 */
static RFC5280Parser_certificate_return
certificate(pRFC5280Parser ctx)
{
    RFC5280Parser_certificate_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag3;
    #undef	RETURN_TYPE_sequenceTag3
    #define	RETURN_TYPE_sequenceTag3 RFC5280Parser_sequenceTag_return

    RFC5280Parser_tbscertificate_return tbscertificate4;
    #undef	RETURN_TYPE_tbscertificate4
    #define	RETURN_TYPE_tbscertificate4 RFC5280Parser_tbscertificate_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag3.tree = NULL;

    tbscertificate4.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1237:10: ( sequenceTag tbscertificate )
        // Grammar/RFC5280.g:1237:12: sequenceTag tbscertificate
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_certificate97);
            sequenceTag3=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecertificateEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag3.tree);

            {

                	extern int counter_primitive,max;
                	if(counter_primitive > 0)
                		exit(TRUNCATED_FILE_ERROR);
                	//printf("max lookahead is %d \n",max);
                	
                	
            }


            FOLLOWPUSH(FOLLOW_tbscertificate_in_certificate104);
            tbscertificate4=tbscertificate(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecertificateEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, tbscertificate4.tree);

            {
                printf("after EOF \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecertificateEx; /* Prevent compiler warnings */
    rulecertificateEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end certificate */

/**
 * $ANTLR start tbscertificate
 * Grammar/RFC5280.g:1249:1: tbscertificate : sequenceTag ( constructedTag0 version3 serialnumber ( rsa_md2_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) pss_alg_id_params signature | dsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_94_alg_id signature | gost_01_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_01_alg_id signature ) | constructedTag0 version2 serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_01_alg_id signature ) | ( constructedTag0 version )? serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo gost_01_alg_id signature ) ) ;
 */
static RFC5280Parser_tbscertificate_return
tbscertificate(pRFC5280Parser ctx)
{
    RFC5280Parser_tbscertificate_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag5;
    #undef	RETURN_TYPE_sequenceTag5
    #define	RETURN_TYPE_sequenceTag5 RFC5280Parser_sequenceTag_return

    RFC5280Parser_constructedTag0_return constructedTag06;
    #undef	RETURN_TYPE_constructedTag06
    #define	RETURN_TYPE_constructedTag06 RFC5280Parser_constructedTag0_return

    RFC5280Parser_version3_return version37;
    #undef	RETURN_TYPE_version37
    #define	RETURN_TYPE_version37 RFC5280Parser_version3_return

    RFC5280Parser_serialnumber_return serialnumber8;
    #undef	RETURN_TYPE_serialnumber8
    #define	RETURN_TYPE_serialnumber8 RFC5280Parser_serialnumber_return

    RFC5280Parser_rsa_md2_alg_id_return rsa_md2_alg_id9;
    #undef	RETURN_TYPE_rsa_md2_alg_id9
    #define	RETURN_TYPE_rsa_md2_alg_id9 RFC5280Parser_rsa_md2_alg_id_return

    RFC5280Parser_issuer_return issuer10;
    #undef	RETURN_TYPE_issuer10
    #define	RETURN_TYPE_issuer10 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity11;
    #undef	RETURN_TYPE_validity11
    #define	RETURN_TYPE_validity11 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject12;
    #undef	RETURN_TYPE_subject12
    #define	RETURN_TYPE_subject12 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo13;
    #undef	RETURN_TYPE_subjectPKinfo13
    #define	RETURN_TYPE_subjectPKinfo13 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId14;
    #undef	RETURN_TYPE_issueruniqueId14
    #define	RETURN_TYPE_issueruniqueId14 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId15;
    #undef	RETURN_TYPE_subjectuniqueId15
    #define	RETURN_TYPE_subjectuniqueId15 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag316;
    #undef	RETURN_TYPE_constructedTag316
    #define	RETURN_TYPE_constructedTag316 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag17;
    #undef	RETURN_TYPE_sequenceTag17
    #define	RETURN_TYPE_sequenceTag17 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions18;
    #undef	RETURN_TYPE_extensions18
    #define	RETURN_TYPE_extensions18 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag19;
    #undef	RETURN_TYPE_sequenceTag19
    #define	RETURN_TYPE_sequenceTag19 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo20;
    #undef	RETURN_TYPE_subjectPKinfo20
    #define	RETURN_TYPE_subjectPKinfo20 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId21;
    #undef	RETURN_TYPE_issueruniqueId21
    #define	RETURN_TYPE_issueruniqueId21 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId22;
    #undef	RETURN_TYPE_subjectuniqueId22
    #define	RETURN_TYPE_subjectuniqueId22 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag323;
    #undef	RETURN_TYPE_constructedTag323
    #define	RETURN_TYPE_constructedTag323 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag24;
    #undef	RETURN_TYPE_sequenceTag24
    #define	RETURN_TYPE_sequenceTag24 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt25;
    #undef	RETURN_TYPE_extensionsWithSubAlt25
    #define	RETURN_TYPE_extensionsWithSubAlt25 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_rsa_md2_alg_id_return rsa_md2_alg_id26;
    #undef	RETURN_TYPE_rsa_md2_alg_id26
    #define	RETURN_TYPE_rsa_md2_alg_id26 RFC5280Parser_rsa_md2_alg_id_return

    RFC5280Parser_signature_return signature27;
    #undef	RETURN_TYPE_signature27
    #define	RETURN_TYPE_signature27 RFC5280Parser_signature_return

    RFC5280Parser_rsa_md5_alg_id_return rsa_md5_alg_id28;
    #undef	RETURN_TYPE_rsa_md5_alg_id28
    #define	RETURN_TYPE_rsa_md5_alg_id28 RFC5280Parser_rsa_md5_alg_id_return

    RFC5280Parser_issuer_return issuer29;
    #undef	RETURN_TYPE_issuer29
    #define	RETURN_TYPE_issuer29 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity30;
    #undef	RETURN_TYPE_validity30
    #define	RETURN_TYPE_validity30 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject31;
    #undef	RETURN_TYPE_subject31
    #define	RETURN_TYPE_subject31 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo32;
    #undef	RETURN_TYPE_subjectPKinfo32
    #define	RETURN_TYPE_subjectPKinfo32 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId33;
    #undef	RETURN_TYPE_issueruniqueId33
    #define	RETURN_TYPE_issueruniqueId33 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId34;
    #undef	RETURN_TYPE_subjectuniqueId34
    #define	RETURN_TYPE_subjectuniqueId34 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag335;
    #undef	RETURN_TYPE_constructedTag335
    #define	RETURN_TYPE_constructedTag335 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag36;
    #undef	RETURN_TYPE_sequenceTag36
    #define	RETURN_TYPE_sequenceTag36 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions37;
    #undef	RETURN_TYPE_extensions37
    #define	RETURN_TYPE_extensions37 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag38;
    #undef	RETURN_TYPE_sequenceTag38
    #define	RETURN_TYPE_sequenceTag38 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo39;
    #undef	RETURN_TYPE_subjectPKinfo39
    #define	RETURN_TYPE_subjectPKinfo39 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId40;
    #undef	RETURN_TYPE_issueruniqueId40
    #define	RETURN_TYPE_issueruniqueId40 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId41;
    #undef	RETURN_TYPE_subjectuniqueId41
    #define	RETURN_TYPE_subjectuniqueId41 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag342;
    #undef	RETURN_TYPE_constructedTag342
    #define	RETURN_TYPE_constructedTag342 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag43;
    #undef	RETURN_TYPE_sequenceTag43
    #define	RETURN_TYPE_sequenceTag43 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt44;
    #undef	RETURN_TYPE_extensionsWithSubAlt44
    #define	RETURN_TYPE_extensionsWithSubAlt44 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_rsa_md5_alg_id_return rsa_md5_alg_id45;
    #undef	RETURN_TYPE_rsa_md5_alg_id45
    #define	RETURN_TYPE_rsa_md5_alg_id45 RFC5280Parser_rsa_md5_alg_id_return

    RFC5280Parser_signature_return signature46;
    #undef	RETURN_TYPE_signature46
    #define	RETURN_TYPE_signature46 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha1_alg_id_return rsa_sha1_alg_id47;
    #undef	RETURN_TYPE_rsa_sha1_alg_id47
    #define	RETURN_TYPE_rsa_sha1_alg_id47 RFC5280Parser_rsa_sha1_alg_id_return

    RFC5280Parser_issuer_return issuer48;
    #undef	RETURN_TYPE_issuer48
    #define	RETURN_TYPE_issuer48 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity49;
    #undef	RETURN_TYPE_validity49
    #define	RETURN_TYPE_validity49 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject50;
    #undef	RETURN_TYPE_subject50
    #define	RETURN_TYPE_subject50 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo51;
    #undef	RETURN_TYPE_subjectPKinfo51
    #define	RETURN_TYPE_subjectPKinfo51 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId52;
    #undef	RETURN_TYPE_issueruniqueId52
    #define	RETURN_TYPE_issueruniqueId52 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId53;
    #undef	RETURN_TYPE_subjectuniqueId53
    #define	RETURN_TYPE_subjectuniqueId53 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag354;
    #undef	RETURN_TYPE_constructedTag354
    #define	RETURN_TYPE_constructedTag354 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag55;
    #undef	RETURN_TYPE_sequenceTag55
    #define	RETURN_TYPE_sequenceTag55 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions56;
    #undef	RETURN_TYPE_extensions56
    #define	RETURN_TYPE_extensions56 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag57;
    #undef	RETURN_TYPE_sequenceTag57
    #define	RETURN_TYPE_sequenceTag57 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo58;
    #undef	RETURN_TYPE_subjectPKinfo58
    #define	RETURN_TYPE_subjectPKinfo58 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId59;
    #undef	RETURN_TYPE_issueruniqueId59
    #define	RETURN_TYPE_issueruniqueId59 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId60;
    #undef	RETURN_TYPE_subjectuniqueId60
    #define	RETURN_TYPE_subjectuniqueId60 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag361;
    #undef	RETURN_TYPE_constructedTag361
    #define	RETURN_TYPE_constructedTag361 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag62;
    #undef	RETURN_TYPE_sequenceTag62
    #define	RETURN_TYPE_sequenceTag62 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt63;
    #undef	RETURN_TYPE_extensionsWithSubAlt63
    #define	RETURN_TYPE_extensionsWithSubAlt63 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_rsa_sha1_alg_id_return rsa_sha1_alg_id64;
    #undef	RETURN_TYPE_rsa_sha1_alg_id64
    #define	RETURN_TYPE_rsa_sha1_alg_id64 RFC5280Parser_rsa_sha1_alg_id_return

    RFC5280Parser_signature_return signature65;
    #undef	RETURN_TYPE_signature65
    #define	RETURN_TYPE_signature65 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha224_alg_id_return rsa_sha224_alg_id66;
    #undef	RETURN_TYPE_rsa_sha224_alg_id66
    #define	RETURN_TYPE_rsa_sha224_alg_id66 RFC5280Parser_rsa_sha224_alg_id_return

    RFC5280Parser_issuer_return issuer67;
    #undef	RETURN_TYPE_issuer67
    #define	RETURN_TYPE_issuer67 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity68;
    #undef	RETURN_TYPE_validity68
    #define	RETURN_TYPE_validity68 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject69;
    #undef	RETURN_TYPE_subject69
    #define	RETURN_TYPE_subject69 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo70;
    #undef	RETURN_TYPE_subjectPKinfo70
    #define	RETURN_TYPE_subjectPKinfo70 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId71;
    #undef	RETURN_TYPE_issueruniqueId71
    #define	RETURN_TYPE_issueruniqueId71 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId72;
    #undef	RETURN_TYPE_subjectuniqueId72
    #define	RETURN_TYPE_subjectuniqueId72 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag373;
    #undef	RETURN_TYPE_constructedTag373
    #define	RETURN_TYPE_constructedTag373 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag74;
    #undef	RETURN_TYPE_sequenceTag74
    #define	RETURN_TYPE_sequenceTag74 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions75;
    #undef	RETURN_TYPE_extensions75
    #define	RETURN_TYPE_extensions75 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag76;
    #undef	RETURN_TYPE_sequenceTag76
    #define	RETURN_TYPE_sequenceTag76 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo77;
    #undef	RETURN_TYPE_subjectPKinfo77
    #define	RETURN_TYPE_subjectPKinfo77 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId78;
    #undef	RETURN_TYPE_issueruniqueId78
    #define	RETURN_TYPE_issueruniqueId78 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId79;
    #undef	RETURN_TYPE_subjectuniqueId79
    #define	RETURN_TYPE_subjectuniqueId79 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag380;
    #undef	RETURN_TYPE_constructedTag380
    #define	RETURN_TYPE_constructedTag380 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag81;
    #undef	RETURN_TYPE_sequenceTag81
    #define	RETURN_TYPE_sequenceTag81 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt82;
    #undef	RETURN_TYPE_extensionsWithSubAlt82
    #define	RETURN_TYPE_extensionsWithSubAlt82 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_rsa_sha224_alg_id_return rsa_sha224_alg_id83;
    #undef	RETURN_TYPE_rsa_sha224_alg_id83
    #define	RETURN_TYPE_rsa_sha224_alg_id83 RFC5280Parser_rsa_sha224_alg_id_return

    RFC5280Parser_signature_return signature84;
    #undef	RETURN_TYPE_signature84
    #define	RETURN_TYPE_signature84 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha256_alg_id_return rsa_sha256_alg_id85;
    #undef	RETURN_TYPE_rsa_sha256_alg_id85
    #define	RETURN_TYPE_rsa_sha256_alg_id85 RFC5280Parser_rsa_sha256_alg_id_return

    RFC5280Parser_issuer_return issuer86;
    #undef	RETURN_TYPE_issuer86
    #define	RETURN_TYPE_issuer86 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity87;
    #undef	RETURN_TYPE_validity87
    #define	RETURN_TYPE_validity87 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject88;
    #undef	RETURN_TYPE_subject88
    #define	RETURN_TYPE_subject88 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo89;
    #undef	RETURN_TYPE_subjectPKinfo89
    #define	RETURN_TYPE_subjectPKinfo89 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId90;
    #undef	RETURN_TYPE_issueruniqueId90
    #define	RETURN_TYPE_issueruniqueId90 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId91;
    #undef	RETURN_TYPE_subjectuniqueId91
    #define	RETURN_TYPE_subjectuniqueId91 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag392;
    #undef	RETURN_TYPE_constructedTag392
    #define	RETURN_TYPE_constructedTag392 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag93;
    #undef	RETURN_TYPE_sequenceTag93
    #define	RETURN_TYPE_sequenceTag93 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions94;
    #undef	RETURN_TYPE_extensions94
    #define	RETURN_TYPE_extensions94 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag95;
    #undef	RETURN_TYPE_sequenceTag95
    #define	RETURN_TYPE_sequenceTag95 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo96;
    #undef	RETURN_TYPE_subjectPKinfo96
    #define	RETURN_TYPE_subjectPKinfo96 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId97;
    #undef	RETURN_TYPE_issueruniqueId97
    #define	RETURN_TYPE_issueruniqueId97 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId98;
    #undef	RETURN_TYPE_subjectuniqueId98
    #define	RETURN_TYPE_subjectuniqueId98 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag399;
    #undef	RETURN_TYPE_constructedTag399
    #define	RETURN_TYPE_constructedTag399 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag100;
    #undef	RETURN_TYPE_sequenceTag100
    #define	RETURN_TYPE_sequenceTag100 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt101;
    #undef	RETURN_TYPE_extensionsWithSubAlt101
    #define	RETURN_TYPE_extensionsWithSubAlt101 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_rsa_sha256_alg_id_return rsa_sha256_alg_id102;
    #undef	RETURN_TYPE_rsa_sha256_alg_id102
    #define	RETURN_TYPE_rsa_sha256_alg_id102 RFC5280Parser_rsa_sha256_alg_id_return

    RFC5280Parser_signature_return signature103;
    #undef	RETURN_TYPE_signature103
    #define	RETURN_TYPE_signature103 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha384_alg_id_return rsa_sha384_alg_id104;
    #undef	RETURN_TYPE_rsa_sha384_alg_id104
    #define	RETURN_TYPE_rsa_sha384_alg_id104 RFC5280Parser_rsa_sha384_alg_id_return

    RFC5280Parser_issuer_return issuer105;
    #undef	RETURN_TYPE_issuer105
    #define	RETURN_TYPE_issuer105 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity106;
    #undef	RETURN_TYPE_validity106
    #define	RETURN_TYPE_validity106 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject107;
    #undef	RETURN_TYPE_subject107
    #define	RETURN_TYPE_subject107 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo108;
    #undef	RETURN_TYPE_subjectPKinfo108
    #define	RETURN_TYPE_subjectPKinfo108 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId109;
    #undef	RETURN_TYPE_issueruniqueId109
    #define	RETURN_TYPE_issueruniqueId109 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId110;
    #undef	RETURN_TYPE_subjectuniqueId110
    #define	RETURN_TYPE_subjectuniqueId110 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3111;
    #undef	RETURN_TYPE_constructedTag3111
    #define	RETURN_TYPE_constructedTag3111 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag112;
    #undef	RETURN_TYPE_sequenceTag112
    #define	RETURN_TYPE_sequenceTag112 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions113;
    #undef	RETURN_TYPE_extensions113
    #define	RETURN_TYPE_extensions113 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag114;
    #undef	RETURN_TYPE_sequenceTag114
    #define	RETURN_TYPE_sequenceTag114 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo115;
    #undef	RETURN_TYPE_subjectPKinfo115
    #define	RETURN_TYPE_subjectPKinfo115 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId116;
    #undef	RETURN_TYPE_issueruniqueId116
    #define	RETURN_TYPE_issueruniqueId116 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId117;
    #undef	RETURN_TYPE_subjectuniqueId117
    #define	RETURN_TYPE_subjectuniqueId117 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3118;
    #undef	RETURN_TYPE_constructedTag3118
    #define	RETURN_TYPE_constructedTag3118 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag119;
    #undef	RETURN_TYPE_sequenceTag119
    #define	RETURN_TYPE_sequenceTag119 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt120;
    #undef	RETURN_TYPE_extensionsWithSubAlt120
    #define	RETURN_TYPE_extensionsWithSubAlt120 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_rsa_sha384_alg_id_return rsa_sha384_alg_id121;
    #undef	RETURN_TYPE_rsa_sha384_alg_id121
    #define	RETURN_TYPE_rsa_sha384_alg_id121 RFC5280Parser_rsa_sha384_alg_id_return

    RFC5280Parser_signature_return signature122;
    #undef	RETURN_TYPE_signature122
    #define	RETURN_TYPE_signature122 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha512_alg_id_return rsa_sha512_alg_id123;
    #undef	RETURN_TYPE_rsa_sha512_alg_id123
    #define	RETURN_TYPE_rsa_sha512_alg_id123 RFC5280Parser_rsa_sha512_alg_id_return

    RFC5280Parser_issuer_return issuer124;
    #undef	RETURN_TYPE_issuer124
    #define	RETURN_TYPE_issuer124 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity125;
    #undef	RETURN_TYPE_validity125
    #define	RETURN_TYPE_validity125 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject126;
    #undef	RETURN_TYPE_subject126
    #define	RETURN_TYPE_subject126 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo127;
    #undef	RETURN_TYPE_subjectPKinfo127
    #define	RETURN_TYPE_subjectPKinfo127 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId128;
    #undef	RETURN_TYPE_issueruniqueId128
    #define	RETURN_TYPE_issueruniqueId128 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId129;
    #undef	RETURN_TYPE_subjectuniqueId129
    #define	RETURN_TYPE_subjectuniqueId129 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3130;
    #undef	RETURN_TYPE_constructedTag3130
    #define	RETURN_TYPE_constructedTag3130 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag131;
    #undef	RETURN_TYPE_sequenceTag131
    #define	RETURN_TYPE_sequenceTag131 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions132;
    #undef	RETURN_TYPE_extensions132
    #define	RETURN_TYPE_extensions132 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag133;
    #undef	RETURN_TYPE_sequenceTag133
    #define	RETURN_TYPE_sequenceTag133 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo134;
    #undef	RETURN_TYPE_subjectPKinfo134
    #define	RETURN_TYPE_subjectPKinfo134 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId135;
    #undef	RETURN_TYPE_issueruniqueId135
    #define	RETURN_TYPE_issueruniqueId135 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId136;
    #undef	RETURN_TYPE_subjectuniqueId136
    #define	RETURN_TYPE_subjectuniqueId136 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3137;
    #undef	RETURN_TYPE_constructedTag3137
    #define	RETURN_TYPE_constructedTag3137 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag138;
    #undef	RETURN_TYPE_sequenceTag138
    #define	RETURN_TYPE_sequenceTag138 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt139;
    #undef	RETURN_TYPE_extensionsWithSubAlt139
    #define	RETURN_TYPE_extensionsWithSubAlt139 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_rsa_sha512_alg_id_return rsa_sha512_alg_id140;
    #undef	RETURN_TYPE_rsa_sha512_alg_id140
    #define	RETURN_TYPE_rsa_sha512_alg_id140 RFC5280Parser_rsa_sha512_alg_id_return

    RFC5280Parser_signature_return signature141;
    #undef	RETURN_TYPE_signature141
    #define	RETURN_TYPE_signature141 RFC5280Parser_signature_return

    RFC5280Parser_dsa_sha_alg_id_return dsa_sha_alg_id142;
    #undef	RETURN_TYPE_dsa_sha_alg_id142
    #define	RETURN_TYPE_dsa_sha_alg_id142 RFC5280Parser_dsa_sha_alg_id_return

    RFC5280Parser_issuer_return issuer143;
    #undef	RETURN_TYPE_issuer143
    #define	RETURN_TYPE_issuer143 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity144;
    #undef	RETURN_TYPE_validity144
    #define	RETURN_TYPE_validity144 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject145;
    #undef	RETURN_TYPE_subject145
    #define	RETURN_TYPE_subject145 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo146;
    #undef	RETURN_TYPE_subjectPKinfo146
    #define	RETURN_TYPE_subjectPKinfo146 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId147;
    #undef	RETURN_TYPE_issueruniqueId147
    #define	RETURN_TYPE_issueruniqueId147 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId148;
    #undef	RETURN_TYPE_subjectuniqueId148
    #define	RETURN_TYPE_subjectuniqueId148 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3149;
    #undef	RETURN_TYPE_constructedTag3149
    #define	RETURN_TYPE_constructedTag3149 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag150;
    #undef	RETURN_TYPE_sequenceTag150
    #define	RETURN_TYPE_sequenceTag150 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions151;
    #undef	RETURN_TYPE_extensions151
    #define	RETURN_TYPE_extensions151 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag152;
    #undef	RETURN_TYPE_sequenceTag152
    #define	RETURN_TYPE_sequenceTag152 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo153;
    #undef	RETURN_TYPE_subjectPKinfo153
    #define	RETURN_TYPE_subjectPKinfo153 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId154;
    #undef	RETURN_TYPE_issueruniqueId154
    #define	RETURN_TYPE_issueruniqueId154 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId155;
    #undef	RETURN_TYPE_subjectuniqueId155
    #define	RETURN_TYPE_subjectuniqueId155 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3156;
    #undef	RETURN_TYPE_constructedTag3156
    #define	RETURN_TYPE_constructedTag3156 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag157;
    #undef	RETURN_TYPE_sequenceTag157
    #define	RETURN_TYPE_sequenceTag157 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt158;
    #undef	RETURN_TYPE_extensionsWithSubAlt158
    #define	RETURN_TYPE_extensionsWithSubAlt158 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_dsa_sha_alg_id_return dsa_sha_alg_id159;
    #undef	RETURN_TYPE_dsa_sha_alg_id159
    #define	RETURN_TYPE_dsa_sha_alg_id159 RFC5280Parser_dsa_sha_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature160;
    #undef	RETURN_TYPE_dsa_signature160
    #define	RETURN_TYPE_dsa_signature160 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha_alg_id_return ec_sha_alg_id161;
    #undef	RETURN_TYPE_ec_sha_alg_id161
    #define	RETURN_TYPE_ec_sha_alg_id161 RFC5280Parser_ec_sha_alg_id_return

    RFC5280Parser_issuer_return issuer162;
    #undef	RETURN_TYPE_issuer162
    #define	RETURN_TYPE_issuer162 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity163;
    #undef	RETURN_TYPE_validity163
    #define	RETURN_TYPE_validity163 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject164;
    #undef	RETURN_TYPE_subject164
    #define	RETURN_TYPE_subject164 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo165;
    #undef	RETURN_TYPE_subjectPKinfo165
    #define	RETURN_TYPE_subjectPKinfo165 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId166;
    #undef	RETURN_TYPE_issueruniqueId166
    #define	RETURN_TYPE_issueruniqueId166 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId167;
    #undef	RETURN_TYPE_subjectuniqueId167
    #define	RETURN_TYPE_subjectuniqueId167 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3168;
    #undef	RETURN_TYPE_constructedTag3168
    #define	RETURN_TYPE_constructedTag3168 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag169;
    #undef	RETURN_TYPE_sequenceTag169
    #define	RETURN_TYPE_sequenceTag169 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions170;
    #undef	RETURN_TYPE_extensions170
    #define	RETURN_TYPE_extensions170 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag171;
    #undef	RETURN_TYPE_sequenceTag171
    #define	RETURN_TYPE_sequenceTag171 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo172;
    #undef	RETURN_TYPE_subjectPKinfo172
    #define	RETURN_TYPE_subjectPKinfo172 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId173;
    #undef	RETURN_TYPE_issueruniqueId173
    #define	RETURN_TYPE_issueruniqueId173 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId174;
    #undef	RETURN_TYPE_subjectuniqueId174
    #define	RETURN_TYPE_subjectuniqueId174 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3175;
    #undef	RETURN_TYPE_constructedTag3175
    #define	RETURN_TYPE_constructedTag3175 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag176;
    #undef	RETURN_TYPE_sequenceTag176
    #define	RETURN_TYPE_sequenceTag176 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt177;
    #undef	RETURN_TYPE_extensionsWithSubAlt177
    #define	RETURN_TYPE_extensionsWithSubAlt177 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_ec_sha_alg_id_return ec_sha_alg_id178;
    #undef	RETURN_TYPE_ec_sha_alg_id178
    #define	RETURN_TYPE_ec_sha_alg_id178 RFC5280Parser_ec_sha_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature179;
    #undef	RETURN_TYPE_dsa_signature179
    #define	RETURN_TYPE_dsa_signature179 RFC5280Parser_dsa_signature_return

    RFC5280Parser_pss_alg_id_params_return pss_alg_id_params180;
    #undef	RETURN_TYPE_pss_alg_id_params180
    #define	RETURN_TYPE_pss_alg_id_params180 RFC5280Parser_pss_alg_id_params_return

    RFC5280Parser_issuer_return issuer181;
    #undef	RETURN_TYPE_issuer181
    #define	RETURN_TYPE_issuer181 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity182;
    #undef	RETURN_TYPE_validity182
    #define	RETURN_TYPE_validity182 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject183;
    #undef	RETURN_TYPE_subject183
    #define	RETURN_TYPE_subject183 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo184;
    #undef	RETURN_TYPE_subjectPKinfo184
    #define	RETURN_TYPE_subjectPKinfo184 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId185;
    #undef	RETURN_TYPE_issueruniqueId185
    #define	RETURN_TYPE_issueruniqueId185 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId186;
    #undef	RETURN_TYPE_subjectuniqueId186
    #define	RETURN_TYPE_subjectuniqueId186 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3187;
    #undef	RETURN_TYPE_constructedTag3187
    #define	RETURN_TYPE_constructedTag3187 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag188;
    #undef	RETURN_TYPE_sequenceTag188
    #define	RETURN_TYPE_sequenceTag188 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions189;
    #undef	RETURN_TYPE_extensions189
    #define	RETURN_TYPE_extensions189 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag190;
    #undef	RETURN_TYPE_sequenceTag190
    #define	RETURN_TYPE_sequenceTag190 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo191;
    #undef	RETURN_TYPE_subjectPKinfo191
    #define	RETURN_TYPE_subjectPKinfo191 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId192;
    #undef	RETURN_TYPE_issueruniqueId192
    #define	RETURN_TYPE_issueruniqueId192 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId193;
    #undef	RETURN_TYPE_subjectuniqueId193
    #define	RETURN_TYPE_subjectuniqueId193 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3194;
    #undef	RETURN_TYPE_constructedTag3194
    #define	RETURN_TYPE_constructedTag3194 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag195;
    #undef	RETURN_TYPE_sequenceTag195
    #define	RETURN_TYPE_sequenceTag195 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt196;
    #undef	RETURN_TYPE_extensionsWithSubAlt196
    #define	RETURN_TYPE_extensionsWithSubAlt196 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_pss_alg_id_params_return pss_alg_id_params197;
    #undef	RETURN_TYPE_pss_alg_id_params197
    #define	RETURN_TYPE_pss_alg_id_params197 RFC5280Parser_pss_alg_id_params_return

    RFC5280Parser_signature_return signature198;
    #undef	RETURN_TYPE_signature198
    #define	RETURN_TYPE_signature198 RFC5280Parser_signature_return

    RFC5280Parser_dsa_sha224_alg_id_return dsa_sha224_alg_id199;
    #undef	RETURN_TYPE_dsa_sha224_alg_id199
    #define	RETURN_TYPE_dsa_sha224_alg_id199 RFC5280Parser_dsa_sha224_alg_id_return

    RFC5280Parser_issuer_return issuer200;
    #undef	RETURN_TYPE_issuer200
    #define	RETURN_TYPE_issuer200 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity201;
    #undef	RETURN_TYPE_validity201
    #define	RETURN_TYPE_validity201 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject202;
    #undef	RETURN_TYPE_subject202
    #define	RETURN_TYPE_subject202 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo203;
    #undef	RETURN_TYPE_subjectPKinfo203
    #define	RETURN_TYPE_subjectPKinfo203 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId204;
    #undef	RETURN_TYPE_issueruniqueId204
    #define	RETURN_TYPE_issueruniqueId204 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId205;
    #undef	RETURN_TYPE_subjectuniqueId205
    #define	RETURN_TYPE_subjectuniqueId205 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3206;
    #undef	RETURN_TYPE_constructedTag3206
    #define	RETURN_TYPE_constructedTag3206 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag207;
    #undef	RETURN_TYPE_sequenceTag207
    #define	RETURN_TYPE_sequenceTag207 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions208;
    #undef	RETURN_TYPE_extensions208
    #define	RETURN_TYPE_extensions208 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag209;
    #undef	RETURN_TYPE_sequenceTag209
    #define	RETURN_TYPE_sequenceTag209 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo210;
    #undef	RETURN_TYPE_subjectPKinfo210
    #define	RETURN_TYPE_subjectPKinfo210 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId211;
    #undef	RETURN_TYPE_issueruniqueId211
    #define	RETURN_TYPE_issueruniqueId211 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId212;
    #undef	RETURN_TYPE_subjectuniqueId212
    #define	RETURN_TYPE_subjectuniqueId212 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3213;
    #undef	RETURN_TYPE_constructedTag3213
    #define	RETURN_TYPE_constructedTag3213 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag214;
    #undef	RETURN_TYPE_sequenceTag214
    #define	RETURN_TYPE_sequenceTag214 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt215;
    #undef	RETURN_TYPE_extensionsWithSubAlt215
    #define	RETURN_TYPE_extensionsWithSubAlt215 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_dsa_sha224_alg_id_return dsa_sha224_alg_id216;
    #undef	RETURN_TYPE_dsa_sha224_alg_id216
    #define	RETURN_TYPE_dsa_sha224_alg_id216 RFC5280Parser_dsa_sha224_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature217;
    #undef	RETURN_TYPE_dsa_signature217
    #define	RETURN_TYPE_dsa_signature217 RFC5280Parser_dsa_signature_return

    RFC5280Parser_dsa_sha256_alg_id_return dsa_sha256_alg_id218;
    #undef	RETURN_TYPE_dsa_sha256_alg_id218
    #define	RETURN_TYPE_dsa_sha256_alg_id218 RFC5280Parser_dsa_sha256_alg_id_return

    RFC5280Parser_issuer_return issuer219;
    #undef	RETURN_TYPE_issuer219
    #define	RETURN_TYPE_issuer219 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity220;
    #undef	RETURN_TYPE_validity220
    #define	RETURN_TYPE_validity220 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject221;
    #undef	RETURN_TYPE_subject221
    #define	RETURN_TYPE_subject221 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo222;
    #undef	RETURN_TYPE_subjectPKinfo222
    #define	RETURN_TYPE_subjectPKinfo222 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId223;
    #undef	RETURN_TYPE_issueruniqueId223
    #define	RETURN_TYPE_issueruniqueId223 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId224;
    #undef	RETURN_TYPE_subjectuniqueId224
    #define	RETURN_TYPE_subjectuniqueId224 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3225;
    #undef	RETURN_TYPE_constructedTag3225
    #define	RETURN_TYPE_constructedTag3225 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag226;
    #undef	RETURN_TYPE_sequenceTag226
    #define	RETURN_TYPE_sequenceTag226 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions227;
    #undef	RETURN_TYPE_extensions227
    #define	RETURN_TYPE_extensions227 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag228;
    #undef	RETURN_TYPE_sequenceTag228
    #define	RETURN_TYPE_sequenceTag228 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo229;
    #undef	RETURN_TYPE_subjectPKinfo229
    #define	RETURN_TYPE_subjectPKinfo229 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId230;
    #undef	RETURN_TYPE_issueruniqueId230
    #define	RETURN_TYPE_issueruniqueId230 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId231;
    #undef	RETURN_TYPE_subjectuniqueId231
    #define	RETURN_TYPE_subjectuniqueId231 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3232;
    #undef	RETURN_TYPE_constructedTag3232
    #define	RETURN_TYPE_constructedTag3232 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag233;
    #undef	RETURN_TYPE_sequenceTag233
    #define	RETURN_TYPE_sequenceTag233 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt234;
    #undef	RETURN_TYPE_extensionsWithSubAlt234
    #define	RETURN_TYPE_extensionsWithSubAlt234 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_dsa_sha256_alg_id_return dsa_sha256_alg_id235;
    #undef	RETURN_TYPE_dsa_sha256_alg_id235
    #define	RETURN_TYPE_dsa_sha256_alg_id235 RFC5280Parser_dsa_sha256_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature236;
    #undef	RETURN_TYPE_dsa_signature236
    #define	RETURN_TYPE_dsa_signature236 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha224_alg_id_return ec_sha224_alg_id237;
    #undef	RETURN_TYPE_ec_sha224_alg_id237
    #define	RETURN_TYPE_ec_sha224_alg_id237 RFC5280Parser_ec_sha224_alg_id_return

    RFC5280Parser_issuer_return issuer238;
    #undef	RETURN_TYPE_issuer238
    #define	RETURN_TYPE_issuer238 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity239;
    #undef	RETURN_TYPE_validity239
    #define	RETURN_TYPE_validity239 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject240;
    #undef	RETURN_TYPE_subject240
    #define	RETURN_TYPE_subject240 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo241;
    #undef	RETURN_TYPE_subjectPKinfo241
    #define	RETURN_TYPE_subjectPKinfo241 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId242;
    #undef	RETURN_TYPE_issueruniqueId242
    #define	RETURN_TYPE_issueruniqueId242 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId243;
    #undef	RETURN_TYPE_subjectuniqueId243
    #define	RETURN_TYPE_subjectuniqueId243 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3244;
    #undef	RETURN_TYPE_constructedTag3244
    #define	RETURN_TYPE_constructedTag3244 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag245;
    #undef	RETURN_TYPE_sequenceTag245
    #define	RETURN_TYPE_sequenceTag245 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions246;
    #undef	RETURN_TYPE_extensions246
    #define	RETURN_TYPE_extensions246 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag247;
    #undef	RETURN_TYPE_sequenceTag247
    #define	RETURN_TYPE_sequenceTag247 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo248;
    #undef	RETURN_TYPE_subjectPKinfo248
    #define	RETURN_TYPE_subjectPKinfo248 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId249;
    #undef	RETURN_TYPE_issueruniqueId249
    #define	RETURN_TYPE_issueruniqueId249 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId250;
    #undef	RETURN_TYPE_subjectuniqueId250
    #define	RETURN_TYPE_subjectuniqueId250 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3251;
    #undef	RETURN_TYPE_constructedTag3251
    #define	RETURN_TYPE_constructedTag3251 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag252;
    #undef	RETURN_TYPE_sequenceTag252
    #define	RETURN_TYPE_sequenceTag252 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt253;
    #undef	RETURN_TYPE_extensionsWithSubAlt253
    #define	RETURN_TYPE_extensionsWithSubAlt253 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_ec_sha224_alg_id_return ec_sha224_alg_id254;
    #undef	RETURN_TYPE_ec_sha224_alg_id254
    #define	RETURN_TYPE_ec_sha224_alg_id254 RFC5280Parser_ec_sha224_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature255;
    #undef	RETURN_TYPE_dsa_signature255
    #define	RETURN_TYPE_dsa_signature255 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha256_alg_id_return ec_sha256_alg_id256;
    #undef	RETURN_TYPE_ec_sha256_alg_id256
    #define	RETURN_TYPE_ec_sha256_alg_id256 RFC5280Parser_ec_sha256_alg_id_return

    RFC5280Parser_issuer_return issuer257;
    #undef	RETURN_TYPE_issuer257
    #define	RETURN_TYPE_issuer257 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity258;
    #undef	RETURN_TYPE_validity258
    #define	RETURN_TYPE_validity258 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject259;
    #undef	RETURN_TYPE_subject259
    #define	RETURN_TYPE_subject259 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo260;
    #undef	RETURN_TYPE_subjectPKinfo260
    #define	RETURN_TYPE_subjectPKinfo260 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId261;
    #undef	RETURN_TYPE_issueruniqueId261
    #define	RETURN_TYPE_issueruniqueId261 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId262;
    #undef	RETURN_TYPE_subjectuniqueId262
    #define	RETURN_TYPE_subjectuniqueId262 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3263;
    #undef	RETURN_TYPE_constructedTag3263
    #define	RETURN_TYPE_constructedTag3263 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag264;
    #undef	RETURN_TYPE_sequenceTag264
    #define	RETURN_TYPE_sequenceTag264 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions265;
    #undef	RETURN_TYPE_extensions265
    #define	RETURN_TYPE_extensions265 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag266;
    #undef	RETURN_TYPE_sequenceTag266
    #define	RETURN_TYPE_sequenceTag266 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo267;
    #undef	RETURN_TYPE_subjectPKinfo267
    #define	RETURN_TYPE_subjectPKinfo267 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId268;
    #undef	RETURN_TYPE_issueruniqueId268
    #define	RETURN_TYPE_issueruniqueId268 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId269;
    #undef	RETURN_TYPE_subjectuniqueId269
    #define	RETURN_TYPE_subjectuniqueId269 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3270;
    #undef	RETURN_TYPE_constructedTag3270
    #define	RETURN_TYPE_constructedTag3270 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag271;
    #undef	RETURN_TYPE_sequenceTag271
    #define	RETURN_TYPE_sequenceTag271 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt272;
    #undef	RETURN_TYPE_extensionsWithSubAlt272
    #define	RETURN_TYPE_extensionsWithSubAlt272 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_ec_sha256_alg_id_return ec_sha256_alg_id273;
    #undef	RETURN_TYPE_ec_sha256_alg_id273
    #define	RETURN_TYPE_ec_sha256_alg_id273 RFC5280Parser_ec_sha256_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature274;
    #undef	RETURN_TYPE_dsa_signature274
    #define	RETURN_TYPE_dsa_signature274 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha384_alg_id_return ec_sha384_alg_id275;
    #undef	RETURN_TYPE_ec_sha384_alg_id275
    #define	RETURN_TYPE_ec_sha384_alg_id275 RFC5280Parser_ec_sha384_alg_id_return

    RFC5280Parser_issuer_return issuer276;
    #undef	RETURN_TYPE_issuer276
    #define	RETURN_TYPE_issuer276 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity277;
    #undef	RETURN_TYPE_validity277
    #define	RETURN_TYPE_validity277 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject278;
    #undef	RETURN_TYPE_subject278
    #define	RETURN_TYPE_subject278 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo279;
    #undef	RETURN_TYPE_subjectPKinfo279
    #define	RETURN_TYPE_subjectPKinfo279 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId280;
    #undef	RETURN_TYPE_issueruniqueId280
    #define	RETURN_TYPE_issueruniqueId280 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId281;
    #undef	RETURN_TYPE_subjectuniqueId281
    #define	RETURN_TYPE_subjectuniqueId281 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3282;
    #undef	RETURN_TYPE_constructedTag3282
    #define	RETURN_TYPE_constructedTag3282 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag283;
    #undef	RETURN_TYPE_sequenceTag283
    #define	RETURN_TYPE_sequenceTag283 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions284;
    #undef	RETURN_TYPE_extensions284
    #define	RETURN_TYPE_extensions284 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag285;
    #undef	RETURN_TYPE_sequenceTag285
    #define	RETURN_TYPE_sequenceTag285 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo286;
    #undef	RETURN_TYPE_subjectPKinfo286
    #define	RETURN_TYPE_subjectPKinfo286 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId287;
    #undef	RETURN_TYPE_issueruniqueId287
    #define	RETURN_TYPE_issueruniqueId287 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId288;
    #undef	RETURN_TYPE_subjectuniqueId288
    #define	RETURN_TYPE_subjectuniqueId288 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3289;
    #undef	RETURN_TYPE_constructedTag3289
    #define	RETURN_TYPE_constructedTag3289 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag290;
    #undef	RETURN_TYPE_sequenceTag290
    #define	RETURN_TYPE_sequenceTag290 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt291;
    #undef	RETURN_TYPE_extensionsWithSubAlt291
    #define	RETURN_TYPE_extensionsWithSubAlt291 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_ec_sha384_alg_id_return ec_sha384_alg_id292;
    #undef	RETURN_TYPE_ec_sha384_alg_id292
    #define	RETURN_TYPE_ec_sha384_alg_id292 RFC5280Parser_ec_sha384_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature293;
    #undef	RETURN_TYPE_dsa_signature293
    #define	RETURN_TYPE_dsa_signature293 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha512_alg_id_return ec_sha512_alg_id294;
    #undef	RETURN_TYPE_ec_sha512_alg_id294
    #define	RETURN_TYPE_ec_sha512_alg_id294 RFC5280Parser_ec_sha512_alg_id_return

    RFC5280Parser_issuer_return issuer295;
    #undef	RETURN_TYPE_issuer295
    #define	RETURN_TYPE_issuer295 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity296;
    #undef	RETURN_TYPE_validity296
    #define	RETURN_TYPE_validity296 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject297;
    #undef	RETURN_TYPE_subject297
    #define	RETURN_TYPE_subject297 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo298;
    #undef	RETURN_TYPE_subjectPKinfo298
    #define	RETURN_TYPE_subjectPKinfo298 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId299;
    #undef	RETURN_TYPE_issueruniqueId299
    #define	RETURN_TYPE_issueruniqueId299 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId300;
    #undef	RETURN_TYPE_subjectuniqueId300
    #define	RETURN_TYPE_subjectuniqueId300 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3301;
    #undef	RETURN_TYPE_constructedTag3301
    #define	RETURN_TYPE_constructedTag3301 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag302;
    #undef	RETURN_TYPE_sequenceTag302
    #define	RETURN_TYPE_sequenceTag302 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions303;
    #undef	RETURN_TYPE_extensions303
    #define	RETURN_TYPE_extensions303 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag304;
    #undef	RETURN_TYPE_sequenceTag304
    #define	RETURN_TYPE_sequenceTag304 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo305;
    #undef	RETURN_TYPE_subjectPKinfo305
    #define	RETURN_TYPE_subjectPKinfo305 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId306;
    #undef	RETURN_TYPE_issueruniqueId306
    #define	RETURN_TYPE_issueruniqueId306 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId307;
    #undef	RETURN_TYPE_subjectuniqueId307
    #define	RETURN_TYPE_subjectuniqueId307 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3308;
    #undef	RETURN_TYPE_constructedTag3308
    #define	RETURN_TYPE_constructedTag3308 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag309;
    #undef	RETURN_TYPE_sequenceTag309
    #define	RETURN_TYPE_sequenceTag309 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt310;
    #undef	RETURN_TYPE_extensionsWithSubAlt310
    #define	RETURN_TYPE_extensionsWithSubAlt310 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_ec_sha512_alg_id_return ec_sha512_alg_id311;
    #undef	RETURN_TYPE_ec_sha512_alg_id311
    #define	RETURN_TYPE_ec_sha512_alg_id311 RFC5280Parser_ec_sha512_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature312;
    #undef	RETURN_TYPE_dsa_signature312
    #define	RETURN_TYPE_dsa_signature312 RFC5280Parser_dsa_signature_return

    RFC5280Parser_gost_94_alg_id_return gost_94_alg_id313;
    #undef	RETURN_TYPE_gost_94_alg_id313
    #define	RETURN_TYPE_gost_94_alg_id313 RFC5280Parser_gost_94_alg_id_return

    RFC5280Parser_issuer_return issuer314;
    #undef	RETURN_TYPE_issuer314
    #define	RETURN_TYPE_issuer314 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity315;
    #undef	RETURN_TYPE_validity315
    #define	RETURN_TYPE_validity315 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject316;
    #undef	RETURN_TYPE_subject316
    #define	RETURN_TYPE_subject316 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo317;
    #undef	RETURN_TYPE_subjectPKinfo317
    #define	RETURN_TYPE_subjectPKinfo317 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId318;
    #undef	RETURN_TYPE_issueruniqueId318
    #define	RETURN_TYPE_issueruniqueId318 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId319;
    #undef	RETURN_TYPE_subjectuniqueId319
    #define	RETURN_TYPE_subjectuniqueId319 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3320;
    #undef	RETURN_TYPE_constructedTag3320
    #define	RETURN_TYPE_constructedTag3320 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag321;
    #undef	RETURN_TYPE_sequenceTag321
    #define	RETURN_TYPE_sequenceTag321 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions322;
    #undef	RETURN_TYPE_extensions322
    #define	RETURN_TYPE_extensions322 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag323;
    #undef	RETURN_TYPE_sequenceTag323
    #define	RETURN_TYPE_sequenceTag323 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo324;
    #undef	RETURN_TYPE_subjectPKinfo324
    #define	RETURN_TYPE_subjectPKinfo324 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId325;
    #undef	RETURN_TYPE_issueruniqueId325
    #define	RETURN_TYPE_issueruniqueId325 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId326;
    #undef	RETURN_TYPE_subjectuniqueId326
    #define	RETURN_TYPE_subjectuniqueId326 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3327;
    #undef	RETURN_TYPE_constructedTag3327
    #define	RETURN_TYPE_constructedTag3327 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag328;
    #undef	RETURN_TYPE_sequenceTag328
    #define	RETURN_TYPE_sequenceTag328 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt329;
    #undef	RETURN_TYPE_extensionsWithSubAlt329
    #define	RETURN_TYPE_extensionsWithSubAlt329 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_gost_94_alg_id_return gost_94_alg_id330;
    #undef	RETURN_TYPE_gost_94_alg_id330
    #define	RETURN_TYPE_gost_94_alg_id330 RFC5280Parser_gost_94_alg_id_return

    RFC5280Parser_signature_return signature331;
    #undef	RETURN_TYPE_signature331
    #define	RETURN_TYPE_signature331 RFC5280Parser_signature_return

    RFC5280Parser_gost_01_alg_id_return gost_01_alg_id332;
    #undef	RETURN_TYPE_gost_01_alg_id332
    #define	RETURN_TYPE_gost_01_alg_id332 RFC5280Parser_gost_01_alg_id_return

    RFC5280Parser_issuer_return issuer333;
    #undef	RETURN_TYPE_issuer333
    #define	RETURN_TYPE_issuer333 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity334;
    #undef	RETURN_TYPE_validity334
    #define	RETURN_TYPE_validity334 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject335;
    #undef	RETURN_TYPE_subject335
    #define	RETURN_TYPE_subject335 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo336;
    #undef	RETURN_TYPE_subjectPKinfo336
    #define	RETURN_TYPE_subjectPKinfo336 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId337;
    #undef	RETURN_TYPE_issueruniqueId337
    #define	RETURN_TYPE_issueruniqueId337 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId338;
    #undef	RETURN_TYPE_subjectuniqueId338
    #define	RETURN_TYPE_subjectuniqueId338 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3339;
    #undef	RETURN_TYPE_constructedTag3339
    #define	RETURN_TYPE_constructedTag3339 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag340;
    #undef	RETURN_TYPE_sequenceTag340
    #define	RETURN_TYPE_sequenceTag340 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensions_return extensions341;
    #undef	RETURN_TYPE_extensions341
    #define	RETURN_TYPE_extensions341 RFC5280Parser_extensions_return

    RFC5280Parser_sequenceTag_return sequenceTag342;
    #undef	RETURN_TYPE_sequenceTag342
    #define	RETURN_TYPE_sequenceTag342 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo343;
    #undef	RETURN_TYPE_subjectPKinfo343
    #define	RETURN_TYPE_subjectPKinfo343 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId344;
    #undef	RETURN_TYPE_issueruniqueId344
    #define	RETURN_TYPE_issueruniqueId344 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId345;
    #undef	RETURN_TYPE_subjectuniqueId345
    #define	RETURN_TYPE_subjectuniqueId345 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_constructedTag3_return constructedTag3346;
    #undef	RETURN_TYPE_constructedTag3346
    #define	RETURN_TYPE_constructedTag3346 RFC5280Parser_constructedTag3_return

    RFC5280Parser_sequenceTag_return sequenceTag347;
    #undef	RETURN_TYPE_sequenceTag347
    #define	RETURN_TYPE_sequenceTag347 RFC5280Parser_sequenceTag_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt348;
    #undef	RETURN_TYPE_extensionsWithSubAlt348
    #define	RETURN_TYPE_extensionsWithSubAlt348 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_gost_01_alg_id_return gost_01_alg_id349;
    #undef	RETURN_TYPE_gost_01_alg_id349
    #define	RETURN_TYPE_gost_01_alg_id349 RFC5280Parser_gost_01_alg_id_return

    RFC5280Parser_signature_return signature350;
    #undef	RETURN_TYPE_signature350
    #define	RETURN_TYPE_signature350 RFC5280Parser_signature_return

    RFC5280Parser_constructedTag0_return constructedTag0351;
    #undef	RETURN_TYPE_constructedTag0351
    #define	RETURN_TYPE_constructedTag0351 RFC5280Parser_constructedTag0_return

    RFC5280Parser_version2_return version2352;
    #undef	RETURN_TYPE_version2352
    #define	RETURN_TYPE_version2352 RFC5280Parser_version2_return

    RFC5280Parser_serialnumber_return serialnumber353;
    #undef	RETURN_TYPE_serialnumber353
    #define	RETURN_TYPE_serialnumber353 RFC5280Parser_serialnumber_return

    RFC5280Parser_rsa_md2_alg_id_return rsa_md2_alg_id354;
    #undef	RETURN_TYPE_rsa_md2_alg_id354
    #define	RETURN_TYPE_rsa_md2_alg_id354 RFC5280Parser_rsa_md2_alg_id_return

    RFC5280Parser_issuer_return issuer355;
    #undef	RETURN_TYPE_issuer355
    #define	RETURN_TYPE_issuer355 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity356;
    #undef	RETURN_TYPE_validity356
    #define	RETURN_TYPE_validity356 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject357;
    #undef	RETURN_TYPE_subject357
    #define	RETURN_TYPE_subject357 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo358;
    #undef	RETURN_TYPE_subjectPKinfo358
    #define	RETURN_TYPE_subjectPKinfo358 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId359;
    #undef	RETURN_TYPE_issueruniqueId359
    #define	RETURN_TYPE_issueruniqueId359 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId360;
    #undef	RETURN_TYPE_subjectuniqueId360
    #define	RETURN_TYPE_subjectuniqueId360 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_rsa_md2_alg_id_return rsa_md2_alg_id361;
    #undef	RETURN_TYPE_rsa_md2_alg_id361
    #define	RETURN_TYPE_rsa_md2_alg_id361 RFC5280Parser_rsa_md2_alg_id_return

    RFC5280Parser_signature_return signature362;
    #undef	RETURN_TYPE_signature362
    #define	RETURN_TYPE_signature362 RFC5280Parser_signature_return

    RFC5280Parser_rsa_md5_alg_id_return rsa_md5_alg_id363;
    #undef	RETURN_TYPE_rsa_md5_alg_id363
    #define	RETURN_TYPE_rsa_md5_alg_id363 RFC5280Parser_rsa_md5_alg_id_return

    RFC5280Parser_issuer_return issuer364;
    #undef	RETURN_TYPE_issuer364
    #define	RETURN_TYPE_issuer364 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity365;
    #undef	RETURN_TYPE_validity365
    #define	RETURN_TYPE_validity365 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject366;
    #undef	RETURN_TYPE_subject366
    #define	RETURN_TYPE_subject366 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo367;
    #undef	RETURN_TYPE_subjectPKinfo367
    #define	RETURN_TYPE_subjectPKinfo367 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId368;
    #undef	RETURN_TYPE_issueruniqueId368
    #define	RETURN_TYPE_issueruniqueId368 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId369;
    #undef	RETURN_TYPE_subjectuniqueId369
    #define	RETURN_TYPE_subjectuniqueId369 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_rsa_md5_alg_id_return rsa_md5_alg_id370;
    #undef	RETURN_TYPE_rsa_md5_alg_id370
    #define	RETURN_TYPE_rsa_md5_alg_id370 RFC5280Parser_rsa_md5_alg_id_return

    RFC5280Parser_signature_return signature371;
    #undef	RETURN_TYPE_signature371
    #define	RETURN_TYPE_signature371 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha1_alg_id_return rsa_sha1_alg_id372;
    #undef	RETURN_TYPE_rsa_sha1_alg_id372
    #define	RETURN_TYPE_rsa_sha1_alg_id372 RFC5280Parser_rsa_sha1_alg_id_return

    RFC5280Parser_issuer_return issuer373;
    #undef	RETURN_TYPE_issuer373
    #define	RETURN_TYPE_issuer373 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity374;
    #undef	RETURN_TYPE_validity374
    #define	RETURN_TYPE_validity374 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject375;
    #undef	RETURN_TYPE_subject375
    #define	RETURN_TYPE_subject375 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo376;
    #undef	RETURN_TYPE_subjectPKinfo376
    #define	RETURN_TYPE_subjectPKinfo376 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId377;
    #undef	RETURN_TYPE_issueruniqueId377
    #define	RETURN_TYPE_issueruniqueId377 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId378;
    #undef	RETURN_TYPE_subjectuniqueId378
    #define	RETURN_TYPE_subjectuniqueId378 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_rsa_sha1_alg_id_return rsa_sha1_alg_id379;
    #undef	RETURN_TYPE_rsa_sha1_alg_id379
    #define	RETURN_TYPE_rsa_sha1_alg_id379 RFC5280Parser_rsa_sha1_alg_id_return

    RFC5280Parser_signature_return signature380;
    #undef	RETURN_TYPE_signature380
    #define	RETURN_TYPE_signature380 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha224_alg_id_return rsa_sha224_alg_id381;
    #undef	RETURN_TYPE_rsa_sha224_alg_id381
    #define	RETURN_TYPE_rsa_sha224_alg_id381 RFC5280Parser_rsa_sha224_alg_id_return

    RFC5280Parser_issuer_return issuer382;
    #undef	RETURN_TYPE_issuer382
    #define	RETURN_TYPE_issuer382 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity383;
    #undef	RETURN_TYPE_validity383
    #define	RETURN_TYPE_validity383 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject384;
    #undef	RETURN_TYPE_subject384
    #define	RETURN_TYPE_subject384 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo385;
    #undef	RETURN_TYPE_subjectPKinfo385
    #define	RETURN_TYPE_subjectPKinfo385 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId386;
    #undef	RETURN_TYPE_issueruniqueId386
    #define	RETURN_TYPE_issueruniqueId386 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId387;
    #undef	RETURN_TYPE_subjectuniqueId387
    #define	RETURN_TYPE_subjectuniqueId387 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_rsa_sha224_alg_id_return rsa_sha224_alg_id388;
    #undef	RETURN_TYPE_rsa_sha224_alg_id388
    #define	RETURN_TYPE_rsa_sha224_alg_id388 RFC5280Parser_rsa_sha224_alg_id_return

    RFC5280Parser_signature_return signature389;
    #undef	RETURN_TYPE_signature389
    #define	RETURN_TYPE_signature389 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha256_alg_id_return rsa_sha256_alg_id390;
    #undef	RETURN_TYPE_rsa_sha256_alg_id390
    #define	RETURN_TYPE_rsa_sha256_alg_id390 RFC5280Parser_rsa_sha256_alg_id_return

    RFC5280Parser_issuer_return issuer391;
    #undef	RETURN_TYPE_issuer391
    #define	RETURN_TYPE_issuer391 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity392;
    #undef	RETURN_TYPE_validity392
    #define	RETURN_TYPE_validity392 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject393;
    #undef	RETURN_TYPE_subject393
    #define	RETURN_TYPE_subject393 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo394;
    #undef	RETURN_TYPE_subjectPKinfo394
    #define	RETURN_TYPE_subjectPKinfo394 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId395;
    #undef	RETURN_TYPE_issueruniqueId395
    #define	RETURN_TYPE_issueruniqueId395 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId396;
    #undef	RETURN_TYPE_subjectuniqueId396
    #define	RETURN_TYPE_subjectuniqueId396 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_rsa_sha256_alg_id_return rsa_sha256_alg_id397;
    #undef	RETURN_TYPE_rsa_sha256_alg_id397
    #define	RETURN_TYPE_rsa_sha256_alg_id397 RFC5280Parser_rsa_sha256_alg_id_return

    RFC5280Parser_signature_return signature398;
    #undef	RETURN_TYPE_signature398
    #define	RETURN_TYPE_signature398 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha384_alg_id_return rsa_sha384_alg_id399;
    #undef	RETURN_TYPE_rsa_sha384_alg_id399
    #define	RETURN_TYPE_rsa_sha384_alg_id399 RFC5280Parser_rsa_sha384_alg_id_return

    RFC5280Parser_issuer_return issuer400;
    #undef	RETURN_TYPE_issuer400
    #define	RETURN_TYPE_issuer400 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity401;
    #undef	RETURN_TYPE_validity401
    #define	RETURN_TYPE_validity401 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject402;
    #undef	RETURN_TYPE_subject402
    #define	RETURN_TYPE_subject402 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo403;
    #undef	RETURN_TYPE_subjectPKinfo403
    #define	RETURN_TYPE_subjectPKinfo403 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId404;
    #undef	RETURN_TYPE_issueruniqueId404
    #define	RETURN_TYPE_issueruniqueId404 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId405;
    #undef	RETURN_TYPE_subjectuniqueId405
    #define	RETURN_TYPE_subjectuniqueId405 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_rsa_sha384_alg_id_return rsa_sha384_alg_id406;
    #undef	RETURN_TYPE_rsa_sha384_alg_id406
    #define	RETURN_TYPE_rsa_sha384_alg_id406 RFC5280Parser_rsa_sha384_alg_id_return

    RFC5280Parser_signature_return signature407;
    #undef	RETURN_TYPE_signature407
    #define	RETURN_TYPE_signature407 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha512_alg_id_return rsa_sha512_alg_id408;
    #undef	RETURN_TYPE_rsa_sha512_alg_id408
    #define	RETURN_TYPE_rsa_sha512_alg_id408 RFC5280Parser_rsa_sha512_alg_id_return

    RFC5280Parser_issuer_return issuer409;
    #undef	RETURN_TYPE_issuer409
    #define	RETURN_TYPE_issuer409 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity410;
    #undef	RETURN_TYPE_validity410
    #define	RETURN_TYPE_validity410 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject411;
    #undef	RETURN_TYPE_subject411
    #define	RETURN_TYPE_subject411 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo412;
    #undef	RETURN_TYPE_subjectPKinfo412
    #define	RETURN_TYPE_subjectPKinfo412 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId413;
    #undef	RETURN_TYPE_issueruniqueId413
    #define	RETURN_TYPE_issueruniqueId413 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId414;
    #undef	RETURN_TYPE_subjectuniqueId414
    #define	RETURN_TYPE_subjectuniqueId414 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_rsa_sha512_alg_id_return rsa_sha512_alg_id415;
    #undef	RETURN_TYPE_rsa_sha512_alg_id415
    #define	RETURN_TYPE_rsa_sha512_alg_id415 RFC5280Parser_rsa_sha512_alg_id_return

    RFC5280Parser_signature_return signature416;
    #undef	RETURN_TYPE_signature416
    #define	RETURN_TYPE_signature416 RFC5280Parser_signature_return

    RFC5280Parser_dsa_sha_alg_id_return dsa_sha_alg_id417;
    #undef	RETURN_TYPE_dsa_sha_alg_id417
    #define	RETURN_TYPE_dsa_sha_alg_id417 RFC5280Parser_dsa_sha_alg_id_return

    RFC5280Parser_issuer_return issuer418;
    #undef	RETURN_TYPE_issuer418
    #define	RETURN_TYPE_issuer418 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity419;
    #undef	RETURN_TYPE_validity419
    #define	RETURN_TYPE_validity419 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject420;
    #undef	RETURN_TYPE_subject420
    #define	RETURN_TYPE_subject420 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo421;
    #undef	RETURN_TYPE_subjectPKinfo421
    #define	RETURN_TYPE_subjectPKinfo421 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId422;
    #undef	RETURN_TYPE_issueruniqueId422
    #define	RETURN_TYPE_issueruniqueId422 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId423;
    #undef	RETURN_TYPE_subjectuniqueId423
    #define	RETURN_TYPE_subjectuniqueId423 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_dsa_sha_alg_id_return dsa_sha_alg_id424;
    #undef	RETURN_TYPE_dsa_sha_alg_id424
    #define	RETURN_TYPE_dsa_sha_alg_id424 RFC5280Parser_dsa_sha_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature425;
    #undef	RETURN_TYPE_dsa_signature425
    #define	RETURN_TYPE_dsa_signature425 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha_alg_id_return ec_sha_alg_id426;
    #undef	RETURN_TYPE_ec_sha_alg_id426
    #define	RETURN_TYPE_ec_sha_alg_id426 RFC5280Parser_ec_sha_alg_id_return

    RFC5280Parser_issuer_return issuer427;
    #undef	RETURN_TYPE_issuer427
    #define	RETURN_TYPE_issuer427 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity428;
    #undef	RETURN_TYPE_validity428
    #define	RETURN_TYPE_validity428 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject429;
    #undef	RETURN_TYPE_subject429
    #define	RETURN_TYPE_subject429 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo430;
    #undef	RETURN_TYPE_subjectPKinfo430
    #define	RETURN_TYPE_subjectPKinfo430 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId431;
    #undef	RETURN_TYPE_issueruniqueId431
    #define	RETURN_TYPE_issueruniqueId431 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId432;
    #undef	RETURN_TYPE_subjectuniqueId432
    #define	RETURN_TYPE_subjectuniqueId432 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_ec_sha_alg_id_return ec_sha_alg_id433;
    #undef	RETURN_TYPE_ec_sha_alg_id433
    #define	RETURN_TYPE_ec_sha_alg_id433 RFC5280Parser_ec_sha_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature434;
    #undef	RETURN_TYPE_dsa_signature434
    #define	RETURN_TYPE_dsa_signature434 RFC5280Parser_dsa_signature_return

    RFC5280Parser_pss_alg_id_params_return pss_alg_id_params435;
    #undef	RETURN_TYPE_pss_alg_id_params435
    #define	RETURN_TYPE_pss_alg_id_params435 RFC5280Parser_pss_alg_id_params_return

    RFC5280Parser_issuer_return issuer436;
    #undef	RETURN_TYPE_issuer436
    #define	RETURN_TYPE_issuer436 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity437;
    #undef	RETURN_TYPE_validity437
    #define	RETURN_TYPE_validity437 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject438;
    #undef	RETURN_TYPE_subject438
    #define	RETURN_TYPE_subject438 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo439;
    #undef	RETURN_TYPE_subjectPKinfo439
    #define	RETURN_TYPE_subjectPKinfo439 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId440;
    #undef	RETURN_TYPE_issueruniqueId440
    #define	RETURN_TYPE_issueruniqueId440 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId441;
    #undef	RETURN_TYPE_subjectuniqueId441
    #define	RETURN_TYPE_subjectuniqueId441 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_pss_alg_id_params_return pss_alg_id_params442;
    #undef	RETURN_TYPE_pss_alg_id_params442
    #define	RETURN_TYPE_pss_alg_id_params442 RFC5280Parser_pss_alg_id_params_return

    RFC5280Parser_signature_return signature443;
    #undef	RETURN_TYPE_signature443
    #define	RETURN_TYPE_signature443 RFC5280Parser_signature_return

    RFC5280Parser_dsa_sha224_alg_id_return dsa_sha224_alg_id444;
    #undef	RETURN_TYPE_dsa_sha224_alg_id444
    #define	RETURN_TYPE_dsa_sha224_alg_id444 RFC5280Parser_dsa_sha224_alg_id_return

    RFC5280Parser_issuer_return issuer445;
    #undef	RETURN_TYPE_issuer445
    #define	RETURN_TYPE_issuer445 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity446;
    #undef	RETURN_TYPE_validity446
    #define	RETURN_TYPE_validity446 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject447;
    #undef	RETURN_TYPE_subject447
    #define	RETURN_TYPE_subject447 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo448;
    #undef	RETURN_TYPE_subjectPKinfo448
    #define	RETURN_TYPE_subjectPKinfo448 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId449;
    #undef	RETURN_TYPE_issueruniqueId449
    #define	RETURN_TYPE_issueruniqueId449 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId450;
    #undef	RETURN_TYPE_subjectuniqueId450
    #define	RETURN_TYPE_subjectuniqueId450 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_dsa_sha224_alg_id_return dsa_sha224_alg_id451;
    #undef	RETURN_TYPE_dsa_sha224_alg_id451
    #define	RETURN_TYPE_dsa_sha224_alg_id451 RFC5280Parser_dsa_sha224_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature452;
    #undef	RETURN_TYPE_dsa_signature452
    #define	RETURN_TYPE_dsa_signature452 RFC5280Parser_dsa_signature_return

    RFC5280Parser_dsa_sha256_alg_id_return dsa_sha256_alg_id453;
    #undef	RETURN_TYPE_dsa_sha256_alg_id453
    #define	RETURN_TYPE_dsa_sha256_alg_id453 RFC5280Parser_dsa_sha256_alg_id_return

    RFC5280Parser_issuer_return issuer454;
    #undef	RETURN_TYPE_issuer454
    #define	RETURN_TYPE_issuer454 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity455;
    #undef	RETURN_TYPE_validity455
    #define	RETURN_TYPE_validity455 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject456;
    #undef	RETURN_TYPE_subject456
    #define	RETURN_TYPE_subject456 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo457;
    #undef	RETURN_TYPE_subjectPKinfo457
    #define	RETURN_TYPE_subjectPKinfo457 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId458;
    #undef	RETURN_TYPE_issueruniqueId458
    #define	RETURN_TYPE_issueruniqueId458 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId459;
    #undef	RETURN_TYPE_subjectuniqueId459
    #define	RETURN_TYPE_subjectuniqueId459 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_dsa_sha256_alg_id_return dsa_sha256_alg_id460;
    #undef	RETURN_TYPE_dsa_sha256_alg_id460
    #define	RETURN_TYPE_dsa_sha256_alg_id460 RFC5280Parser_dsa_sha256_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature461;
    #undef	RETURN_TYPE_dsa_signature461
    #define	RETURN_TYPE_dsa_signature461 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha224_alg_id_return ec_sha224_alg_id462;
    #undef	RETURN_TYPE_ec_sha224_alg_id462
    #define	RETURN_TYPE_ec_sha224_alg_id462 RFC5280Parser_ec_sha224_alg_id_return

    RFC5280Parser_issuer_return issuer463;
    #undef	RETURN_TYPE_issuer463
    #define	RETURN_TYPE_issuer463 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity464;
    #undef	RETURN_TYPE_validity464
    #define	RETURN_TYPE_validity464 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject465;
    #undef	RETURN_TYPE_subject465
    #define	RETURN_TYPE_subject465 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo466;
    #undef	RETURN_TYPE_subjectPKinfo466
    #define	RETURN_TYPE_subjectPKinfo466 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId467;
    #undef	RETURN_TYPE_issueruniqueId467
    #define	RETURN_TYPE_issueruniqueId467 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId468;
    #undef	RETURN_TYPE_subjectuniqueId468
    #define	RETURN_TYPE_subjectuniqueId468 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_ec_sha224_alg_id_return ec_sha224_alg_id469;
    #undef	RETURN_TYPE_ec_sha224_alg_id469
    #define	RETURN_TYPE_ec_sha224_alg_id469 RFC5280Parser_ec_sha224_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature470;
    #undef	RETURN_TYPE_dsa_signature470
    #define	RETURN_TYPE_dsa_signature470 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha256_alg_id_return ec_sha256_alg_id471;
    #undef	RETURN_TYPE_ec_sha256_alg_id471
    #define	RETURN_TYPE_ec_sha256_alg_id471 RFC5280Parser_ec_sha256_alg_id_return

    RFC5280Parser_issuer_return issuer472;
    #undef	RETURN_TYPE_issuer472
    #define	RETURN_TYPE_issuer472 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity473;
    #undef	RETURN_TYPE_validity473
    #define	RETURN_TYPE_validity473 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject474;
    #undef	RETURN_TYPE_subject474
    #define	RETURN_TYPE_subject474 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo475;
    #undef	RETURN_TYPE_subjectPKinfo475
    #define	RETURN_TYPE_subjectPKinfo475 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId476;
    #undef	RETURN_TYPE_issueruniqueId476
    #define	RETURN_TYPE_issueruniqueId476 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId477;
    #undef	RETURN_TYPE_subjectuniqueId477
    #define	RETURN_TYPE_subjectuniqueId477 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_ec_sha256_alg_id_return ec_sha256_alg_id478;
    #undef	RETURN_TYPE_ec_sha256_alg_id478
    #define	RETURN_TYPE_ec_sha256_alg_id478 RFC5280Parser_ec_sha256_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature479;
    #undef	RETURN_TYPE_dsa_signature479
    #define	RETURN_TYPE_dsa_signature479 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha384_alg_id_return ec_sha384_alg_id480;
    #undef	RETURN_TYPE_ec_sha384_alg_id480
    #define	RETURN_TYPE_ec_sha384_alg_id480 RFC5280Parser_ec_sha384_alg_id_return

    RFC5280Parser_issuer_return issuer481;
    #undef	RETURN_TYPE_issuer481
    #define	RETURN_TYPE_issuer481 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity482;
    #undef	RETURN_TYPE_validity482
    #define	RETURN_TYPE_validity482 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject483;
    #undef	RETURN_TYPE_subject483
    #define	RETURN_TYPE_subject483 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo484;
    #undef	RETURN_TYPE_subjectPKinfo484
    #define	RETURN_TYPE_subjectPKinfo484 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId485;
    #undef	RETURN_TYPE_issueruniqueId485
    #define	RETURN_TYPE_issueruniqueId485 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId486;
    #undef	RETURN_TYPE_subjectuniqueId486
    #define	RETURN_TYPE_subjectuniqueId486 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_ec_sha384_alg_id_return ec_sha384_alg_id487;
    #undef	RETURN_TYPE_ec_sha384_alg_id487
    #define	RETURN_TYPE_ec_sha384_alg_id487 RFC5280Parser_ec_sha384_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature488;
    #undef	RETURN_TYPE_dsa_signature488
    #define	RETURN_TYPE_dsa_signature488 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha512_alg_id_return ec_sha512_alg_id489;
    #undef	RETURN_TYPE_ec_sha512_alg_id489
    #define	RETURN_TYPE_ec_sha512_alg_id489 RFC5280Parser_ec_sha512_alg_id_return

    RFC5280Parser_issuer_return issuer490;
    #undef	RETURN_TYPE_issuer490
    #define	RETURN_TYPE_issuer490 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity491;
    #undef	RETURN_TYPE_validity491
    #define	RETURN_TYPE_validity491 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject492;
    #undef	RETURN_TYPE_subject492
    #define	RETURN_TYPE_subject492 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo493;
    #undef	RETURN_TYPE_subjectPKinfo493
    #define	RETURN_TYPE_subjectPKinfo493 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId494;
    #undef	RETURN_TYPE_issueruniqueId494
    #define	RETURN_TYPE_issueruniqueId494 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId495;
    #undef	RETURN_TYPE_subjectuniqueId495
    #define	RETURN_TYPE_subjectuniqueId495 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_ec_sha512_alg_id_return ec_sha512_alg_id496;
    #undef	RETURN_TYPE_ec_sha512_alg_id496
    #define	RETURN_TYPE_ec_sha512_alg_id496 RFC5280Parser_ec_sha512_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature497;
    #undef	RETURN_TYPE_dsa_signature497
    #define	RETURN_TYPE_dsa_signature497 RFC5280Parser_dsa_signature_return

    RFC5280Parser_gost_94_alg_id_return gost_94_alg_id498;
    #undef	RETURN_TYPE_gost_94_alg_id498
    #define	RETURN_TYPE_gost_94_alg_id498 RFC5280Parser_gost_94_alg_id_return

    RFC5280Parser_issuer_return issuer499;
    #undef	RETURN_TYPE_issuer499
    #define	RETURN_TYPE_issuer499 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity500;
    #undef	RETURN_TYPE_validity500
    #define	RETURN_TYPE_validity500 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject501;
    #undef	RETURN_TYPE_subject501
    #define	RETURN_TYPE_subject501 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo502;
    #undef	RETURN_TYPE_subjectPKinfo502
    #define	RETURN_TYPE_subjectPKinfo502 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId503;
    #undef	RETURN_TYPE_issueruniqueId503
    #define	RETURN_TYPE_issueruniqueId503 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId504;
    #undef	RETURN_TYPE_subjectuniqueId504
    #define	RETURN_TYPE_subjectuniqueId504 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_gost_94_alg_id_return gost_94_alg_id505;
    #undef	RETURN_TYPE_gost_94_alg_id505
    #define	RETURN_TYPE_gost_94_alg_id505 RFC5280Parser_gost_94_alg_id_return

    RFC5280Parser_signature_return signature506;
    #undef	RETURN_TYPE_signature506
    #define	RETURN_TYPE_signature506 RFC5280Parser_signature_return

    RFC5280Parser_gost_01_alg_id_return gost_01_alg_id507;
    #undef	RETURN_TYPE_gost_01_alg_id507
    #define	RETURN_TYPE_gost_01_alg_id507 RFC5280Parser_gost_01_alg_id_return

    RFC5280Parser_issuer_return issuer508;
    #undef	RETURN_TYPE_issuer508
    #define	RETURN_TYPE_issuer508 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity509;
    #undef	RETURN_TYPE_validity509
    #define	RETURN_TYPE_validity509 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject510;
    #undef	RETURN_TYPE_subject510
    #define	RETURN_TYPE_subject510 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo511;
    #undef	RETURN_TYPE_subjectPKinfo511
    #define	RETURN_TYPE_subjectPKinfo511 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_issueruniqueId_return issueruniqueId512;
    #undef	RETURN_TYPE_issueruniqueId512
    #define	RETURN_TYPE_issueruniqueId512 RFC5280Parser_issueruniqueId_return

    RFC5280Parser_subjectuniqueId_return subjectuniqueId513;
    #undef	RETURN_TYPE_subjectuniqueId513
    #define	RETURN_TYPE_subjectuniqueId513 RFC5280Parser_subjectuniqueId_return

    RFC5280Parser_gost_01_alg_id_return gost_01_alg_id514;
    #undef	RETURN_TYPE_gost_01_alg_id514
    #define	RETURN_TYPE_gost_01_alg_id514 RFC5280Parser_gost_01_alg_id_return

    RFC5280Parser_signature_return signature515;
    #undef	RETURN_TYPE_signature515
    #define	RETURN_TYPE_signature515 RFC5280Parser_signature_return

    RFC5280Parser_constructedTag0_return constructedTag0516;
    #undef	RETURN_TYPE_constructedTag0516
    #define	RETURN_TYPE_constructedTag0516 RFC5280Parser_constructedTag0_return

    RFC5280Parser_version_return version517;
    #undef	RETURN_TYPE_version517
    #define	RETURN_TYPE_version517 RFC5280Parser_version_return

    RFC5280Parser_serialnumber_return serialnumber518;
    #undef	RETURN_TYPE_serialnumber518
    #define	RETURN_TYPE_serialnumber518 RFC5280Parser_serialnumber_return

    RFC5280Parser_rsa_md2_alg_id_return rsa_md2_alg_id519;
    #undef	RETURN_TYPE_rsa_md2_alg_id519
    #define	RETURN_TYPE_rsa_md2_alg_id519 RFC5280Parser_rsa_md2_alg_id_return

    RFC5280Parser_issuer_return issuer520;
    #undef	RETURN_TYPE_issuer520
    #define	RETURN_TYPE_issuer520 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity521;
    #undef	RETURN_TYPE_validity521
    #define	RETURN_TYPE_validity521 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject522;
    #undef	RETURN_TYPE_subject522
    #define	RETURN_TYPE_subject522 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo523;
    #undef	RETURN_TYPE_subjectPKinfo523
    #define	RETURN_TYPE_subjectPKinfo523 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_rsa_md2_alg_id_return rsa_md2_alg_id524;
    #undef	RETURN_TYPE_rsa_md2_alg_id524
    #define	RETURN_TYPE_rsa_md2_alg_id524 RFC5280Parser_rsa_md2_alg_id_return

    RFC5280Parser_signature_return signature525;
    #undef	RETURN_TYPE_signature525
    #define	RETURN_TYPE_signature525 RFC5280Parser_signature_return

    RFC5280Parser_rsa_md5_alg_id_return rsa_md5_alg_id526;
    #undef	RETURN_TYPE_rsa_md5_alg_id526
    #define	RETURN_TYPE_rsa_md5_alg_id526 RFC5280Parser_rsa_md5_alg_id_return

    RFC5280Parser_issuer_return issuer527;
    #undef	RETURN_TYPE_issuer527
    #define	RETURN_TYPE_issuer527 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity528;
    #undef	RETURN_TYPE_validity528
    #define	RETURN_TYPE_validity528 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject529;
    #undef	RETURN_TYPE_subject529
    #define	RETURN_TYPE_subject529 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo530;
    #undef	RETURN_TYPE_subjectPKinfo530
    #define	RETURN_TYPE_subjectPKinfo530 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_rsa_md5_alg_id_return rsa_md5_alg_id531;
    #undef	RETURN_TYPE_rsa_md5_alg_id531
    #define	RETURN_TYPE_rsa_md5_alg_id531 RFC5280Parser_rsa_md5_alg_id_return

    RFC5280Parser_signature_return signature532;
    #undef	RETURN_TYPE_signature532
    #define	RETURN_TYPE_signature532 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha1_alg_id_return rsa_sha1_alg_id533;
    #undef	RETURN_TYPE_rsa_sha1_alg_id533
    #define	RETURN_TYPE_rsa_sha1_alg_id533 RFC5280Parser_rsa_sha1_alg_id_return

    RFC5280Parser_issuer_return issuer534;
    #undef	RETURN_TYPE_issuer534
    #define	RETURN_TYPE_issuer534 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity535;
    #undef	RETURN_TYPE_validity535
    #define	RETURN_TYPE_validity535 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject536;
    #undef	RETURN_TYPE_subject536
    #define	RETURN_TYPE_subject536 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo537;
    #undef	RETURN_TYPE_subjectPKinfo537
    #define	RETURN_TYPE_subjectPKinfo537 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_rsa_sha1_alg_id_return rsa_sha1_alg_id538;
    #undef	RETURN_TYPE_rsa_sha1_alg_id538
    #define	RETURN_TYPE_rsa_sha1_alg_id538 RFC5280Parser_rsa_sha1_alg_id_return

    RFC5280Parser_signature_return signature539;
    #undef	RETURN_TYPE_signature539
    #define	RETURN_TYPE_signature539 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha224_alg_id_return rsa_sha224_alg_id540;
    #undef	RETURN_TYPE_rsa_sha224_alg_id540
    #define	RETURN_TYPE_rsa_sha224_alg_id540 RFC5280Parser_rsa_sha224_alg_id_return

    RFC5280Parser_issuer_return issuer541;
    #undef	RETURN_TYPE_issuer541
    #define	RETURN_TYPE_issuer541 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity542;
    #undef	RETURN_TYPE_validity542
    #define	RETURN_TYPE_validity542 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject543;
    #undef	RETURN_TYPE_subject543
    #define	RETURN_TYPE_subject543 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo544;
    #undef	RETURN_TYPE_subjectPKinfo544
    #define	RETURN_TYPE_subjectPKinfo544 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_rsa_sha224_alg_id_return rsa_sha224_alg_id545;
    #undef	RETURN_TYPE_rsa_sha224_alg_id545
    #define	RETURN_TYPE_rsa_sha224_alg_id545 RFC5280Parser_rsa_sha224_alg_id_return

    RFC5280Parser_signature_return signature546;
    #undef	RETURN_TYPE_signature546
    #define	RETURN_TYPE_signature546 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha256_alg_id_return rsa_sha256_alg_id547;
    #undef	RETURN_TYPE_rsa_sha256_alg_id547
    #define	RETURN_TYPE_rsa_sha256_alg_id547 RFC5280Parser_rsa_sha256_alg_id_return

    RFC5280Parser_issuer_return issuer548;
    #undef	RETURN_TYPE_issuer548
    #define	RETURN_TYPE_issuer548 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity549;
    #undef	RETURN_TYPE_validity549
    #define	RETURN_TYPE_validity549 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject550;
    #undef	RETURN_TYPE_subject550
    #define	RETURN_TYPE_subject550 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo551;
    #undef	RETURN_TYPE_subjectPKinfo551
    #define	RETURN_TYPE_subjectPKinfo551 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_rsa_sha256_alg_id_return rsa_sha256_alg_id552;
    #undef	RETURN_TYPE_rsa_sha256_alg_id552
    #define	RETURN_TYPE_rsa_sha256_alg_id552 RFC5280Parser_rsa_sha256_alg_id_return

    RFC5280Parser_signature_return signature553;
    #undef	RETURN_TYPE_signature553
    #define	RETURN_TYPE_signature553 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha384_alg_id_return rsa_sha384_alg_id554;
    #undef	RETURN_TYPE_rsa_sha384_alg_id554
    #define	RETURN_TYPE_rsa_sha384_alg_id554 RFC5280Parser_rsa_sha384_alg_id_return

    RFC5280Parser_issuer_return issuer555;
    #undef	RETURN_TYPE_issuer555
    #define	RETURN_TYPE_issuer555 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity556;
    #undef	RETURN_TYPE_validity556
    #define	RETURN_TYPE_validity556 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject557;
    #undef	RETURN_TYPE_subject557
    #define	RETURN_TYPE_subject557 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo558;
    #undef	RETURN_TYPE_subjectPKinfo558
    #define	RETURN_TYPE_subjectPKinfo558 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_rsa_sha384_alg_id_return rsa_sha384_alg_id559;
    #undef	RETURN_TYPE_rsa_sha384_alg_id559
    #define	RETURN_TYPE_rsa_sha384_alg_id559 RFC5280Parser_rsa_sha384_alg_id_return

    RFC5280Parser_signature_return signature560;
    #undef	RETURN_TYPE_signature560
    #define	RETURN_TYPE_signature560 RFC5280Parser_signature_return

    RFC5280Parser_rsa_sha512_alg_id_return rsa_sha512_alg_id561;
    #undef	RETURN_TYPE_rsa_sha512_alg_id561
    #define	RETURN_TYPE_rsa_sha512_alg_id561 RFC5280Parser_rsa_sha512_alg_id_return

    RFC5280Parser_issuer_return issuer562;
    #undef	RETURN_TYPE_issuer562
    #define	RETURN_TYPE_issuer562 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity563;
    #undef	RETURN_TYPE_validity563
    #define	RETURN_TYPE_validity563 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject564;
    #undef	RETURN_TYPE_subject564
    #define	RETURN_TYPE_subject564 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo565;
    #undef	RETURN_TYPE_subjectPKinfo565
    #define	RETURN_TYPE_subjectPKinfo565 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_rsa_sha512_alg_id_return rsa_sha512_alg_id566;
    #undef	RETURN_TYPE_rsa_sha512_alg_id566
    #define	RETURN_TYPE_rsa_sha512_alg_id566 RFC5280Parser_rsa_sha512_alg_id_return

    RFC5280Parser_signature_return signature567;
    #undef	RETURN_TYPE_signature567
    #define	RETURN_TYPE_signature567 RFC5280Parser_signature_return

    RFC5280Parser_dsa_sha_alg_id_return dsa_sha_alg_id568;
    #undef	RETURN_TYPE_dsa_sha_alg_id568
    #define	RETURN_TYPE_dsa_sha_alg_id568 RFC5280Parser_dsa_sha_alg_id_return

    RFC5280Parser_issuer_return issuer569;
    #undef	RETURN_TYPE_issuer569
    #define	RETURN_TYPE_issuer569 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity570;
    #undef	RETURN_TYPE_validity570
    #define	RETURN_TYPE_validity570 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject571;
    #undef	RETURN_TYPE_subject571
    #define	RETURN_TYPE_subject571 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo572;
    #undef	RETURN_TYPE_subjectPKinfo572
    #define	RETURN_TYPE_subjectPKinfo572 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_dsa_sha_alg_id_return dsa_sha_alg_id573;
    #undef	RETURN_TYPE_dsa_sha_alg_id573
    #define	RETURN_TYPE_dsa_sha_alg_id573 RFC5280Parser_dsa_sha_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature574;
    #undef	RETURN_TYPE_dsa_signature574
    #define	RETURN_TYPE_dsa_signature574 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha_alg_id_return ec_sha_alg_id575;
    #undef	RETURN_TYPE_ec_sha_alg_id575
    #define	RETURN_TYPE_ec_sha_alg_id575 RFC5280Parser_ec_sha_alg_id_return

    RFC5280Parser_issuer_return issuer576;
    #undef	RETURN_TYPE_issuer576
    #define	RETURN_TYPE_issuer576 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity577;
    #undef	RETURN_TYPE_validity577
    #define	RETURN_TYPE_validity577 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject578;
    #undef	RETURN_TYPE_subject578
    #define	RETURN_TYPE_subject578 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo579;
    #undef	RETURN_TYPE_subjectPKinfo579
    #define	RETURN_TYPE_subjectPKinfo579 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_ec_sha_alg_id_return ec_sha_alg_id580;
    #undef	RETURN_TYPE_ec_sha_alg_id580
    #define	RETURN_TYPE_ec_sha_alg_id580 RFC5280Parser_ec_sha_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature581;
    #undef	RETURN_TYPE_dsa_signature581
    #define	RETURN_TYPE_dsa_signature581 RFC5280Parser_dsa_signature_return

    RFC5280Parser_pss_alg_id_params_return pss_alg_id_params582;
    #undef	RETURN_TYPE_pss_alg_id_params582
    #define	RETURN_TYPE_pss_alg_id_params582 RFC5280Parser_pss_alg_id_params_return

    RFC5280Parser_issuer_return issuer583;
    #undef	RETURN_TYPE_issuer583
    #define	RETURN_TYPE_issuer583 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity584;
    #undef	RETURN_TYPE_validity584
    #define	RETURN_TYPE_validity584 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject585;
    #undef	RETURN_TYPE_subject585
    #define	RETURN_TYPE_subject585 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo586;
    #undef	RETURN_TYPE_subjectPKinfo586
    #define	RETURN_TYPE_subjectPKinfo586 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_pss_alg_id_params_return pss_alg_id_params587;
    #undef	RETURN_TYPE_pss_alg_id_params587
    #define	RETURN_TYPE_pss_alg_id_params587 RFC5280Parser_pss_alg_id_params_return

    RFC5280Parser_signature_return signature588;
    #undef	RETURN_TYPE_signature588
    #define	RETURN_TYPE_signature588 RFC5280Parser_signature_return

    RFC5280Parser_dsa_sha224_alg_id_return dsa_sha224_alg_id589;
    #undef	RETURN_TYPE_dsa_sha224_alg_id589
    #define	RETURN_TYPE_dsa_sha224_alg_id589 RFC5280Parser_dsa_sha224_alg_id_return

    RFC5280Parser_issuer_return issuer590;
    #undef	RETURN_TYPE_issuer590
    #define	RETURN_TYPE_issuer590 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity591;
    #undef	RETURN_TYPE_validity591
    #define	RETURN_TYPE_validity591 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject592;
    #undef	RETURN_TYPE_subject592
    #define	RETURN_TYPE_subject592 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo593;
    #undef	RETURN_TYPE_subjectPKinfo593
    #define	RETURN_TYPE_subjectPKinfo593 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_dsa_sha224_alg_id_return dsa_sha224_alg_id594;
    #undef	RETURN_TYPE_dsa_sha224_alg_id594
    #define	RETURN_TYPE_dsa_sha224_alg_id594 RFC5280Parser_dsa_sha224_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature595;
    #undef	RETURN_TYPE_dsa_signature595
    #define	RETURN_TYPE_dsa_signature595 RFC5280Parser_dsa_signature_return

    RFC5280Parser_dsa_sha256_alg_id_return dsa_sha256_alg_id596;
    #undef	RETURN_TYPE_dsa_sha256_alg_id596
    #define	RETURN_TYPE_dsa_sha256_alg_id596 RFC5280Parser_dsa_sha256_alg_id_return

    RFC5280Parser_issuer_return issuer597;
    #undef	RETURN_TYPE_issuer597
    #define	RETURN_TYPE_issuer597 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity598;
    #undef	RETURN_TYPE_validity598
    #define	RETURN_TYPE_validity598 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject599;
    #undef	RETURN_TYPE_subject599
    #define	RETURN_TYPE_subject599 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo600;
    #undef	RETURN_TYPE_subjectPKinfo600
    #define	RETURN_TYPE_subjectPKinfo600 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_dsa_sha256_alg_id_return dsa_sha256_alg_id601;
    #undef	RETURN_TYPE_dsa_sha256_alg_id601
    #define	RETURN_TYPE_dsa_sha256_alg_id601 RFC5280Parser_dsa_sha256_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature602;
    #undef	RETURN_TYPE_dsa_signature602
    #define	RETURN_TYPE_dsa_signature602 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha224_alg_id_return ec_sha224_alg_id603;
    #undef	RETURN_TYPE_ec_sha224_alg_id603
    #define	RETURN_TYPE_ec_sha224_alg_id603 RFC5280Parser_ec_sha224_alg_id_return

    RFC5280Parser_issuer_return issuer604;
    #undef	RETURN_TYPE_issuer604
    #define	RETURN_TYPE_issuer604 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity605;
    #undef	RETURN_TYPE_validity605
    #define	RETURN_TYPE_validity605 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject606;
    #undef	RETURN_TYPE_subject606
    #define	RETURN_TYPE_subject606 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo607;
    #undef	RETURN_TYPE_subjectPKinfo607
    #define	RETURN_TYPE_subjectPKinfo607 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_ec_sha224_alg_id_return ec_sha224_alg_id608;
    #undef	RETURN_TYPE_ec_sha224_alg_id608
    #define	RETURN_TYPE_ec_sha224_alg_id608 RFC5280Parser_ec_sha224_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature609;
    #undef	RETURN_TYPE_dsa_signature609
    #define	RETURN_TYPE_dsa_signature609 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha256_alg_id_return ec_sha256_alg_id610;
    #undef	RETURN_TYPE_ec_sha256_alg_id610
    #define	RETURN_TYPE_ec_sha256_alg_id610 RFC5280Parser_ec_sha256_alg_id_return

    RFC5280Parser_issuer_return issuer611;
    #undef	RETURN_TYPE_issuer611
    #define	RETURN_TYPE_issuer611 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity612;
    #undef	RETURN_TYPE_validity612
    #define	RETURN_TYPE_validity612 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject613;
    #undef	RETURN_TYPE_subject613
    #define	RETURN_TYPE_subject613 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo614;
    #undef	RETURN_TYPE_subjectPKinfo614
    #define	RETURN_TYPE_subjectPKinfo614 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_ec_sha256_alg_id_return ec_sha256_alg_id615;
    #undef	RETURN_TYPE_ec_sha256_alg_id615
    #define	RETURN_TYPE_ec_sha256_alg_id615 RFC5280Parser_ec_sha256_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature616;
    #undef	RETURN_TYPE_dsa_signature616
    #define	RETURN_TYPE_dsa_signature616 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha384_alg_id_return ec_sha384_alg_id617;
    #undef	RETURN_TYPE_ec_sha384_alg_id617
    #define	RETURN_TYPE_ec_sha384_alg_id617 RFC5280Parser_ec_sha384_alg_id_return

    RFC5280Parser_issuer_return issuer618;
    #undef	RETURN_TYPE_issuer618
    #define	RETURN_TYPE_issuer618 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity619;
    #undef	RETURN_TYPE_validity619
    #define	RETURN_TYPE_validity619 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject620;
    #undef	RETURN_TYPE_subject620
    #define	RETURN_TYPE_subject620 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo621;
    #undef	RETURN_TYPE_subjectPKinfo621
    #define	RETURN_TYPE_subjectPKinfo621 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_ec_sha384_alg_id_return ec_sha384_alg_id622;
    #undef	RETURN_TYPE_ec_sha384_alg_id622
    #define	RETURN_TYPE_ec_sha384_alg_id622 RFC5280Parser_ec_sha384_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature623;
    #undef	RETURN_TYPE_dsa_signature623
    #define	RETURN_TYPE_dsa_signature623 RFC5280Parser_dsa_signature_return

    RFC5280Parser_ec_sha512_alg_id_return ec_sha512_alg_id624;
    #undef	RETURN_TYPE_ec_sha512_alg_id624
    #define	RETURN_TYPE_ec_sha512_alg_id624 RFC5280Parser_ec_sha512_alg_id_return

    RFC5280Parser_issuer_return issuer625;
    #undef	RETURN_TYPE_issuer625
    #define	RETURN_TYPE_issuer625 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity626;
    #undef	RETURN_TYPE_validity626
    #define	RETURN_TYPE_validity626 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject627;
    #undef	RETURN_TYPE_subject627
    #define	RETURN_TYPE_subject627 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo628;
    #undef	RETURN_TYPE_subjectPKinfo628
    #define	RETURN_TYPE_subjectPKinfo628 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_ec_sha512_alg_id_return ec_sha512_alg_id629;
    #undef	RETURN_TYPE_ec_sha512_alg_id629
    #define	RETURN_TYPE_ec_sha512_alg_id629 RFC5280Parser_ec_sha512_alg_id_return

    RFC5280Parser_dsa_signature_return dsa_signature630;
    #undef	RETURN_TYPE_dsa_signature630
    #define	RETURN_TYPE_dsa_signature630 RFC5280Parser_dsa_signature_return

    RFC5280Parser_gost_94_alg_id_return gost_94_alg_id631;
    #undef	RETURN_TYPE_gost_94_alg_id631
    #define	RETURN_TYPE_gost_94_alg_id631 RFC5280Parser_gost_94_alg_id_return

    RFC5280Parser_issuer_return issuer632;
    #undef	RETURN_TYPE_issuer632
    #define	RETURN_TYPE_issuer632 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity633;
    #undef	RETURN_TYPE_validity633
    #define	RETURN_TYPE_validity633 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject634;
    #undef	RETURN_TYPE_subject634
    #define	RETURN_TYPE_subject634 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo635;
    #undef	RETURN_TYPE_subjectPKinfo635
    #define	RETURN_TYPE_subjectPKinfo635 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_gost_94_alg_id_return gost_94_alg_id636;
    #undef	RETURN_TYPE_gost_94_alg_id636
    #define	RETURN_TYPE_gost_94_alg_id636 RFC5280Parser_gost_94_alg_id_return

    RFC5280Parser_signature_return signature637;
    #undef	RETURN_TYPE_signature637
    #define	RETURN_TYPE_signature637 RFC5280Parser_signature_return

    RFC5280Parser_gost_01_alg_id_return gost_01_alg_id638;
    #undef	RETURN_TYPE_gost_01_alg_id638
    #define	RETURN_TYPE_gost_01_alg_id638 RFC5280Parser_gost_01_alg_id_return

    RFC5280Parser_issuer_return issuer639;
    #undef	RETURN_TYPE_issuer639
    #define	RETURN_TYPE_issuer639 RFC5280Parser_issuer_return

    RFC5280Parser_validity_return validity640;
    #undef	RETURN_TYPE_validity640
    #define	RETURN_TYPE_validity640 RFC5280Parser_validity_return

    RFC5280Parser_subject_return subject641;
    #undef	RETURN_TYPE_subject641
    #define	RETURN_TYPE_subject641 RFC5280Parser_subject_return

    RFC5280Parser_subjectPKinfo_return subjectPKinfo642;
    #undef	RETURN_TYPE_subjectPKinfo642
    #define	RETURN_TYPE_subjectPKinfo642 RFC5280Parser_subjectPKinfo_return

    RFC5280Parser_gost_01_alg_id_return gost_01_alg_id643;
    #undef	RETURN_TYPE_gost_01_alg_id643
    #define	RETURN_TYPE_gost_01_alg_id643 RFC5280Parser_gost_01_alg_id_return

    RFC5280Parser_signature_return signature644;
    #undef	RETURN_TYPE_signature644
    #define	RETURN_TYPE_signature644 RFC5280Parser_signature_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag5.tree = NULL;

    constructedTag06.tree = NULL;

    version37.tree = NULL;

    serialnumber8.tree = NULL;

    rsa_md2_alg_id9.tree = NULL;

    issuer10.tree = NULL;

    validity11.tree = NULL;

    subject12.tree = NULL;

    subjectPKinfo13.tree = NULL;

    issueruniqueId14.tree = NULL;

    subjectuniqueId15.tree = NULL;

    constructedTag316.tree = NULL;

    sequenceTag17.tree = NULL;

    extensions18.tree = NULL;

    sequenceTag19.tree = NULL;

    subjectPKinfo20.tree = NULL;

    issueruniqueId21.tree = NULL;

    subjectuniqueId22.tree = NULL;

    constructedTag323.tree = NULL;

    sequenceTag24.tree = NULL;

    extensionsWithSubAlt25.tree = NULL;

    rsa_md2_alg_id26.tree = NULL;

    signature27.tree = NULL;

    rsa_md5_alg_id28.tree = NULL;

    issuer29.tree = NULL;

    validity30.tree = NULL;

    subject31.tree = NULL;

    subjectPKinfo32.tree = NULL;

    issueruniqueId33.tree = NULL;

    subjectuniqueId34.tree = NULL;

    constructedTag335.tree = NULL;

    sequenceTag36.tree = NULL;

    extensions37.tree = NULL;

    sequenceTag38.tree = NULL;

    subjectPKinfo39.tree = NULL;

    issueruniqueId40.tree = NULL;

    subjectuniqueId41.tree = NULL;

    constructedTag342.tree = NULL;

    sequenceTag43.tree = NULL;

    extensionsWithSubAlt44.tree = NULL;

    rsa_md5_alg_id45.tree = NULL;

    signature46.tree = NULL;

    rsa_sha1_alg_id47.tree = NULL;

    issuer48.tree = NULL;

    validity49.tree = NULL;

    subject50.tree = NULL;

    subjectPKinfo51.tree = NULL;

    issueruniqueId52.tree = NULL;

    subjectuniqueId53.tree = NULL;

    constructedTag354.tree = NULL;

    sequenceTag55.tree = NULL;

    extensions56.tree = NULL;

    sequenceTag57.tree = NULL;

    subjectPKinfo58.tree = NULL;

    issueruniqueId59.tree = NULL;

    subjectuniqueId60.tree = NULL;

    constructedTag361.tree = NULL;

    sequenceTag62.tree = NULL;

    extensionsWithSubAlt63.tree = NULL;

    rsa_sha1_alg_id64.tree = NULL;

    signature65.tree = NULL;

    rsa_sha224_alg_id66.tree = NULL;

    issuer67.tree = NULL;

    validity68.tree = NULL;

    subject69.tree = NULL;

    subjectPKinfo70.tree = NULL;

    issueruniqueId71.tree = NULL;

    subjectuniqueId72.tree = NULL;

    constructedTag373.tree = NULL;

    sequenceTag74.tree = NULL;

    extensions75.tree = NULL;

    sequenceTag76.tree = NULL;

    subjectPKinfo77.tree = NULL;

    issueruniqueId78.tree = NULL;

    subjectuniqueId79.tree = NULL;

    constructedTag380.tree = NULL;

    sequenceTag81.tree = NULL;

    extensionsWithSubAlt82.tree = NULL;

    rsa_sha224_alg_id83.tree = NULL;

    signature84.tree = NULL;

    rsa_sha256_alg_id85.tree = NULL;

    issuer86.tree = NULL;

    validity87.tree = NULL;

    subject88.tree = NULL;

    subjectPKinfo89.tree = NULL;

    issueruniqueId90.tree = NULL;

    subjectuniqueId91.tree = NULL;

    constructedTag392.tree = NULL;

    sequenceTag93.tree = NULL;

    extensions94.tree = NULL;

    sequenceTag95.tree = NULL;

    subjectPKinfo96.tree = NULL;

    issueruniqueId97.tree = NULL;

    subjectuniqueId98.tree = NULL;

    constructedTag399.tree = NULL;

    sequenceTag100.tree = NULL;

    extensionsWithSubAlt101.tree = NULL;

    rsa_sha256_alg_id102.tree = NULL;

    signature103.tree = NULL;

    rsa_sha384_alg_id104.tree = NULL;

    issuer105.tree = NULL;

    validity106.tree = NULL;

    subject107.tree = NULL;

    subjectPKinfo108.tree = NULL;

    issueruniqueId109.tree = NULL;

    subjectuniqueId110.tree = NULL;

    constructedTag3111.tree = NULL;

    sequenceTag112.tree = NULL;

    extensions113.tree = NULL;

    sequenceTag114.tree = NULL;

    subjectPKinfo115.tree = NULL;

    issueruniqueId116.tree = NULL;

    subjectuniqueId117.tree = NULL;

    constructedTag3118.tree = NULL;

    sequenceTag119.tree = NULL;

    extensionsWithSubAlt120.tree = NULL;

    rsa_sha384_alg_id121.tree = NULL;

    signature122.tree = NULL;

    rsa_sha512_alg_id123.tree = NULL;

    issuer124.tree = NULL;

    validity125.tree = NULL;

    subject126.tree = NULL;

    subjectPKinfo127.tree = NULL;

    issueruniqueId128.tree = NULL;

    subjectuniqueId129.tree = NULL;

    constructedTag3130.tree = NULL;

    sequenceTag131.tree = NULL;

    extensions132.tree = NULL;

    sequenceTag133.tree = NULL;

    subjectPKinfo134.tree = NULL;

    issueruniqueId135.tree = NULL;

    subjectuniqueId136.tree = NULL;

    constructedTag3137.tree = NULL;

    sequenceTag138.tree = NULL;

    extensionsWithSubAlt139.tree = NULL;

    rsa_sha512_alg_id140.tree = NULL;

    signature141.tree = NULL;

    dsa_sha_alg_id142.tree = NULL;

    issuer143.tree = NULL;

    validity144.tree = NULL;

    subject145.tree = NULL;

    subjectPKinfo146.tree = NULL;

    issueruniqueId147.tree = NULL;

    subjectuniqueId148.tree = NULL;

    constructedTag3149.tree = NULL;

    sequenceTag150.tree = NULL;

    extensions151.tree = NULL;

    sequenceTag152.tree = NULL;

    subjectPKinfo153.tree = NULL;

    issueruniqueId154.tree = NULL;

    subjectuniqueId155.tree = NULL;

    constructedTag3156.tree = NULL;

    sequenceTag157.tree = NULL;

    extensionsWithSubAlt158.tree = NULL;

    dsa_sha_alg_id159.tree = NULL;

    dsa_signature160.tree = NULL;

    ec_sha_alg_id161.tree = NULL;

    issuer162.tree = NULL;

    validity163.tree = NULL;

    subject164.tree = NULL;

    subjectPKinfo165.tree = NULL;

    issueruniqueId166.tree = NULL;

    subjectuniqueId167.tree = NULL;

    constructedTag3168.tree = NULL;

    sequenceTag169.tree = NULL;

    extensions170.tree = NULL;

    sequenceTag171.tree = NULL;

    subjectPKinfo172.tree = NULL;

    issueruniqueId173.tree = NULL;

    subjectuniqueId174.tree = NULL;

    constructedTag3175.tree = NULL;

    sequenceTag176.tree = NULL;

    extensionsWithSubAlt177.tree = NULL;

    ec_sha_alg_id178.tree = NULL;

    dsa_signature179.tree = NULL;

    pss_alg_id_params180.tree = NULL;

    issuer181.tree = NULL;

    validity182.tree = NULL;

    subject183.tree = NULL;

    subjectPKinfo184.tree = NULL;

    issueruniqueId185.tree = NULL;

    subjectuniqueId186.tree = NULL;

    constructedTag3187.tree = NULL;

    sequenceTag188.tree = NULL;

    extensions189.tree = NULL;

    sequenceTag190.tree = NULL;

    subjectPKinfo191.tree = NULL;

    issueruniqueId192.tree = NULL;

    subjectuniqueId193.tree = NULL;

    constructedTag3194.tree = NULL;

    sequenceTag195.tree = NULL;

    extensionsWithSubAlt196.tree = NULL;

    pss_alg_id_params197.tree = NULL;

    signature198.tree = NULL;

    dsa_sha224_alg_id199.tree = NULL;

    issuer200.tree = NULL;

    validity201.tree = NULL;

    subject202.tree = NULL;

    subjectPKinfo203.tree = NULL;

    issueruniqueId204.tree = NULL;

    subjectuniqueId205.tree = NULL;

    constructedTag3206.tree = NULL;

    sequenceTag207.tree = NULL;

    extensions208.tree = NULL;

    sequenceTag209.tree = NULL;

    subjectPKinfo210.tree = NULL;

    issueruniqueId211.tree = NULL;

    subjectuniqueId212.tree = NULL;

    constructedTag3213.tree = NULL;

    sequenceTag214.tree = NULL;

    extensionsWithSubAlt215.tree = NULL;

    dsa_sha224_alg_id216.tree = NULL;

    dsa_signature217.tree = NULL;

    dsa_sha256_alg_id218.tree = NULL;

    issuer219.tree = NULL;

    validity220.tree = NULL;

    subject221.tree = NULL;

    subjectPKinfo222.tree = NULL;

    issueruniqueId223.tree = NULL;

    subjectuniqueId224.tree = NULL;

    constructedTag3225.tree = NULL;

    sequenceTag226.tree = NULL;

    extensions227.tree = NULL;

    sequenceTag228.tree = NULL;

    subjectPKinfo229.tree = NULL;

    issueruniqueId230.tree = NULL;

    subjectuniqueId231.tree = NULL;

    constructedTag3232.tree = NULL;

    sequenceTag233.tree = NULL;

    extensionsWithSubAlt234.tree = NULL;

    dsa_sha256_alg_id235.tree = NULL;

    dsa_signature236.tree = NULL;

    ec_sha224_alg_id237.tree = NULL;

    issuer238.tree = NULL;

    validity239.tree = NULL;

    subject240.tree = NULL;

    subjectPKinfo241.tree = NULL;

    issueruniqueId242.tree = NULL;

    subjectuniqueId243.tree = NULL;

    constructedTag3244.tree = NULL;

    sequenceTag245.tree = NULL;

    extensions246.tree = NULL;

    sequenceTag247.tree = NULL;

    subjectPKinfo248.tree = NULL;

    issueruniqueId249.tree = NULL;

    subjectuniqueId250.tree = NULL;

    constructedTag3251.tree = NULL;

    sequenceTag252.tree = NULL;

    extensionsWithSubAlt253.tree = NULL;

    ec_sha224_alg_id254.tree = NULL;

    dsa_signature255.tree = NULL;

    ec_sha256_alg_id256.tree = NULL;

    issuer257.tree = NULL;

    validity258.tree = NULL;

    subject259.tree = NULL;

    subjectPKinfo260.tree = NULL;

    issueruniqueId261.tree = NULL;

    subjectuniqueId262.tree = NULL;

    constructedTag3263.tree = NULL;

    sequenceTag264.tree = NULL;

    extensions265.tree = NULL;

    sequenceTag266.tree = NULL;

    subjectPKinfo267.tree = NULL;

    issueruniqueId268.tree = NULL;

    subjectuniqueId269.tree = NULL;

    constructedTag3270.tree = NULL;

    sequenceTag271.tree = NULL;

    extensionsWithSubAlt272.tree = NULL;

    ec_sha256_alg_id273.tree = NULL;

    dsa_signature274.tree = NULL;

    ec_sha384_alg_id275.tree = NULL;

    issuer276.tree = NULL;

    validity277.tree = NULL;

    subject278.tree = NULL;

    subjectPKinfo279.tree = NULL;

    issueruniqueId280.tree = NULL;

    subjectuniqueId281.tree = NULL;

    constructedTag3282.tree = NULL;

    sequenceTag283.tree = NULL;

    extensions284.tree = NULL;

    sequenceTag285.tree = NULL;

    subjectPKinfo286.tree = NULL;

    issueruniqueId287.tree = NULL;

    subjectuniqueId288.tree = NULL;

    constructedTag3289.tree = NULL;

    sequenceTag290.tree = NULL;

    extensionsWithSubAlt291.tree = NULL;

    ec_sha384_alg_id292.tree = NULL;

    dsa_signature293.tree = NULL;

    ec_sha512_alg_id294.tree = NULL;

    issuer295.tree = NULL;

    validity296.tree = NULL;

    subject297.tree = NULL;

    subjectPKinfo298.tree = NULL;

    issueruniqueId299.tree = NULL;

    subjectuniqueId300.tree = NULL;

    constructedTag3301.tree = NULL;

    sequenceTag302.tree = NULL;

    extensions303.tree = NULL;

    sequenceTag304.tree = NULL;

    subjectPKinfo305.tree = NULL;

    issueruniqueId306.tree = NULL;

    subjectuniqueId307.tree = NULL;

    constructedTag3308.tree = NULL;

    sequenceTag309.tree = NULL;

    extensionsWithSubAlt310.tree = NULL;

    ec_sha512_alg_id311.tree = NULL;

    dsa_signature312.tree = NULL;

    gost_94_alg_id313.tree = NULL;

    issuer314.tree = NULL;

    validity315.tree = NULL;

    subject316.tree = NULL;

    subjectPKinfo317.tree = NULL;

    issueruniqueId318.tree = NULL;

    subjectuniqueId319.tree = NULL;

    constructedTag3320.tree = NULL;

    sequenceTag321.tree = NULL;

    extensions322.tree = NULL;

    sequenceTag323.tree = NULL;

    subjectPKinfo324.tree = NULL;

    issueruniqueId325.tree = NULL;

    subjectuniqueId326.tree = NULL;

    constructedTag3327.tree = NULL;

    sequenceTag328.tree = NULL;

    extensionsWithSubAlt329.tree = NULL;

    gost_94_alg_id330.tree = NULL;

    signature331.tree = NULL;

    gost_01_alg_id332.tree = NULL;

    issuer333.tree = NULL;

    validity334.tree = NULL;

    subject335.tree = NULL;

    subjectPKinfo336.tree = NULL;

    issueruniqueId337.tree = NULL;

    subjectuniqueId338.tree = NULL;

    constructedTag3339.tree = NULL;

    sequenceTag340.tree = NULL;

    extensions341.tree = NULL;

    sequenceTag342.tree = NULL;

    subjectPKinfo343.tree = NULL;

    issueruniqueId344.tree = NULL;

    subjectuniqueId345.tree = NULL;

    constructedTag3346.tree = NULL;

    sequenceTag347.tree = NULL;

    extensionsWithSubAlt348.tree = NULL;

    gost_01_alg_id349.tree = NULL;

    signature350.tree = NULL;

    constructedTag0351.tree = NULL;

    version2352.tree = NULL;

    serialnumber353.tree = NULL;

    rsa_md2_alg_id354.tree = NULL;

    issuer355.tree = NULL;

    validity356.tree = NULL;

    subject357.tree = NULL;

    subjectPKinfo358.tree = NULL;

    issueruniqueId359.tree = NULL;

    subjectuniqueId360.tree = NULL;

    rsa_md2_alg_id361.tree = NULL;

    signature362.tree = NULL;

    rsa_md5_alg_id363.tree = NULL;

    issuer364.tree = NULL;

    validity365.tree = NULL;

    subject366.tree = NULL;

    subjectPKinfo367.tree = NULL;

    issueruniqueId368.tree = NULL;

    subjectuniqueId369.tree = NULL;

    rsa_md5_alg_id370.tree = NULL;

    signature371.tree = NULL;

    rsa_sha1_alg_id372.tree = NULL;

    issuer373.tree = NULL;

    validity374.tree = NULL;

    subject375.tree = NULL;

    subjectPKinfo376.tree = NULL;

    issueruniqueId377.tree = NULL;

    subjectuniqueId378.tree = NULL;

    rsa_sha1_alg_id379.tree = NULL;

    signature380.tree = NULL;

    rsa_sha224_alg_id381.tree = NULL;

    issuer382.tree = NULL;

    validity383.tree = NULL;

    subject384.tree = NULL;

    subjectPKinfo385.tree = NULL;

    issueruniqueId386.tree = NULL;

    subjectuniqueId387.tree = NULL;

    rsa_sha224_alg_id388.tree = NULL;

    signature389.tree = NULL;

    rsa_sha256_alg_id390.tree = NULL;

    issuer391.tree = NULL;

    validity392.tree = NULL;

    subject393.tree = NULL;

    subjectPKinfo394.tree = NULL;

    issueruniqueId395.tree = NULL;

    subjectuniqueId396.tree = NULL;

    rsa_sha256_alg_id397.tree = NULL;

    signature398.tree = NULL;

    rsa_sha384_alg_id399.tree = NULL;

    issuer400.tree = NULL;

    validity401.tree = NULL;

    subject402.tree = NULL;

    subjectPKinfo403.tree = NULL;

    issueruniqueId404.tree = NULL;

    subjectuniqueId405.tree = NULL;

    rsa_sha384_alg_id406.tree = NULL;

    signature407.tree = NULL;

    rsa_sha512_alg_id408.tree = NULL;

    issuer409.tree = NULL;

    validity410.tree = NULL;

    subject411.tree = NULL;

    subjectPKinfo412.tree = NULL;

    issueruniqueId413.tree = NULL;

    subjectuniqueId414.tree = NULL;

    rsa_sha512_alg_id415.tree = NULL;

    signature416.tree = NULL;

    dsa_sha_alg_id417.tree = NULL;

    issuer418.tree = NULL;

    validity419.tree = NULL;

    subject420.tree = NULL;

    subjectPKinfo421.tree = NULL;

    issueruniqueId422.tree = NULL;

    subjectuniqueId423.tree = NULL;

    dsa_sha_alg_id424.tree = NULL;

    dsa_signature425.tree = NULL;

    ec_sha_alg_id426.tree = NULL;

    issuer427.tree = NULL;

    validity428.tree = NULL;

    subject429.tree = NULL;

    subjectPKinfo430.tree = NULL;

    issueruniqueId431.tree = NULL;

    subjectuniqueId432.tree = NULL;

    ec_sha_alg_id433.tree = NULL;

    dsa_signature434.tree = NULL;

    pss_alg_id_params435.tree = NULL;

    issuer436.tree = NULL;

    validity437.tree = NULL;

    subject438.tree = NULL;

    subjectPKinfo439.tree = NULL;

    issueruniqueId440.tree = NULL;

    subjectuniqueId441.tree = NULL;

    pss_alg_id_params442.tree = NULL;

    signature443.tree = NULL;

    dsa_sha224_alg_id444.tree = NULL;

    issuer445.tree = NULL;

    validity446.tree = NULL;

    subject447.tree = NULL;

    subjectPKinfo448.tree = NULL;

    issueruniqueId449.tree = NULL;

    subjectuniqueId450.tree = NULL;

    dsa_sha224_alg_id451.tree = NULL;

    dsa_signature452.tree = NULL;

    dsa_sha256_alg_id453.tree = NULL;

    issuer454.tree = NULL;

    validity455.tree = NULL;

    subject456.tree = NULL;

    subjectPKinfo457.tree = NULL;

    issueruniqueId458.tree = NULL;

    subjectuniqueId459.tree = NULL;

    dsa_sha256_alg_id460.tree = NULL;

    dsa_signature461.tree = NULL;

    ec_sha224_alg_id462.tree = NULL;

    issuer463.tree = NULL;

    validity464.tree = NULL;

    subject465.tree = NULL;

    subjectPKinfo466.tree = NULL;

    issueruniqueId467.tree = NULL;

    subjectuniqueId468.tree = NULL;

    ec_sha224_alg_id469.tree = NULL;

    dsa_signature470.tree = NULL;

    ec_sha256_alg_id471.tree = NULL;

    issuer472.tree = NULL;

    validity473.tree = NULL;

    subject474.tree = NULL;

    subjectPKinfo475.tree = NULL;

    issueruniqueId476.tree = NULL;

    subjectuniqueId477.tree = NULL;

    ec_sha256_alg_id478.tree = NULL;

    dsa_signature479.tree = NULL;

    ec_sha384_alg_id480.tree = NULL;

    issuer481.tree = NULL;

    validity482.tree = NULL;

    subject483.tree = NULL;

    subjectPKinfo484.tree = NULL;

    issueruniqueId485.tree = NULL;

    subjectuniqueId486.tree = NULL;

    ec_sha384_alg_id487.tree = NULL;

    dsa_signature488.tree = NULL;

    ec_sha512_alg_id489.tree = NULL;

    issuer490.tree = NULL;

    validity491.tree = NULL;

    subject492.tree = NULL;

    subjectPKinfo493.tree = NULL;

    issueruniqueId494.tree = NULL;

    subjectuniqueId495.tree = NULL;

    ec_sha512_alg_id496.tree = NULL;

    dsa_signature497.tree = NULL;

    gost_94_alg_id498.tree = NULL;

    issuer499.tree = NULL;

    validity500.tree = NULL;

    subject501.tree = NULL;

    subjectPKinfo502.tree = NULL;

    issueruniqueId503.tree = NULL;

    subjectuniqueId504.tree = NULL;

    gost_94_alg_id505.tree = NULL;

    signature506.tree = NULL;

    gost_01_alg_id507.tree = NULL;

    issuer508.tree = NULL;

    validity509.tree = NULL;

    subject510.tree = NULL;

    subjectPKinfo511.tree = NULL;

    issueruniqueId512.tree = NULL;

    subjectuniqueId513.tree = NULL;

    gost_01_alg_id514.tree = NULL;

    signature515.tree = NULL;

    constructedTag0516.tree = NULL;

    version517.tree = NULL;

    serialnumber518.tree = NULL;

    rsa_md2_alg_id519.tree = NULL;

    issuer520.tree = NULL;

    validity521.tree = NULL;

    subject522.tree = NULL;

    subjectPKinfo523.tree = NULL;

    rsa_md2_alg_id524.tree = NULL;

    signature525.tree = NULL;

    rsa_md5_alg_id526.tree = NULL;

    issuer527.tree = NULL;

    validity528.tree = NULL;

    subject529.tree = NULL;

    subjectPKinfo530.tree = NULL;

    rsa_md5_alg_id531.tree = NULL;

    signature532.tree = NULL;

    rsa_sha1_alg_id533.tree = NULL;

    issuer534.tree = NULL;

    validity535.tree = NULL;

    subject536.tree = NULL;

    subjectPKinfo537.tree = NULL;

    rsa_sha1_alg_id538.tree = NULL;

    signature539.tree = NULL;

    rsa_sha224_alg_id540.tree = NULL;

    issuer541.tree = NULL;

    validity542.tree = NULL;

    subject543.tree = NULL;

    subjectPKinfo544.tree = NULL;

    rsa_sha224_alg_id545.tree = NULL;

    signature546.tree = NULL;

    rsa_sha256_alg_id547.tree = NULL;

    issuer548.tree = NULL;

    validity549.tree = NULL;

    subject550.tree = NULL;

    subjectPKinfo551.tree = NULL;

    rsa_sha256_alg_id552.tree = NULL;

    signature553.tree = NULL;

    rsa_sha384_alg_id554.tree = NULL;

    issuer555.tree = NULL;

    validity556.tree = NULL;

    subject557.tree = NULL;

    subjectPKinfo558.tree = NULL;

    rsa_sha384_alg_id559.tree = NULL;

    signature560.tree = NULL;

    rsa_sha512_alg_id561.tree = NULL;

    issuer562.tree = NULL;

    validity563.tree = NULL;

    subject564.tree = NULL;

    subjectPKinfo565.tree = NULL;

    rsa_sha512_alg_id566.tree = NULL;

    signature567.tree = NULL;

    dsa_sha_alg_id568.tree = NULL;

    issuer569.tree = NULL;

    validity570.tree = NULL;

    subject571.tree = NULL;

    subjectPKinfo572.tree = NULL;

    dsa_sha_alg_id573.tree = NULL;

    dsa_signature574.tree = NULL;

    ec_sha_alg_id575.tree = NULL;

    issuer576.tree = NULL;

    validity577.tree = NULL;

    subject578.tree = NULL;

    subjectPKinfo579.tree = NULL;

    ec_sha_alg_id580.tree = NULL;

    dsa_signature581.tree = NULL;

    pss_alg_id_params582.tree = NULL;

    issuer583.tree = NULL;

    validity584.tree = NULL;

    subject585.tree = NULL;

    subjectPKinfo586.tree = NULL;

    pss_alg_id_params587.tree = NULL;

    signature588.tree = NULL;

    dsa_sha224_alg_id589.tree = NULL;

    issuer590.tree = NULL;

    validity591.tree = NULL;

    subject592.tree = NULL;

    subjectPKinfo593.tree = NULL;

    dsa_sha224_alg_id594.tree = NULL;

    dsa_signature595.tree = NULL;

    dsa_sha256_alg_id596.tree = NULL;

    issuer597.tree = NULL;

    validity598.tree = NULL;

    subject599.tree = NULL;

    subjectPKinfo600.tree = NULL;

    dsa_sha256_alg_id601.tree = NULL;

    dsa_signature602.tree = NULL;

    ec_sha224_alg_id603.tree = NULL;

    issuer604.tree = NULL;

    validity605.tree = NULL;

    subject606.tree = NULL;

    subjectPKinfo607.tree = NULL;

    ec_sha224_alg_id608.tree = NULL;

    dsa_signature609.tree = NULL;

    ec_sha256_alg_id610.tree = NULL;

    issuer611.tree = NULL;

    validity612.tree = NULL;

    subject613.tree = NULL;

    subjectPKinfo614.tree = NULL;

    ec_sha256_alg_id615.tree = NULL;

    dsa_signature616.tree = NULL;

    ec_sha384_alg_id617.tree = NULL;

    issuer618.tree = NULL;

    validity619.tree = NULL;

    subject620.tree = NULL;

    subjectPKinfo621.tree = NULL;

    ec_sha384_alg_id622.tree = NULL;

    dsa_signature623.tree = NULL;

    ec_sha512_alg_id624.tree = NULL;

    issuer625.tree = NULL;

    validity626.tree = NULL;

    subject627.tree = NULL;

    subjectPKinfo628.tree = NULL;

    ec_sha512_alg_id629.tree = NULL;

    dsa_signature630.tree = NULL;

    gost_94_alg_id631.tree = NULL;

    issuer632.tree = NULL;

    validity633.tree = NULL;

    subject634.tree = NULL;

    subjectPKinfo635.tree = NULL;

    gost_94_alg_id636.tree = NULL;

    signature637.tree = NULL;

    gost_01_alg_id638.tree = NULL;

    issuer639.tree = NULL;

    validity640.tree = NULL;

    subject641.tree = NULL;

    subjectPKinfo642.tree = NULL;

    gost_01_alg_id643.tree = NULL;

    signature644.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1252:2: ( sequenceTag ( constructedTag0 version3 serialnumber ( rsa_md2_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) pss_alg_id_params signature | dsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_94_alg_id signature | gost_01_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_01_alg_id signature ) | constructedTag0 version2 serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_01_alg_id signature ) | ( constructedTag0 version )? serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo gost_01_alg_id signature ) ) )
        // Grammar/RFC5280.g:1252:4: sequenceTag ( constructedTag0 version3 serialnumber ( rsa_md2_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) pss_alg_id_params signature | dsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_94_alg_id signature | gost_01_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_01_alg_id signature ) | constructedTag0 version2 serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_01_alg_id signature ) | ( constructedTag0 version )? serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo gost_01_alg_id signature ) )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate123);
            sequenceTag5=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletbscertificateEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag5.tree);

            // Grammar/RFC5280.g:1256:2: ( constructedTag0 version3 serialnumber ( rsa_md2_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) pss_alg_id_params signature | dsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_94_alg_id signature | gost_01_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_01_alg_id signature ) | constructedTag0 version2 serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_01_alg_id signature ) | ( constructedTag0 version )? serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo gost_01_alg_id signature ) )
            {
                int alt149=3;
                switch ( LA(1) )
                {
                case ConstructedTag0:
                	{
                		switch ( LA(2) )
                		{
                		case Int2:
                			{
                				alt149=1;
                			}
                		    break;
                		case Int1:
                			{
                				alt149=2;
                			}
                		    break;
                		case Int0:
                			{
                				alt149=3;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 149;
                		    EXCEPTION->state        = 1;


                		    goto ruletbscertificateEx;

                		}

                	}
                    break;
                case Int0:
                case Int1:
                case Int2:
                case IntTag:
                	{
                		alt149=3;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 149;
                    EXCEPTION->state        = 0;


                    goto ruletbscertificateEx;

                }

                switch (alt149)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1256:3: constructedTag0 version3 serialnumber ( rsa_md2_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) pss_alg_id_params signature | dsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_94_alg_id signature | gost_01_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_01_alg_id signature )
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag0_in_tbscertificate128);
            	        constructedTag06=constructedTag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletbscertificateEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag06.tree);

            	        FOLLOWPUSH(FOLLOW_version3_in_tbscertificate130);
            	        version37=version3(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletbscertificateEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, version37.tree);

            	        FOLLOWPUSH(FOLLOW_serialnumber_in_tbscertificate132);
            	        serialnumber8=serialnumber(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletbscertificateEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, serialnumber8.tree);

            	        // Grammar/RFC5280.g:1257:2: ( rsa_md2_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) pss_alg_id_params signature | dsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_94_alg_id signature | gost_01_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_01_alg_id signature )
            	        {
            	            int alt109=18;
            	            switch ( LA(1) )
            	            {
            	            case SequenceTag:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case OIDTag:
            	            			{
            	            				switch ( LA(3) )
            	            				{
            	            				case MD2RSAOID:
            	            					{
            	            						alt109=1;
            	            					}
            	            				    break;
            	            				case MD5RSAOID:
            	            					{
            	            						alt109=2;
            	            					}
            	            				    break;
            	            				case SHA1RSAOID:
            	            					{
            	            						alt109=3;
            	            					}
            	            				    break;
            	            				case SHA224RSAOID:
            	            					{
            	            						alt109=4;
            	            					}
            	            				    break;
            	            				case SHA256RSAOID:
            	            					{
            	            						alt109=5;
            	            					}
            	            				    break;
            	            				case SHA384RSAOID:
            	            					{
            	            						alt109=6;
            	            					}
            	            				    break;
            	            				case SHA512RSAOID:
            	            					{
            	            						alt109=7;
            	            					}
            	            				    break;
            	            				case SHA1DSAOID:
            	            					{
            	            						alt109=8;
            	            					}
            	            				    break;
            	            				case SHA1ECOID:
            	            					{
            	            						alt109=9;
            	            					}
            	            				    break;
            	            				case RSAPSSOID:
            	            					{
            	            						alt109=10;
            	            					}
            	            				    break;
            	            				case SHA224DSAOID:
            	            					{
            	            						alt109=11;
            	            					}
            	            				    break;
            	            				case SHA256DSAOID:
            	            					{
            	            						alt109=12;
            	            					}
            	            				    break;
            	            				case SHA224ECOID:
            	            					{
            	            						alt109=13;
            	            					}
            	            				    break;
            	            				case SHA256ECOID:
            	            					{
            	            						alt109=14;
            	            					}
            	            				    break;
            	            				case SHA384ECOID:
            	            					{
            	            						alt109=15;
            	            					}
            	            				    break;
            	            				case SHA512ECOID:
            	            					{
            	            						alt109=16;
            	            					}
            	            				    break;
            	            				case GOST94SIGN:
            	            					{
            	            						alt109=17;
            	            					}
            	            				    break;
            	            				case GOST01SIGN:
            	            					{
            	            						alt109=18;
            	            					}
            	            				    break;

            	            				default:
            	            				    CONSTRUCTEX();
            	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				    EXCEPTION->message      = (void *)"";
            	            				    EXCEPTION->decisionNum  = 109;
            	            				    EXCEPTION->state        = 2;


            	            				    goto ruletbscertificateEx;

            	            				}

            	            			}
            	            		    break;

            	            		default:
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 109;
            	            		    EXCEPTION->state        = 1;


            	            		    goto ruletbscertificateEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 109;
            	                EXCEPTION->state        = 0;


            	                goto ruletbscertificateEx;

            	            }

            	            switch (alt109)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1257:2: rsa_md2_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md2_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_md2_alg_id_in_tbscertificate136);
            	        	        rsa_md2_alg_id9=rsa_md2_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md2_alg_id9.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate138);
            	        	        issuer10=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer10.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate140);
            	        	        validity11=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity11.tree);

            	        	        // Grammar/RFC5280.g:1257:33: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt6=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt6=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt6=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 6;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 6;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt6)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1257:34: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate143);
            	        	        	        subject12=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject12.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate145);
            	        	        	        subjectPKinfo13=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo13.tree);

            	        	        	        // Grammar/RFC5280.g:1257:56: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt1=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt1=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt1)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1257:57: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate148);
            	        	        	        	        issueruniqueId14=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId14.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1257:74: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt2=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt2=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt2)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1257:75: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate153);
            	        	        	        	        subjectuniqueId15=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId15.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1257:93: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt3=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt3=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt3)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1257:94: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate158);
            	        	        	        	        constructedTag316=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag316.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate160);
            	        	        	        	        sequenceTag17=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag17.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate163);
            	        	        	        	        extensions18=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions18.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1258:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate176);
            	        	        	        sequenceTag19=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag19.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate178);
            	        	        	        subjectPKinfo20=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo20.tree);

            	        	        	        // Grammar/RFC5280.g:1258:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt4=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt4=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt4)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1258:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate181);
            	        	        	        	        issueruniqueId21=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId21.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1258:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt5=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt5=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt5)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1258:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate186);
            	        	        	        	        subjectuniqueId22=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId22.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate190);
            	        	        	        constructedTag323=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag323.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate192);
            	        	        	        sequenceTag24=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag24.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate194);
            	        	        	        extensionsWithSubAlt25=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt25.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_md2_alg_id_in_tbscertificate198);
            	        	        rsa_md2_alg_id26=rsa_md2_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md2_alg_id26.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate200);
            	        	        signature27=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature27.tree);

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:1259:2: rsa_md5_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_md5_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_md5_alg_id_in_tbscertificate203);
            	        	        rsa_md5_alg_id28=rsa_md5_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md5_alg_id28.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate205);
            	        	        issuer29=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer29.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate207);
            	        	        validity30=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity30.tree);

            	        	        // Grammar/RFC5280.g:1259:33: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt12=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt12=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt12=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 12;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 12;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt12)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1259:34: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate210);
            	        	        	        subject31=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject31.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate212);
            	        	        	        subjectPKinfo32=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo32.tree);

            	        	        	        // Grammar/RFC5280.g:1259:56: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt7=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt7=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt7)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1259:57: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate215);
            	        	        	        	        issueruniqueId33=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId33.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1259:74: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt8=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt8=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt8)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1259:75: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate220);
            	        	        	        	        subjectuniqueId34=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId34.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1259:93: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt9=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt9=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt9)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1259:94: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate225);
            	        	        	        	        constructedTag335=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag335.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate227);
            	        	        	        	        sequenceTag36=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag36.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate230);
            	        	        	        	        extensions37=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions37.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1260:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate243);
            	        	        	        sequenceTag38=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag38.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate245);
            	        	        	        subjectPKinfo39=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo39.tree);

            	        	        	        // Grammar/RFC5280.g:1260:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt10=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt10=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt10)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1260:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate248);
            	        	        	        	        issueruniqueId40=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId40.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1260:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt11=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt11=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt11)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1260:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate253);
            	        	        	        	        subjectuniqueId41=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId41.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate257);
            	        	        	        constructedTag342=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag342.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate259);
            	        	        	        sequenceTag43=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag43.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate261);
            	        	        	        extensionsWithSubAlt44=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt44.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_md5_alg_id_in_tbscertificate265);
            	        	        rsa_md5_alg_id45=rsa_md5_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md5_alg_id45.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate267);
            	        	        signature46=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature46.tree);

            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // Grammar/RFC5280.g:1261:2: rsa_sha1_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha1_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha1_alg_id_in_tbscertificate270);
            	        	        rsa_sha1_alg_id47=rsa_sha1_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha1_alg_id47.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate272);
            	        	        issuer48=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer48.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate274);
            	        	        validity49=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity49.tree);

            	        	        // Grammar/RFC5280.g:1261:34: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt18=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt18=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt18=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 18;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 18;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt18)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1261:35: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate277);
            	        	        	        subject50=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject50.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate279);
            	        	        	        subjectPKinfo51=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo51.tree);

            	        	        	        // Grammar/RFC5280.g:1261:57: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt13=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt13=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt13)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1261:58: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate282);
            	        	        	        	        issueruniqueId52=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId52.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1261:75: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt14=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt14=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt14)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1261:76: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate287);
            	        	        	        	        subjectuniqueId53=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId53.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1261:94: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt15=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt15=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt15)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1261:95: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate292);
            	        	        	        	        constructedTag354=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag354.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate294);
            	        	        	        	        sequenceTag55=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag55.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate297);
            	        	        	        	        extensions56=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions56.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1262:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate310);
            	        	        	        sequenceTag57=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag57.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate312);
            	        	        	        subjectPKinfo58=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo58.tree);

            	        	        	        // Grammar/RFC5280.g:1262:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt16=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt16=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt16)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1262:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate315);
            	        	        	        	        issueruniqueId59=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId59.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1262:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt17=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt17=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt17)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1262:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate320);
            	        	        	        	        subjectuniqueId60=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId60.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate324);
            	        	        	        constructedTag361=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag361.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate326);
            	        	        	        sequenceTag62=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag62.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate328);
            	        	        	        extensionsWithSubAlt63=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt63.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha1_alg_id_in_tbscertificate332);
            	        	        rsa_sha1_alg_id64=rsa_sha1_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha1_alg_id64.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate334);
            	        	        signature65=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature65.tree);

            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // Grammar/RFC5280.g:1263:2: rsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha224_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha224_alg_id_in_tbscertificate337);
            	        	        rsa_sha224_alg_id66=rsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha224_alg_id66.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate339);
            	        	        issuer67=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer67.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate341);
            	        	        validity68=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity68.tree);

            	        	        // Grammar/RFC5280.g:1263:36: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt24=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt24=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt24=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 24;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 24;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt24)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1263:37: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate344);
            	        	        	        subject69=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject69.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate346);
            	        	        	        subjectPKinfo70=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo70.tree);

            	        	        	        // Grammar/RFC5280.g:1263:59: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt19=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt19=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt19)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1263:60: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate349);
            	        	        	        	        issueruniqueId71=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId71.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1263:77: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt20=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt20=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt20)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1263:78: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate354);
            	        	        	        	        subjectuniqueId72=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId72.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1263:96: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt21=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt21=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt21)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1263:97: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate359);
            	        	        	        	        constructedTag373=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag373.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate361);
            	        	        	        	        sequenceTag74=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag74.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate364);
            	        	        	        	        extensions75=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions75.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1264:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate377);
            	        	        	        sequenceTag76=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag76.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate379);
            	        	        	        subjectPKinfo77=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo77.tree);

            	        	        	        // Grammar/RFC5280.g:1264:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt22=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt22=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt22)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1264:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate382);
            	        	        	        	        issueruniqueId78=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId78.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1264:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt23=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt23=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt23)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1264:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate387);
            	        	        	        	        subjectuniqueId79=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId79.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate391);
            	        	        	        constructedTag380=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag380.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate393);
            	        	        	        sequenceTag81=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag81.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate395);
            	        	        	        extensionsWithSubAlt82=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt82.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha224_alg_id_in_tbscertificate399);
            	        	        rsa_sha224_alg_id83=rsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha224_alg_id83.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate401);
            	        	        signature84=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature84.tree);

            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // Grammar/RFC5280.g:1265:2: rsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha256_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha256_alg_id_in_tbscertificate404);
            	        	        rsa_sha256_alg_id85=rsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha256_alg_id85.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate406);
            	        	        issuer86=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer86.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate408);
            	        	        validity87=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity87.tree);

            	        	        // Grammar/RFC5280.g:1265:36: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt30=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt30=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt30=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 30;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 30;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt30)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1265:37: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate411);
            	        	        	        subject88=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject88.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate413);
            	        	        	        subjectPKinfo89=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo89.tree);

            	        	        	        // Grammar/RFC5280.g:1265:59: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt25=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt25=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt25)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1265:60: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate416);
            	        	        	        	        issueruniqueId90=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId90.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1265:77: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt26=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt26=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt26)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1265:78: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate421);
            	        	        	        	        subjectuniqueId91=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId91.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1265:96: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt27=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt27=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt27)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1265:97: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate426);
            	        	        	        	        constructedTag392=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag392.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate428);
            	        	        	        	        sequenceTag93=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag93.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate431);
            	        	        	        	        extensions94=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions94.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1266:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate444);
            	        	        	        sequenceTag95=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag95.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate446);
            	        	        	        subjectPKinfo96=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo96.tree);

            	        	        	        // Grammar/RFC5280.g:1266:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt28=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt28=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt28)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1266:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate449);
            	        	        	        	        issueruniqueId97=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId97.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1266:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt29=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt29=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt29)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1266:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate454);
            	        	        	        	        subjectuniqueId98=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId98.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate458);
            	        	        	        constructedTag399=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag399.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate460);
            	        	        	        sequenceTag100=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag100.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate462);
            	        	        	        extensionsWithSubAlt101=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt101.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha256_alg_id_in_tbscertificate466);
            	        	        rsa_sha256_alg_id102=rsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha256_alg_id102.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate468);
            	        	        signature103=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature103.tree);

            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // Grammar/RFC5280.g:1267:2: rsa_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha384_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha384_alg_id_in_tbscertificate471);
            	        	        rsa_sha384_alg_id104=rsa_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha384_alg_id104.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate473);
            	        	        issuer105=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer105.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate475);
            	        	        validity106=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity106.tree);

            	        	        // Grammar/RFC5280.g:1267:36: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt36=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt36=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt36=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 36;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 36;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt36)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1267:37: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate478);
            	        	        	        subject107=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject107.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate480);
            	        	        	        subjectPKinfo108=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo108.tree);

            	        	        	        // Grammar/RFC5280.g:1267:59: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt31=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt31=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt31)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1267:60: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate483);
            	        	        	        	        issueruniqueId109=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId109.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1267:77: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt32=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt32=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt32)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1267:78: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate488);
            	        	        	        	        subjectuniqueId110=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId110.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1267:96: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt33=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt33=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt33)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1267:97: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate493);
            	        	        	        	        constructedTag3111=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3111.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate495);
            	        	        	        	        sequenceTag112=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag112.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate498);
            	        	        	        	        extensions113=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions113.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1268:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate511);
            	        	        	        sequenceTag114=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag114.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate513);
            	        	        	        subjectPKinfo115=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo115.tree);

            	        	        	        // Grammar/RFC5280.g:1268:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt34=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt34=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt34)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1268:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate516);
            	        	        	        	        issueruniqueId116=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId116.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1268:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt35=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt35=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt35)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1268:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate521);
            	        	        	        	        subjectuniqueId117=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId117.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate525);
            	        	        	        constructedTag3118=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3118.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate527);
            	        	        	        sequenceTag119=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag119.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate529);
            	        	        	        extensionsWithSubAlt120=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt120.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha384_alg_id_in_tbscertificate533);
            	        	        rsa_sha384_alg_id121=rsa_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha384_alg_id121.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate535);
            	        	        signature122=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature122.tree);

            	        	    }
            	        	    break;
            	        	case 7:
            	        	    // Grammar/RFC5280.g:1269:2: rsa_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) rsa_sha512_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha512_alg_id_in_tbscertificate538);
            	        	        rsa_sha512_alg_id123=rsa_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha512_alg_id123.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate540);
            	        	        issuer124=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer124.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate542);
            	        	        validity125=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity125.tree);

            	        	        // Grammar/RFC5280.g:1269:36: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt42=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt42=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt42=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 42;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 42;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt42)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1269:37: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate545);
            	        	        	        subject126=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject126.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate547);
            	        	        	        subjectPKinfo127=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo127.tree);

            	        	        	        // Grammar/RFC5280.g:1269:59: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt37=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt37=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt37)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1269:60: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate550);
            	        	        	        	        issueruniqueId128=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId128.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1269:77: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt38=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt38=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt38)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1269:78: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate555);
            	        	        	        	        subjectuniqueId129=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId129.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1269:96: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt39=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt39=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt39)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1269:97: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate560);
            	        	        	        	        constructedTag3130=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3130.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate562);
            	        	        	        	        sequenceTag131=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag131.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate565);
            	        	        	        	        extensions132=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions132.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1270:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate578);
            	        	        	        sequenceTag133=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag133.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate580);
            	        	        	        subjectPKinfo134=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo134.tree);

            	        	        	        // Grammar/RFC5280.g:1270:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt40=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt40=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt40)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1270:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate583);
            	        	        	        	        issueruniqueId135=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId135.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1270:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt41=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt41=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt41)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1270:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate588);
            	        	        	        	        subjectuniqueId136=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId136.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate592);
            	        	        	        constructedTag3137=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3137.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate594);
            	        	        	        sequenceTag138=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag138.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate596);
            	        	        	        extensionsWithSubAlt139=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt139.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha512_alg_id_in_tbscertificate600);
            	        	        rsa_sha512_alg_id140=rsa_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha512_alg_id140.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate602);
            	        	        signature141=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature141.tree);

            	        	    }
            	        	    break;
            	        	case 8:
            	        	    // Grammar/RFC5280.g:1271:2: dsa_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dsa_sha_alg_id_in_tbscertificate605);
            	        	        dsa_sha_alg_id142=dsa_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha_alg_id142.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate607);
            	        	        issuer143=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer143.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate609);
            	        	        validity144=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity144.tree);

            	        	        // Grammar/RFC5280.g:1271:33: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt48=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt48=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt48=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 48;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 48;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt48)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1271:34: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate612);
            	        	        	        subject145=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject145.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate614);
            	        	        	        subjectPKinfo146=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo146.tree);

            	        	        	        // Grammar/RFC5280.g:1271:56: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt43=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt43=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt43)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1271:57: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate617);
            	        	        	        	        issueruniqueId147=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId147.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1271:74: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt44=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt44=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt44)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1271:75: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate622);
            	        	        	        	        subjectuniqueId148=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId148.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1271:93: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt45=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt45=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt45)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1271:94: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate627);
            	        	        	        	        constructedTag3149=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3149.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate629);
            	        	        	        	        sequenceTag150=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag150.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate632);
            	        	        	        	        extensions151=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions151.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1272:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate645);
            	        	        	        sequenceTag152=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag152.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate647);
            	        	        	        subjectPKinfo153=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo153.tree);

            	        	        	        // Grammar/RFC5280.g:1272:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt46=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt46=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt46)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1272:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate650);
            	        	        	        	        issueruniqueId154=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId154.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1272:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt47=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt47=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt47)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1272:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate655);
            	        	        	        	        subjectuniqueId155=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId155.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate659);
            	        	        	        constructedTag3156=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3156.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate661);
            	        	        	        sequenceTag157=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag157.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate663);
            	        	        	        extensionsWithSubAlt158=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt158.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_dsa_sha_alg_id_in_tbscertificate667);
            	        	        dsa_sha_alg_id159=dsa_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha_alg_id159.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate669);
            	        	        dsa_signature160=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature160.tree);

            	        	    }
            	        	    break;
            	        	case 9:
            	        	    // Grammar/RFC5280.g:1273:2: ec_sha_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha_alg_id_in_tbscertificate672);
            	        	        ec_sha_alg_id161=ec_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha_alg_id161.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate674);
            	        	        issuer162=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer162.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate676);
            	        	        validity163=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity163.tree);

            	        	        // Grammar/RFC5280.g:1273:32: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt54=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt54=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt54=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 54;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 54;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt54)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1273:33: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate679);
            	        	        	        subject164=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject164.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate681);
            	        	        	        subjectPKinfo165=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo165.tree);

            	        	        	        // Grammar/RFC5280.g:1273:55: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt49=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt49=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt49)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1273:56: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate684);
            	        	        	        	        issueruniqueId166=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId166.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1273:73: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt50=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt50=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt50)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1273:74: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate689);
            	        	        	        	        subjectuniqueId167=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId167.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1273:92: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt51=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt51=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt51)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1273:93: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate694);
            	        	        	        	        constructedTag3168=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3168.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate696);
            	        	        	        	        sequenceTag169=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag169.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate699);
            	        	        	        	        extensions170=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions170.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1274:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate712);
            	        	        	        sequenceTag171=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag171.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate714);
            	        	        	        subjectPKinfo172=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo172.tree);

            	        	        	        // Grammar/RFC5280.g:1274:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt52=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt52=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt52)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1274:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate717);
            	        	        	        	        issueruniqueId173=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId173.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1274:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt53=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt53=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt53)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1274:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate722);
            	        	        	        	        subjectuniqueId174=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId174.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate726);
            	        	        	        constructedTag3175=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3175.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate728);
            	        	        	        sequenceTag176=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag176.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate730);
            	        	        	        extensionsWithSubAlt177=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt177.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha_alg_id_in_tbscertificate734);
            	        	        ec_sha_alg_id178=ec_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha_alg_id178.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate736);
            	        	        dsa_signature179=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature179.tree);

            	        	    }
            	        	    break;
            	        	case 10:
            	        	    // Grammar/RFC5280.g:1275:2: pss_alg_id_params issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) pss_alg_id_params signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_pss_alg_id_params_in_tbscertificate739);
            	        	        pss_alg_id_params180=pss_alg_id_params(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, pss_alg_id_params180.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate741);
            	        	        issuer181=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer181.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate743);
            	        	        validity182=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity182.tree);

            	        	        // Grammar/RFC5280.g:1275:36: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt60=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt60=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt60=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 60;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 60;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt60)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1275:37: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate746);
            	        	        	        subject183=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject183.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate748);
            	        	        	        subjectPKinfo184=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo184.tree);

            	        	        	        // Grammar/RFC5280.g:1275:59: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt55=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt55=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt55)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1275:60: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate751);
            	        	        	        	        issueruniqueId185=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId185.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1275:77: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt56=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt56=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt56)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1275:78: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate756);
            	        	        	        	        subjectuniqueId186=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId186.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1275:96: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt57=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt57=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt57)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1275:97: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate761);
            	        	        	        	        constructedTag3187=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3187.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate763);
            	        	        	        	        sequenceTag188=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag188.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate766);
            	        	        	        	        extensions189=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions189.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1276:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate779);
            	        	        	        sequenceTag190=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag190.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate781);
            	        	        	        subjectPKinfo191=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo191.tree);

            	        	        	        // Grammar/RFC5280.g:1276:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt58=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt58=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt58)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1276:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate784);
            	        	        	        	        issueruniqueId192=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId192.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1276:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt59=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt59=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt59)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1276:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate789);
            	        	        	        	        subjectuniqueId193=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId193.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate793);
            	        	        	        constructedTag3194=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3194.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate795);
            	        	        	        sequenceTag195=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag195.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate797);
            	        	        	        extensionsWithSubAlt196=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt196.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_pss_alg_id_params_in_tbscertificate801);
            	        	        pss_alg_id_params197=pss_alg_id_params(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, pss_alg_id_params197.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate803);
            	        	        signature198=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature198.tree);

            	        	    }
            	        	    break;
            	        	case 11:
            	        	    // Grammar/RFC5280.g:1277:2: dsa_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha224_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dsa_sha224_alg_id_in_tbscertificate806);
            	        	        dsa_sha224_alg_id199=dsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha224_alg_id199.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate808);
            	        	        issuer200=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer200.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate810);
            	        	        validity201=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity201.tree);

            	        	        // Grammar/RFC5280.g:1277:36: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt66=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt66=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt66=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 66;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 66;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt66)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1277:37: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate813);
            	        	        	        subject202=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject202.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate815);
            	        	        	        subjectPKinfo203=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo203.tree);

            	        	        	        // Grammar/RFC5280.g:1277:59: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt61=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt61=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt61)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1277:60: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate818);
            	        	        	        	        issueruniqueId204=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId204.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1277:77: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt62=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt62=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt62)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1277:78: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate823);
            	        	        	        	        subjectuniqueId205=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId205.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1277:96: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt63=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt63=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt63)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1277:97: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate828);
            	        	        	        	        constructedTag3206=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3206.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate830);
            	        	        	        	        sequenceTag207=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag207.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate833);
            	        	        	        	        extensions208=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions208.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1278:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate846);
            	        	        	        sequenceTag209=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag209.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate848);
            	        	        	        subjectPKinfo210=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo210.tree);

            	        	        	        // Grammar/RFC5280.g:1278:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt64=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt64=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt64)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1278:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate851);
            	        	        	        	        issueruniqueId211=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId211.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1278:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt65=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt65=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt65)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1278:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate856);
            	        	        	        	        subjectuniqueId212=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId212.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate860);
            	        	        	        constructedTag3213=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3213.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate862);
            	        	        	        sequenceTag214=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag214.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate864);
            	        	        	        extensionsWithSubAlt215=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt215.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_dsa_sha224_alg_id_in_tbscertificate868);
            	        	        dsa_sha224_alg_id216=dsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha224_alg_id216.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate870);
            	        	        dsa_signature217=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature217.tree);

            	        	    }
            	        	    break;
            	        	case 12:
            	        	    // Grammar/RFC5280.g:1279:2: dsa_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) dsa_sha256_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dsa_sha256_alg_id_in_tbscertificate873);
            	        	        dsa_sha256_alg_id218=dsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha256_alg_id218.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate875);
            	        	        issuer219=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer219.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate877);
            	        	        validity220=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity220.tree);

            	        	        // Grammar/RFC5280.g:1279:36: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt72=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt72=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt72=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 72;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 72;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt72)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1279:37: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate880);
            	        	        	        subject221=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject221.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate882);
            	        	        	        subjectPKinfo222=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo222.tree);

            	        	        	        // Grammar/RFC5280.g:1279:59: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt67=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt67=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt67)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1279:60: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate885);
            	        	        	        	        issueruniqueId223=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId223.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1279:77: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt68=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt68=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt68)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1279:78: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate890);
            	        	        	        	        subjectuniqueId224=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId224.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1279:96: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt69=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt69=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt69)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1279:97: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate895);
            	        	        	        	        constructedTag3225=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3225.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate897);
            	        	        	        	        sequenceTag226=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag226.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate900);
            	        	        	        	        extensions227=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions227.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1280:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate913);
            	        	        	        sequenceTag228=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag228.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate915);
            	        	        	        subjectPKinfo229=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo229.tree);

            	        	        	        // Grammar/RFC5280.g:1280:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt70=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt70=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt70)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1280:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate918);
            	        	        	        	        issueruniqueId230=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId230.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1280:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt71=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt71=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt71)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1280:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate923);
            	        	        	        	        subjectuniqueId231=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId231.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate927);
            	        	        	        constructedTag3232=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3232.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate929);
            	        	        	        sequenceTag233=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag233.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate931);
            	        	        	        extensionsWithSubAlt234=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt234.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_dsa_sha256_alg_id_in_tbscertificate935);
            	        	        dsa_sha256_alg_id235=dsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha256_alg_id235.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate937);
            	        	        dsa_signature236=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature236.tree);

            	        	    }
            	        	    break;
            	        	case 13:
            	        	    // Grammar/RFC5280.g:1281:2: ec_sha224_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha224_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha224_alg_id_in_tbscertificate940);
            	        	        ec_sha224_alg_id237=ec_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha224_alg_id237.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate942);
            	        	        issuer238=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer238.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate944);
            	        	        validity239=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity239.tree);

            	        	        // Grammar/RFC5280.g:1281:35: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt78=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt78=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt78=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 78;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 78;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt78)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1281:36: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate947);
            	        	        	        subject240=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject240.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate949);
            	        	        	        subjectPKinfo241=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo241.tree);

            	        	        	        // Grammar/RFC5280.g:1281:58: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt73=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt73=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt73)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1281:59: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate952);
            	        	        	        	        issueruniqueId242=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId242.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1281:76: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt74=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt74=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt74)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1281:77: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate957);
            	        	        	        	        subjectuniqueId243=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId243.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1281:95: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt75=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt75=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt75)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1281:96: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate962);
            	        	        	        	        constructedTag3244=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3244.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate964);
            	        	        	        	        sequenceTag245=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag245.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate967);
            	        	        	        	        extensions246=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions246.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1282:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate980);
            	        	        	        sequenceTag247=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag247.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate982);
            	        	        	        subjectPKinfo248=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo248.tree);

            	        	        	        // Grammar/RFC5280.g:1282:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt76=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt76=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt76)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1282:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate985);
            	        	        	        	        issueruniqueId249=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId249.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1282:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt77=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt77=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt77)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1282:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate990);
            	        	        	        	        subjectuniqueId250=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId250.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate994);
            	        	        	        constructedTag3251=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3251.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate996);
            	        	        	        sequenceTag252=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag252.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate998);
            	        	        	        extensionsWithSubAlt253=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt253.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha224_alg_id_in_tbscertificate1002);
            	        	        ec_sha224_alg_id254=ec_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha224_alg_id254.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1004);
            	        	        dsa_signature255=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature255.tree);

            	        	    }
            	        	    break;
            	        	case 14:
            	        	    // Grammar/RFC5280.g:1283:2: ec_sha256_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha256_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha256_alg_id_in_tbscertificate1007);
            	        	        ec_sha256_alg_id256=ec_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha256_alg_id256.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1009);
            	        	        issuer257=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer257.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1011);
            	        	        validity258=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity258.tree);

            	        	        // Grammar/RFC5280.g:1283:35: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt84=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt84=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt84=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 84;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 84;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt84)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1283:36: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1014);
            	        	        	        subject259=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject259.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1016);
            	        	        	        subjectPKinfo260=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo260.tree);

            	        	        	        // Grammar/RFC5280.g:1283:58: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt79=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt79=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt79)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1283:59: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1019);
            	        	        	        	        issueruniqueId261=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId261.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1283:76: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt80=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt80=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt80)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1283:77: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1024);
            	        	        	        	        subjectuniqueId262=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId262.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1283:95: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt81=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt81=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt81)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1283:96: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1029);
            	        	        	        	        constructedTag3263=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3263.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1031);
            	        	        	        	        sequenceTag264=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag264.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate1034);
            	        	        	        	        extensions265=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions265.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1284:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1047);
            	        	        	        sequenceTag266=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag266.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1049);
            	        	        	        subjectPKinfo267=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo267.tree);

            	        	        	        // Grammar/RFC5280.g:1284:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt82=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt82=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt82)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1284:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1052);
            	        	        	        	        issueruniqueId268=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId268.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1284:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt83=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt83=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt83)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1284:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1057);
            	        	        	        	        subjectuniqueId269=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId269.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1061);
            	        	        	        constructedTag3270=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3270.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1063);
            	        	        	        sequenceTag271=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag271.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate1065);
            	        	        	        extensionsWithSubAlt272=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt272.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha256_alg_id_in_tbscertificate1069);
            	        	        ec_sha256_alg_id273=ec_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha256_alg_id273.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1071);
            	        	        dsa_signature274=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature274.tree);

            	        	    }
            	        	    break;
            	        	case 15:
            	        	    // Grammar/RFC5280.g:1285:2: ec_sha384_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha384_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha384_alg_id_in_tbscertificate1074);
            	        	        ec_sha384_alg_id275=ec_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha384_alg_id275.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1076);
            	        	        issuer276=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer276.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1078);
            	        	        validity277=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity277.tree);

            	        	        // Grammar/RFC5280.g:1285:35: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt90=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt90=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt90=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 90;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 90;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt90)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1285:36: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1081);
            	        	        	        subject278=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject278.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1083);
            	        	        	        subjectPKinfo279=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo279.tree);

            	        	        	        // Grammar/RFC5280.g:1285:58: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt85=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt85=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt85)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1285:59: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1086);
            	        	        	        	        issueruniqueId280=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId280.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1285:76: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt86=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt86=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt86)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1285:77: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1091);
            	        	        	        	        subjectuniqueId281=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId281.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1285:95: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt87=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt87=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt87)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1285:96: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1096);
            	        	        	        	        constructedTag3282=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3282.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1098);
            	        	        	        	        sequenceTag283=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag283.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate1101);
            	        	        	        	        extensions284=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions284.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1286:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1114);
            	        	        	        sequenceTag285=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag285.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1116);
            	        	        	        subjectPKinfo286=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo286.tree);

            	        	        	        // Grammar/RFC5280.g:1286:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt88=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt88=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt88)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1286:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1119);
            	        	        	        	        issueruniqueId287=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId287.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1286:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt89=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt89=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt89)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1286:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1124);
            	        	        	        	        subjectuniqueId288=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId288.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1128);
            	        	        	        constructedTag3289=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3289.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1130);
            	        	        	        sequenceTag290=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag290.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate1132);
            	        	        	        extensionsWithSubAlt291=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt291.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha384_alg_id_in_tbscertificate1136);
            	        	        ec_sha384_alg_id292=ec_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha384_alg_id292.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1138);
            	        	        dsa_signature293=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature293.tree);

            	        	    }
            	        	    break;
            	        	case 16:
            	        	    // Grammar/RFC5280.g:1287:2: ec_sha512_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) ec_sha512_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha512_alg_id_in_tbscertificate1141);
            	        	        ec_sha512_alg_id294=ec_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha512_alg_id294.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1143);
            	        	        issuer295=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer295.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1145);
            	        	        validity296=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity296.tree);

            	        	        // Grammar/RFC5280.g:1287:35: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt96=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt96=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt96=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 96;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 96;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt96)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1287:36: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1148);
            	        	        	        subject297=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject297.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1150);
            	        	        	        subjectPKinfo298=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo298.tree);

            	        	        	        // Grammar/RFC5280.g:1287:58: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt91=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt91=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt91)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1287:59: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1153);
            	        	        	        	        issueruniqueId299=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId299.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1287:76: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt92=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt92=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt92)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1287:77: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1158);
            	        	        	        	        subjectuniqueId300=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId300.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1287:95: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt93=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt93=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt93)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1287:96: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1163);
            	        	        	        	        constructedTag3301=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3301.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1165);
            	        	        	        	        sequenceTag302=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag302.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate1168);
            	        	        	        	        extensions303=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions303.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1288:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1181);
            	        	        	        sequenceTag304=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag304.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1183);
            	        	        	        subjectPKinfo305=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo305.tree);

            	        	        	        // Grammar/RFC5280.g:1288:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt94=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt94=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt94)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1288:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1186);
            	        	        	        	        issueruniqueId306=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId306.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1288:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt95=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt95=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt95)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1288:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1191);
            	        	        	        	        subjectuniqueId307=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId307.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1195);
            	        	        	        constructedTag3308=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3308.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1197);
            	        	        	        sequenceTag309=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag309.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate1199);
            	        	        	        extensionsWithSubAlt310=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt310.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha512_alg_id_in_tbscertificate1203);
            	        	        ec_sha512_alg_id311=ec_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha512_alg_id311.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1205);
            	        	        dsa_signature312=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature312.tree);

            	        	    }
            	        	    break;
            	        	case 17:
            	        	    // Grammar/RFC5280.g:1289:2: gost_94_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_94_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_gost_94_alg_id_in_tbscertificate1208);
            	        	        gost_94_alg_id313=gost_94_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_94_alg_id313.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1210);
            	        	        issuer314=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer314.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1212);
            	        	        validity315=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity315.tree);

            	        	        // Grammar/RFC5280.g:1289:33: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt102=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt102=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt102=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 102;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 102;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt102)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1289:34: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1215);
            	        	        	        subject316=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject316.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1217);
            	        	        	        subjectPKinfo317=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo317.tree);

            	        	        	        // Grammar/RFC5280.g:1289:56: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt97=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt97=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt97)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1289:57: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1220);
            	        	        	        	        issueruniqueId318=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId318.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1289:74: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt98=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt98=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt98)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1289:75: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1225);
            	        	        	        	        subjectuniqueId319=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId319.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1289:93: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt99=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt99=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt99)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1289:94: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1230);
            	        	        	        	        constructedTag3320=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3320.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1232);
            	        	        	        	        sequenceTag321=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag321.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate1235);
            	        	        	        	        extensions322=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions322.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1290:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1248);
            	        	        	        sequenceTag323=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag323.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1250);
            	        	        	        subjectPKinfo324=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo324.tree);

            	        	        	        // Grammar/RFC5280.g:1290:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt100=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt100=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt100)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1290:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1253);
            	        	        	        	        issueruniqueId325=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId325.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1290:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt101=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt101=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt101)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1290:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1258);
            	        	        	        	        subjectuniqueId326=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId326.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1262);
            	        	        	        constructedTag3327=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3327.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1264);
            	        	        	        sequenceTag328=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag328.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate1266);
            	        	        	        extensionsWithSubAlt329=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt329.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_gost_94_alg_id_in_tbscertificate1270);
            	        	        gost_94_alg_id330=gost_94_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_94_alg_id330.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1272);
            	        	        signature331=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature331.tree);

            	        	    }
            	        	    break;
            	        	case 18:
            	        	    // Grammar/RFC5280.g:1291:2: gost_01_alg_id issuer validity ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt ) gost_01_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_gost_01_alg_id_in_tbscertificate1275);
            	        	        gost_01_alg_id332=gost_01_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_01_alg_id332.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1277);
            	        	        issuer333=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer333.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1279);
            	        	        validity334=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity334.tree);

            	        	        // Grammar/RFC5280.g:1291:33: ( subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )? | sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt )
            	        	        {
            	        	            int alt108=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case SequenceTag:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case SetTag:
            	        	            			{
            	        	            				alt108=1;
            	        	            			}
            	        	            		    break;
            	        	            		case SequenceTag:
            	        	            			{
            	        	            				alt108=2;
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 108;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruletbscertificateEx;

            	        	            		}

            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 108;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruletbscertificateEx;

            	        	            }

            	        	            switch (alt108)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1291:34: subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ( constructedTag3 sequenceTag extensions )?
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1282);
            	        	        	        subject335=subject(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject335.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1284);
            	        	        	        subjectPKinfo336=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo336.tree);

            	        	        	        // Grammar/RFC5280.g:1291:56: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt103=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt103=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt103)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1291:57: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1287);
            	        	        	        	        issueruniqueId337=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId337.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1291:74: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt104=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt104=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt104)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1291:75: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1292);
            	        	        	        	        subjectuniqueId338=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId338.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1291:93: ( constructedTag3 sequenceTag extensions )?
            	        	        	        {
            	        	        	            int alt105=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case ConstructedTag3:
            	        	        	                	{
            	        	        	                		alt105=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt105)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1291:94: constructedTag3 sequenceTag extensions
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1297);
            	        	        	        	        constructedTag3339=constructedTag3(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3339.tree);

            	        	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1299);
            	        	        	        	        sequenceTag340=sequenceTag(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag340.tree);

            	        	        	        	        {
            	        	        	        	            printf("before ext \n");
            	        	        	        	        }


            	        	        	        	        FOLLOWPUSH(FOLLOW_extensions_in_tbscertificate1302);
            	        	        	        	        extensions341=extensions(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions341.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:1292:9: sequenceTag subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? constructedTag3 sequenceTag extensionsWithSubAlt
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1315);
            	        	        	        sequenceTag342=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag342.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1317);
            	        	        	        subjectPKinfo343=subjectPKinfo(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo343.tree);

            	        	        	        // Grammar/RFC5280.g:1292:35: ( issueruniqueId )?
            	        	        	        {
            	        	        	            int alt106=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag1:
            	        	        	                	{
            	        	        	                		alt106=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt106)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1292:36: issueruniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1320);
            	        	        	        	        issueruniqueId344=issueruniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId344.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        // Grammar/RFC5280.g:1292:53: ( subjectuniqueId )?
            	        	        	        {
            	        	        	            int alt107=2;
            	        	        	            switch ( LA(1) )
            	        	        	            {
            	        	        	                case Tag2:
            	        	        	                	{
            	        	        	                		alt107=1;
            	        	        	                	}
            	        	        	                    break;
            	        	        	            }

            	        	        	            switch (alt107)
            	        	        	            {
            	        	        	        	case 1:
            	        	        	        	    // Grammar/RFC5280.g:1292:54: subjectuniqueId
            	        	        	        	    {
            	        	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1325);
            	        	        	        	        subjectuniqueId345=subjectuniqueId(ctx);

            	        	        	        	        FOLLOWPOP();
            	        	        	        	        if  (HASEXCEPTION())
            	        	        	        	        {
            	        	        	        	            goto ruletbscertificateEx;
            	        	        	        	        }

            	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId345.tree);

            	        	        	        	    }
            	        	        	        	    break;

            	        	        	            }
            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_tbscertificate1329);
            	        	        	        constructedTag3346=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3346.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_tbscertificate1331);
            	        	        	        sequenceTag347=sequenceTag(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag347.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_tbscertificate1333);
            	        	        	        extensionsWithSubAlt348=extensionsWithSubAlt(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt348.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_gost_01_alg_id_in_tbscertificate1337);
            	        	        gost_01_alg_id349=gost_01_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_01_alg_id349.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1339);
            	        	        signature350=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature350.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:1296:4: constructedTag0 version2 serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_01_alg_id signature )
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag0_in_tbscertificate1349);
            	        constructedTag0351=constructedTag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletbscertificateEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag0351.tree);

            	        FOLLOWPUSH(FOLLOW_version2_in_tbscertificate1351);
            	        version2352=version2(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletbscertificateEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, version2352.tree);

            	        FOLLOWPUSH(FOLLOW_serialnumber_in_tbscertificate1353);
            	        serialnumber353=serialnumber(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletbscertificateEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, serialnumber353.tree);

            	        // Grammar/RFC5280.g:1297:2: ( rsa_md2_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_01_alg_id signature )
            	        {
            	            int alt146=18;
            	            switch ( LA(1) )
            	            {
            	            case SequenceTag:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case OIDTag:
            	            			{
            	            				switch ( LA(3) )
            	            				{
            	            				case MD2RSAOID:
            	            					{
            	            						alt146=1;
            	            					}
            	            				    break;
            	            				case MD5RSAOID:
            	            					{
            	            						alt146=2;
            	            					}
            	            				    break;
            	            				case SHA1RSAOID:
            	            					{
            	            						alt146=3;
            	            					}
            	            				    break;
            	            				case SHA224RSAOID:
            	            					{
            	            						alt146=4;
            	            					}
            	            				    break;
            	            				case SHA256RSAOID:
            	            					{
            	            						alt146=5;
            	            					}
            	            				    break;
            	            				case SHA384RSAOID:
            	            					{
            	            						alt146=6;
            	            					}
            	            				    break;
            	            				case SHA512RSAOID:
            	            					{
            	            						alt146=7;
            	            					}
            	            				    break;
            	            				case SHA1DSAOID:
            	            					{
            	            						alt146=8;
            	            					}
            	            				    break;
            	            				case SHA1ECOID:
            	            					{
            	            						alt146=9;
            	            					}
            	            				    break;
            	            				case RSAPSSOID:
            	            					{
            	            						alt146=10;
            	            					}
            	            				    break;
            	            				case SHA224DSAOID:
            	            					{
            	            						alt146=11;
            	            					}
            	            				    break;
            	            				case SHA256DSAOID:
            	            					{
            	            						alt146=12;
            	            					}
            	            				    break;
            	            				case SHA224ECOID:
            	            					{
            	            						alt146=13;
            	            					}
            	            				    break;
            	            				case SHA256ECOID:
            	            					{
            	            						alt146=14;
            	            					}
            	            				    break;
            	            				case SHA384ECOID:
            	            					{
            	            						alt146=15;
            	            					}
            	            				    break;
            	            				case SHA512ECOID:
            	            					{
            	            						alt146=16;
            	            					}
            	            				    break;
            	            				case GOST94SIGN:
            	            					{
            	            						alt146=17;
            	            					}
            	            				    break;
            	            				case GOST01SIGN:
            	            					{
            	            						alt146=18;
            	            					}
            	            				    break;

            	            				default:
            	            				    CONSTRUCTEX();
            	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				    EXCEPTION->message      = (void *)"";
            	            				    EXCEPTION->decisionNum  = 146;
            	            				    EXCEPTION->state        = 2;


            	            				    goto ruletbscertificateEx;

            	            				}

            	            			}
            	            		    break;

            	            		default:
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 146;
            	            		    EXCEPTION->state        = 1;


            	            		    goto ruletbscertificateEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 146;
            	                EXCEPTION->state        = 0;


            	                goto ruletbscertificateEx;

            	            }

            	            switch (alt146)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1297:3: rsa_md2_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md2_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_md2_alg_id_in_tbscertificate1358);
            	        	        rsa_md2_alg_id354=rsa_md2_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md2_alg_id354.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1360);
            	        	        issuer355=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer355.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1362);
            	        	        validity356=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity356.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1364);
            	        	        subject357=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject357.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1366);
            	        	        subjectPKinfo358=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo358.tree);

            	        	        // Grammar/RFC5280.g:1297:56: ( issueruniqueId )?
            	        	        {
            	        	            int alt110=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt110=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt110)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1297:57: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1369);
            	        	        	        issueruniqueId359=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId359.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1297:74: ( subjectuniqueId )?
            	        	        {
            	        	            int alt111=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt111=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt111)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1297:75: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1374);
            	        	        	        subjectuniqueId360=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId360.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_md2_alg_id_in_tbscertificate1379);
            	        	        rsa_md2_alg_id361=rsa_md2_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md2_alg_id361.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1381);
            	        	        signature362=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature362.tree);

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:1298:3: rsa_md5_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_md5_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_md5_alg_id_in_tbscertificate1385);
            	        	        rsa_md5_alg_id363=rsa_md5_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md5_alg_id363.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1387);
            	        	        issuer364=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer364.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1389);
            	        	        validity365=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity365.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1391);
            	        	        subject366=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject366.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1393);
            	        	        subjectPKinfo367=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo367.tree);

            	        	        // Grammar/RFC5280.g:1298:56: ( issueruniqueId )?
            	        	        {
            	        	            int alt112=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt112=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt112)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1298:57: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1396);
            	        	        	        issueruniqueId368=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId368.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1298:74: ( subjectuniqueId )?
            	        	        {
            	        	            int alt113=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt113=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt113)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1298:75: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1401);
            	        	        	        subjectuniqueId369=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId369.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_md5_alg_id_in_tbscertificate1406);
            	        	        rsa_md5_alg_id370=rsa_md5_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md5_alg_id370.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1408);
            	        	        signature371=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature371.tree);

            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // Grammar/RFC5280.g:1299:3: rsa_sha1_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha1_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha1_alg_id_in_tbscertificate1412);
            	        	        rsa_sha1_alg_id372=rsa_sha1_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha1_alg_id372.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1414);
            	        	        issuer373=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer373.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1416);
            	        	        validity374=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity374.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1418);
            	        	        subject375=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject375.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1420);
            	        	        subjectPKinfo376=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo376.tree);

            	        	        // Grammar/RFC5280.g:1299:57: ( issueruniqueId )?
            	        	        {
            	        	            int alt114=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt114=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt114)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1299:58: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1423);
            	        	        	        issueruniqueId377=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId377.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1299:75: ( subjectuniqueId )?
            	        	        {
            	        	            int alt115=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt115=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt115)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1299:76: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1428);
            	        	        	        subjectuniqueId378=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId378.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha1_alg_id_in_tbscertificate1433);
            	        	        rsa_sha1_alg_id379=rsa_sha1_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha1_alg_id379.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1435);
            	        	        signature380=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature380.tree);

            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // Grammar/RFC5280.g:1300:3: rsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha224_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha224_alg_id_in_tbscertificate1439);
            	        	        rsa_sha224_alg_id381=rsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha224_alg_id381.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1441);
            	        	        issuer382=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer382.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1443);
            	        	        validity383=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity383.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1445);
            	        	        subject384=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject384.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1447);
            	        	        subjectPKinfo385=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo385.tree);

            	        	        // Grammar/RFC5280.g:1300:59: ( issueruniqueId )?
            	        	        {
            	        	            int alt116=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt116=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt116)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1300:60: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1450);
            	        	        	        issueruniqueId386=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId386.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1300:77: ( subjectuniqueId )?
            	        	        {
            	        	            int alt117=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt117=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt117)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1300:78: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1455);
            	        	        	        subjectuniqueId387=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId387.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha224_alg_id_in_tbscertificate1460);
            	        	        rsa_sha224_alg_id388=rsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha224_alg_id388.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1462);
            	        	        signature389=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature389.tree);

            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // Grammar/RFC5280.g:1301:3: rsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha256_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha256_alg_id_in_tbscertificate1466);
            	        	        rsa_sha256_alg_id390=rsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha256_alg_id390.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1468);
            	        	        issuer391=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer391.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1470);
            	        	        validity392=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity392.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1472);
            	        	        subject393=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject393.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1474);
            	        	        subjectPKinfo394=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo394.tree);

            	        	        // Grammar/RFC5280.g:1301:59: ( issueruniqueId )?
            	        	        {
            	        	            int alt118=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt118=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt118)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1301:60: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1477);
            	        	        	        issueruniqueId395=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId395.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1301:77: ( subjectuniqueId )?
            	        	        {
            	        	            int alt119=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt119=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt119)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1301:78: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1482);
            	        	        	        subjectuniqueId396=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId396.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha256_alg_id_in_tbscertificate1487);
            	        	        rsa_sha256_alg_id397=rsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha256_alg_id397.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1489);
            	        	        signature398=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature398.tree);

            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // Grammar/RFC5280.g:1302:3: rsa_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha384_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha384_alg_id_in_tbscertificate1493);
            	        	        rsa_sha384_alg_id399=rsa_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha384_alg_id399.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1495);
            	        	        issuer400=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer400.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1497);
            	        	        validity401=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity401.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1499);
            	        	        subject402=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject402.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1501);
            	        	        subjectPKinfo403=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo403.tree);

            	        	        // Grammar/RFC5280.g:1302:59: ( issueruniqueId )?
            	        	        {
            	        	            int alt120=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt120=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt120)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1302:60: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1504);
            	        	        	        issueruniqueId404=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId404.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1302:77: ( subjectuniqueId )?
            	        	        {
            	        	            int alt121=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt121=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt121)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1302:78: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1509);
            	        	        	        subjectuniqueId405=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId405.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha384_alg_id_in_tbscertificate1514);
            	        	        rsa_sha384_alg_id406=rsa_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha384_alg_id406.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1516);
            	        	        signature407=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature407.tree);

            	        	    }
            	        	    break;
            	        	case 7:
            	        	    // Grammar/RFC5280.g:1303:3: rsa_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? rsa_sha512_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha512_alg_id_in_tbscertificate1520);
            	        	        rsa_sha512_alg_id408=rsa_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha512_alg_id408.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1522);
            	        	        issuer409=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer409.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1524);
            	        	        validity410=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity410.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1526);
            	        	        subject411=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject411.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1528);
            	        	        subjectPKinfo412=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo412.tree);

            	        	        // Grammar/RFC5280.g:1303:59: ( issueruniqueId )?
            	        	        {
            	        	            int alt122=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt122=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt122)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1303:60: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1531);
            	        	        	        issueruniqueId413=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId413.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1303:77: ( subjectuniqueId )?
            	        	        {
            	        	            int alt123=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt123=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt123)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1303:78: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1536);
            	        	        	        subjectuniqueId414=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId414.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha512_alg_id_in_tbscertificate1541);
            	        	        rsa_sha512_alg_id415=rsa_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha512_alg_id415.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1543);
            	        	        signature416=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature416.tree);

            	        	    }
            	        	    break;
            	        	case 8:
            	        	    // Grammar/RFC5280.g:1304:3: dsa_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dsa_sha_alg_id_in_tbscertificate1547);
            	        	        dsa_sha_alg_id417=dsa_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha_alg_id417.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1549);
            	        	        issuer418=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer418.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1551);
            	        	        validity419=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity419.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1553);
            	        	        subject420=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject420.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1555);
            	        	        subjectPKinfo421=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo421.tree);

            	        	        // Grammar/RFC5280.g:1304:56: ( issueruniqueId )?
            	        	        {
            	        	            int alt124=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt124=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt124)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1304:57: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1558);
            	        	        	        issueruniqueId422=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId422.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1304:74: ( subjectuniqueId )?
            	        	        {
            	        	            int alt125=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt125=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt125)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1304:75: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1563);
            	        	        	        subjectuniqueId423=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId423.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_dsa_sha_alg_id_in_tbscertificate1568);
            	        	        dsa_sha_alg_id424=dsa_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha_alg_id424.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1570);
            	        	        dsa_signature425=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature425.tree);

            	        	    }
            	        	    break;
            	        	case 9:
            	        	    // Grammar/RFC5280.g:1305:3: ec_sha_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha_alg_id_in_tbscertificate1574);
            	        	        ec_sha_alg_id426=ec_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha_alg_id426.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1576);
            	        	        issuer427=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer427.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1578);
            	        	        validity428=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity428.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1580);
            	        	        subject429=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject429.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1582);
            	        	        subjectPKinfo430=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo430.tree);

            	        	        // Grammar/RFC5280.g:1305:55: ( issueruniqueId )?
            	        	        {
            	        	            int alt126=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt126=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt126)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1305:56: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1585);
            	        	        	        issueruniqueId431=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId431.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1305:73: ( subjectuniqueId )?
            	        	        {
            	        	            int alt127=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt127=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt127)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1305:74: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1590);
            	        	        	        subjectuniqueId432=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId432.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha_alg_id_in_tbscertificate1595);
            	        	        ec_sha_alg_id433=ec_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha_alg_id433.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1597);
            	        	        dsa_signature434=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature434.tree);

            	        	    }
            	        	    break;
            	        	case 10:
            	        	    // Grammar/RFC5280.g:1306:3: pss_alg_id_params issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? pss_alg_id_params signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_pss_alg_id_params_in_tbscertificate1602);
            	        	        pss_alg_id_params435=pss_alg_id_params(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, pss_alg_id_params435.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1604);
            	        	        issuer436=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer436.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1606);
            	        	        validity437=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity437.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1608);
            	        	        subject438=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject438.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1610);
            	        	        subjectPKinfo439=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo439.tree);

            	        	        // Grammar/RFC5280.g:1306:59: ( issueruniqueId )?
            	        	        {
            	        	            int alt128=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt128=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt128)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1306:60: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1613);
            	        	        	        issueruniqueId440=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId440.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1306:77: ( subjectuniqueId )?
            	        	        {
            	        	            int alt129=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt129=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt129)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1306:78: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1618);
            	        	        	        subjectuniqueId441=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId441.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_pss_alg_id_params_in_tbscertificate1623);
            	        	        pss_alg_id_params442=pss_alg_id_params(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, pss_alg_id_params442.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1625);
            	        	        signature443=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature443.tree);

            	        	    }
            	        	    break;
            	        	case 11:
            	        	    // Grammar/RFC5280.g:1307:3: dsa_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha224_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dsa_sha224_alg_id_in_tbscertificate1629);
            	        	        dsa_sha224_alg_id444=dsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha224_alg_id444.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1631);
            	        	        issuer445=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer445.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1633);
            	        	        validity446=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity446.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1635);
            	        	        subject447=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject447.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1637);
            	        	        subjectPKinfo448=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo448.tree);

            	        	        // Grammar/RFC5280.g:1307:59: ( issueruniqueId )?
            	        	        {
            	        	            int alt130=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt130=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt130)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1307:60: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1640);
            	        	        	        issueruniqueId449=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId449.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1307:77: ( subjectuniqueId )?
            	        	        {
            	        	            int alt131=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt131=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt131)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1307:78: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1645);
            	        	        	        subjectuniqueId450=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId450.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_dsa_sha224_alg_id_in_tbscertificate1650);
            	        	        dsa_sha224_alg_id451=dsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha224_alg_id451.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1652);
            	        	        dsa_signature452=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature452.tree);

            	        	    }
            	        	    break;
            	        	case 12:
            	        	    // Grammar/RFC5280.g:1308:3: dsa_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? dsa_sha256_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dsa_sha256_alg_id_in_tbscertificate1656);
            	        	        dsa_sha256_alg_id453=dsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha256_alg_id453.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1658);
            	        	        issuer454=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer454.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1660);
            	        	        validity455=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity455.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1662);
            	        	        subject456=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject456.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1664);
            	        	        subjectPKinfo457=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo457.tree);

            	        	        // Grammar/RFC5280.g:1308:59: ( issueruniqueId )?
            	        	        {
            	        	            int alt132=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt132=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt132)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1308:60: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1667);
            	        	        	        issueruniqueId458=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId458.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1308:77: ( subjectuniqueId )?
            	        	        {
            	        	            int alt133=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt133=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt133)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1308:78: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1672);
            	        	        	        subjectuniqueId459=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId459.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_dsa_sha256_alg_id_in_tbscertificate1677);
            	        	        dsa_sha256_alg_id460=dsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha256_alg_id460.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1679);
            	        	        dsa_signature461=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature461.tree);

            	        	    }
            	        	    break;
            	        	case 13:
            	        	    // Grammar/RFC5280.g:1309:3: ec_sha224_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha224_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha224_alg_id_in_tbscertificate1683);
            	        	        ec_sha224_alg_id462=ec_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha224_alg_id462.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1685);
            	        	        issuer463=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer463.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1687);
            	        	        validity464=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity464.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1689);
            	        	        subject465=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject465.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1691);
            	        	        subjectPKinfo466=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo466.tree);

            	        	        // Grammar/RFC5280.g:1309:58: ( issueruniqueId )?
            	        	        {
            	        	            int alt134=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt134=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt134)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1309:59: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1694);
            	        	        	        issueruniqueId467=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId467.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1309:76: ( subjectuniqueId )?
            	        	        {
            	        	            int alt135=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt135=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt135)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1309:77: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1699);
            	        	        	        subjectuniqueId468=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId468.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha224_alg_id_in_tbscertificate1704);
            	        	        ec_sha224_alg_id469=ec_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha224_alg_id469.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1706);
            	        	        dsa_signature470=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature470.tree);

            	        	    }
            	        	    break;
            	        	case 14:
            	        	    // Grammar/RFC5280.g:1310:3: ec_sha256_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha256_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha256_alg_id_in_tbscertificate1710);
            	        	        ec_sha256_alg_id471=ec_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha256_alg_id471.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1712);
            	        	        issuer472=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer472.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1714);
            	        	        validity473=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity473.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1716);
            	        	        subject474=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject474.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1718);
            	        	        subjectPKinfo475=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo475.tree);

            	        	        // Grammar/RFC5280.g:1310:58: ( issueruniqueId )?
            	        	        {
            	        	            int alt136=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt136=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt136)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1310:59: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1721);
            	        	        	        issueruniqueId476=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId476.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1310:76: ( subjectuniqueId )?
            	        	        {
            	        	            int alt137=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt137=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt137)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1310:77: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1726);
            	        	        	        subjectuniqueId477=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId477.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha256_alg_id_in_tbscertificate1731);
            	        	        ec_sha256_alg_id478=ec_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha256_alg_id478.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1733);
            	        	        dsa_signature479=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature479.tree);

            	        	    }
            	        	    break;
            	        	case 15:
            	        	    // Grammar/RFC5280.g:1311:3: ec_sha384_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha384_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha384_alg_id_in_tbscertificate1737);
            	        	        ec_sha384_alg_id480=ec_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha384_alg_id480.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1739);
            	        	        issuer481=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer481.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1741);
            	        	        validity482=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity482.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1743);
            	        	        subject483=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject483.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1745);
            	        	        subjectPKinfo484=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo484.tree);

            	        	        // Grammar/RFC5280.g:1311:58: ( issueruniqueId )?
            	        	        {
            	        	            int alt138=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt138=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt138)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1311:59: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1748);
            	        	        	        issueruniqueId485=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId485.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1311:76: ( subjectuniqueId )?
            	        	        {
            	        	            int alt139=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt139=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt139)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1311:77: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1753);
            	        	        	        subjectuniqueId486=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId486.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha384_alg_id_in_tbscertificate1758);
            	        	        ec_sha384_alg_id487=ec_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha384_alg_id487.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1760);
            	        	        dsa_signature488=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature488.tree);

            	        	    }
            	        	    break;
            	        	case 16:
            	        	    // Grammar/RFC5280.g:1312:3: ec_sha512_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? ec_sha512_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha512_alg_id_in_tbscertificate1764);
            	        	        ec_sha512_alg_id489=ec_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha512_alg_id489.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1766);
            	        	        issuer490=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer490.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1768);
            	        	        validity491=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity491.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1770);
            	        	        subject492=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject492.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1772);
            	        	        subjectPKinfo493=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo493.tree);

            	        	        // Grammar/RFC5280.g:1312:58: ( issueruniqueId )?
            	        	        {
            	        	            int alt140=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt140=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt140)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1312:59: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1775);
            	        	        	        issueruniqueId494=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId494.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1312:76: ( subjectuniqueId )?
            	        	        {
            	        	            int alt141=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt141=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt141)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1312:77: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1780);
            	        	        	        subjectuniqueId495=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId495.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_ec_sha512_alg_id_in_tbscertificate1785);
            	        	        ec_sha512_alg_id496=ec_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha512_alg_id496.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1787);
            	        	        dsa_signature497=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature497.tree);

            	        	    }
            	        	    break;
            	        	case 17:
            	        	    // Grammar/RFC5280.g:1313:3: gost_94_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_94_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_gost_94_alg_id_in_tbscertificate1791);
            	        	        gost_94_alg_id498=gost_94_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_94_alg_id498.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1793);
            	        	        issuer499=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer499.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1795);
            	        	        validity500=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity500.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1797);
            	        	        subject501=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject501.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1799);
            	        	        subjectPKinfo502=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo502.tree);

            	        	        // Grammar/RFC5280.g:1313:56: ( issueruniqueId )?
            	        	        {
            	        	            int alt142=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt142=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt142)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1313:57: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1802);
            	        	        	        issueruniqueId503=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId503.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1313:74: ( subjectuniqueId )?
            	        	        {
            	        	            int alt143=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt143=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt143)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1313:75: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1807);
            	        	        	        subjectuniqueId504=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId504.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_gost_94_alg_id_in_tbscertificate1812);
            	        	        gost_94_alg_id505=gost_94_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_94_alg_id505.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1814);
            	        	        signature506=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature506.tree);

            	        	    }
            	        	    break;
            	        	case 18:
            	        	    // Grammar/RFC5280.g:1314:3: gost_01_alg_id issuer validity subject subjectPKinfo ( issueruniqueId )? ( subjectuniqueId )? gost_01_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_gost_01_alg_id_in_tbscertificate1818);
            	        	        gost_01_alg_id507=gost_01_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_01_alg_id507.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1820);
            	        	        issuer508=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer508.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1822);
            	        	        validity509=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity509.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1824);
            	        	        subject510=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject510.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1826);
            	        	        subjectPKinfo511=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo511.tree);

            	        	        // Grammar/RFC5280.g:1314:56: ( issueruniqueId )?
            	        	        {
            	        	            int alt144=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt144=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt144)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1314:57: issueruniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_issueruniqueId_in_tbscertificate1829);
            	        	        	        issueruniqueId512=issueruniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, issueruniqueId512.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:1314:74: ( subjectuniqueId )?
            	        	        {
            	        	            int alt145=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag2:
            	        	                	{
            	        	                		alt145=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt145)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1314:75: subjectuniqueId
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_subjectuniqueId_in_tbscertificate1834);
            	        	        	        subjectuniqueId513=subjectuniqueId(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruletbscertificateEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectuniqueId513.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_gost_01_alg_id_in_tbscertificate1839);
            	        	        gost_01_alg_id514=gost_01_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_01_alg_id514.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1841);
            	        	        signature515=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature515.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:1317:4: ( constructedTag0 version )? serialnumber ( rsa_md2_alg_id issuer validity subject subjectPKinfo rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo gost_01_alg_id signature )
            	    {
            	        // Grammar/RFC5280.g:1317:4: ( constructedTag0 version )?
            	        {
            	            int alt147=2;
            	            switch ( LA(1) )
            	            {
            	                case ConstructedTag0:
            	                	{
            	                		alt147=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt147)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1317:5: constructedTag0 version
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag0_in_tbscertificate1852);
            	        	        constructedTag0516=constructedTag0(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag0516.tree);

            	        	        FOLLOWPUSH(FOLLOW_version_in_tbscertificate1854);
            	        	        version517=version(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, version517.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_serialnumber_in_tbscertificate1858);
            	        serialnumber518=serialnumber(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletbscertificateEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, serialnumber518.tree);

            	        // Grammar/RFC5280.g:1318:2: ( rsa_md2_alg_id issuer validity subject subjectPKinfo rsa_md2_alg_id signature | rsa_md5_alg_id issuer validity subject subjectPKinfo rsa_md5_alg_id signature | rsa_sha1_alg_id issuer validity subject subjectPKinfo rsa_sha1_alg_id signature | rsa_sha224_alg_id issuer validity subject subjectPKinfo rsa_sha224_alg_id signature | rsa_sha256_alg_id issuer validity subject subjectPKinfo rsa_sha256_alg_id signature | rsa_sha384_alg_id issuer validity subject subjectPKinfo rsa_sha384_alg_id signature | rsa_sha512_alg_id issuer validity subject subjectPKinfo rsa_sha512_alg_id signature | dsa_sha_alg_id issuer validity subject subjectPKinfo dsa_sha_alg_id dsa_signature | ec_sha_alg_id issuer validity subject subjectPKinfo ec_sha_alg_id dsa_signature | pss_alg_id_params issuer validity subject subjectPKinfo pss_alg_id_params signature | dsa_sha224_alg_id issuer validity subject subjectPKinfo dsa_sha224_alg_id dsa_signature | dsa_sha256_alg_id issuer validity subject subjectPKinfo dsa_sha256_alg_id dsa_signature | ec_sha224_alg_id issuer validity subject subjectPKinfo ec_sha224_alg_id dsa_signature | ec_sha256_alg_id issuer validity subject subjectPKinfo ec_sha256_alg_id dsa_signature | ec_sha384_alg_id issuer validity subject subjectPKinfo ec_sha384_alg_id dsa_signature | ec_sha512_alg_id issuer validity subject subjectPKinfo ec_sha512_alg_id dsa_signature | gost_94_alg_id issuer validity subject subjectPKinfo gost_94_alg_id signature | gost_01_alg_id issuer validity subject subjectPKinfo gost_01_alg_id signature )
            	        {
            	            int alt148=18;
            	            switch ( LA(1) )
            	            {
            	            case SequenceTag:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case OIDTag:
            	            			{
            	            				switch ( LA(3) )
            	            				{
            	            				case MD2RSAOID:
            	            					{
            	            						alt148=1;
            	            					}
            	            				    break;
            	            				case MD5RSAOID:
            	            					{
            	            						alt148=2;
            	            					}
            	            				    break;
            	            				case SHA1RSAOID:
            	            					{
            	            						alt148=3;
            	            					}
            	            				    break;
            	            				case SHA224RSAOID:
            	            					{
            	            						alt148=4;
            	            					}
            	            				    break;
            	            				case SHA256RSAOID:
            	            					{
            	            						alt148=5;
            	            					}
            	            				    break;
            	            				case SHA384RSAOID:
            	            					{
            	            						alt148=6;
            	            					}
            	            				    break;
            	            				case SHA512RSAOID:
            	            					{
            	            						alt148=7;
            	            					}
            	            				    break;
            	            				case SHA1DSAOID:
            	            					{
            	            						alt148=8;
            	            					}
            	            				    break;
            	            				case SHA1ECOID:
            	            					{
            	            						alt148=9;
            	            					}
            	            				    break;
            	            				case RSAPSSOID:
            	            					{
            	            						alt148=10;
            	            					}
            	            				    break;
            	            				case SHA224DSAOID:
            	            					{
            	            						alt148=11;
            	            					}
            	            				    break;
            	            				case SHA256DSAOID:
            	            					{
            	            						alt148=12;
            	            					}
            	            				    break;
            	            				case SHA224ECOID:
            	            					{
            	            						alt148=13;
            	            					}
            	            				    break;
            	            				case SHA256ECOID:
            	            					{
            	            						alt148=14;
            	            					}
            	            				    break;
            	            				case SHA384ECOID:
            	            					{
            	            						alt148=15;
            	            					}
            	            				    break;
            	            				case SHA512ECOID:
            	            					{
            	            						alt148=16;
            	            					}
            	            				    break;
            	            				case GOST94SIGN:
            	            					{
            	            						alt148=17;
            	            					}
            	            				    break;
            	            				case GOST01SIGN:
            	            					{
            	            						alt148=18;
            	            					}
            	            				    break;

            	            				default:
            	            				    CONSTRUCTEX();
            	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				    EXCEPTION->message      = (void *)"";
            	            				    EXCEPTION->decisionNum  = 148;
            	            				    EXCEPTION->state        = 2;


            	            				    goto ruletbscertificateEx;

            	            				}

            	            			}
            	            		    break;

            	            		default:
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 148;
            	            		    EXCEPTION->state        = 1;


            	            		    goto ruletbscertificateEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 148;
            	                EXCEPTION->state        = 0;


            	                goto ruletbscertificateEx;

            	            }

            	            switch (alt148)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1318:3: rsa_md2_alg_id issuer validity subject subjectPKinfo rsa_md2_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_md2_alg_id_in_tbscertificate1862);
            	        	        rsa_md2_alg_id519=rsa_md2_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md2_alg_id519.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1864);
            	        	        issuer520=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer520.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1866);
            	        	        validity521=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity521.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1868);
            	        	        subject522=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject522.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1870);
            	        	        subjectPKinfo523=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo523.tree);

            	        	        FOLLOWPUSH(FOLLOW_rsa_md2_alg_id_in_tbscertificate1872);
            	        	        rsa_md2_alg_id524=rsa_md2_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md2_alg_id524.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1874);
            	        	        signature525=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature525.tree);

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:1319:3: rsa_md5_alg_id issuer validity subject subjectPKinfo rsa_md5_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_md5_alg_id_in_tbscertificate1879);
            	        	        rsa_md5_alg_id526=rsa_md5_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md5_alg_id526.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1881);
            	        	        issuer527=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer527.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1883);
            	        	        validity528=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity528.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1885);
            	        	        subject529=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject529.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1887);
            	        	        subjectPKinfo530=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo530.tree);

            	        	        FOLLOWPUSH(FOLLOW_rsa_md5_alg_id_in_tbscertificate1889);
            	        	        rsa_md5_alg_id531=rsa_md5_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_md5_alg_id531.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1891);
            	        	        signature532=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature532.tree);

            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // Grammar/RFC5280.g:1320:3: rsa_sha1_alg_id issuer validity subject subjectPKinfo rsa_sha1_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha1_alg_id_in_tbscertificate1895);
            	        	        rsa_sha1_alg_id533=rsa_sha1_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha1_alg_id533.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1897);
            	        	        issuer534=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer534.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1899);
            	        	        validity535=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity535.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1901);
            	        	        subject536=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject536.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1903);
            	        	        subjectPKinfo537=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo537.tree);

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha1_alg_id_in_tbscertificate1905);
            	        	        rsa_sha1_alg_id538=rsa_sha1_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha1_alg_id538.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1907);
            	        	        signature539=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature539.tree);

            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // Grammar/RFC5280.g:1321:3: rsa_sha224_alg_id issuer validity subject subjectPKinfo rsa_sha224_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha224_alg_id_in_tbscertificate1911);
            	        	        rsa_sha224_alg_id540=rsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha224_alg_id540.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1913);
            	        	        issuer541=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer541.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1915);
            	        	        validity542=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity542.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1917);
            	        	        subject543=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject543.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1919);
            	        	        subjectPKinfo544=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo544.tree);

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha224_alg_id_in_tbscertificate1921);
            	        	        rsa_sha224_alg_id545=rsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha224_alg_id545.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1923);
            	        	        signature546=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature546.tree);

            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // Grammar/RFC5280.g:1322:3: rsa_sha256_alg_id issuer validity subject subjectPKinfo rsa_sha256_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha256_alg_id_in_tbscertificate1927);
            	        	        rsa_sha256_alg_id547=rsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha256_alg_id547.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1929);
            	        	        issuer548=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer548.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1931);
            	        	        validity549=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity549.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1933);
            	        	        subject550=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject550.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1935);
            	        	        subjectPKinfo551=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo551.tree);

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha256_alg_id_in_tbscertificate1937);
            	        	        rsa_sha256_alg_id552=rsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha256_alg_id552.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1939);
            	        	        signature553=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature553.tree);

            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // Grammar/RFC5280.g:1323:3: rsa_sha384_alg_id issuer validity subject subjectPKinfo rsa_sha384_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha384_alg_id_in_tbscertificate1943);
            	        	        rsa_sha384_alg_id554=rsa_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha384_alg_id554.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1945);
            	        	        issuer555=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer555.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1947);
            	        	        validity556=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity556.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1949);
            	        	        subject557=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject557.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1951);
            	        	        subjectPKinfo558=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo558.tree);

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha384_alg_id_in_tbscertificate1953);
            	        	        rsa_sha384_alg_id559=rsa_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha384_alg_id559.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1955);
            	        	        signature560=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature560.tree);

            	        	    }
            	        	    break;
            	        	case 7:
            	        	    // Grammar/RFC5280.g:1324:3: rsa_sha512_alg_id issuer validity subject subjectPKinfo rsa_sha512_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_rsa_sha512_alg_id_in_tbscertificate1959);
            	        	        rsa_sha512_alg_id561=rsa_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha512_alg_id561.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1961);
            	        	        issuer562=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer562.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1963);
            	        	        validity563=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity563.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1965);
            	        	        subject564=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject564.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1967);
            	        	        subjectPKinfo565=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo565.tree);

            	        	        FOLLOWPUSH(FOLLOW_rsa_sha512_alg_id_in_tbscertificate1969);
            	        	        rsa_sha512_alg_id566=rsa_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rsa_sha512_alg_id566.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate1971);
            	        	        signature567=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature567.tree);

            	        	    }
            	        	    break;
            	        	case 8:
            	        	    // Grammar/RFC5280.g:1325:3: dsa_sha_alg_id issuer validity subject subjectPKinfo dsa_sha_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dsa_sha_alg_id_in_tbscertificate1975);
            	        	        dsa_sha_alg_id568=dsa_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha_alg_id568.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1977);
            	        	        issuer569=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer569.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1979);
            	        	        validity570=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity570.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1981);
            	        	        subject571=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject571.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1983);
            	        	        subjectPKinfo572=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo572.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_sha_alg_id_in_tbscertificate1985);
            	        	        dsa_sha_alg_id573=dsa_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha_alg_id573.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate1987);
            	        	        dsa_signature574=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature574.tree);

            	        	    }
            	        	    break;
            	        	case 9:
            	        	    // Grammar/RFC5280.g:1326:3: ec_sha_alg_id issuer validity subject subjectPKinfo ec_sha_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha_alg_id_in_tbscertificate1991);
            	        	        ec_sha_alg_id575=ec_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha_alg_id575.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate1993);
            	        	        issuer576=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer576.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate1995);
            	        	        validity577=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity577.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate1997);
            	        	        subject578=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject578.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate1999);
            	        	        subjectPKinfo579=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo579.tree);

            	        	        FOLLOWPUSH(FOLLOW_ec_sha_alg_id_in_tbscertificate2001);
            	        	        ec_sha_alg_id580=ec_sha_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha_alg_id580.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate2003);
            	        	        dsa_signature581=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature581.tree);

            	        	    }
            	        	    break;
            	        	case 10:
            	        	    // Grammar/RFC5280.g:1327:3: pss_alg_id_params issuer validity subject subjectPKinfo pss_alg_id_params signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_pss_alg_id_params_in_tbscertificate2007);
            	        	        pss_alg_id_params582=pss_alg_id_params(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, pss_alg_id_params582.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate2009);
            	        	        issuer583=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer583.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate2011);
            	        	        validity584=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity584.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate2013);
            	        	        subject585=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject585.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate2015);
            	        	        subjectPKinfo586=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo586.tree);

            	        	        FOLLOWPUSH(FOLLOW_pss_alg_id_params_in_tbscertificate2017);
            	        	        pss_alg_id_params587=pss_alg_id_params(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, pss_alg_id_params587.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate2019);
            	        	        signature588=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature588.tree);

            	        	    }
            	        	    break;
            	        	case 11:
            	        	    // Grammar/RFC5280.g:1328:3: dsa_sha224_alg_id issuer validity subject subjectPKinfo dsa_sha224_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dsa_sha224_alg_id_in_tbscertificate2023);
            	        	        dsa_sha224_alg_id589=dsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha224_alg_id589.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate2025);
            	        	        issuer590=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer590.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate2027);
            	        	        validity591=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity591.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate2029);
            	        	        subject592=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject592.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate2031);
            	        	        subjectPKinfo593=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo593.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_sha224_alg_id_in_tbscertificate2033);
            	        	        dsa_sha224_alg_id594=dsa_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha224_alg_id594.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate2035);
            	        	        dsa_signature595=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature595.tree);

            	        	    }
            	        	    break;
            	        	case 12:
            	        	    // Grammar/RFC5280.g:1329:3: dsa_sha256_alg_id issuer validity subject subjectPKinfo dsa_sha256_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dsa_sha256_alg_id_in_tbscertificate2039);
            	        	        dsa_sha256_alg_id596=dsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha256_alg_id596.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate2041);
            	        	        issuer597=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer597.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate2043);
            	        	        validity598=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity598.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate2045);
            	        	        subject599=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject599.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate2047);
            	        	        subjectPKinfo600=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo600.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_sha256_alg_id_in_tbscertificate2049);
            	        	        dsa_sha256_alg_id601=dsa_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_sha256_alg_id601.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate2051);
            	        	        dsa_signature602=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature602.tree);

            	        	    }
            	        	    break;
            	        	case 13:
            	        	    // Grammar/RFC5280.g:1330:3: ec_sha224_alg_id issuer validity subject subjectPKinfo ec_sha224_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha224_alg_id_in_tbscertificate2055);
            	        	        ec_sha224_alg_id603=ec_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha224_alg_id603.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate2057);
            	        	        issuer604=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer604.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate2059);
            	        	        validity605=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity605.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate2061);
            	        	        subject606=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject606.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate2063);
            	        	        subjectPKinfo607=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo607.tree);

            	        	        FOLLOWPUSH(FOLLOW_ec_sha224_alg_id_in_tbscertificate2065);
            	        	        ec_sha224_alg_id608=ec_sha224_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha224_alg_id608.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate2067);
            	        	        dsa_signature609=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature609.tree);

            	        	    }
            	        	    break;
            	        	case 14:
            	        	    // Grammar/RFC5280.g:1331:3: ec_sha256_alg_id issuer validity subject subjectPKinfo ec_sha256_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha256_alg_id_in_tbscertificate2071);
            	        	        ec_sha256_alg_id610=ec_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha256_alg_id610.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate2073);
            	        	        issuer611=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer611.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate2075);
            	        	        validity612=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity612.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate2077);
            	        	        subject613=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject613.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate2079);
            	        	        subjectPKinfo614=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo614.tree);

            	        	        FOLLOWPUSH(FOLLOW_ec_sha256_alg_id_in_tbscertificate2081);
            	        	        ec_sha256_alg_id615=ec_sha256_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha256_alg_id615.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate2083);
            	        	        dsa_signature616=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature616.tree);

            	        	    }
            	        	    break;
            	        	case 15:
            	        	    // Grammar/RFC5280.g:1332:3: ec_sha384_alg_id issuer validity subject subjectPKinfo ec_sha384_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha384_alg_id_in_tbscertificate2087);
            	        	        ec_sha384_alg_id617=ec_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha384_alg_id617.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate2089);
            	        	        issuer618=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer618.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate2091);
            	        	        validity619=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity619.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate2093);
            	        	        subject620=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject620.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate2095);
            	        	        subjectPKinfo621=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo621.tree);

            	        	        FOLLOWPUSH(FOLLOW_ec_sha384_alg_id_in_tbscertificate2097);
            	        	        ec_sha384_alg_id622=ec_sha384_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha384_alg_id622.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate2099);
            	        	        dsa_signature623=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature623.tree);

            	        	    }
            	        	    break;
            	        	case 16:
            	        	    // Grammar/RFC5280.g:1333:3: ec_sha512_alg_id issuer validity subject subjectPKinfo ec_sha512_alg_id dsa_signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ec_sha512_alg_id_in_tbscertificate2103);
            	        	        ec_sha512_alg_id624=ec_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha512_alg_id624.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate2105);
            	        	        issuer625=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer625.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate2107);
            	        	        validity626=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity626.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate2109);
            	        	        subject627=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject627.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate2111);
            	        	        subjectPKinfo628=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo628.tree);

            	        	        FOLLOWPUSH(FOLLOW_ec_sha512_alg_id_in_tbscertificate2113);
            	        	        ec_sha512_alg_id629=ec_sha512_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ec_sha512_alg_id629.tree);

            	        	        FOLLOWPUSH(FOLLOW_dsa_signature_in_tbscertificate2115);
            	        	        dsa_signature630=dsa_signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dsa_signature630.tree);

            	        	    }
            	        	    break;
            	        	case 17:
            	        	    // Grammar/RFC5280.g:1334:3: gost_94_alg_id issuer validity subject subjectPKinfo gost_94_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_gost_94_alg_id_in_tbscertificate2119);
            	        	        gost_94_alg_id631=gost_94_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_94_alg_id631.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate2121);
            	        	        issuer632=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer632.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate2123);
            	        	        validity633=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity633.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate2125);
            	        	        subject634=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject634.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate2127);
            	        	        subjectPKinfo635=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo635.tree);

            	        	        FOLLOWPUSH(FOLLOW_gost_94_alg_id_in_tbscertificate2129);
            	        	        gost_94_alg_id636=gost_94_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_94_alg_id636.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate2131);
            	        	        signature637=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature637.tree);

            	        	    }
            	        	    break;
            	        	case 18:
            	        	    // Grammar/RFC5280.g:1335:3: gost_01_alg_id issuer validity subject subjectPKinfo gost_01_alg_id signature
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_gost_01_alg_id_in_tbscertificate2135);
            	        	        gost_01_alg_id638=gost_01_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_01_alg_id638.tree);

            	        	        FOLLOWPUSH(FOLLOW_issuer_in_tbscertificate2137);
            	        	        issuer639=issuer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, issuer639.tree);

            	        	        FOLLOWPUSH(FOLLOW_validity_in_tbscertificate2139);
            	        	        validity640=validity(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, validity640.tree);

            	        	        FOLLOWPUSH(FOLLOW_subject_in_tbscertificate2141);
            	        	        subject641=subject(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subject641.tree);

            	        	        FOLLOWPUSH(FOLLOW_subjectPKinfo_in_tbscertificate2143);
            	        	        subjectPKinfo642=subjectPKinfo(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectPKinfo642.tree);

            	        	        FOLLOWPUSH(FOLLOW_gost_01_alg_id_in_tbscertificate2145);
            	        	        gost_01_alg_id643=gost_01_alg_id(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, gost_01_alg_id643.tree);

            	        	        FOLLOWPUSH(FOLLOW_signature_in_tbscertificate2147);
            	        	        signature644=signature(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruletbscertificateEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, signature644.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruletbscertificateEx; /* Prevent compiler warnings */
    ruletbscertificateEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tbscertificate */

/**
 * $ANTLR start algorithm_id
 * Grammar/RFC5280.g:1339:1: algorithm_id : sequenceTag oid ({...}? => any |) ;
 */
static RFC5280Parser_algorithm_id_return
algorithm_id(pRFC5280Parser ctx)
{
    RFC5280Parser_algorithm_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag645;
    #undef	RETURN_TYPE_sequenceTag645
    #define	RETURN_TYPE_sequenceTag645 RFC5280Parser_sequenceTag_return

    RFC5280Parser_oid_return oid646;
    #undef	RETURN_TYPE_oid646
    #define	RETURN_TYPE_oid646 RFC5280Parser_oid_return

    RFC5280Parser_any_return any647;
    #undef	RETURN_TYPE_any647
    #define	RETURN_TYPE_any647 RFC5280Parser_any_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag645.tree = NULL;

    oid646.tree = NULL;

    any647.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1342:2: ( sequenceTag oid ({...}? => any |) )
        // Grammar/RFC5280.g:1342:4: sequenceTag oid ({...}? => any |)
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_algorithm_id2168);
            sequenceTag645=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealgorithm_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag645.tree);

            {
                any_pointer = counter_list;
            }


            FOLLOWPUSH(FOLLOW_oid_in_algorithm_id2172);
            oid646=oid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulealgorithm_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, oid646.tree);

            // Grammar/RFC5280.g:1344:57: ({...}? => any |)
            {
                int alt150=2;
                {
                    int LA150_0 = LA(1);
                    if ( ((any_pointer != NULL)) && (((LA150_0 >= BMPTag) && (LA150_0 <= BitStringTag)) || ((LA150_0 >= ConstructedOctetTag) && (LA150_0 <= ConstructedTag8)) || LA150_0 == FalseTag || ((LA150_0 >= GeneralStringTag) && (LA150_0 <= GraphicalStringTag)) || ((LA150_0 >= IA5StringTag) && (LA150_0 <= IntTag)) || LA150_0 == Null || ((LA150_0 >= OIDTag) && (LA150_0 <= OctetTag)) || LA150_0 == PrintStringTag || ((LA150_0 >= SequenceTag) && (LA150_0 <= SetTag)) || ((LA150_0 >= Tag0) && (LA150_0 <= TrueTag)) || ((LA150_0 >= UTCTag) && (LA150_0 <= UniverStringTag)) || ((LA150_0 >= VideoStringTag) && (LA150_0 <= VisibleStringTag))))
                    {
                        alt150=1;
                    }
                    else if ( (LA150_0 == EOF))
                    {
                        alt150=2;
                    }
                    else
                    {

                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 150;
                        EXCEPTION->state        = 0;


                        goto rulealgorithm_idEx;

                    }
                }
                switch (alt150)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1344:58: {...}? => any
            	    {
            	        if ( !((any_pointer != NULL)) )
            	        {
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	                EXCEPTION->message      = (void *)"any_pointer != NULL";
            	                EXCEPTION->ruleName	 = (void *)"algorithm_id";


            	        }

            	        FOLLOWPUSH(FOLLOW_any_in_algorithm_id2179);
            	        any647=any(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealgorithm_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, any647.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:1344:88: 
            	    {
            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulealgorithm_idEx; /* Prevent compiler warnings */
    rulealgorithm_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end algorithm_id */

/**
 * $ANTLR start rsa_md2_alg_id
 * Grammar/RFC5280.g:1346:1: rsa_md2_alg_id : sequenceTag md2rsaoid ( null )? ;
 */
static RFC5280Parser_rsa_md2_alg_id_return
rsa_md2_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_rsa_md2_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag648;
    #undef	RETURN_TYPE_sequenceTag648
    #define	RETURN_TYPE_sequenceTag648 RFC5280Parser_sequenceTag_return

    RFC5280Parser_md2rsaoid_return md2rsaoid649;
    #undef	RETURN_TYPE_md2rsaoid649
    #define	RETURN_TYPE_md2rsaoid649 RFC5280Parser_md2rsaoid_return

    RFC5280Parser_null_return null650;
    #undef	RETURN_TYPE_null650
    #define	RETURN_TYPE_null650 RFC5280Parser_null_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag648.tree = NULL;

    md2rsaoid649.tree = NULL;

    null650.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1349:2: ( sequenceTag md2rsaoid ( null )? )
        // Grammar/RFC5280.g:1349:4: sequenceTag md2rsaoid ( null )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsa_md2_alg_id2200);
            sequenceTag648=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_md2_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag648.tree);

            FOLLOWPUSH(FOLLOW_md2rsaoid_in_rsa_md2_alg_id2202);
            md2rsaoid649=md2rsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_md2_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, md2rsaoid649.tree);

            // Grammar/RFC5280.g:1352:25: ( null )?
            {
                int alt151=2;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt151=1;
                    	}
                        break;
                }

                switch (alt151)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1352:25: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_rsa_md2_alg_id2204);
            	        null650=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulersa_md2_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null650.tree);

            	    }
            	    break;

                }
            }

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(md2rsaoid649.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersa_md2_alg_idEx; /* Prevent compiler warnings */
    rulersa_md2_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsa_md2_alg_id */

/**
 * $ANTLR start rsa_md5_alg_id
 * Grammar/RFC5280.g:1357:1: rsa_md5_alg_id : sequenceTag md5rsaoid ( null )? ;
 */
static RFC5280Parser_rsa_md5_alg_id_return
rsa_md5_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_rsa_md5_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag651;
    #undef	RETURN_TYPE_sequenceTag651
    #define	RETURN_TYPE_sequenceTag651 RFC5280Parser_sequenceTag_return

    RFC5280Parser_md5rsaoid_return md5rsaoid652;
    #undef	RETURN_TYPE_md5rsaoid652
    #define	RETURN_TYPE_md5rsaoid652 RFC5280Parser_md5rsaoid_return

    RFC5280Parser_null_return null653;
    #undef	RETURN_TYPE_null653
    #define	RETURN_TYPE_null653 RFC5280Parser_null_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag651.tree = NULL;

    md5rsaoid652.tree = NULL;

    null653.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1360:2: ( sequenceTag md5rsaoid ( null )? )
        // Grammar/RFC5280.g:1360:3: sequenceTag md5rsaoid ( null )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsa_md5_alg_id2224);
            sequenceTag651=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_md5_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag651.tree);

            FOLLOWPUSH(FOLLOW_md5rsaoid_in_rsa_md5_alg_id2226);
            md5rsaoid652=md5rsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_md5_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, md5rsaoid652.tree);

            // Grammar/RFC5280.g:1363:25: ( null )?
            {
                int alt152=2;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt152=1;
                    	}
                        break;
                }

                switch (alt152)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1363:25: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_rsa_md5_alg_id2228);
            	        null653=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulersa_md5_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null653.tree);

            	    }
            	    break;

                }
            }

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(md5rsaoid652.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersa_md5_alg_idEx; /* Prevent compiler warnings */
    rulersa_md5_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsa_md5_alg_id */

/**
 * $ANTLR start rsa_sha1_alg_id
 * Grammar/RFC5280.g:1368:1: rsa_sha1_alg_id : sequenceTag sha1rsaoid ( null )? ;
 */
static RFC5280Parser_rsa_sha1_alg_id_return
rsa_sha1_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_rsa_sha1_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag654;
    #undef	RETURN_TYPE_sequenceTag654
    #define	RETURN_TYPE_sequenceTag654 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha1rsaoid_return sha1rsaoid655;
    #undef	RETURN_TYPE_sha1rsaoid655
    #define	RETURN_TYPE_sha1rsaoid655 RFC5280Parser_sha1rsaoid_return

    RFC5280Parser_null_return null656;
    #undef	RETURN_TYPE_null656
    #define	RETURN_TYPE_null656 RFC5280Parser_null_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag654.tree = NULL;

    sha1rsaoid655.tree = NULL;

    null656.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1371:2: ( sequenceTag sha1rsaoid ( null )? )
        // Grammar/RFC5280.g:1371:3: sequenceTag sha1rsaoid ( null )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsa_sha1_alg_id2247);
            sequenceTag654=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha1_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag654.tree);

            FOLLOWPUSH(FOLLOW_sha1rsaoid_in_rsa_sha1_alg_id2249);
            sha1rsaoid655=sha1rsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha1_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha1rsaoid655.tree);

            // Grammar/RFC5280.g:1374:26: ( null )?
            {
                int alt153=2;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt153=1;
                    	}
                        break;
                }

                switch (alt153)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1374:26: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_rsa_sha1_alg_id2251);
            	        null656=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulersa_sha1_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null656.tree);

            	    }
            	    break;

                }
            }

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha1rsaoid655.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersa_sha1_alg_idEx; /* Prevent compiler warnings */
    rulersa_sha1_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsa_sha1_alg_id */

/**
 * $ANTLR start rsa_sha224_alg_id
 * Grammar/RFC5280.g:1380:1: rsa_sha224_alg_id : sequenceTag sha224rsaoid ( null )? ;
 */
static RFC5280Parser_rsa_sha224_alg_id_return
rsa_sha224_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_rsa_sha224_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag657;
    #undef	RETURN_TYPE_sequenceTag657
    #define	RETURN_TYPE_sequenceTag657 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha224rsaoid_return sha224rsaoid658;
    #undef	RETURN_TYPE_sha224rsaoid658
    #define	RETURN_TYPE_sha224rsaoid658 RFC5280Parser_sha224rsaoid_return

    RFC5280Parser_null_return null659;
    #undef	RETURN_TYPE_null659
    #define	RETURN_TYPE_null659 RFC5280Parser_null_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag657.tree = NULL;

    sha224rsaoid658.tree = NULL;

    null659.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1383:2: ( sequenceTag sha224rsaoid ( null )? )
        // Grammar/RFC5280.g:1383:3: sequenceTag sha224rsaoid ( null )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsa_sha224_alg_id2272);
            sequenceTag657=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha224_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag657.tree);

            FOLLOWPUSH(FOLLOW_sha224rsaoid_in_rsa_sha224_alg_id2274);
            sha224rsaoid658=sha224rsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha224_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha224rsaoid658.tree);

            // Grammar/RFC5280.g:1386:28: ( null )?
            {
                int alt154=2;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt154=1;
                    	}
                        break;
                }

                switch (alt154)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1386:28: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_rsa_sha224_alg_id2276);
            	        null659=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulersa_sha224_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null659.tree);

            	    }
            	    break;

                }
            }

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha224rsaoid658.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersa_sha224_alg_idEx; /* Prevent compiler warnings */
    rulersa_sha224_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsa_sha224_alg_id */

/**
 * $ANTLR start rsa_sha256_alg_id
 * Grammar/RFC5280.g:1392:1: rsa_sha256_alg_id : sequenceTag sha256rsaoid ( null )? ;
 */
static RFC5280Parser_rsa_sha256_alg_id_return
rsa_sha256_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_rsa_sha256_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag660;
    #undef	RETURN_TYPE_sequenceTag660
    #define	RETURN_TYPE_sequenceTag660 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha256rsaoid_return sha256rsaoid661;
    #undef	RETURN_TYPE_sha256rsaoid661
    #define	RETURN_TYPE_sha256rsaoid661 RFC5280Parser_sha256rsaoid_return

    RFC5280Parser_null_return null662;
    #undef	RETURN_TYPE_null662
    #define	RETURN_TYPE_null662 RFC5280Parser_null_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag660.tree = NULL;

    sha256rsaoid661.tree = NULL;

    null662.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1395:2: ( sequenceTag sha256rsaoid ( null )? )
        // Grammar/RFC5280.g:1395:3: sequenceTag sha256rsaoid ( null )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsa_sha256_alg_id2296);
            sequenceTag660=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha256_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag660.tree);

            FOLLOWPUSH(FOLLOW_sha256rsaoid_in_rsa_sha256_alg_id2298);
            sha256rsaoid661=sha256rsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha256_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha256rsaoid661.tree);

            // Grammar/RFC5280.g:1398:28: ( null )?
            {
                int alt155=2;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt155=1;
                    	}
                        break;
                }

                switch (alt155)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1398:28: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_rsa_sha256_alg_id2300);
            	        null662=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulersa_sha256_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null662.tree);

            	    }
            	    break;

                }
            }

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha256rsaoid661.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersa_sha256_alg_idEx; /* Prevent compiler warnings */
    rulersa_sha256_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsa_sha256_alg_id */

/**
 * $ANTLR start rsa_sha384_alg_id
 * Grammar/RFC5280.g:1403:1: rsa_sha384_alg_id : sequenceTag sha384rsaoid ( null )? ;
 */
static RFC5280Parser_rsa_sha384_alg_id_return
rsa_sha384_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_rsa_sha384_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag663;
    #undef	RETURN_TYPE_sequenceTag663
    #define	RETURN_TYPE_sequenceTag663 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha384rsaoid_return sha384rsaoid664;
    #undef	RETURN_TYPE_sha384rsaoid664
    #define	RETURN_TYPE_sha384rsaoid664 RFC5280Parser_sha384rsaoid_return

    RFC5280Parser_null_return null665;
    #undef	RETURN_TYPE_null665
    #define	RETURN_TYPE_null665 RFC5280Parser_null_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag663.tree = NULL;

    sha384rsaoid664.tree = NULL;

    null665.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1406:2: ( sequenceTag sha384rsaoid ( null )? )
        // Grammar/RFC5280.g:1406:3: sequenceTag sha384rsaoid ( null )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsa_sha384_alg_id2319);
            sequenceTag663=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha384_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag663.tree);

            FOLLOWPUSH(FOLLOW_sha384rsaoid_in_rsa_sha384_alg_id2321);
            sha384rsaoid664=sha384rsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha384_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha384rsaoid664.tree);

            // Grammar/RFC5280.g:1409:28: ( null )?
            {
                int alt156=2;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt156=1;
                    	}
                        break;
                }

                switch (alt156)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1409:28: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_rsa_sha384_alg_id2323);
            	        null665=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulersa_sha384_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null665.tree);

            	    }
            	    break;

                }
            }

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha384rsaoid664.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersa_sha384_alg_idEx; /* Prevent compiler warnings */
    rulersa_sha384_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsa_sha384_alg_id */

/**
 * $ANTLR start rsa_sha512_alg_id
 * Grammar/RFC5280.g:1414:1: rsa_sha512_alg_id : sequenceTag sha512rsaoid ( null )? ;
 */
static RFC5280Parser_rsa_sha512_alg_id_return
rsa_sha512_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_rsa_sha512_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag666;
    #undef	RETURN_TYPE_sequenceTag666
    #define	RETURN_TYPE_sequenceTag666 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha512rsaoid_return sha512rsaoid667;
    #undef	RETURN_TYPE_sha512rsaoid667
    #define	RETURN_TYPE_sha512rsaoid667 RFC5280Parser_sha512rsaoid_return

    RFC5280Parser_null_return null668;
    #undef	RETURN_TYPE_null668
    #define	RETURN_TYPE_null668 RFC5280Parser_null_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag666.tree = NULL;

    sha512rsaoid667.tree = NULL;

    null668.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1417:2: ( sequenceTag sha512rsaoid ( null )? )
        // Grammar/RFC5280.g:1417:3: sequenceTag sha512rsaoid ( null )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsa_sha512_alg_id2342);
            sequenceTag666=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha512_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag666.tree);

            FOLLOWPUSH(FOLLOW_sha512rsaoid_in_rsa_sha512_alg_id2344);
            sha512rsaoid667=sha512rsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_sha512_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha512rsaoid667.tree);

            // Grammar/RFC5280.g:1420:28: ( null )?
            {
                int alt157=2;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt157=1;
                    	}
                        break;
                }

                switch (alt157)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1420:28: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_rsa_sha512_alg_id2346);
            	        null668=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulersa_sha512_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null668.tree);

            	    }
            	    break;

                }
            }

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha512rsaoid667.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersa_sha512_alg_idEx; /* Prevent compiler warnings */
    rulersa_sha512_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsa_sha512_alg_id */

/**
 * $ANTLR start dsa_sha_alg_id
 * Grammar/RFC5280.g:1425:1: dsa_sha_alg_id : sequenceTag sha1dsaoid ;
 */
static RFC5280Parser_dsa_sha_alg_id_return
dsa_sha_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_dsa_sha_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag669;
    #undef	RETURN_TYPE_sequenceTag669
    #define	RETURN_TYPE_sequenceTag669 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha1dsaoid_return sha1dsaoid670;
    #undef	RETURN_TYPE_sha1dsaoid670
    #define	RETURN_TYPE_sha1dsaoid670 RFC5280Parser_sha1dsaoid_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag669.tree = NULL;

    sha1dsaoid670.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1428:2: ( sequenceTag sha1dsaoid )
        // Grammar/RFC5280.g:1428:3: sequenceTag sha1dsaoid
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_dsa_sha_alg_id2365);
            sequenceTag669=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_sha_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag669.tree);

            FOLLOWPUSH(FOLLOW_sha1dsaoid_in_dsa_sha_alg_id2367);
            sha1dsaoid670=sha1dsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_sha_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha1dsaoid670.tree);

            {

                		if(cert->signature_algorithm == NULL)
                			new_alg_id(sha1dsaoid670.obj
                );	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledsa_sha_alg_idEx; /* Prevent compiler warnings */
    ruledsa_sha_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dsa_sha_alg_id */

/**
 * $ANTLR start dsa_sha224_alg_id
 * Grammar/RFC5280.g:1437:1: dsa_sha224_alg_id : sequenceTag sha224dsaoid ( sequenceTag i1= integer i2= integer i3= integer )? ;
 */
static RFC5280Parser_dsa_sha224_alg_id_return
dsa_sha224_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_dsa_sha224_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return i1;
    #undef	RETURN_TYPE_i1
    #define	RETURN_TYPE_i1 RFC5280Parser_integer_return

    RFC5280Parser_integer_return i2;
    #undef	RETURN_TYPE_i2
    #define	RETURN_TYPE_i2 RFC5280Parser_integer_return

    RFC5280Parser_integer_return i3;
    #undef	RETURN_TYPE_i3
    #define	RETURN_TYPE_i3 RFC5280Parser_integer_return

    RFC5280Parser_sequenceTag_return sequenceTag671;
    #undef	RETURN_TYPE_sequenceTag671
    #define	RETURN_TYPE_sequenceTag671 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha224dsaoid_return sha224dsaoid672;
    #undef	RETURN_TYPE_sha224dsaoid672
    #define	RETURN_TYPE_sha224dsaoid672 RFC5280Parser_sha224dsaoid_return

    RFC5280Parser_sequenceTag_return sequenceTag673;
    #undef	RETURN_TYPE_sequenceTag673
    #define	RETURN_TYPE_sequenceTag673 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    i1.tree = NULL;

    i2.tree = NULL;

    i3.tree = NULL;

    sequenceTag671.tree = NULL;

    sha224dsaoid672.tree = NULL;

    sequenceTag673.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1440:2: ( sequenceTag sha224dsaoid ( sequenceTag i1= integer i2= integer i3= integer )? )
        // Grammar/RFC5280.g:1440:3: sequenceTag sha224dsaoid ( sequenceTag i1= integer i2= integer i3= integer )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_dsa_sha224_alg_id2387);
            sequenceTag671=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_sha224_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag671.tree);

            FOLLOWPUSH(FOLLOW_sha224dsaoid_in_dsa_sha224_alg_id2389);
            sha224dsaoid672=sha224dsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_sha224_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha224dsaoid672.tree);

            {

                		if(cert->signature_algorithm == NULL)
                			new_alg_id(sha224dsaoid672.obj
                );	
                	
            }


            // Grammar/RFC5280.g:1446:3: ( sequenceTag i1= integer i2= integer i3= integer )?
            {
                int alt158=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case Int0:
                    		    case Int1:
                    		    case Int2:
                    		    case IntTag:
                    		    	{
                    		    		alt158=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt158)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1446:4: sequenceTag i1= integer i2= integer i3= integer
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_dsa_sha224_alg_id2393);
            	        sequenceTag673=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_sha224_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag673.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_dsa_sha224_alg_id2397);
            	        i1=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_sha224_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i1.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_dsa_sha224_alg_id2401);
            	        i2=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_sha224_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i2.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_dsa_sha224_alg_id2405);
            	        i3=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_sha224_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i3.tree);

            	        {
            	            if(cert->signature_algorithm->params == NULL)
            	            	{
            	            		cert->signature_algorithm->params = malloc(sizeof(alg_id_params));
            	            		cert->signature_algorithm->params->dsa.p=i1.text
            	            ;
            	            		cert->signature_algorithm->params->dsa.q=i2.text
            	            ;
            	            		cert->signature_algorithm->params->dsa.g=i3.text
            	            ;
            	            	}
            	            	else
            	            	{
            	            		if(!cmp_asn1_string(cert->signature_algorithm->params->dsa.p,i1.text
            	            ) || !cmp_asn1_string(cert->signature_algorithm->params->dsa.q,i2.text
            	            ) || !cmp_asn1_string(cert->signature_algorithm->params->dsa.g,i3.text
            	            ))
            	            		{
            	            			printf("Error! Signature parameters doesn't match \n");
            	            			exit(DSA_SIGNATURE_PARAMS_MATCHING_ERROR);		
            	            		}
            	            	}
            	            	
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledsa_sha224_alg_idEx; /* Prevent compiler warnings */
    ruledsa_sha224_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dsa_sha224_alg_id */

/**
 * $ANTLR start dsa_sha256_alg_id
 * Grammar/RFC5280.g:1463:1: dsa_sha256_alg_id : sequenceTag sha256dsaoid ( sequenceTag i1= integer i2= integer i3= integer )? ;
 */
static RFC5280Parser_dsa_sha256_alg_id_return
dsa_sha256_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_dsa_sha256_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return i1;
    #undef	RETURN_TYPE_i1
    #define	RETURN_TYPE_i1 RFC5280Parser_integer_return

    RFC5280Parser_integer_return i2;
    #undef	RETURN_TYPE_i2
    #define	RETURN_TYPE_i2 RFC5280Parser_integer_return

    RFC5280Parser_integer_return i3;
    #undef	RETURN_TYPE_i3
    #define	RETURN_TYPE_i3 RFC5280Parser_integer_return

    RFC5280Parser_sequenceTag_return sequenceTag674;
    #undef	RETURN_TYPE_sequenceTag674
    #define	RETURN_TYPE_sequenceTag674 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha256dsaoid_return sha256dsaoid675;
    #undef	RETURN_TYPE_sha256dsaoid675
    #define	RETURN_TYPE_sha256dsaoid675 RFC5280Parser_sha256dsaoid_return

    RFC5280Parser_sequenceTag_return sequenceTag676;
    #undef	RETURN_TYPE_sequenceTag676
    #define	RETURN_TYPE_sequenceTag676 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    i1.tree = NULL;

    i2.tree = NULL;

    i3.tree = NULL;

    sequenceTag674.tree = NULL;

    sha256dsaoid675.tree = NULL;

    sequenceTag676.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1466:2: ( sequenceTag sha256dsaoid ( sequenceTag i1= integer i2= integer i3= integer )? )
        // Grammar/RFC5280.g:1466:3: sequenceTag sha256dsaoid ( sequenceTag i1= integer i2= integer i3= integer )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_dsa_sha256_alg_id2424);
            sequenceTag674=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_sha256_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag674.tree);

            FOLLOWPUSH(FOLLOW_sha256dsaoid_in_dsa_sha256_alg_id2426);
            sha256dsaoid675=sha256dsaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_sha256_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha256dsaoid675.tree);

            {

                		if(cert->signature_algorithm == NULL)
                			new_alg_id(sha256dsaoid675.obj
                );
                	
            }


            // Grammar/RFC5280.g:1472:3: ( sequenceTag i1= integer i2= integer i3= integer )?
            {
                int alt159=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case Int0:
                    		    case Int1:
                    		    case Int2:
                    		    case IntTag:
                    		    	{
                    		    		alt159=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt159)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1472:4: sequenceTag i1= integer i2= integer i3= integer
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_dsa_sha256_alg_id2430);
            	        sequenceTag676=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_sha256_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag676.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_dsa_sha256_alg_id2434);
            	        i1=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_sha256_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i1.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_dsa_sha256_alg_id2438);
            	        i2=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_sha256_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i2.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_dsa_sha256_alg_id2442);
            	        i3=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_sha256_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i3.tree);

            	        {
            	            if(cert->signature_algorithm->params == NULL)
            	            	{
            	            		cert->signature_algorithm->params = malloc(sizeof(alg_id_params));
            	            		cert->signature_algorithm->params->dsa.p=i1.text
            	            ;
            	            		cert->signature_algorithm->params->dsa.q=i2.text
            	            ;
            	            		cert->signature_algorithm->params->dsa.g=i3.text
            	            ;
            	            	}
            	            	else
            	            	{
            	            		if(!cmp_asn1_string(cert->signature_algorithm->params->dsa.p,i1.text
            	            ) || !cmp_asn1_string(cert->signature_algorithm->params->dsa.q,i2.text
            	            ) || !cmp_asn1_string(cert->signature_algorithm->params->dsa.g,i3.text
            	            ))
            	            		{
            	            			printf("Error! Signature parameters doesn't match \n");
            	            			exit(DSA_SIGNATURE_PARAMS_MATCHING_ERROR);		
            	            		}
            	            	}
            	            	
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledsa_sha256_alg_idEx; /* Prevent compiler warnings */
    ruledsa_sha256_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dsa_sha256_alg_id */

/**
 * $ANTLR start ec_sha_alg_id
 * Grammar/RFC5280.g:1489:1: ec_sha_alg_id : sequenceTag sha1ecoid ;
 */
static RFC5280Parser_ec_sha_alg_id_return
ec_sha_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_ec_sha_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag677;
    #undef	RETURN_TYPE_sequenceTag677
    #define	RETURN_TYPE_sequenceTag677 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha1ecoid_return sha1ecoid678;
    #undef	RETURN_TYPE_sha1ecoid678
    #define	RETURN_TYPE_sha1ecoid678 RFC5280Parser_sha1ecoid_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag677.tree = NULL;

    sha1ecoid678.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1492:2: ( sequenceTag sha1ecoid )
        // Grammar/RFC5280.g:1492:3: sequenceTag sha1ecoid
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_ec_sha_alg_id2462);
            sequenceTag677=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag677.tree);

            FOLLOWPUSH(FOLLOW_sha1ecoid_in_ec_sha_alg_id2464);
            sha1ecoid678=sha1ecoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha1ecoid678.tree);

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha1ecoid678.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleec_sha_alg_idEx; /* Prevent compiler warnings */
    ruleec_sha_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ec_sha_alg_id */

/**
 * $ANTLR start ec_sha224_alg_id
 * Grammar/RFC5280.g:1499:1: ec_sha224_alg_id : sequenceTag sha224ecoid ;
 */
static RFC5280Parser_ec_sha224_alg_id_return
ec_sha224_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_ec_sha224_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag679;
    #undef	RETURN_TYPE_sequenceTag679
    #define	RETURN_TYPE_sequenceTag679 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha224ecoid_return sha224ecoid680;
    #undef	RETURN_TYPE_sha224ecoid680
    #define	RETURN_TYPE_sha224ecoid680 RFC5280Parser_sha224ecoid_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag679.tree = NULL;

    sha224ecoid680.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1502:2: ( sequenceTag sha224ecoid )
        // Grammar/RFC5280.g:1502:3: sequenceTag sha224ecoid
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_ec_sha224_alg_id2480);
            sequenceTag679=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha224_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag679.tree);

            FOLLOWPUSH(FOLLOW_sha224ecoid_in_ec_sha224_alg_id2482);
            sha224ecoid680=sha224ecoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha224_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha224ecoid680.tree);

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha224ecoid680.obj
                );
                			
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleec_sha224_alg_idEx; /* Prevent compiler warnings */
    ruleec_sha224_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ec_sha224_alg_id */

/**
 * $ANTLR start ec_sha256_alg_id
 * Grammar/RFC5280.g:1509:1: ec_sha256_alg_id : sequenceTag sha256ecoid ;
 */
static RFC5280Parser_ec_sha256_alg_id_return
ec_sha256_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_ec_sha256_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag681;
    #undef	RETURN_TYPE_sequenceTag681
    #define	RETURN_TYPE_sequenceTag681 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha256ecoid_return sha256ecoid682;
    #undef	RETURN_TYPE_sha256ecoid682
    #define	RETURN_TYPE_sha256ecoid682 RFC5280Parser_sha256ecoid_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag681.tree = NULL;

    sha256ecoid682.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1512:2: ( sequenceTag sha256ecoid )
        // Grammar/RFC5280.g:1512:3: sequenceTag sha256ecoid
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_ec_sha256_alg_id2499);
            sequenceTag681=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha256_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag681.tree);

            FOLLOWPUSH(FOLLOW_sha256ecoid_in_ec_sha256_alg_id2501);
            sha256ecoid682=sha256ecoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha256_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha256ecoid682.tree);

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha256ecoid682.obj
                );
                			
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleec_sha256_alg_idEx; /* Prevent compiler warnings */
    ruleec_sha256_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ec_sha256_alg_id */

/**
 * $ANTLR start ec_sha384_alg_id
 * Grammar/RFC5280.g:1519:1: ec_sha384_alg_id : sequenceTag sha384ecoid ;
 */
static RFC5280Parser_ec_sha384_alg_id_return
ec_sha384_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_ec_sha384_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag683;
    #undef	RETURN_TYPE_sequenceTag683
    #define	RETURN_TYPE_sequenceTag683 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha384ecoid_return sha384ecoid684;
    #undef	RETURN_TYPE_sha384ecoid684
    #define	RETURN_TYPE_sha384ecoid684 RFC5280Parser_sha384ecoid_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag683.tree = NULL;

    sha384ecoid684.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1522:2: ( sequenceTag sha384ecoid )
        // Grammar/RFC5280.g:1522:3: sequenceTag sha384ecoid
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_ec_sha384_alg_id2519);
            sequenceTag683=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha384_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag683.tree);

            FOLLOWPUSH(FOLLOW_sha384ecoid_in_ec_sha384_alg_id2521);
            sha384ecoid684=sha384ecoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha384_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha384ecoid684.tree);

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha384ecoid684.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleec_sha384_alg_idEx; /* Prevent compiler warnings */
    ruleec_sha384_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ec_sha384_alg_id */

/**
 * $ANTLR start ec_sha512_alg_id
 * Grammar/RFC5280.g:1529:1: ec_sha512_alg_id : sequenceTag sha512ecoid ;
 */
static RFC5280Parser_ec_sha512_alg_id_return
ec_sha512_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_ec_sha512_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag685;
    #undef	RETURN_TYPE_sequenceTag685
    #define	RETURN_TYPE_sequenceTag685 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha512ecoid_return sha512ecoid686;
    #undef	RETURN_TYPE_sha512ecoid686
    #define	RETURN_TYPE_sha512ecoid686 RFC5280Parser_sha512ecoid_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag685.tree = NULL;

    sha512ecoid686.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1532:2: ( sequenceTag sha512ecoid )
        // Grammar/RFC5280.g:1532:3: sequenceTag sha512ecoid
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_ec_sha512_alg_id2539);
            sequenceTag685=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha512_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag685.tree);

            FOLLOWPUSH(FOLLOW_sha512ecoid_in_ec_sha512_alg_id2541);
            sha512ecoid686=sha512ecoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_sha512_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sha512ecoid686.tree);

            {

                	if(cert->signature_algorithm == NULL)
                		new_alg_id(sha512ecoid686.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleec_sha512_alg_idEx; /* Prevent compiler warnings */
    ruleec_sha512_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ec_sha512_alg_id */

/**
 * $ANTLR start rsa_alg_id
 * Grammar/RFC5280.g:1540:1: rsa_alg_id : sequenceTag rsapkoid ( null )? ;
 */
static RFC5280Parser_rsa_alg_id_return
rsa_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_rsa_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag687;
    #undef	RETURN_TYPE_sequenceTag687
    #define	RETURN_TYPE_sequenceTag687 RFC5280Parser_sequenceTag_return

    RFC5280Parser_rsapkoid_return rsapkoid688;
    #undef	RETURN_TYPE_rsapkoid688
    #define	RETURN_TYPE_rsapkoid688 RFC5280Parser_rsapkoid_return

    RFC5280Parser_null_return null689;
    #undef	RETURN_TYPE_null689
    #define	RETURN_TYPE_null689 RFC5280Parser_null_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag687.tree = NULL;

    rsapkoid688.tree = NULL;

    null689.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1543:2: ( sequenceTag rsapkoid ( null )? )
        // Grammar/RFC5280.g:1543:3: sequenceTag rsapkoid ( null )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsa_alg_id2560);
            sequenceTag687=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag687.tree);

            FOLLOWPUSH(FOLLOW_rsapkoid_in_rsa_alg_id2562);
            rsapkoid688=rsapkoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersa_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, rsapkoid688.tree);

            // Grammar/RFC5280.g:1546:24: ( null )?
            {
                int alt160=2;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt160=1;
                    	}
                        break;
                }

                switch (alt160)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1546:24: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_rsa_alg_id2564);
            	        null689=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulersa_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null689.tree);

            	    }
            	    break;

                }
            }

            {

                	new_alg_id_pk(rsapkoid688.obj
                );
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersa_alg_idEx; /* Prevent compiler warnings */
    rulersa_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsa_alg_id */

/**
 * $ANTLR start dsa_alg_id
 * Grammar/RFC5280.g:1550:1: dsa_alg_id : sequenceTag dsapkoid ( sequenceTag i1= integer i2= integer i3= integer )? ;
 */
static RFC5280Parser_dsa_alg_id_return
dsa_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_dsa_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return i1;
    #undef	RETURN_TYPE_i1
    #define	RETURN_TYPE_i1 RFC5280Parser_integer_return

    RFC5280Parser_integer_return i2;
    #undef	RETURN_TYPE_i2
    #define	RETURN_TYPE_i2 RFC5280Parser_integer_return

    RFC5280Parser_integer_return i3;
    #undef	RETURN_TYPE_i3
    #define	RETURN_TYPE_i3 RFC5280Parser_integer_return

    RFC5280Parser_sequenceTag_return sequenceTag690;
    #undef	RETURN_TYPE_sequenceTag690
    #define	RETURN_TYPE_sequenceTag690 RFC5280Parser_sequenceTag_return

    RFC5280Parser_dsapkoid_return dsapkoid691;
    #undef	RETURN_TYPE_dsapkoid691
    #define	RETURN_TYPE_dsapkoid691 RFC5280Parser_dsapkoid_return

    RFC5280Parser_sequenceTag_return sequenceTag692;
    #undef	RETURN_TYPE_sequenceTag692
    #define	RETURN_TYPE_sequenceTag692 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    i1.tree = NULL;

    i2.tree = NULL;

    i3.tree = NULL;

    sequenceTag690.tree = NULL;

    dsapkoid691.tree = NULL;

    sequenceTag692.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1553:2: ( sequenceTag dsapkoid ( sequenceTag i1= integer i2= integer i3= integer )? )
        // Grammar/RFC5280.g:1553:3: sequenceTag dsapkoid ( sequenceTag i1= integer i2= integer i3= integer )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_dsa_alg_id2583);
            sequenceTag690=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag690.tree);

            FOLLOWPUSH(FOLLOW_dsapkoid_in_dsa_alg_id2585);
            dsapkoid691=dsapkoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, dsapkoid691.tree);

            {
                new_alg_id_pk(dsapkoid691.obj
                );
            }


            // Grammar/RFC5280.g:1556:55: ( sequenceTag i1= integer i2= integer i3= integer )?
            {
                int alt161=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		alt161=1;
                    	}
                        break;
                }

                switch (alt161)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1556:56: sequenceTag i1= integer i2= integer i3= integer
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_dsa_alg_id2589);
            	        sequenceTag692=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag692.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_dsa_alg_id2593);
            	        i1=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i1.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_dsa_alg_id2597);
            	        i2=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i2.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_dsa_alg_id2601);
            	        i3=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledsa_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i3.tree);

            	        {

            	            		cert->pkey->alg->params =  malloc(sizeof(alg_id_params));
            	            		cert->pkey->alg->params->dsa.p = i1.text
            	            ;
            	            		cert->pkey->alg->params->dsa.q = i2.text
            	            ;
            	            		cert->pkey->alg->params->dsa.g = i3.text
            	            ;
            	            	
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledsa_alg_idEx; /* Prevent compiler warnings */
    ruledsa_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dsa_alg_id */

/**
 * $ANTLR start dh_alg_id
 * Grammar/RFC5280.g:1563:1: dh_alg_id : sequenceTag dhpkoid sequenceTag p= integer g= integer q= integer (j= integer (| sequenceTag bitstring pgen= integer ) )? ;
 */
static RFC5280Parser_dh_alg_id_return
dh_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_dh_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return p;
    #undef	RETURN_TYPE_p
    #define	RETURN_TYPE_p RFC5280Parser_integer_return

    RFC5280Parser_integer_return g;
    #undef	RETURN_TYPE_g
    #define	RETURN_TYPE_g RFC5280Parser_integer_return

    RFC5280Parser_integer_return q;
    #undef	RETURN_TYPE_q
    #define	RETURN_TYPE_q RFC5280Parser_integer_return

    RFC5280Parser_integer_return j;
    #undef	RETURN_TYPE_j
    #define	RETURN_TYPE_j RFC5280Parser_integer_return

    RFC5280Parser_integer_return pgen;
    #undef	RETURN_TYPE_pgen
    #define	RETURN_TYPE_pgen RFC5280Parser_integer_return

    RFC5280Parser_sequenceTag_return sequenceTag693;
    #undef	RETURN_TYPE_sequenceTag693
    #define	RETURN_TYPE_sequenceTag693 RFC5280Parser_sequenceTag_return

    RFC5280Parser_dhpkoid_return dhpkoid694;
    #undef	RETURN_TYPE_dhpkoid694
    #define	RETURN_TYPE_dhpkoid694 RFC5280Parser_dhpkoid_return

    RFC5280Parser_sequenceTag_return sequenceTag695;
    #undef	RETURN_TYPE_sequenceTag695
    #define	RETURN_TYPE_sequenceTag695 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sequenceTag_return sequenceTag696;
    #undef	RETURN_TYPE_sequenceTag696
    #define	RETURN_TYPE_sequenceTag696 RFC5280Parser_sequenceTag_return

    RFC5280Parser_bitstring_return bitstring697;
    #undef	RETURN_TYPE_bitstring697
    #define	RETURN_TYPE_bitstring697 RFC5280Parser_bitstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    p.tree = NULL;

    g.tree = NULL;

    q.tree = NULL;

    j.tree = NULL;

    pgen.tree = NULL;

    sequenceTag693.tree = NULL;

    dhpkoid694.tree = NULL;

    sequenceTag695.tree = NULL;

    sequenceTag696.tree = NULL;

    bitstring697.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1566:2: ( sequenceTag dhpkoid sequenceTag p= integer g= integer q= integer (j= integer (| sequenceTag bitstring pgen= integer ) )? )
        // Grammar/RFC5280.g:1566:3: sequenceTag dhpkoid sequenceTag p= integer g= integer q= integer (j= integer (| sequenceTag bitstring pgen= integer ) )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_dh_alg_id2621);
            sequenceTag693=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledh_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag693.tree);

            FOLLOWPUSH(FOLLOW_dhpkoid_in_dh_alg_id2623);
            dhpkoid694=dhpkoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledh_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, dhpkoid694.tree);

            {
                new_alg_id_pk(dhpkoid694.obj
                );
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_dh_alg_id2627);
            sequenceTag695=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledh_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag695.tree);

            FOLLOWPUSH(FOLLOW_integer_in_dh_alg_id2631);
            p=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledh_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, p.tree);

            FOLLOWPUSH(FOLLOW_integer_in_dh_alg_id2635);
            g=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledh_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, g.tree);

            FOLLOWPUSH(FOLLOW_integer_in_dh_alg_id2639);
            q=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledh_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, q.tree);

            {

                		cert->pkey->alg->params = malloc(sizeof(alg_id_params));
                		cert->pkey->alg->params->dh.p = p.text
                ;
                		cert->pkey->alg->params->dh.g = g.text
                ;
                		cert->pkey->alg->params->dh.q = q.text
                ;
                		cert->pkey->alg->params->dh.j = NULL;
                		cert->pkey->alg->params->dh.seed = NULL;
                		cert->pkey->alg->params->dh.pgen_counter = NULL;
                	
            }


            // Grammar/RFC5280.g:1580:3: (j= integer (| sequenceTag bitstring pgen= integer ) )?
            {
                int alt163=2;
                switch ( LA(1) )
                {
                    case Int0:
                    case Int1:
                    case Int2:
                    case IntTag:
                    	{
                    		alt163=1;
                    	}
                        break;
                }

                switch (alt163)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1580:4: j= integer (| sequenceTag bitstring pgen= integer )
            	    {
            	        FOLLOWPUSH(FOLLOW_integer_in_dh_alg_id2651);
            	        j=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledh_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, j.tree);

            	        {
            	            cert->pkey->alg->params->dh.j = j.text
            	            ;
            	        }


            	        // Grammar/RFC5280.g:1580:56: (| sequenceTag bitstring pgen= integer )
            	        {
            	            int alt162=2;
            	            switch ( LA(1) )
            	            {
            	            case BitStringKeyCert:
            	            case BitStringTag:
            	            	{
            	            		alt162=1;
            	            	}
            	                break;
            	            case SequenceTag:
            	            	{
            	            		alt162=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 162;
            	                EXCEPTION->state        = 0;


            	                goto ruledh_alg_idEx;

            	            }

            	            switch (alt162)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1580:58: 
            	        	    {
            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:1580:59: sequenceTag bitstring pgen= integer
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_dh_alg_id2657);
            	        	        sequenceTag696=sequenceTag(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledh_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag696.tree);

            	        	        FOLLOWPUSH(FOLLOW_bitstring_in_dh_alg_id2659);
            	        	        bitstring697=bitstring(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledh_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring697.tree);

            	        	        FOLLOWPUSH(FOLLOW_integer_in_dh_alg_id2663);
            	        	        pgen=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledh_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, pgen.tree);

            	        	        {

            	        	            	 cert->pkey->alg->params->dh.seed = bitstring697.text
            	        	            ;
            	        	            	 cert->pkey->alg->params->dh.pgen_counter = pgen.text
            	        	            ;
            	        	            	 
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledh_alg_idEx; /* Prevent compiler warnings */
    ruledh_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dh_alg_id */

/**
 * $ANTLR start kea_alg_id
 * Grammar/RFC5280.g:1585:1: kea_alg_id : sequenceTag keapkoid octetstring ;
 */
static RFC5280Parser_kea_alg_id_return
kea_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_kea_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag698;
    #undef	RETURN_TYPE_sequenceTag698
    #define	RETURN_TYPE_sequenceTag698 RFC5280Parser_sequenceTag_return

    RFC5280Parser_keapkoid_return keapkoid699;
    #undef	RETURN_TYPE_keapkoid699
    #define	RETURN_TYPE_keapkoid699 RFC5280Parser_keapkoid_return

    RFC5280Parser_octetstring_return octetstring700;
    #undef	RETURN_TYPE_octetstring700
    #define	RETURN_TYPE_octetstring700 RFC5280Parser_octetstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag698.tree = NULL;

    keapkoid699.tree = NULL;

    octetstring700.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1588:2: ( sequenceTag keapkoid octetstring )
        // Grammar/RFC5280.g:1588:3: sequenceTag keapkoid octetstring
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_kea_alg_id2685);
            sequenceTag698=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekea_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag698.tree);

            FOLLOWPUSH(FOLLOW_keapkoid_in_kea_alg_id2687);
            keapkoid699=keapkoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekea_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, keapkoid699.tree);

            FOLLOWPUSH(FOLLOW_octetstring_in_kea_alg_id2689);
            octetstring700=octetstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekea_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, octetstring700.tree);

            {

                	new_alg_id_pk(keapkoid699.obj
                );
                	cert->pkey->alg->params = malloc(sizeof(alg_id_params));
                	if(octetstring700.text
                ->length != 10)
                	{
                		printf("Error on kea domain identifier length \n");
                		exit(KEA_DOMAINID_LENGTH_ERROR);
                	}
                	cert->pkey->alg->params->kea.domain_id = octetstring700.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekea_alg_idEx; /* Prevent compiler warnings */
    rulekea_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end kea_alg_id */

/**
 * $ANTLR start ec_alg_id
 * Grammar/RFC5280.g:1602:1: ec_alg_id : sequenceTag ( ecpkoid | ecdhoid | ecmqvoid ) oid ;
 */
static RFC5280Parser_ec_alg_id_return
ec_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_ec_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag701;
    #undef	RETURN_TYPE_sequenceTag701
    #define	RETURN_TYPE_sequenceTag701 RFC5280Parser_sequenceTag_return

    RFC5280Parser_ecpkoid_return ecpkoid702;
    #undef	RETURN_TYPE_ecpkoid702
    #define	RETURN_TYPE_ecpkoid702 RFC5280Parser_ecpkoid_return

    RFC5280Parser_ecdhoid_return ecdhoid703;
    #undef	RETURN_TYPE_ecdhoid703
    #define	RETURN_TYPE_ecdhoid703 RFC5280Parser_ecdhoid_return

    RFC5280Parser_ecmqvoid_return ecmqvoid704;
    #undef	RETURN_TYPE_ecmqvoid704
    #define	RETURN_TYPE_ecmqvoid704 RFC5280Parser_ecmqvoid_return

    RFC5280Parser_oid_return oid705;
    #undef	RETURN_TYPE_oid705
    #define	RETURN_TYPE_oid705 RFC5280Parser_oid_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag701.tree = NULL;

    ecpkoid702.tree = NULL;

    ecdhoid703.tree = NULL;

    ecmqvoid704.tree = NULL;

    oid705.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1605:2: ( sequenceTag ( ecpkoid | ecdhoid | ecmqvoid ) oid )
        // Grammar/RFC5280.g:1605:3: sequenceTag ( ecpkoid | ecdhoid | ecmqvoid ) oid
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_ec_alg_id2707);
            sequenceTag701=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag701.tree);

            // Grammar/RFC5280.g:1608:15: ( ecpkoid | ecdhoid | ecmqvoid )
            {
                int alt164=3;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case ECPKOID:
                			{
                				alt164=1;
                			}
                		    break;
                		case ECDHOID:
                			{
                				alt164=2;
                			}
                		    break;
                		case ECMQVOID:
                			{
                				alt164=3;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 164;
                		    EXCEPTION->state        = 1;


                		    goto ruleec_alg_idEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 164;
                    EXCEPTION->state        = 0;


                    goto ruleec_alg_idEx;

                }

                switch (alt164)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1608:16: ecpkoid
            	    {
            	        FOLLOWPUSH(FOLLOW_ecpkoid_in_ec_alg_id2710);
            	        ecpkoid702=ecpkoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleec_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, ecpkoid702.tree);

            	        {
            	            new_alg_id_pk(ecpkoid702.obj
            	            );cert->mask = 54;cert->mask_ca=48;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:1609:4: ecdhoid
            	    {
            	        FOLLOWPUSH(FOLLOW_ecdhoid_in_ec_alg_id2717);
            	        ecdhoid703=ecdhoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleec_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, ecdhoid703.tree);

            	        {
            	            new_alg_id_pk(ecdhoid703.obj
            	            );cert->mask = 246;cert->mask_ca=246;
            	        }


            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:1610:5: ecmqvoid
            	    {
            	        FOLLOWPUSH(FOLLOW_ecmqvoid_in_ec_alg_id2725);
            	        ecmqvoid704=ecmqvoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleec_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, ecmqvoid704.tree);

            	        {
            	            new_alg_id_pk(ecmqvoid704.obj
            	            );cert->mask = 246;cert->mask_ca=246;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_oid_in_ec_alg_id2730);
            oid705=oid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleec_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, oid705.tree);

            {

                	cert->pkey->alg->params = malloc(sizeof(alg_id_params));
                	cert->pkey->alg->params->ecpk = malloc(sizeof(ecpk_params));
                	cert->pkey->alg->params->ecpk->named_curve = oid705.text
                ->obj;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleec_alg_idEx; /* Prevent compiler warnings */
    ruleec_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ec_alg_id */

/**
 * $ANTLR start ecParams
 * Grammar/RFC5280.g:1616:1: ecParams : sequenceTag int1 field_id a= octetstring b= octetstring ( bitstring )? base= octetstring order= integer (cofactor= integer )? ;
 */
static RFC5280Parser_ecParams_return
ecParams(pRFC5280Parser ctx)
{
    RFC5280Parser_ecParams_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_octetstring_return a;
    #undef	RETURN_TYPE_a
    #define	RETURN_TYPE_a RFC5280Parser_octetstring_return

    RFC5280Parser_octetstring_return b;
    #undef	RETURN_TYPE_b
    #define	RETURN_TYPE_b RFC5280Parser_octetstring_return

    RFC5280Parser_octetstring_return base;
    #undef	RETURN_TYPE_base
    #define	RETURN_TYPE_base RFC5280Parser_octetstring_return

    RFC5280Parser_integer_return order;
    #undef	RETURN_TYPE_order
    #define	RETURN_TYPE_order RFC5280Parser_integer_return

    RFC5280Parser_integer_return cofactor;
    #undef	RETURN_TYPE_cofactor
    #define	RETURN_TYPE_cofactor RFC5280Parser_integer_return

    RFC5280Parser_sequenceTag_return sequenceTag706;
    #undef	RETURN_TYPE_sequenceTag706
    #define	RETURN_TYPE_sequenceTag706 RFC5280Parser_sequenceTag_return

    RFC5280Parser_int1_return int1707;
    #undef	RETURN_TYPE_int1707
    #define	RETURN_TYPE_int1707 RFC5280Parser_int1_return

    RFC5280Parser_field_id_return field_id708;
    #undef	RETURN_TYPE_field_id708
    #define	RETURN_TYPE_field_id708 RFC5280Parser_field_id_return

    RFC5280Parser_bitstring_return bitstring709;
    #undef	RETURN_TYPE_bitstring709
    #define	RETURN_TYPE_bitstring709 RFC5280Parser_bitstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    a.tree = NULL;

    b.tree = NULL;

    base.tree = NULL;

    order.tree = NULL;

    cofactor.tree = NULL;

    sequenceTag706.tree = NULL;

    int1707.tree = NULL;

    field_id708.tree = NULL;

    bitstring709.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1618:10: ( sequenceTag int1 field_id a= octetstring b= octetstring ( bitstring )? base= octetstring order= integer (cofactor= integer )? )
        // Grammar/RFC5280.g:1618:11: sequenceTag int1 field_id a= octetstring b= octetstring ( bitstring )? base= octetstring order= integer (cofactor= integer )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_ecParams2749);
            sequenceTag706=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleecParamsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag706.tree);

            FOLLOWPUSH(FOLLOW_int1_in_ecParams2751);
            int1707=int1(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleecParamsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, int1707.tree);

            {

                	cert->pkey->alg->params = malloc(sizeof(alg_id_params));
                	cert->pkey->alg->params->ecpk = malloc(sizeof(ecpk_params));
                	cert->pkey->alg->params->ecpk->ec = malloc(sizeof(ec_params));
                	
            }


            FOLLOWPUSH(FOLLOW_field_id_in_ecParams2755);
            field_id708=field_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleecParamsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, field_id708.tree);

            FOLLOWPUSH(FOLLOW_octetstring_in_ecParams2759);
            a=octetstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleecParamsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, a.tree);

            FOLLOWPUSH(FOLLOW_octetstring_in_ecParams2763);
            b=octetstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleecParamsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, b.tree);

            // Grammar/RFC5280.g:1625:42: ( bitstring )?
            {
                int alt165=2;
                switch ( LA(1) )
                {
                    case BitStringKeyCert:
                    case BitStringTag:
                    	{
                    		alt165=1;
                    	}
                        break;
                }

                switch (alt165)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1625:43: bitstring
            	    {
            	        FOLLOWPUSH(FOLLOW_bitstring_in_ecParams2766);
            	        bitstring709=bitstring(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleecParamsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring709.tree);

            	        {
            	            cert->pkey->alg->params->ecpk->ec->seed = bitstring709.text
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_octetstring_in_ecParams2774);
            base=octetstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleecParamsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, base.tree);

            FOLLOWPUSH(FOLLOW_integer_in_ecParams2778);
            order=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleecParamsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, order.tree);

            // Grammar/RFC5280.g:1625:147: (cofactor= integer )?
            {
                int alt166=2;
                switch ( LA(1) )
                {
                    case Int0:
                    case Int1:
                    case Int2:
                    case IntTag:
                    	{
                    		alt166=1;
                    	}
                        break;
                }

                switch (alt166)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1625:148: cofactor= integer
            	    {
            	        FOLLOWPUSH(FOLLOW_integer_in_ecParams2783);
            	        cofactor=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleecParamsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, cofactor.tree);

            	        {

            	            	cert->pkey->alg->params->ecpk->ec->cofactor = cofactor.text
            	            ;
            	            	
            	        }


            	    }
            	    break;

                }
            }

            {

                	cert->pkey->alg->params->ecpk->ec->a = a.text
                ;
                	cert->pkey->alg->params->ecpk->ec->b = b.text
                ;
                	cert->pkey->alg->params->ecpk->ec->base = base.text
                ;
                	cert->pkey->alg->params->ecpk->ec->order = order.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleecParamsEx; /* Prevent compiler warnings */
    ruleecParamsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ecParams */

/**
 * $ANTLR start field_id
 * Grammar/RFC5280.g:1635:1: field_id : ( primeoid integer | basis2oid m= integer ( gnoid null | tpoid tri= integer | ppoid sequenceTag k1= integer k2= integer k3= integer | oid any ) | oid any );
 */
static RFC5280Parser_field_id_return
field_id(pRFC5280Parser ctx)
{
    RFC5280Parser_field_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return m;
    #undef	RETURN_TYPE_m
    #define	RETURN_TYPE_m RFC5280Parser_integer_return

    RFC5280Parser_integer_return tri;
    #undef	RETURN_TYPE_tri
    #define	RETURN_TYPE_tri RFC5280Parser_integer_return

    RFC5280Parser_integer_return k1;
    #undef	RETURN_TYPE_k1
    #define	RETURN_TYPE_k1 RFC5280Parser_integer_return

    RFC5280Parser_integer_return k2;
    #undef	RETURN_TYPE_k2
    #define	RETURN_TYPE_k2 RFC5280Parser_integer_return

    RFC5280Parser_integer_return k3;
    #undef	RETURN_TYPE_k3
    #define	RETURN_TYPE_k3 RFC5280Parser_integer_return

    RFC5280Parser_primeoid_return primeoid710;
    #undef	RETURN_TYPE_primeoid710
    #define	RETURN_TYPE_primeoid710 RFC5280Parser_primeoid_return

    RFC5280Parser_integer_return integer711;
    #undef	RETURN_TYPE_integer711
    #define	RETURN_TYPE_integer711 RFC5280Parser_integer_return

    RFC5280Parser_basis2oid_return basis2oid712;
    #undef	RETURN_TYPE_basis2oid712
    #define	RETURN_TYPE_basis2oid712 RFC5280Parser_basis2oid_return

    RFC5280Parser_gnoid_return gnoid713;
    #undef	RETURN_TYPE_gnoid713
    #define	RETURN_TYPE_gnoid713 RFC5280Parser_gnoid_return

    RFC5280Parser_null_return null714;
    #undef	RETURN_TYPE_null714
    #define	RETURN_TYPE_null714 RFC5280Parser_null_return

    RFC5280Parser_tpoid_return tpoid715;
    #undef	RETURN_TYPE_tpoid715
    #define	RETURN_TYPE_tpoid715 RFC5280Parser_tpoid_return

    RFC5280Parser_ppoid_return ppoid716;
    #undef	RETURN_TYPE_ppoid716
    #define	RETURN_TYPE_ppoid716 RFC5280Parser_ppoid_return

    RFC5280Parser_sequenceTag_return sequenceTag717;
    #undef	RETURN_TYPE_sequenceTag717
    #define	RETURN_TYPE_sequenceTag717 RFC5280Parser_sequenceTag_return

    RFC5280Parser_oid_return oid718;
    #undef	RETURN_TYPE_oid718
    #define	RETURN_TYPE_oid718 RFC5280Parser_oid_return

    RFC5280Parser_any_return any719;
    #undef	RETURN_TYPE_any719
    #define	RETURN_TYPE_any719 RFC5280Parser_any_return

    RFC5280Parser_oid_return oid720;
    #undef	RETURN_TYPE_oid720
    #define	RETURN_TYPE_oid720 RFC5280Parser_oid_return

    RFC5280Parser_any_return any721;
    #undef	RETURN_TYPE_any721
    #define	RETURN_TYPE_any721 RFC5280Parser_any_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    m.tree = NULL;

    tri.tree = NULL;

    k1.tree = NULL;

    k2.tree = NULL;

    k3.tree = NULL;

    primeoid710.tree = NULL;

    integer711.tree = NULL;

    basis2oid712.tree = NULL;

    gnoid713.tree = NULL;

    null714.tree = NULL;

    tpoid715.tree = NULL;

    ppoid716.tree = NULL;

    sequenceTag717.tree = NULL;

    oid718.tree = NULL;

    any719.tree = NULL;

    oid720.tree = NULL;

    any721.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:1642:2: ( primeoid integer | basis2oid m= integer ( gnoid null | tpoid tri= integer | ppoid sequenceTag k1= integer k2= integer k3= integer | oid any ) | oid any )

            ANTLR3_UINT32 alt168;

            alt168=3;

            switch ( LA(1) )
            {
            case OIDTag:
            	{
            		switch ( LA(2) )
            		{
            		case PRIMEOID:
            			{
            				alt168=1;
            			}
            		    break;
            		case BASIS2OID:
            			{
            				alt168=2;
            			}
            		    break;
            		case PRINTABLE:
            		case VALUE:
            			{
            				alt168=3;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 168;
            		    EXCEPTION->state        = 1;


            		    goto rulefield_idEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 168;
                EXCEPTION->state        = 0;


                goto rulefield_idEx;

            }

            switch (alt168)
            {
        	case 1:
        	    // Grammar/RFC5280.g:1643:3: primeoid integer
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_primeoid_in_field_id2812);
        	        primeoid710=primeoid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefield_idEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, primeoid710.tree);

        	        FOLLOWPUSH(FOLLOW_integer_in_field_id2814);
        	        integer711=integer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefield_idEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, integer711.tree);

        	        {
        	            cert->pkey->alg->params->ecpk->ec->field = malloc(sizeof(FIELD_ID));
        	            	cert->pkey->alg->params->ecpk->ec->field->field_type = primeoid710.obj
        	            ;
        	            	cert->pkey->alg->params->ecpk->ec->field->field_params = malloc(sizeof(field_params));
        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->p = integer711.text
        	            ;
        	            	
        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:1647:6: basis2oid m= integer ( gnoid null | tpoid tri= integer | ppoid sequenceTag k1= integer k2= integer k3= integer | oid any )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basis2oid_in_field_id2820);
        	        basis2oid712=basis2oid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefield_idEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basis2oid712.tree);

        	        FOLLOWPUSH(FOLLOW_integer_in_field_id2824);
        	        m=integer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefield_idEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, m.tree);

        	        {
        	            cert->pkey->alg->params->ecpk->ec->field = malloc(sizeof(FIELD_ID));
        	            	cert->pkey->alg->params->ecpk->ec->field->field_type = basis2oid712.obj
        	            ;
        	            	cert->pkey->alg->params->ecpk->ec->field->field_params = malloc(sizeof(field_params));
        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two = malloc(sizeof(characteristic_two));
        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->m = m.text
        	            ;
        	            	
        	        }


        	        // Grammar/RFC5280.g:1652:4: ( gnoid null | tpoid tri= integer | ppoid sequenceTag k1= integer k2= integer k3= integer | oid any )
        	        {
        	            int alt167=4;
        	            switch ( LA(1) )
        	            {
        	            case OIDTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case GNBASISOID:
        	            			{
        	            				alt167=1;
        	            			}
        	            		    break;
        	            		case TPBASISOID:
        	            			{
        	            				alt167=2;
        	            			}
        	            		    break;
        	            		case PPBASISOID:
        	            			{
        	            				alt167=3;
        	            			}
        	            		    break;
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt167=4;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 167;
        	            		    EXCEPTION->state        = 1;


        	            		    goto rulefield_idEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 167;
        	                EXCEPTION->state        = 0;


        	                goto rulefield_idEx;

        	            }

        	            switch (alt167)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:1652:5: gnoid null
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_gnoid_in_field_id2829);
        	        	        gnoid713=gnoid(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, gnoid713.tree);

        	        	        FOLLOWPUSH(FOLLOW_null_in_field_id2831);
        	        	        null714=null(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, null714.tree);

        	        	        {
        	        	            cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->basis = gnoid713.obj
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:1652:106: tpoid tri= integer
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tpoid_in_field_id2837);
        	        	        tpoid715=tpoid(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tpoid715.tree);

        	        	        FOLLOWPUSH(FOLLOW_integer_in_field_id2841);
        	        	        tri=integer(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tri.tree);

        	        	        {
        	        	            cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->basis = tpoid715.obj
        	        	            ;
        	        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->char_two_params = malloc(sizeof(char_two_params));
        	        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->char_two_params->trinomial = tri.text
        	        	            ;
        	        	            	
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // Grammar/RFC5280.g:1657:4: ppoid sequenceTag k1= integer k2= integer k3= integer
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_ppoid_in_field_id2850);
        	        	        ppoid716=ppoid(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, ppoid716.tree);

        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_field_id2852);
        	        	        sequenceTag717=sequenceTag(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag717.tree);

        	        	        FOLLOWPUSH(FOLLOW_integer_in_field_id2856);
        	        	        k1=integer(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, k1.tree);

        	        	        FOLLOWPUSH(FOLLOW_integer_in_field_id2860);
        	        	        k2=integer(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, k2.tree);

        	        	        FOLLOWPUSH(FOLLOW_integer_in_field_id2864);
        	        	        k3=integer(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, k3.tree);

        	        	        {
        	        	            cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->basis = ppoid716.obj
        	        	            ;
        	        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->char_two_params = malloc(sizeof(char_two_params));
        	        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->char_two_params->pentanomial = malloc(sizeof(penta_params));
        	        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->char_two_params->pentanomial->k1 = k1.text
        	        	            ;
        	        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->char_two_params->pentanomial->k2 = k2.text
        	        	            ;
        	        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->char_two_params->pentanomial->k3 = k3.text
        	        	            ;
        	        	            	
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // Grammar/RFC5280.g:1663:5: oid any
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_oid_in_field_id2869);
        	        	        oid718=oid(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, oid718.tree);

        	        	        FOLLOWPUSH(FOLLOW_any_in_field_id2871);
        	        	        any719=any(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulefield_idEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, any719.tree);

        	        	        {
        	        	            cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->basis = oid718.text
        	        	            ->obj;
        	        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->char_two_params = malloc(sizeof(char_two_params));
        	        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->char_two->char_two_params->any = any719.text
        	        	            ; 
        	        	            	
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:1666:7: oid any
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_oid_in_field_id2878);
        	        oid720=oid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefield_idEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, oid720.tree);

        	        FOLLOWPUSH(FOLLOW_any_in_field_id2880);
        	        any721=any(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefield_idEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, any721.tree);

        	        {
        	            cert->pkey->alg->params->ecpk->ec->field = malloc(sizeof(FIELD_ID));
        	            	cert->pkey->alg->params->ecpk->ec->field->field_type = oid720.text
        	            ->obj;
        	            	cert->pkey->alg->params->ecpk->ec->field->field_params =  malloc(sizeof(field_params));
        	            	cert->pkey->alg->params->ecpk->ec->field->field_params->any = any721.text
        	            ;
        	            	
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulefield_idEx; /* Prevent compiler warnings */
    rulefield_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end field_id */

/**
 * $ANTLR start pss_alg_id
 * Grammar/RFC5280.g:1672:1: pss_alg_id : sequenceTag rsapssoid ( sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 salt= integer )? ( constructedTag3 trailer= integer )? )? ;
 */
static RFC5280Parser_pss_alg_id_return
pss_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_pss_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return salt;
    #undef	RETURN_TYPE_salt
    #define	RETURN_TYPE_salt RFC5280Parser_integer_return

    RFC5280Parser_integer_return trailer;
    #undef	RETURN_TYPE_trailer
    #define	RETURN_TYPE_trailer RFC5280Parser_integer_return

    RFC5280Parser_sequenceTag_return sequenceTag722;
    #undef	RETURN_TYPE_sequenceTag722
    #define	RETURN_TYPE_sequenceTag722 RFC5280Parser_sequenceTag_return

    RFC5280Parser_rsapssoid_return rsapssoid723;
    #undef	RETURN_TYPE_rsapssoid723
    #define	RETURN_TYPE_rsapssoid723 RFC5280Parser_rsapssoid_return

    RFC5280Parser_sequenceTag_return sequenceTag724;
    #undef	RETURN_TYPE_sequenceTag724
    #define	RETURN_TYPE_sequenceTag724 RFC5280Parser_sequenceTag_return

    RFC5280Parser_constructedTag0_return constructedTag0725;
    #undef	RETURN_TYPE_constructedTag0725
    #define	RETURN_TYPE_constructedTag0725 RFC5280Parser_constructedTag0_return

    RFC5280Parser_hash_alg_return hash_alg726;
    #undef	RETURN_TYPE_hash_alg726
    #define	RETURN_TYPE_hash_alg726 RFC5280Parser_hash_alg_return

    RFC5280Parser_constructedTag1_return constructedTag1727;
    #undef	RETURN_TYPE_constructedTag1727
    #define	RETURN_TYPE_constructedTag1727 RFC5280Parser_constructedTag1_return

    RFC5280Parser_mask_gen_alg_return mask_gen_alg728;
    #undef	RETURN_TYPE_mask_gen_alg728
    #define	RETURN_TYPE_mask_gen_alg728 RFC5280Parser_mask_gen_alg_return

    RFC5280Parser_constructedTag2_return constructedTag2729;
    #undef	RETURN_TYPE_constructedTag2729
    #define	RETURN_TYPE_constructedTag2729 RFC5280Parser_constructedTag2_return

    RFC5280Parser_constructedTag3_return constructedTag3730;
    #undef	RETURN_TYPE_constructedTag3730
    #define	RETURN_TYPE_constructedTag3730 RFC5280Parser_constructedTag3_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    salt.tree = NULL;

    trailer.tree = NULL;

    sequenceTag722.tree = NULL;

    rsapssoid723.tree = NULL;

    sequenceTag724.tree = NULL;

    constructedTag0725.tree = NULL;

    hash_alg726.tree = NULL;

    constructedTag1727.tree = NULL;

    mask_gen_alg728.tree = NULL;

    constructedTag2729.tree = NULL;

    constructedTag3730.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1675:2: ( sequenceTag rsapssoid ( sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 salt= integer )? ( constructedTag3 trailer= integer )? )? )
        // Grammar/RFC5280.g:1675:3: sequenceTag rsapssoid ( sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 salt= integer )? ( constructedTag3 trailer= integer )? )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_pss_alg_id2899);
            sequenceTag722=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepss_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag722.tree);

            FOLLOWPUSH(FOLLOW_rsapssoid_in_pss_alg_id2901);
            rsapssoid723=rsapssoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepss_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, rsapssoid723.tree);

            {

                		new_alg_id_pk(rsapssoid723.obj
                );
                		cert->pkey->alg->params = malloc(sizeof(alg_id_params));
                		cert->pkey->alg->params->pss.hash_func= NULL;
                		cert->pkey->alg->params->pss.mgf1_hash_func=NULL;
                		cert->pkey->alg->params->pss.salt_length=NULL;
                		cert->pkey->alg->params->pss.trailer_field=NULL;
                		
            }


            // Grammar/RFC5280.g:1685:5: ( sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 salt= integer )? ( constructedTag3 trailer= integer )? )?
            {
                int alt173=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		alt173=1;
                    	}
                        break;
                }

                switch (alt173)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1685:6: sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 salt= integer )? ( constructedTag3 trailer= integer )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_pss_alg_id2906);
            	        sequenceTag724=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepss_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag724.tree);

            	        // Grammar/RFC5280.g:1685:18: ( constructedTag0 hash_alg )?
            	        {
            	            int alt169=2;
            	            switch ( LA(1) )
            	            {
            	                case ConstructedTag0:
            	                	{
            	                		alt169=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt169)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1685:19: constructedTag0 hash_alg
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag0_in_pss_alg_id2909);
            	        	        constructedTag0725=constructedTag0(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepss_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag0725.tree);

            	        	        FOLLOWPUSH(FOLLOW_hash_alg_in_pss_alg_id2911);
            	        	        hash_alg726=hash_alg(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepss_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, hash_alg726.tree);

            	        	        {

            	        	            		cert->pkey->alg->params->pss.hash_func = hash_alg726.alg
            	        	             ;
            	        	            		
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:1687:7: ( constructedTag1 mask_gen_alg )?
            	        {
            	            int alt170=2;
            	            switch ( LA(1) )
            	            {
            	                case ConstructedTag1:
            	                	{
            	                		alt170=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt170)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1687:8: constructedTag1 mask_gen_alg
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag1_in_pss_alg_id2918);
            	        	        constructedTag1727=constructedTag1(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepss_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag1727.tree);

            	        	        FOLLOWPUSH(FOLLOW_mask_gen_alg_in_pss_alg_id2920);
            	        	        mask_gen_alg728=mask_gen_alg(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepss_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, mask_gen_alg728.tree);

            	        	        {

            	        	            		cert->pkey->alg->params->pss.mgf1_hash_func = mask_gen_alg728.alg
            	        	             ;
            	        	            		
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:1689:7: ( constructedTag2 salt= integer )?
            	        {
            	            int alt171=2;
            	            switch ( LA(1) )
            	            {
            	                case ConstructedTag2:
            	                	{
            	                		alt171=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt171)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1689:8: constructedTag2 salt= integer
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag2_in_pss_alg_id2927);
            	        	        constructedTag2729=constructedTag2(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepss_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag2729.tree);

            	        	        FOLLOWPUSH(FOLLOW_integer_in_pss_alg_id2931);
            	        	        salt=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepss_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, salt.tree);

            	        	        {

            	        	            		cert->pkey->alg->params->pss.salt_length = salt.text
            	        	            ;
            	        	            		
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:1691:7: ( constructedTag3 trailer= integer )?
            	        {
            	            int alt172=2;
            	            switch ( LA(1) )
            	            {
            	                case ConstructedTag3:
            	                	{
            	                		alt172=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt172)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1691:8: constructedTag3 trailer= integer
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_pss_alg_id2937);
            	        	        constructedTag3730=constructedTag3(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepss_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3730.tree);

            	        	        FOLLOWPUSH(FOLLOW_integer_in_pss_alg_id2941);
            	        	        trailer=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepss_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, trailer.tree);

            	        	        {

            	        	            		cert->pkey->alg->params->pss.trailer_field = trailer.text
            	        	            ;
            	        	            		
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            {

                		if(!cert->pkey->alg->params->pss.hash_func)
                			cert->pkey->alg->params->pss.hash_func = OBJ_nid2obj(NID_sha1);
                		if(!cert->pkey->alg->params->pss.mgf1_hash_func)
                			cert->pkey->alg->params->pss.mgf1_hash_func = OBJ_nid2obj(NID_sha1);
                		if(!cert->pkey->alg->params->pss.salt_length)
                		{
                			if(!default_salt)
                				default_salt = new_asn1_string(2,1,data_salt);
                			cert->pkey->alg->params->pss.salt_length = default_salt;
                		}
                		if(!cert->pkey->alg->params->pss.trailer_field)
                		{
                			if(!default_trailer)
                				default_trailer = new_asn1_string(2,1,data_trailer);
                			cert->pkey->alg->params->pss.salt_length = default_trailer;
                		}
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepss_alg_idEx; /* Prevent compiler warnings */
    rulepss_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end pss_alg_id */

/**
 * $ANTLR start pss_alg_id_params
 * Grammar/RFC5280.g:1713:1: pss_alg_id_params : sequenceTag rsapssoid sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 salt= integer )? ( constructedTag3 trailer= integer )? ;
 */
static RFC5280Parser_pss_alg_id_params_return
pss_alg_id_params(pRFC5280Parser ctx)
{
    RFC5280Parser_pss_alg_id_params_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return salt;
    #undef	RETURN_TYPE_salt
    #define	RETURN_TYPE_salt RFC5280Parser_integer_return

    RFC5280Parser_integer_return trailer;
    #undef	RETURN_TYPE_trailer
    #define	RETURN_TYPE_trailer RFC5280Parser_integer_return

    RFC5280Parser_sequenceTag_return sequenceTag731;
    #undef	RETURN_TYPE_sequenceTag731
    #define	RETURN_TYPE_sequenceTag731 RFC5280Parser_sequenceTag_return

    RFC5280Parser_rsapssoid_return rsapssoid732;
    #undef	RETURN_TYPE_rsapssoid732
    #define	RETURN_TYPE_rsapssoid732 RFC5280Parser_rsapssoid_return

    RFC5280Parser_sequenceTag_return sequenceTag733;
    #undef	RETURN_TYPE_sequenceTag733
    #define	RETURN_TYPE_sequenceTag733 RFC5280Parser_sequenceTag_return

    RFC5280Parser_constructedTag0_return constructedTag0734;
    #undef	RETURN_TYPE_constructedTag0734
    #define	RETURN_TYPE_constructedTag0734 RFC5280Parser_constructedTag0_return

    RFC5280Parser_hash_alg_return hash_alg735;
    #undef	RETURN_TYPE_hash_alg735
    #define	RETURN_TYPE_hash_alg735 RFC5280Parser_hash_alg_return

    RFC5280Parser_constructedTag1_return constructedTag1736;
    #undef	RETURN_TYPE_constructedTag1736
    #define	RETURN_TYPE_constructedTag1736 RFC5280Parser_constructedTag1_return

    RFC5280Parser_mask_gen_alg_return mask_gen_alg737;
    #undef	RETURN_TYPE_mask_gen_alg737
    #define	RETURN_TYPE_mask_gen_alg737 RFC5280Parser_mask_gen_alg_return

    RFC5280Parser_constructedTag2_return constructedTag2738;
    #undef	RETURN_TYPE_constructedTag2738
    #define	RETURN_TYPE_constructedTag2738 RFC5280Parser_constructedTag2_return

    RFC5280Parser_constructedTag3_return constructedTag3739;
    #undef	RETURN_TYPE_constructedTag3739
    #define	RETURN_TYPE_constructedTag3739 RFC5280Parser_constructedTag3_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    int check = 0;
    		if(default_salt == NULL)
    			default_salt = new_asn1_string(2,1,data_salt);
    		if(default_trailer == NULL)
    			default_trailer = new_asn1_string(2,1,data_trailer);
    		#ifdef DEBUG 
    		push_rule(__func__); 
    		#endif	
    			
    salt.tree = NULL;

    trailer.tree = NULL;

    sequenceTag731.tree = NULL;

    rsapssoid732.tree = NULL;

    sequenceTag733.tree = NULL;

    constructedTag0734.tree = NULL;

    hash_alg735.tree = NULL;

    constructedTag1736.tree = NULL;

    mask_gen_alg737.tree = NULL;

    constructedTag2738.tree = NULL;

    constructedTag3739.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1724:2: ( sequenceTag rsapssoid sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 salt= integer )? ( constructedTag3 trailer= integer )? )
        // Grammar/RFC5280.g:1724:4: sequenceTag rsapssoid sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 salt= integer )? ( constructedTag3 trailer= integer )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_sequenceTag_in_pss_alg_id_params2968);
            sequenceTag731=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepss_alg_id_paramsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag731.tree);

            FOLLOWPUSH(FOLLOW_rsapssoid_in_pss_alg_id_params2970);
            rsapssoid732=rsapssoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepss_alg_id_paramsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, rsapssoid732.tree);

            {

                		if(cert->signature_algorithm == NULL)
                		{
                		new_alg_id(rsapssoid732.obj
                );
                		cert->signature_algorithm->params = malloc(sizeof(alg_id_params));
                		cert->signature_algorithm->params->pss.hash_func= NULL;
                		cert->signature_algorithm->params->pss.mgf1_hash_func=NULL;
                		cert->signature_algorithm->params->pss.salt_length=NULL;
                		cert->signature_algorithm->params->pss.trailer_field=NULL;
                		}
                		else
                		{
                			if(OBJ_obj2nid(cert->signature_algorithm->params->pss.hash_func) != NID_sha1)
                				check++;
                			if(OBJ_obj2nid(cert->signature_algorithm->params->pss.mgf1_hash_func) != NID_sha1)
                				check++;
                			if(!cmp_asn1_string (default_salt,cert->signature_algorithm->params->pss.salt_length))
                				check++;
                			if(!cmp_asn1_string (default_trailer,cert->signature_algorithm->params->pss.trailer_field))
                				check++;				
                		}	
                	
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_pss_alg_id_params2973);
            sequenceTag733=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepss_alg_id_paramsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag733.tree);

            // Grammar/RFC5280.g:1745:15: ( constructedTag0 hash_alg )?
            {
                int alt174=2;
                switch ( LA(1) )
                {
                    case ConstructedTag0:
                    	{
                    		alt174=1;
                    	}
                        break;
                }

                switch (alt174)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1745:16: constructedTag0 hash_alg
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag0_in_pss_alg_id_params2976);
            	        constructedTag0734=constructedTag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepss_alg_id_paramsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag0734.tree);

            	        FOLLOWPUSH(FOLLOW_hash_alg_in_pss_alg_id_params2978);
            	        hash_alg735=hash_alg(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepss_alg_id_paramsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, hash_alg735.tree);

            	        {
            	            if(cert->signature_algorithm->params->pss.hash_func == NULL) 
            	            		cert->signature_algorithm->params->pss.hash_func = hash_alg735.alg
            	            ;
            	            	else if(OBJ_obj2nid(cert->signature_algorithm->params->pss.hash_func) != OBJ_obj2nid(hash_alg735.alg
            	            ))
            	            	{
            	            		printf("Error! Signature parameters doesn't match \n");
            	            		exit(SIGNATURE_PARAMS_MATCHING_ERROR);		
            	            	}
            	            	if(OBJ_obj2nid(cert->signature_algorithm->params->pss.hash_func) != NID_sha1)	
            	            		check--;
            	            	
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:1755:6: ( constructedTag1 mask_gen_alg )?
            {
                int alt175=2;
                switch ( LA(1) )
                {
                    case ConstructedTag1:
                    	{
                    		alt175=1;
                    	}
                        break;
                }

                switch (alt175)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1755:7: constructedTag1 mask_gen_alg
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_pss_alg_id_params2987);
            	        constructedTag1736=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepss_alg_id_paramsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag1736.tree);

            	        FOLLOWPUSH(FOLLOW_mask_gen_alg_in_pss_alg_id_params2989);
            	        mask_gen_alg737=mask_gen_alg(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepss_alg_id_paramsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, mask_gen_alg737.tree);

            	        {
            	            if(cert->signature_algorithm->params->pss.mgf1_hash_func == NULL) 
            	            		cert->signature_algorithm->params->pss.mgf1_hash_func = mask_gen_alg737.alg
            	            ;
            	            	else if(OBJ_obj2nid(cert->signature_algorithm->params->pss.mgf1_hash_func) != OBJ_obj2nid(mask_gen_alg737.alg
            	            ))
            	            	{
            	            		printf("Error! Signature parameters doesn't match \n");
            	            		exit(SIGNATURE_PARAMS_MATCHING_ERROR);		
            	            	}
            	            	if(OBJ_obj2nid(cert->signature_algorithm->params->pss.mgf1_hash_func) != NID_sha1)	
            	            		check--;
            	            	
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:1765:6: ( constructedTag2 salt= integer )?
            {
                int alt176=2;
                switch ( LA(1) )
                {
                    case ConstructedTag2:
                    	{
                    		alt176=1;
                    	}
                        break;
                }

                switch (alt176)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1765:7: constructedTag2 salt= integer
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag2_in_pss_alg_id_params2997);
            	        constructedTag2738=constructedTag2(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepss_alg_id_paramsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag2738.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_pss_alg_id_params3001);
            	        salt=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepss_alg_id_paramsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, salt.tree);

            	        {
            	            if(cert->signature_algorithm->params->pss.salt_length == NULL)
            	            		cert->signature_algorithm->params->pss.salt_length = salt.text
            	            ;
            	            	else
            	            	{struct asn1_string_st *new = salt.text
            	            ; 
            	            	if(!cmp_asn1_string(cert->signature_algorithm->params->pss.salt_length,new))
            	            	{
            	            		printf("Error! Signature parameters doesn't match \n");
            	            		exit(SIGNATURE_PARAMS_MATCHING_ERROR);		
            	            	}free(new);
            	            	}
            	            	if(!cmp_asn1_string (default_salt,cert->signature_algorithm->params->pss.salt_length))
            	            		check--;
            	            	
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:1778:6: ( constructedTag3 trailer= integer )?
            {
                int alt177=2;
                switch ( LA(1) )
                {
                    case ConstructedTag3:
                    	{
                    		alt177=1;
                    	}
                        break;
                }

                switch (alt177)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1778:7: constructedTag3 trailer= integer
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag3_in_pss_alg_id_params3009);
            	        constructedTag3739=constructedTag3(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepss_alg_id_paramsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag3739.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_pss_alg_id_params3013);
            	        trailer=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepss_alg_id_paramsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, trailer.tree);

            	        {
            	            if(cert->signature_algorithm->params->pss.trailer_field == NULL)
            	            		cert->signature_algorithm->params->pss.trailer_field= trailer.text
            	            ;
            	            	else
            	            	{struct asn1_string_st *new = trailer.text
            	            ; 
            	            	if(!cmp_asn1_string(cert->signature_algorithm->params->pss.trailer_field,new))
            	            	{
            	            		printf("Error! Signature parameters doesn't match \n");
            	            		exit(SIGNATURE_PARAMS_MATCHING_ERROR);		
            	            	}free(new);
            	            	}
            	            	if(!cmp_asn1_string (default_trailer,cert->signature_algorithm->params->pss.trailer_field))
            	            		check--;
            	            	
            	        }


            	    }
            	    break;

                }
            }

            {

                		if(check > 0)
                		{
                		printf("Error! Signature parameters doesn't match \n");
                		exit(SIGNATURE_PARAMS_MATCHING_ERROR);		
                		}
                		else{
                			if(cert->signature_algorithm->params->pss.hash_func == NULL)
                			{
                				cert->signature_algorithm->params->pss.hash_func = OBJ_nid2obj(NID_sha1);
                			}
                			if(cert->signature_algorithm->params->pss.mgf1_hash_func == NULL)
                				cert->signature_algorithm->params->pss.mgf1_hash_func = OBJ_nid2obj(NID_sha1);
                			if(cert->signature_algorithm->params->pss.salt_length == NULL)
                				cert->signature_algorithm->params->pss.salt_length = default_salt;
                			if(cert->signature_algorithm->params->pss.trailer_field == NULL)
                				cert->signature_algorithm->params->pss.trailer_field = default_trailer;
                		}
                		if(!cmp_asn1_string(cert->signature_algorithm->params->pss.salt_length,default_salt))
                		{
                			free(default_salt);
                			default_salt = NULL;
                		}
                		if(!cmp_asn1_string(cert->signature_algorithm->params->pss.trailer_field,default_trailer))
                		{
                			free(default_trailer);
                			default_trailer = NULL;
                		}
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepss_alg_id_paramsEx; /* Prevent compiler warnings */
    rulepss_alg_id_paramsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end pss_alg_id_params */

/**
 * $ANTLR start oaep_alg_id
 * Grammar/RFC5280.g:1821:1: oaep_alg_id : sequenceTag rsaoaepoid ( sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 sequenceTag pspecoid ( octetstring )? )? )? ;
 */
static RFC5280Parser_oaep_alg_id_return
oaep_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_oaep_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag740;
    #undef	RETURN_TYPE_sequenceTag740
    #define	RETURN_TYPE_sequenceTag740 RFC5280Parser_sequenceTag_return

    RFC5280Parser_rsaoaepoid_return rsaoaepoid741;
    #undef	RETURN_TYPE_rsaoaepoid741
    #define	RETURN_TYPE_rsaoaepoid741 RFC5280Parser_rsaoaepoid_return

    RFC5280Parser_sequenceTag_return sequenceTag742;
    #undef	RETURN_TYPE_sequenceTag742
    #define	RETURN_TYPE_sequenceTag742 RFC5280Parser_sequenceTag_return

    RFC5280Parser_constructedTag0_return constructedTag0743;
    #undef	RETURN_TYPE_constructedTag0743
    #define	RETURN_TYPE_constructedTag0743 RFC5280Parser_constructedTag0_return

    RFC5280Parser_hash_alg_return hash_alg744;
    #undef	RETURN_TYPE_hash_alg744
    #define	RETURN_TYPE_hash_alg744 RFC5280Parser_hash_alg_return

    RFC5280Parser_constructedTag1_return constructedTag1745;
    #undef	RETURN_TYPE_constructedTag1745
    #define	RETURN_TYPE_constructedTag1745 RFC5280Parser_constructedTag1_return

    RFC5280Parser_mask_gen_alg_return mask_gen_alg746;
    #undef	RETURN_TYPE_mask_gen_alg746
    #define	RETURN_TYPE_mask_gen_alg746 RFC5280Parser_mask_gen_alg_return

    RFC5280Parser_constructedTag2_return constructedTag2747;
    #undef	RETURN_TYPE_constructedTag2747
    #define	RETURN_TYPE_constructedTag2747 RFC5280Parser_constructedTag2_return

    RFC5280Parser_sequenceTag_return sequenceTag748;
    #undef	RETURN_TYPE_sequenceTag748
    #define	RETURN_TYPE_sequenceTag748 RFC5280Parser_sequenceTag_return

    RFC5280Parser_pspecoid_return pspecoid749;
    #undef	RETURN_TYPE_pspecoid749
    #define	RETURN_TYPE_pspecoid749 RFC5280Parser_pspecoid_return

    RFC5280Parser_octetstring_return octetstring750;
    #undef	RETURN_TYPE_octetstring750
    #define	RETURN_TYPE_octetstring750 RFC5280Parser_octetstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag740.tree = NULL;

    rsaoaepoid741.tree = NULL;

    sequenceTag742.tree = NULL;

    constructedTag0743.tree = NULL;

    hash_alg744.tree = NULL;

    constructedTag1745.tree = NULL;

    mask_gen_alg746.tree = NULL;

    constructedTag2747.tree = NULL;

    sequenceTag748.tree = NULL;

    pspecoid749.tree = NULL;

    octetstring750.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1824:2: ( sequenceTag rsaoaepoid ( sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 sequenceTag pspecoid ( octetstring )? )? )? )
        // Grammar/RFC5280.g:1824:3: sequenceTag rsaoaepoid ( sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 sequenceTag pspecoid ( octetstring )? )? )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_oaep_alg_id3038);
            sequenceTag740=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoaep_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag740.tree);

            FOLLOWPUSH(FOLLOW_rsaoaepoid_in_oaep_alg_id3040);
            rsaoaepoid741=rsaoaepoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoaep_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, rsaoaepoid741.tree);

            {

                		new_alg_id_pk(rsaoaepoid741.obj
                );
                		cert->pkey->alg->params = malloc(sizeof(alg_id_params));
                		cert->pkey->alg->params->oaep.hash_func= NULL;
                		cert->pkey->alg->params->oaep.mgf1_hash_func=NULL;
                		cert->pkey->alg->params->oaep.P = NULL;
                		
            }


            // Grammar/RFC5280.g:1833:5: ( sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 sequenceTag pspecoid ( octetstring )? )? )?
            {
                int alt182=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		alt182=1;
                    	}
                        break;
                }

                switch (alt182)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1833:7: sequenceTag ( constructedTag0 hash_alg )? ( constructedTag1 mask_gen_alg )? ( constructedTag2 sequenceTag pspecoid ( octetstring )? )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_oaep_alg_id3045);
            	        sequenceTag742=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleoaep_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag742.tree);

            	        // Grammar/RFC5280.g:1833:19: ( constructedTag0 hash_alg )?
            	        {
            	            int alt178=2;
            	            switch ( LA(1) )
            	            {
            	                case ConstructedTag0:
            	                	{
            	                		alt178=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt178)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1833:20: constructedTag0 hash_alg
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag0_in_oaep_alg_id3048);
            	        	        constructedTag0743=constructedTag0(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoaep_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag0743.tree);

            	        	        FOLLOWPUSH(FOLLOW_hash_alg_in_oaep_alg_id3050);
            	        	        hash_alg744=hash_alg(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoaep_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, hash_alg744.tree);

            	        	        {

            	        	            		cert->pkey->alg->params->oaep.hash_func = hash_alg744.alg
            	        	            ;
            	        	            		
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:1835:7: ( constructedTag1 mask_gen_alg )?
            	        {
            	            int alt179=2;
            	            switch ( LA(1) )
            	            {
            	                case ConstructedTag1:
            	                	{
            	                		alt179=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt179)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1835:8: constructedTag1 mask_gen_alg
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag1_in_oaep_alg_id3056);
            	        	        constructedTag1745=constructedTag1(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoaep_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag1745.tree);

            	        	        FOLLOWPUSH(FOLLOW_mask_gen_alg_in_oaep_alg_id3058);
            	        	        mask_gen_alg746=mask_gen_alg(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoaep_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, mask_gen_alg746.tree);

            	        	        {

            	        	            		cert->pkey->alg->params->oaep.mgf1_hash_func = mask_gen_alg746.alg
            	        	            ;
            	        	            		
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:1837:7: ( constructedTag2 sequenceTag pspecoid ( octetstring )? )?
            	        {
            	            int alt181=2;
            	            switch ( LA(1) )
            	            {
            	                case ConstructedTag2:
            	                	{
            	                		alt181=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt181)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1837:8: constructedTag2 sequenceTag pspecoid ( octetstring )?
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag2_in_oaep_alg_id3064);
            	        	        constructedTag2747=constructedTag2(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoaep_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag2747.tree);

            	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_oaep_alg_id3066);
            	        	        sequenceTag748=sequenceTag(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoaep_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag748.tree);

            	        	        FOLLOWPUSH(FOLLOW_pspecoid_in_oaep_alg_id3068);
            	        	        pspecoid749=pspecoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleoaep_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, pspecoid749.tree);

            	        	        // Grammar/RFC5280.g:1837:45: ( octetstring )?
            	        	        {
            	        	            int alt180=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case OctetTag:
            	        	                	{
            	        	                		alt180=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt180)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:1837:46: octetstring
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_octetstring_in_oaep_alg_id3071);
            	        	        	        octetstring750=octetstring(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleoaep_alg_idEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, octetstring750.tree);

            	        	        	        {

            	        	        	            		cert->pkey->alg->params->oaep.P = octetstring750.text
            	        	        	            ;
            	        	        	            		
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            {

                		if(!cert->pkey->alg->params->oaep.hash_func)
                			cert->pkey->alg->params->oaep.hash_func = OBJ_nid2obj(NID_sha1);
                		if(!cert->pkey->alg->params->oaep.mgf1_hash_func)
                			cert->pkey->alg->params->oaep.mgf1_hash_func = OBJ_nid2obj(NID_sha1);
                		if(!cert->pkey->alg->params->oaep.P)
                			cert->pkey->alg->params->oaep.P = new_asn1_string(4,0,NULL);
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoaep_alg_idEx; /* Prevent compiler warnings */
    ruleoaep_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end oaep_alg_id */

/**
 * $ANTLR start hash_alg
 * Grammar/RFC5280.g:1851:1: hash_alg returns [ASN1_OBJECT *alg] : sequenceTag ( sha1oid ( null )? | sha224oid ( null )? | sha256oid ( null )? | sha384oid ( null )? | sha512oid ( null )? ) ;
 */
static RFC5280Parser_hash_alg_return
hash_alg(pRFC5280Parser ctx)
{
    RFC5280Parser_hash_alg_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag751;
    #undef	RETURN_TYPE_sequenceTag751
    #define	RETURN_TYPE_sequenceTag751 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sha1oid_return sha1oid752;
    #undef	RETURN_TYPE_sha1oid752
    #define	RETURN_TYPE_sha1oid752 RFC5280Parser_sha1oid_return

    RFC5280Parser_null_return null753;
    #undef	RETURN_TYPE_null753
    #define	RETURN_TYPE_null753 RFC5280Parser_null_return

    RFC5280Parser_sha224oid_return sha224oid754;
    #undef	RETURN_TYPE_sha224oid754
    #define	RETURN_TYPE_sha224oid754 RFC5280Parser_sha224oid_return

    RFC5280Parser_null_return null755;
    #undef	RETURN_TYPE_null755
    #define	RETURN_TYPE_null755 RFC5280Parser_null_return

    RFC5280Parser_sha256oid_return sha256oid756;
    #undef	RETURN_TYPE_sha256oid756
    #define	RETURN_TYPE_sha256oid756 RFC5280Parser_sha256oid_return

    RFC5280Parser_null_return null757;
    #undef	RETURN_TYPE_null757
    #define	RETURN_TYPE_null757 RFC5280Parser_null_return

    RFC5280Parser_sha384oid_return sha384oid758;
    #undef	RETURN_TYPE_sha384oid758
    #define	RETURN_TYPE_sha384oid758 RFC5280Parser_sha384oid_return

    RFC5280Parser_null_return null759;
    #undef	RETURN_TYPE_null759
    #define	RETURN_TYPE_null759 RFC5280Parser_null_return

    RFC5280Parser_sha512oid_return sha512oid760;
    #undef	RETURN_TYPE_sha512oid760
    #define	RETURN_TYPE_sha512oid760 RFC5280Parser_sha512oid_return

    RFC5280Parser_null_return null761;
    #undef	RETURN_TYPE_null761
    #define	RETURN_TYPE_null761 RFC5280Parser_null_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    sequenceTag751.tree = NULL;

    sha1oid752.tree = NULL;

    null753.tree = NULL;

    sha224oid754.tree = NULL;

    null755.tree = NULL;

    sha256oid756.tree = NULL;

    null757.tree = NULL;

    sha384oid758.tree = NULL;

    null759.tree = NULL;

    sha512oid760.tree = NULL;

    null761.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1858:2: ( sequenceTag ( sha1oid ( null )? | sha224oid ( null )? | sha256oid ( null )? | sha384oid ( null )? | sha512oid ( null )? ) )
        // Grammar/RFC5280.g:1858:4: sequenceTag ( sha1oid ( null )? | sha224oid ( null )? | sha256oid ( null )? | sha384oid ( null )? | sha512oid ( null )? )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_sequenceTag_in_hash_alg3113);
            sequenceTag751=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehash_algEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag751.tree);

            // Grammar/RFC5280.g:1859:3: ( sha1oid ( null )? | sha224oid ( null )? | sha256oid ( null )? | sha384oid ( null )? | sha512oid ( null )? )
            {
                int alt188=5;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case SHA1OID:
                			{
                				alt188=1;
                			}
                		    break;
                		case SHA224OID:
                			{
                				alt188=2;
                			}
                		    break;
                		case SHA256OID:
                			{
                				alt188=3;
                			}
                		    break;
                		case SHA384OID:
                			{
                				alt188=4;
                			}
                		    break;
                		case SHA512OID:
                			{
                				alt188=5;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 188;
                		    EXCEPTION->state        = 1;


                		    goto rulehash_algEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 188;
                    EXCEPTION->state        = 0;


                    goto rulehash_algEx;

                }

                switch (alt188)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1859:4: sha1oid ( null )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sha1oid_in_hash_alg3118);
            	        sha1oid752=sha1oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehash_algEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sha1oid752.tree);

            	        // Grammar/RFC5280.g:1859:12: ( null )?
            	        {
            	            int alt183=2;
            	            switch ( LA(1) )
            	            {
            	                case Null:
            	                	{
            	                		alt183=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt183)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1859:13: null
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_null_in_hash_alg3121);
            	        	        null753=null(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulehash_algEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, null753.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	            retval.alg= 
            	            sha1oid752.obj
            	            ;

            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:1860:4: sha224oid ( null )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sha224oid_in_hash_alg3130);
            	        sha224oid754=sha224oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehash_algEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sha224oid754.tree);

            	        // Grammar/RFC5280.g:1860:14: ( null )?
            	        {
            	            int alt184=2;
            	            switch ( LA(1) )
            	            {
            	                case Null:
            	                	{
            	                		alt184=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt184)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1860:15: null
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_null_in_hash_alg3133);
            	        	        null755=null(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulehash_algEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, null755.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	            retval.alg= 
            	            sha224oid754.obj
            	            ;

            	        }


            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:1861:4: sha256oid ( null )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sha256oid_in_hash_alg3142);
            	        sha256oid756=sha256oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehash_algEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sha256oid756.tree);

            	        // Grammar/RFC5280.g:1861:14: ( null )?
            	        {
            	            int alt185=2;
            	            switch ( LA(1) )
            	            {
            	                case Null:
            	                	{
            	                		alt185=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt185)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1861:15: null
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_null_in_hash_alg3145);
            	        	        null757=null(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulehash_algEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, null757.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	            retval.alg= 
            	            sha256oid756.obj
            	            ;

            	        }


            	    }
            	    break;
            	case 4:
            	    // Grammar/RFC5280.g:1862:4: sha384oid ( null )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sha384oid_in_hash_alg3154);
            	        sha384oid758=sha384oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehash_algEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sha384oid758.tree);

            	        // Grammar/RFC5280.g:1862:14: ( null )?
            	        {
            	            int alt186=2;
            	            switch ( LA(1) )
            	            {
            	                case Null:
            	                	{
            	                		alt186=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt186)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1862:15: null
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_null_in_hash_alg3157);
            	        	        null759=null(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulehash_algEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, null759.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	            retval.alg= 
            	            sha384oid758.obj
            	            ;

            	        }


            	    }
            	    break;
            	case 5:
            	    // Grammar/RFC5280.g:1863:4: sha512oid ( null )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sha512oid_in_hash_alg3166);
            	        sha512oid760=sha512oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehash_algEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sha512oid760.tree);

            	        // Grammar/RFC5280.g:1863:14: ( null )?
            	        {
            	            int alt187=2;
            	            switch ( LA(1) )
            	            {
            	                case Null:
            	                	{
            	                		alt187=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt187)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1863:15: null
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_null_in_hash_alg3169);
            	        	        null761=null(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulehash_algEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, null761.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	            retval.alg= 
            	            sha512oid760.obj
            	            ;

            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulehash_algEx; /* Prevent compiler warnings */
    rulehash_algEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end hash_alg */

/**
 * $ANTLR start mask_gen_alg
 * Grammar/RFC5280.g:1866:1: mask_gen_alg returns [ASN1_OBJECT *alg] : sequenceTag mgf1oid hash_alg ;
 */
static RFC5280Parser_mask_gen_alg_return
mask_gen_alg(pRFC5280Parser ctx)
{
    RFC5280Parser_mask_gen_alg_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag762;
    #undef	RETURN_TYPE_sequenceTag762
    #define	RETURN_TYPE_sequenceTag762 RFC5280Parser_sequenceTag_return

    RFC5280Parser_mgf1oid_return mgf1oid763;
    #undef	RETURN_TYPE_mgf1oid763
    #define	RETURN_TYPE_mgf1oid763 RFC5280Parser_mgf1oid_return

    RFC5280Parser_hash_alg_return hash_alg764;
    #undef	RETURN_TYPE_hash_alg764
    #define	RETURN_TYPE_hash_alg764 RFC5280Parser_hash_alg_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag762.tree = NULL;

    mgf1oid763.tree = NULL;

    hash_alg764.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1870:2: ( sequenceTag mgf1oid hash_alg )
        // Grammar/RFC5280.g:1870:3: sequenceTag mgf1oid hash_alg
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_mask_gen_alg3198);
            sequenceTag762=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemask_gen_algEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag762.tree);

            FOLLOWPUSH(FOLLOW_mgf1oid_in_mask_gen_alg3200);
            mgf1oid763=mgf1oid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemask_gen_algEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, mgf1oid763.tree);

            FOLLOWPUSH(FOLLOW_hash_alg_in_mask_gen_alg3202);
            hash_alg764=hash_alg(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemask_gen_algEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, hash_alg764.tree);

            {
                retval.alg= 
                hash_alg764.alg
                 ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemask_gen_algEx; /* Prevent compiler warnings */
    rulemask_gen_algEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end mask_gen_alg */

/**
 * $ANTLR start gost_94_alg_id
 * Grammar/RFC5280.g:1875:1: gost_94_alg_id : sequenceTag gost94signoid ( null | sequenceTag o1= oid o2= oid (o3= oid )? )? ;
 */
static RFC5280Parser_gost_94_alg_id_return
gost_94_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_gost_94_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_oid_return o1;
    #undef	RETURN_TYPE_o1
    #define	RETURN_TYPE_o1 RFC5280Parser_oid_return

    RFC5280Parser_oid_return o2;
    #undef	RETURN_TYPE_o2
    #define	RETURN_TYPE_o2 RFC5280Parser_oid_return

    RFC5280Parser_oid_return o3;
    #undef	RETURN_TYPE_o3
    #define	RETURN_TYPE_o3 RFC5280Parser_oid_return

    RFC5280Parser_sequenceTag_return sequenceTag765;
    #undef	RETURN_TYPE_sequenceTag765
    #define	RETURN_TYPE_sequenceTag765 RFC5280Parser_sequenceTag_return

    RFC5280Parser_gost94signoid_return gost94signoid766;
    #undef	RETURN_TYPE_gost94signoid766
    #define	RETURN_TYPE_gost94signoid766 RFC5280Parser_gost94signoid_return

    RFC5280Parser_null_return null767;
    #undef	RETURN_TYPE_null767
    #define	RETURN_TYPE_null767 RFC5280Parser_null_return

    RFC5280Parser_sequenceTag_return sequenceTag768;
    #undef	RETURN_TYPE_sequenceTag768
    #define	RETURN_TYPE_sequenceTag768 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    int check=0;
    	if(default_encryption == NULL)
    		default_encryption = OBJ_nid2obj(NID_id_Gost28147_89_CryptoPro_A_ParamSet);
    	if(cert->signature_algorithm!=NULL)
    	{
    		if(cert->signature_algorithm->params->gost.public_key_param_set != NULL)
    			check++;
    		if(OBJ_obj2nid(cert->signature_algorithm->params->gost.encryption_param_set) != OBJ_obj2nid(default_encryption))
    			check++;
    	}
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    	
    o1.tree = NULL;

    o2.tree = NULL;

    o3.tree = NULL;

    sequenceTag765.tree = NULL;

    gost94signoid766.tree = NULL;

    null767.tree = NULL;

    sequenceTag768.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1892:2: ( sequenceTag gost94signoid ( null | sequenceTag o1= oid o2= oid (o3= oid )? )? )
        // Grammar/RFC5280.g:1892:4: sequenceTag gost94signoid ( null | sequenceTag o1= oid o2= oid (o3= oid )? )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_sequenceTag_in_gost_94_alg_id3223);
            sequenceTag765=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegost_94_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag765.tree);

            FOLLOWPUSH(FOLLOW_gost94signoid_in_gost_94_alg_id3225);
            gost94signoid766=gost94signoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegost_94_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, gost94signoid766.tree);

            // Grammar/RFC5280.g:1892:30: ( null | sequenceTag o1= oid o2= oid (o3= oid )? )?
            {
                int alt190=3;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt190=1;
                    	}
                        break;
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case OIDTag:
                    		    	{
                    		    		alt190=2;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt190)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1892:31: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_gost_94_alg_id3228);
            	        null767=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegost_94_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null767.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:1892:38: sequenceTag o1= oid o2= oid (o3= oid )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_gost_94_alg_id3232);
            	        sequenceTag768=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegost_94_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag768.tree);

            	        FOLLOWPUSH(FOLLOW_oid_in_gost_94_alg_id3236);
            	        o1=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegost_94_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, o1.tree);

            	        FOLLOWPUSH(FOLLOW_oid_in_gost_94_alg_id3240);
            	        o2=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegost_94_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, o2.tree);

            	        {

            	            	if(cert->signature_algorithm == NULL)
            	            	{
            	            		cert->signature_algorithm =  malloc(sizeof(ALG_ID));
            	            		cert->signature_algorithm->oid = gost94signoid766.obj
            	            ;
            	            		cert->signature_algorithm->params = malloc(sizeof(alg_id_params));
            	            		cert->signature_algorithm->params->gost.public_key_param_set = o1.text
            	            ->obj;	
            	            		cert->signature_algorithm->params->gost.digest_param_set = o2.text
            	            ->obj;
            	            		cert->signature_algorithm->params->gost.encryption_param_set = NULL;
            	            	}
            	            	else {if(cert->signature_algorithm->params->gost.public_key_param_set != NULL && cert->signature_algorithm->params->gost.digest_param_set != NULL &&
            	            		OBJ_obj2nid(cert->signature_algorithm->params->gost.public_key_param_set) == OBJ_obj2nid(o1.text
            	            ->obj) && OBJ_obj2nid(cert->signature_algorithm->params->gost.digest_param_set) == OBJ_obj2nid(o2.text
            	            ->obj))
            	            		{
            	            			printf("Error! Signature parameters doesn't match \n");
            	            			exit(GOST_SIGNATURE_PARAMS_MATCHING_ERROR);		
            	            		}
            	            	if(cert->signature_algorithm->params->gost.public_key_param_set != NULL)
            	            		check--;
            	            		}
            	            	
            	        }


            	        // Grammar/RFC5280.g:1911:4: (o3= oid )?
            	        {
            	            int alt189=2;
            	            switch ( LA(1) )
            	            {
            	                case OIDTag:
            	                	{
            	                		alt189=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt189)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1911:5: o3= oid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_oid_in_gost_94_alg_id3247);
            	        	        o3=oid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulegost_94_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, o3.tree);

            	        	        {

            	        	            	if(cert->signature_algorithm->params->gost.encryption_param_set == NULL)
            	        	            		cert->signature_algorithm->params->gost.encryption_param_set = o3.text
            	        	            ->obj;
            	        	            	else {
            	        	            	if(OBJ_obj2nid(cert->signature_algorithm->params->gost.encryption_param_set) !=  OBJ_obj2nid(o3.text
            	        	            ->obj))
            	        	            		{
            	        	            			printf("Error! Signature parameters doesn't match \n");
            	        	            			exit(GOST_SIGNATURE_PARAMS_MATCHING_ERROR);		
            	        	            		}	
            	        	            		if(OBJ_obj2nid(cert->signature_algorithm->params->gost.encryption_param_set) != OBJ_obj2nid(default_encryption))
            	        	            			check--;}
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            {

                	if(cert->signature_algorithm == NULL)
                	{
                		new_alg_id(gost94signoid766.obj
                );
                		cert->signature_algorithm->params = malloc(sizeof(alg_id_params));
                		cert->signature_algorithm->params->gost.public_key_param_set = NULL;
                		cert->signature_algorithm->params->gost.digest_param_set = NULL;
                		cert->signature_algorithm->params->gost.encryption_param_set = default_encryption;
                	}
                	else{ 
                	if(cert->signature_algorithm->params->gost.encryption_param_set != default_encryption)
                	{
                		free(default_encryption);
                		default_encryption = NULL;
                	}
                	if(check > 0)
                		{
                			printf("Error! Signature parameters doesn't match \n");
                			exit(GOST_SIGNATURE_PARAMS_MATCHING_ERROR);		
                		}	
                	}
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegost_94_alg_idEx; /* Prevent compiler warnings */
    rulegost_94_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end gost_94_alg_id */

/**
 * $ANTLR start gost_01_alg_id
 * Grammar/RFC5280.g:1945:1: gost_01_alg_id : sequenceTag gost01signoid ( null | sequenceTag o1= oid o2= oid (o3= oid )? )? ;
 */
static RFC5280Parser_gost_01_alg_id_return
gost_01_alg_id(pRFC5280Parser ctx)
{
    RFC5280Parser_gost_01_alg_id_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_oid_return o1;
    #undef	RETURN_TYPE_o1
    #define	RETURN_TYPE_o1 RFC5280Parser_oid_return

    RFC5280Parser_oid_return o2;
    #undef	RETURN_TYPE_o2
    #define	RETURN_TYPE_o2 RFC5280Parser_oid_return

    RFC5280Parser_oid_return o3;
    #undef	RETURN_TYPE_o3
    #define	RETURN_TYPE_o3 RFC5280Parser_oid_return

    RFC5280Parser_sequenceTag_return sequenceTag769;
    #undef	RETURN_TYPE_sequenceTag769
    #define	RETURN_TYPE_sequenceTag769 RFC5280Parser_sequenceTag_return

    RFC5280Parser_gost01signoid_return gost01signoid770;
    #undef	RETURN_TYPE_gost01signoid770
    #define	RETURN_TYPE_gost01signoid770 RFC5280Parser_gost01signoid_return

    RFC5280Parser_null_return null771;
    #undef	RETURN_TYPE_null771
    #define	RETURN_TYPE_null771 RFC5280Parser_null_return

    RFC5280Parser_sequenceTag_return sequenceTag772;
    #undef	RETURN_TYPE_sequenceTag772
    #define	RETURN_TYPE_sequenceTag772 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    int check=0;
    	if(default_encryption == NULL)
    		default_encryption = OBJ_nid2obj(NID_id_Gost28147_89_CryptoPro_A_ParamSet);
    	if(cert->signature_algorithm!=NULL)
    	{
    		if(cert->signature_algorithm->params->gost.public_key_param_set != NULL)
    			check++;
    		if(OBJ_obj2nid(cert->signature_algorithm->params->gost.encryption_param_set) != OBJ_obj2nid(default_encryption))
    			check++;
    	}
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    	
    o1.tree = NULL;

    o2.tree = NULL;

    o3.tree = NULL;

    sequenceTag769.tree = NULL;

    gost01signoid770.tree = NULL;

    null771.tree = NULL;

    sequenceTag772.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:1962:2: ( sequenceTag gost01signoid ( null | sequenceTag o1= oid o2= oid (o3= oid )? )? )
        // Grammar/RFC5280.g:1962:4: sequenceTag gost01signoid ( null | sequenceTag o1= oid o2= oid (o3= oid )? )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_sequenceTag_in_gost_01_alg_id3274);
            sequenceTag769=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegost_01_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag769.tree);

            FOLLOWPUSH(FOLLOW_gost01signoid_in_gost_01_alg_id3276);
            gost01signoid770=gost01signoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegost_01_alg_idEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, gost01signoid770.tree);

            // Grammar/RFC5280.g:1962:30: ( null | sequenceTag o1= oid o2= oid (o3= oid )? )?
            {
                int alt192=3;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt192=1;
                    	}
                        break;
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case OIDTag:
                    		    	{
                    		    		alt192=2;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt192)
                {
            	case 1:
            	    // Grammar/RFC5280.g:1962:31: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_gost_01_alg_id3279);
            	        null771=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegost_01_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null771.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:1962:38: sequenceTag o1= oid o2= oid (o3= oid )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_gost_01_alg_id3283);
            	        sequenceTag772=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegost_01_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag772.tree);

            	        FOLLOWPUSH(FOLLOW_oid_in_gost_01_alg_id3287);
            	        o1=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegost_01_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, o1.tree);

            	        FOLLOWPUSH(FOLLOW_oid_in_gost_01_alg_id3291);
            	        o2=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegost_01_alg_idEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, o2.tree);

            	        {

            	            	if(cert->signature_algorithm == NULL)
            	            	{
            	            		cert->signature_algorithm =  malloc(sizeof(ALG_ID));
            	            		cert->signature_algorithm->oid = gost01signoid770.obj
            	            ;
            	            		cert->signature_algorithm->params = malloc(sizeof(alg_id_params));
            	            		cert->signature_algorithm->params->gost.public_key_param_set = o1.text
            	            ->obj;	
            	            		cert->signature_algorithm->params->gost.digest_param_set = o2.text
            	            ->obj;
            	            		cert->signature_algorithm->params->gost.encryption_param_set = NULL;
            	            	}
            	            	else {if(cert->signature_algorithm->params->gost.public_key_param_set != NULL && cert->signature_algorithm->params->gost.digest_param_set != NULL &&
            	            		OBJ_obj2nid(cert->signature_algorithm->params->gost.public_key_param_set) == OBJ_obj2nid(o1.text
            	            ->obj) && OBJ_obj2nid(cert->signature_algorithm->params->gost.digest_param_set) == OBJ_obj2nid(o2.text
            	            ->obj))
            	            		{
            	            			printf("Error! Signature parameters doesn't match \n");
            	            			exit(GOST_SIGNATURE_PARAMS_MATCHING_ERROR);		
            	            		}
            	            	if(cert->signature_algorithm->params->gost.public_key_param_set != NULL)
            	            		check--;}
            	            	
            	        }


            	        // Grammar/RFC5280.g:1980:4: (o3= oid )?
            	        {
            	            int alt191=2;
            	            switch ( LA(1) )
            	            {
            	                case OIDTag:
            	                	{
            	                		alt191=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt191)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:1980:5: o3= oid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_oid_in_gost_01_alg_id3298);
            	        	        o3=oid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulegost_01_alg_idEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, o3.tree);

            	        	        {

            	        	            	if(cert->signature_algorithm->params->gost.encryption_param_set == NULL)
            	        	            		cert->signature_algorithm->params->gost.encryption_param_set = o3.text
            	        	            ->obj;
            	        	            	else {
            	        	            	if(OBJ_obj2nid(cert->signature_algorithm->params->gost.encryption_param_set) !=  OBJ_obj2nid(o3.text
            	        	            ->obj))
            	        	            		{
            	        	            			printf("Error! Signature parameters doesn't match \n");
            	        	            			exit(GOST_SIGNATURE_PARAMS_MATCHING_ERROR);		
            	        	            		}
            	        	            	if(OBJ_obj2nid(cert->signature_algorithm->params->gost.encryption_param_set) != OBJ_obj2nid(default_encryption))
            	        	            		check--;}
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            {

                	if(cert->signature_algorithm == NULL)
                	{
                		new_alg_id(gost01signoid770.obj
                );
                		cert->signature_algorithm->params = malloc(sizeof(alg_id_params));
                		cert->signature_algorithm->params->gost.public_key_param_set = NULL;
                		cert->signature_algorithm->params->gost.digest_param_set = NULL;
                		cert->signature_algorithm->params->gost.encryption_param_set = default_encryption;
                	}
                	else{ 
                	if(cert->signature_algorithm->params->gost.encryption_param_set != default_encryption)
                	{
                		free(default_encryption);
                		default_encryption = NULL;
                	}
                	if(check > 0)
                		{
                			printf("Error! Signature parameters doesn't match \n");
                			exit(GOST_SIGNATURE_PARAMS_MATCHING_ERROR);		
                		}
                	}
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegost_01_alg_idEx; /* Prevent compiler warnings */
    rulegost_01_alg_idEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end gost_01_alg_id */

/**
 * $ANTLR start version
 * Grammar/RFC5280.g:2014:1: version : int0 ;
 */
static RFC5280Parser_version_return
version(pRFC5280Parser ctx)
{
    RFC5280Parser_version_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_int0_return int0773;
    #undef	RETURN_TYPE_int0773
    #define	RETURN_TYPE_int0773 RFC5280Parser_int0_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    int0773.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2017:2: ( int0 )
        // Grammar/RFC5280.g:2017:3: int0
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_int0_in_version3323);
            int0773=int0(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleversionEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, int0773.tree);

            {
                cert->version=1;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleversionEx; /* Prevent compiler warnings */
    ruleversionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end version */

/**
 * $ANTLR start version2
 * Grammar/RFC5280.g:2022:1: version2 : int1 ;
 */
static RFC5280Parser_version2_return
version2(pRFC5280Parser ctx)
{
    RFC5280Parser_version2_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_int1_return int1774;
    #undef	RETURN_TYPE_int1774
    #define	RETURN_TYPE_int1774 RFC5280Parser_int1_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    int1774.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2025:2: ( int1 )
        // Grammar/RFC5280.g:2025:3: int1
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_int1_in_version23341);
            int1774=int1(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleversion2Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, int1774.tree);

            {
                cert->version=2;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleversion2Ex; /* Prevent compiler warnings */
    ruleversion2Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end version2 */

/**
 * $ANTLR start version3
 * Grammar/RFC5280.g:2030:1: version3 : int2 ;
 */
static RFC5280Parser_version3_return
version3(pRFC5280Parser ctx)
{
    RFC5280Parser_version3_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_int2_return int2775;
    #undef	RETURN_TYPE_int2775
    #define	RETURN_TYPE_int2775 RFC5280Parser_int2_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    int2775.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2033:2: ( int2 )
        // Grammar/RFC5280.g:2033:3: int2
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_int2_in_version33359);
            int2775=int2(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleversion3Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, int2775.tree);

            {
                cert->version=3;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleversion3Ex; /* Prevent compiler warnings */
    ruleversion3Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end version3 */

/**
 * $ANTLR start serialnumber
 * Grammar/RFC5280.g:2038:1: serialnumber : integer ;
 */
static RFC5280Parser_serialnumber_return
serialnumber(pRFC5280Parser ctx)
{
    RFC5280Parser_serialnumber_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return integer776;
    #undef	RETURN_TYPE_integer776
    #define	RETURN_TYPE_integer776 RFC5280Parser_integer_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    integer776.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2041:2: ( integer )
        // Grammar/RFC5280.g:2041:3: integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_integer_in_serialnumber3377);
            integer776=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleserialnumberEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, integer776.tree);

            {
                cert->serial_number=integer776.text
                ;
                		mpz_t value,length;
                		mpz_init_set_ui(value,0);
                		mpz_init_set_ui(length,integer776.text
                ->length);
                		if(integer776.text
                ->length > 20)
                			warning |= SERIAL_NUMBER_TOO_LONG_WARNING;
                		compute_integer(integer776.text
                ->data,length,value);
                		if(mpz_sgn(value) == -1)
                			warning |= NEGATIVE_SERIAL_NUMBER_WARNING;
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleserialnumberEx; /* Prevent compiler warnings */
    ruleserialnumberEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end serialnumber */

/**
 * $ANTLR start issuer
 * Grammar/RFC5280.g:2055:1: issuer : notEmptyName ;
 */
static RFC5280Parser_issuer_return
issuer(pRFC5280Parser ctx)
{
    RFC5280Parser_issuer_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_notEmptyName_return notEmptyName777;
    #undef	RETURN_TYPE_notEmptyName777
    #define	RETURN_TYPE_notEmptyName777 RFC5280Parser_notEmptyName_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    notEmptyName777.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2057:10: ( notEmptyName )
        // Grammar/RFC5280.g:2057:11: notEmptyName
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_notEmptyName_in_issuer3394);
            notEmptyName777=notEmptyName(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleissuerEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, notEmptyName777.tree);

            {
                cert->issuer = dname;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleissuerEx; /* Prevent compiler warnings */
    ruleissuerEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end issuer */

/**
 * $ANTLR start subject
 * Grammar/RFC5280.g:2062:1: subject : notEmptyName ;
 */
static RFC5280Parser_subject_return
subject(pRFC5280Parser ctx)
{
    RFC5280Parser_subject_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_notEmptyName_return notEmptyName778;
    #undef	RETURN_TYPE_notEmptyName778
    #define	RETURN_TYPE_notEmptyName778 RFC5280Parser_notEmptyName_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    notEmptyName778.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2064:10: ( notEmptyName )
        // Grammar/RFC5280.g:2064:11: notEmptyName
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_notEmptyName_in_subject3410);
            notEmptyName778=notEmptyName(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubjectEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, notEmptyName778.tree);

            {
                cert->subject = dname;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubjectEx; /* Prevent compiler warnings */
    rulesubjectEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subject */

/**
 * $ANTLR start validity
 * Grammar/RFC5280.g:2069:1: validity : sequenceTag time1= time_span time2= time_span ;
 */
static RFC5280Parser_validity_return
validity(pRFC5280Parser ctx)
{
    RFC5280Parser_validity_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_time_span_return time1;
    #undef	RETURN_TYPE_time1
    #define	RETURN_TYPE_time1 RFC5280Parser_time_span_return

    RFC5280Parser_time_span_return time2;
    #undef	RETURN_TYPE_time2
    #define	RETURN_TYPE_time2 RFC5280Parser_time_span_return

    RFC5280Parser_sequenceTag_return sequenceTag779;
    #undef	RETURN_TYPE_sequenceTag779
    #define	RETURN_TYPE_sequenceTag779 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    time1.tree = NULL;

    time2.tree = NULL;

    sequenceTag779.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2072:2: ( sequenceTag time1= time_span time2= time_span )
        // Grammar/RFC5280.g:2072:3: sequenceTag time1= time_span time2= time_span
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_validity3428);
            sequenceTag779=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalidityEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag779.tree);

            FOLLOWPUSH(FOLLOW_time_span_in_validity3432);
            time1=time_span(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalidityEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, time1.tree);

            FOLLOWPUSH(FOLLOW_time_span_in_validity3436);
            time2=time_span(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevalidityEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, time2.tree);

            {
                cert->validity = malloc(sizeof(X509_VAL));
                		cert->validity->notBefore = time1.text
                ;
                		cert->validity->notAfter = time2.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevalidityEx; /* Prevent compiler warnings */
    rulevalidityEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end validity */

/**
 * $ANTLR start subjectPKinfo
 * Grammar/RFC5280.g:2080:1: subjectPKinfo : sequenceTag ( rsapk | dsapk | dhpk | ecpk | keapk | rsapsspk | rsaoaep | gostpk ) ;
 */
static RFC5280Parser_subjectPKinfo_return
subjectPKinfo(pRFC5280Parser ctx)
{
    RFC5280Parser_subjectPKinfo_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag780;
    #undef	RETURN_TYPE_sequenceTag780
    #define	RETURN_TYPE_sequenceTag780 RFC5280Parser_sequenceTag_return

    RFC5280Parser_rsapk_return rsapk781;
    #undef	RETURN_TYPE_rsapk781
    #define	RETURN_TYPE_rsapk781 RFC5280Parser_rsapk_return

    RFC5280Parser_dsapk_return dsapk782;
    #undef	RETURN_TYPE_dsapk782
    #define	RETURN_TYPE_dsapk782 RFC5280Parser_dsapk_return

    RFC5280Parser_dhpk_return dhpk783;
    #undef	RETURN_TYPE_dhpk783
    #define	RETURN_TYPE_dhpk783 RFC5280Parser_dhpk_return

    RFC5280Parser_ecpk_return ecpk784;
    #undef	RETURN_TYPE_ecpk784
    #define	RETURN_TYPE_ecpk784 RFC5280Parser_ecpk_return

    RFC5280Parser_keapk_return keapk785;
    #undef	RETURN_TYPE_keapk785
    #define	RETURN_TYPE_keapk785 RFC5280Parser_keapk_return

    RFC5280Parser_rsapsspk_return rsapsspk786;
    #undef	RETURN_TYPE_rsapsspk786
    #define	RETURN_TYPE_rsapsspk786 RFC5280Parser_rsapsspk_return

    RFC5280Parser_rsaoaep_return rsaoaep787;
    #undef	RETURN_TYPE_rsaoaep787
    #define	RETURN_TYPE_rsaoaep787 RFC5280Parser_rsaoaep_return

    RFC5280Parser_gostpk_return gostpk788;
    #undef	RETURN_TYPE_gostpk788
    #define	RETURN_TYPE_gostpk788 RFC5280Parser_gostpk_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag780.tree = NULL;

    rsapk781.tree = NULL;

    dsapk782.tree = NULL;

    dhpk783.tree = NULL;

    ecpk784.tree = NULL;

    keapk785.tree = NULL;

    rsapsspk786.tree = NULL;

    rsaoaep787.tree = NULL;

    gostpk788.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2083:2: ( sequenceTag ( rsapk | dsapk | dhpk | ecpk | keapk | rsapsspk | rsaoaep | gostpk ) )
        // Grammar/RFC5280.g:2083:3: sequenceTag ( rsapk | dsapk | dhpk | ecpk | keapk | rsapsspk | rsaoaep | gostpk )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_subjectPKinfo3455);
            sequenceTag780=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubjectPKinfoEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag780.tree);

            {
                cert->pkey = malloc(sizeof(PUBKEY_ALG));
            }


            // Grammar/RFC5280.g:2086:58: ( rsapk | dsapk | dhpk | ecpk | keapk | rsapsspk | rsaoaep | gostpk )
            {
                int alt193=8;
                switch ( LA(1) )
                {
                case SequenceTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDTag:
                			{
                				switch ( LA(3) )
                				{
                				case RSAPKOID:
                					{
                						alt193=1;
                					}
                				    break;
                				case DSAPKOID:
                					{
                						alt193=2;
                					}
                				    break;
                				case DHPKOID:
                					{
                						alt193=3;
                					}
                				    break;
                				case ECDHOID:
                				case ECMQVOID:
                				case ECPKOID:
                					{
                						alt193=4;
                					}
                				    break;
                				case KEAPKOID:
                					{
                						alt193=5;
                					}
                				    break;
                				case RSAPSSOID:
                					{
                						alt193=6;
                					}
                				    break;
                				case RSAOAEPOID:
                					{
                						alt193=7;
                					}
                				    break;
                				case GOST01PK:
                				case GOST94PK:
                					{
                						alt193=8;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 193;
                				    EXCEPTION->state        = 2;


                				    goto rulesubjectPKinfoEx;

                				}

                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 193;
                		    EXCEPTION->state        = 1;


                		    goto rulesubjectPKinfoEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 193;
                    EXCEPTION->state        = 0;


                    goto rulesubjectPKinfoEx;

                }

                switch (alt193)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2086:59: rsapk
            	    {
            	        FOLLOWPUSH(FOLLOW_rsapk_in_subjectPKinfo3460);
            	        rsapk781=rsapk(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubjectPKinfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, rsapk781.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2086:67: dsapk
            	    {
            	        FOLLOWPUSH(FOLLOW_dsapk_in_subjectPKinfo3464);
            	        dsapk782=dsapk(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubjectPKinfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, dsapk782.tree);

            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:2086:75: dhpk
            	    {
            	        FOLLOWPUSH(FOLLOW_dhpk_in_subjectPKinfo3468);
            	        dhpk783=dhpk(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubjectPKinfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, dhpk783.tree);

            	    }
            	    break;
            	case 4:
            	    // Grammar/RFC5280.g:2086:82: ecpk
            	    {
            	        FOLLOWPUSH(FOLLOW_ecpk_in_subjectPKinfo3472);
            	        ecpk784=ecpk(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubjectPKinfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, ecpk784.tree);

            	    }
            	    break;
            	case 5:
            	    // Grammar/RFC5280.g:2086:89: keapk
            	    {
            	        FOLLOWPUSH(FOLLOW_keapk_in_subjectPKinfo3476);
            	        keapk785=keapk(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubjectPKinfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, keapk785.tree);

            	    }
            	    break;
            	case 6:
            	    // Grammar/RFC5280.g:2086:96: rsapsspk
            	    {
            	        FOLLOWPUSH(FOLLOW_rsapsspk_in_subjectPKinfo3479);
            	        rsapsspk786=rsapsspk(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubjectPKinfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, rsapsspk786.tree);

            	    }
            	    break;
            	case 7:
            	    // Grammar/RFC5280.g:2086:107: rsaoaep
            	    {
            	        FOLLOWPUSH(FOLLOW_rsaoaep_in_subjectPKinfo3483);
            	        rsaoaep787=rsaoaep(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubjectPKinfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, rsaoaep787.tree);

            	    }
            	    break;
            	case 8:
            	    // Grammar/RFC5280.g:2086:117: gostpk
            	    {
            	        FOLLOWPUSH(FOLLOW_gostpk_in_subjectPKinfo3487);
            	        gostpk788=gostpk(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubjectPKinfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, gostpk788.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubjectPKinfoEx; /* Prevent compiler warnings */
    rulesubjectPKinfoEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subjectPKinfo */

/**
 * $ANTLR start rsapk
 * Grammar/RFC5280.g:2088:1: rsapk : rsa_alg_id constructedBitString sequenceTag n= integer e= integer ;
 */
static RFC5280Parser_rsapk_return
rsapk(pRFC5280Parser ctx)
{
    RFC5280Parser_rsapk_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n RFC5280Parser_integer_return

    RFC5280Parser_integer_return e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e RFC5280Parser_integer_return

    RFC5280Parser_rsa_alg_id_return rsa_alg_id789;
    #undef	RETURN_TYPE_rsa_alg_id789
    #define	RETURN_TYPE_rsa_alg_id789 RFC5280Parser_rsa_alg_id_return

    RFC5280Parser_constructedBitString_return constructedBitString790;
    #undef	RETURN_TYPE_constructedBitString790
    #define	RETURN_TYPE_constructedBitString790 RFC5280Parser_constructedBitString_return

    RFC5280Parser_sequenceTag_return sequenceTag791;
    #undef	RETURN_TYPE_sequenceTag791
    #define	RETURN_TYPE_sequenceTag791 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    n.tree = NULL;

    e.tree = NULL;

    rsa_alg_id789.tree = NULL;

    constructedBitString790.tree = NULL;

    sequenceTag791.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2090:10: ( rsa_alg_id constructedBitString sequenceTag n= integer e= integer )
        // Grammar/RFC5280.g:2090:11: rsa_alg_id constructedBitString sequenceTag n= integer e= integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_rsa_alg_id_in_rsapk3504);
            rsa_alg_id789=rsa_alg_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, rsa_alg_id789.tree);

            FOLLOWPUSH(FOLLOW_constructedBitString_in_rsapk3506);
            constructedBitString790=constructedBitString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedBitString790.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsapk3508);
            sequenceTag791=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag791.tree);

            FOLLOWPUSH(FOLLOW_integer_in_rsapk3512);
            n=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, n.tree);

            FOLLOWPUSH(FOLLOW_integer_in_rsapk3516);
            e=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, e.tree);

            {

                	new_rsa_pk(n.text
                ,e.text
                );
                	cert->mask = 15;cert->mask_ca=9;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersapkEx; /* Prevent compiler warnings */
    rulersapkEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsapk */

/**
 * $ANTLR start dsapk
 * Grammar/RFC5280.g:2097:1: dsapk : dsa_alg_id constructedBitString integer ;
 */
static RFC5280Parser_dsapk_return
dsapk(pRFC5280Parser ctx)
{
    RFC5280Parser_dsapk_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_dsa_alg_id_return dsa_alg_id792;
    #undef	RETURN_TYPE_dsa_alg_id792
    #define	RETURN_TYPE_dsa_alg_id792 RFC5280Parser_dsa_alg_id_return

    RFC5280Parser_constructedBitString_return constructedBitString793;
    #undef	RETURN_TYPE_constructedBitString793
    #define	RETURN_TYPE_constructedBitString793 RFC5280Parser_constructedBitString_return

    RFC5280Parser_integer_return integer794;
    #undef	RETURN_TYPE_integer794
    #define	RETURN_TYPE_integer794 RFC5280Parser_integer_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    dsa_alg_id792.tree = NULL;

    constructedBitString793.tree = NULL;

    integer794.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2099:10: ( dsa_alg_id constructedBitString integer )
        // Grammar/RFC5280.g:2099:11: dsa_alg_id constructedBitString integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_dsa_alg_id_in_dsapk3533);
            dsa_alg_id792=dsa_alg_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, dsa_alg_id792.tree);

            FOLLOWPUSH(FOLLOW_constructedBitString_in_dsapk3535);
            constructedBitString793=constructedBitString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedBitString793.tree);

            FOLLOWPUSH(FOLLOW_integer_in_dsapk3537);
            integer794=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, integer794.tree);

            {

                	cert->pkey->pubkey = malloc(sizeof(PUBKEY));
                	cert->pkey->pubkey->dsa_dh_key = integer794.text
                ;
                	cert->mask = 63;cert->mask_ca=57;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledsapkEx; /* Prevent compiler warnings */
    ruledsapkEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dsapk */

/**
 * $ANTLR start dhpk
 * Grammar/RFC5280.g:2107:1: dhpk : dh_alg_id bitstring ;
 */
static RFC5280Parser_dhpk_return
dhpk(pRFC5280Parser ctx)
{
    RFC5280Parser_dhpk_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_dh_alg_id_return dh_alg_id795;
    #undef	RETURN_TYPE_dh_alg_id795
    #define	RETURN_TYPE_dh_alg_id795 RFC5280Parser_dh_alg_id_return

    RFC5280Parser_bitstring_return bitstring796;
    #undef	RETURN_TYPE_bitstring796
    #define	RETURN_TYPE_bitstring796 RFC5280Parser_bitstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    dh_alg_id795.tree = NULL;

    bitstring796.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2109:10: ( dh_alg_id bitstring )
        // Grammar/RFC5280.g:2109:11: dh_alg_id bitstring
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_dh_alg_id_in_dhpk3554);
            dh_alg_id795=dh_alg_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledhpkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, dh_alg_id795.tree);

            FOLLOWPUSH(FOLLOW_bitstring_in_dhpk3556);
            bitstring796=bitstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledhpkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bitstring796.tree);

            {

                	cert->pkey->pubkey = malloc(sizeof(PUBKEY));
                	if(bitstring796.text
                ->data[0] != 2)
                	{
                		printf("Error! Not integer in diffie hellman public key \n");
                		exit(DH_KEY_NOT_INTEGER_ERROR);	
                	}	
                	mpz_t length;
                	mpz_init_set_ui(length,0);
                	int len = compute_len(bitstring796.text
                ->data,length);
                	cert->pkey->pubkey->dsa_dh_key = new_asn1_string(2,mpz_get_ui(length),bitstring796.text
                ->data+len);
                	cert->mask = 246;cert->mask_ca=246;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledhpkEx; /* Prevent compiler warnings */
    ruledhpkEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dhpk */

/**
 * $ANTLR start keapk
 * Grammar/RFC5280.g:2125:1: keapk : kea_alg_id bitstring ;
 */
static RFC5280Parser_keapk_return
keapk(pRFC5280Parser ctx)
{
    RFC5280Parser_keapk_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_kea_alg_id_return kea_alg_id797;
    #undef	RETURN_TYPE_kea_alg_id797
    #define	RETURN_TYPE_kea_alg_id797 RFC5280Parser_kea_alg_id_return

    RFC5280Parser_bitstring_return bitstring798;
    #undef	RETURN_TYPE_bitstring798
    #define	RETURN_TYPE_bitstring798 RFC5280Parser_bitstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    kea_alg_id797.tree = NULL;

    bitstring798.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2127:10: ( kea_alg_id bitstring )
        // Grammar/RFC5280.g:2127:11: kea_alg_id bitstring
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_kea_alg_id_in_keapk3574);
            kea_alg_id797=kea_alg_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekeapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, kea_alg_id797.tree);

            FOLLOWPUSH(FOLLOW_bitstring_in_keapk3576);
            bitstring798=bitstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekeapkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bitstring798.tree);

            {

                	new_bitstring_pk(bitstring798.text
                );
                	cert->mask = 246;cert->mask_ca=246;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeapkEx; /* Prevent compiler warnings */
    rulekeapkEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end keapk */

/**
 * $ANTLR start ecpk
 * Grammar/RFC5280.g:2134:1: ecpk : ec_alg_id bitstring ;
 */
static RFC5280Parser_ecpk_return
ecpk(pRFC5280Parser ctx)
{
    RFC5280Parser_ecpk_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_ec_alg_id_return ec_alg_id799;
    #undef	RETURN_TYPE_ec_alg_id799
    #define	RETURN_TYPE_ec_alg_id799 RFC5280Parser_ec_alg_id_return

    RFC5280Parser_bitstring_return bitstring800;
    #undef	RETURN_TYPE_bitstring800
    #define	RETURN_TYPE_bitstring800 RFC5280Parser_bitstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    ec_alg_id799.tree = NULL;

    bitstring800.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2136:10: ( ec_alg_id bitstring )
        // Grammar/RFC5280.g:2136:11: ec_alg_id bitstring
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_ec_alg_id_in_ecpk3593);
            ec_alg_id799=ec_alg_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleecpkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, ec_alg_id799.tree);

            FOLLOWPUSH(FOLLOW_bitstring_in_ecpk3595);
            bitstring800=bitstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleecpkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bitstring800.tree);

            {
                new_bitstring_pk(bitstring800.text
                );
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleecpkEx; /* Prevent compiler warnings */
    ruleecpkEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ecpk */

/**
 * $ANTLR start gostpk
 * Grammar/RFC5280.g:2142:1: gostpk : sequenceTag ( gost94pkoid | gost01pkoid ) ( null | sequenceTag oid oid ( oid )? )? constructedBitString octetstring ;
 */
static RFC5280Parser_gostpk_return
gostpk(pRFC5280Parser ctx)
{
    RFC5280Parser_gostpk_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag801;
    #undef	RETURN_TYPE_sequenceTag801
    #define	RETURN_TYPE_sequenceTag801 RFC5280Parser_sequenceTag_return

    RFC5280Parser_gost94pkoid_return gost94pkoid802;
    #undef	RETURN_TYPE_gost94pkoid802
    #define	RETURN_TYPE_gost94pkoid802 RFC5280Parser_gost94pkoid_return

    RFC5280Parser_gost01pkoid_return gost01pkoid803;
    #undef	RETURN_TYPE_gost01pkoid803
    #define	RETURN_TYPE_gost01pkoid803 RFC5280Parser_gost01pkoid_return

    RFC5280Parser_null_return null804;
    #undef	RETURN_TYPE_null804
    #define	RETURN_TYPE_null804 RFC5280Parser_null_return

    RFC5280Parser_sequenceTag_return sequenceTag805;
    #undef	RETURN_TYPE_sequenceTag805
    #define	RETURN_TYPE_sequenceTag805 RFC5280Parser_sequenceTag_return

    RFC5280Parser_oid_return oid806;
    #undef	RETURN_TYPE_oid806
    #define	RETURN_TYPE_oid806 RFC5280Parser_oid_return

    RFC5280Parser_oid_return oid807;
    #undef	RETURN_TYPE_oid807
    #define	RETURN_TYPE_oid807 RFC5280Parser_oid_return

    RFC5280Parser_oid_return oid808;
    #undef	RETURN_TYPE_oid808
    #define	RETURN_TYPE_oid808 RFC5280Parser_oid_return

    RFC5280Parser_constructedBitString_return constructedBitString809;
    #undef	RETURN_TYPE_constructedBitString809
    #define	RETURN_TYPE_constructedBitString809 RFC5280Parser_constructedBitString_return

    RFC5280Parser_octetstring_return octetstring810;
    #undef	RETURN_TYPE_octetstring810
    #define	RETURN_TYPE_octetstring810 RFC5280Parser_octetstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag801.tree = NULL;

    gost94pkoid802.tree = NULL;

    gost01pkoid803.tree = NULL;

    null804.tree = NULL;

    sequenceTag805.tree = NULL;

    oid806.tree = NULL;

    oid807.tree = NULL;

    oid808.tree = NULL;

    constructedBitString809.tree = NULL;

    octetstring810.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2144:10: ( sequenceTag ( gost94pkoid | gost01pkoid ) ( null | sequenceTag oid oid ( oid )? )? constructedBitString octetstring )
        // Grammar/RFC5280.g:2144:11: sequenceTag ( gost94pkoid | gost01pkoid ) ( null | sequenceTag oid oid ( oid )? )? constructedBitString octetstring
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_gostpk3615);
            sequenceTag801=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegostpkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag801.tree);

            // Grammar/RFC5280.g:2147:15: ( gost94pkoid | gost01pkoid )
            {
                int alt194=2;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case GOST94PK:
                			{
                				alt194=1;
                			}
                		    break;
                		case GOST01PK:
                			{
                				alt194=2;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 194;
                		    EXCEPTION->state        = 1;


                		    goto rulegostpkEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 194;
                    EXCEPTION->state        = 0;


                    goto rulegostpkEx;

                }

                switch (alt194)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2147:16: gost94pkoid
            	    {
            	        FOLLOWPUSH(FOLLOW_gost94pkoid_in_gostpk3618);
            	        gost94pkoid802=gost94pkoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegostpkEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, gost94pkoid802.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2147:30: gost01pkoid
            	    {
            	        FOLLOWPUSH(FOLLOW_gost01pkoid_in_gostpk3622);
            	        gost01pkoid803=gost01pkoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegostpkEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, gost01pkoid803.tree);

            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:2147:43: ( null | sequenceTag oid oid ( oid )? )?
            {
                int alt196=3;
                switch ( LA(1) )
                {
                    case Null:
                    	{
                    		alt196=1;
                    	}
                        break;
                    case SequenceTag:
                    	{
                    		alt196=2;
                    	}
                        break;
                }

                switch (alt196)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2147:44: null
            	    {
            	        FOLLOWPUSH(FOLLOW_null_in_gostpk3626);
            	        null804=null(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegostpkEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, null804.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2147:51: sequenceTag oid oid ( oid )?
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_gostpk3630);
            	        sequenceTag805=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegostpkEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag805.tree);

            	        FOLLOWPUSH(FOLLOW_oid_in_gostpk3632);
            	        oid806=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegostpkEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, oid806.tree);

            	        FOLLOWPUSH(FOLLOW_oid_in_gostpk3634);
            	        oid807=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegostpkEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, oid807.tree);

            	        // Grammar/RFC5280.g:2147:71: ( oid )?
            	        {
            	            int alt195=2;
            	            switch ( LA(1) )
            	            {
            	                case OIDTag:
            	                	{
            	                		alt195=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt195)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:2147:71: oid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_oid_in_gostpk3636);
            	        	        oid808=oid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulegostpkEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, oid808.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedBitString_in_gostpk3641);
            constructedBitString809=constructedBitString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegostpkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedBitString809.tree);

            FOLLOWPUSH(FOLLOW_octetstring_in_gostpk3643);
            octetstring810=octetstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegostpkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, octetstring810.tree);

            {
                cert->pkey->pubkey = malloc(sizeof(PUBKEY));cert->pkey->pubkey->gost_key = octetstring810.text
                ;cert->mask = 22;cert->mask_ca=57;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegostpkEx; /* Prevent compiler warnings */
    rulegostpkEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end gostpk */

/**
 * $ANTLR start rsapsspk
 * Grammar/RFC5280.g:2150:1: rsapsspk : pss_alg_id constructedBitString sequenceTag n= integer e= integer ;
 */
static RFC5280Parser_rsapsspk_return
rsapsspk(pRFC5280Parser ctx)
{
    RFC5280Parser_rsapsspk_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n RFC5280Parser_integer_return

    RFC5280Parser_integer_return e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e RFC5280Parser_integer_return

    RFC5280Parser_pss_alg_id_return pss_alg_id811;
    #undef	RETURN_TYPE_pss_alg_id811
    #define	RETURN_TYPE_pss_alg_id811 RFC5280Parser_pss_alg_id_return

    RFC5280Parser_constructedBitString_return constructedBitString812;
    #undef	RETURN_TYPE_constructedBitString812
    #define	RETURN_TYPE_constructedBitString812 RFC5280Parser_constructedBitString_return

    RFC5280Parser_sequenceTag_return sequenceTag813;
    #undef	RETURN_TYPE_sequenceTag813
    #define	RETURN_TYPE_sequenceTag813 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    n.tree = NULL;

    e.tree = NULL;

    pss_alg_id811.tree = NULL;

    constructedBitString812.tree = NULL;

    sequenceTag813.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2152:10: ( pss_alg_id constructedBitString sequenceTag n= integer e= integer )
        // Grammar/RFC5280.g:2152:11: pss_alg_id constructedBitString sequenceTag n= integer e= integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_pss_alg_id_in_rsapsspk3664);
            pss_alg_id811=pss_alg_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapsspkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, pss_alg_id811.tree);

            FOLLOWPUSH(FOLLOW_constructedBitString_in_rsapsspk3666);
            constructedBitString812=constructedBitString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapsspkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedBitString812.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsapsspk3668);
            sequenceTag813=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapsspkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag813.tree);

            FOLLOWPUSH(FOLLOW_integer_in_rsapsspk3672);
            n=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapsspkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, n.tree);

            FOLLOWPUSH(FOLLOW_integer_in_rsapsspk3676);
            e=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersapsspkEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, e.tree);

            {

                	new_rsa_pk(n.text
                ,e.text
                );
                	cert->mask = 63;cert->mask_ca=57;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersapsspkEx; /* Prevent compiler warnings */
    rulersapsspkEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsapsspk */

/**
 * $ANTLR start rsaoaep
 * Grammar/RFC5280.g:2159:1: rsaoaep : oaep_alg_id constructedBitString sequenceTag n= integer e= integer ;
 */
static RFC5280Parser_rsaoaep_return
rsaoaep(pRFC5280Parser ctx)
{
    RFC5280Parser_rsaoaep_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n RFC5280Parser_integer_return

    RFC5280Parser_integer_return e;
    #undef	RETURN_TYPE_e
    #define	RETURN_TYPE_e RFC5280Parser_integer_return

    RFC5280Parser_oaep_alg_id_return oaep_alg_id814;
    #undef	RETURN_TYPE_oaep_alg_id814
    #define	RETURN_TYPE_oaep_alg_id814 RFC5280Parser_oaep_alg_id_return

    RFC5280Parser_constructedBitString_return constructedBitString815;
    #undef	RETURN_TYPE_constructedBitString815
    #define	RETURN_TYPE_constructedBitString815 RFC5280Parser_constructedBitString_return

    RFC5280Parser_sequenceTag_return sequenceTag816;
    #undef	RETURN_TYPE_sequenceTag816
    #define	RETURN_TYPE_sequenceTag816 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    n.tree = NULL;

    e.tree = NULL;

    oaep_alg_id814.tree = NULL;

    constructedBitString815.tree = NULL;

    sequenceTag816.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2161:10: ( oaep_alg_id constructedBitString sequenceTag n= integer e= integer )
        // Grammar/RFC5280.g:2161:11: oaep_alg_id constructedBitString sequenceTag n= integer e= integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_oaep_alg_id_in_rsaoaep3693);
            oaep_alg_id814=oaep_alg_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersaoaepEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, oaep_alg_id814.tree);

            FOLLOWPUSH(FOLLOW_constructedBitString_in_rsaoaep3695);
            constructedBitString815=constructedBitString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersaoaepEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedBitString815.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_rsaoaep3697);
            sequenceTag816=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersaoaepEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag816.tree);

            FOLLOWPUSH(FOLLOW_integer_in_rsaoaep3701);
            n=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersaoaepEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, n.tree);

            FOLLOWPUSH(FOLLOW_integer_in_rsaoaep3705);
            e=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulersaoaepEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, e.tree);

            {

                	new_rsa_pk(n.text
                ,e.text
                );
                	cert->mask = 159;cert->mask_ca=159;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersaoaepEx; /* Prevent compiler warnings */
    rulersaoaepEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsaoaep */

/**
 * $ANTLR start subjectuniqueId
 * Grammar/RFC5280.g:2168:1: subjectuniqueId : tag2 ;
 */
static RFC5280Parser_subjectuniqueId_return
subjectuniqueId(pRFC5280Parser ctx)
{
    RFC5280Parser_subjectuniqueId_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_tag2_return tag2817;
    #undef	RETURN_TYPE_tag2817
    #define	RETURN_TYPE_tag2817 RFC5280Parser_tag2_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    tag2817.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2171:2: ( tag2 )
        // Grammar/RFC5280.g:2171:3: tag2
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_tag2_in_subjectuniqueId3723);
            tag2817=tag2(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubjectuniqueIdEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, tag2817.tree);

            {

                		ASN1_STRING *bs;
                		bs = malloc(sizeof(ASN1_STRING));
                		compute_bitstring (tag2817.text
                ->value,tag2817.text
                ->length,bs);	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubjectuniqueIdEx; /* Prevent compiler warnings */
    rulesubjectuniqueIdEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subjectuniqueId */

/**
 * $ANTLR start issueruniqueId
 * Grammar/RFC5280.g:2180:1: issueruniqueId : tag1 ;
 */
static RFC5280Parser_issueruniqueId_return
issueruniqueId(pRFC5280Parser ctx)
{
    RFC5280Parser_issueruniqueId_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_tag1_return tag1818;
    #undef	RETURN_TYPE_tag1818
    #define	RETURN_TYPE_tag1818 RFC5280Parser_tag1_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    tag1818.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2183:2: ( tag1 )
        // Grammar/RFC5280.g:2183:3: tag1
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_tag1_in_issueruniqueId3741);
            tag1818=tag1(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleissueruniqueIdEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, tag1818.tree);

            {

                		ASN1_STRING *bs;
                		bs = malloc(sizeof(ASN1_STRING));
                		compute_bitstring (tag1818.text
                ->value,tag1818.text
                ->length,bs);	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleissueruniqueIdEx; /* Prevent compiler warnings */
    ruleissueruniqueIdEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end issueruniqueId */

/**
 * $ANTLR start extensionsWithSubAlt
 * Grammar/RFC5280.g:2193:1: extensionsWithSubAlt : ( extensionNoSubAlt extensionsWithSubAlt | basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignAndSkiSubAlt ) ) | keyUsageCommon ( bitstring extensionsNoPathLenSubAlt | bitstringCertSign extensionsMustBeCAandSkiSubAlt ) | dependentExtension extensionsMustBeCaAndSkiSubAlt | subjectKeyId extensionsNoSkiSubAlt | subAltNameCritical extensions );
 */
static RFC5280Parser_extensionsWithSubAlt_return
extensionsWithSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsWithSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt819;
    #undef	RETURN_TYPE_extensionNoSubAlt819
    #define	RETURN_TYPE_extensionNoSubAlt819 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsWithSubAlt_return extensionsWithSubAlt820;
    #undef	RETURN_TYPE_extensionsWithSubAlt820
    #define	RETURN_TYPE_extensionsWithSubAlt820 RFC5280Parser_extensionsWithSubAlt_return

    RFC5280Parser_basicConstraintsNotCritical_return basicConstraintsNotCritical821;
    #undef	RETURN_TYPE_basicConstraintsNotCritical821
    #define	RETURN_TYPE_basicConstraintsNotCritical821 RFC5280Parser_basicConstraintsNotCritical_return

    RFC5280Parser_truevalue_return truevalue822;
    #undef	RETURN_TYPE_truevalue822
    #define	RETURN_TYPE_truevalue822 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString823;
    #undef	RETURN_TYPE_constructedOctetString823
    #define	RETURN_TYPE_constructedOctetString823 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag824;
    #undef	RETURN_TYPE_sequenceTag824
    #define	RETURN_TYPE_sequenceTag824 RFC5280Parser_sequenceTag_return

    RFC5280Parser_falsevalue_return falsevalue825;
    #undef	RETURN_TYPE_falsevalue825
    #define	RETURN_TYPE_falsevalue825 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExtsSubAlt_return notDependentExtsSubAlt826;
    #undef	RETURN_TYPE_notDependentExtsSubAlt826
    #define	RETURN_TYPE_notDependentExtsSubAlt826 RFC5280Parser_notDependentExtsSubAlt_return

    RFC5280Parser_truevalue_return truevalue827;
    #undef	RETURN_TYPE_truevalue827
    #define	RETURN_TYPE_truevalue827 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCSubAlt_return extensionsNotBCSubAlt828;
    #undef	RETURN_TYPE_extensionsNotBCSubAlt828
    #define	RETURN_TYPE_extensionsNotBCSubAlt828 RFC5280Parser_extensionsNotBCSubAlt_return

    RFC5280Parser_integer_return integer829;
    #undef	RETURN_TYPE_integer829
    #define	RETURN_TYPE_integer829 RFC5280Parser_integer_return

    RFC5280Parser_extensionsCertSignAndSkiSubAlt_return extensionsCertSignAndSkiSubAlt830;
    #undef	RETURN_TYPE_extensionsCertSignAndSkiSubAlt830
    #define	RETURN_TYPE_extensionsCertSignAndSkiSubAlt830 RFC5280Parser_extensionsCertSignAndSkiSubAlt_return

    RFC5280Parser_falsevalue_return falsevalue831;
    #undef	RETURN_TYPE_falsevalue831
    #define	RETURN_TYPE_falsevalue831 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString832;
    #undef	RETURN_TYPE_constructedOctetString832
    #define	RETURN_TYPE_constructedOctetString832 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag833;
    #undef	RETURN_TYPE_sequenceTag833
    #define	RETURN_TYPE_sequenceTag833 RFC5280Parser_sequenceTag_return

    RFC5280Parser_falsevalue_return falsevalue834;
    #undef	RETURN_TYPE_falsevalue834
    #define	RETURN_TYPE_falsevalue834 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExtsSubAlt_return notDependentExtsSubAlt835;
    #undef	RETURN_TYPE_notDependentExtsSubAlt835
    #define	RETURN_TYPE_notDependentExtsSubAlt835 RFC5280Parser_notDependentExtsSubAlt_return

    RFC5280Parser_truevalue_return truevalue836;
    #undef	RETURN_TYPE_truevalue836
    #define	RETURN_TYPE_truevalue836 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return extensionsNotCertSignAndSkiSubAlt837;
    #undef	RETURN_TYPE_extensionsNotCertSignAndSkiSubAlt837
    #define	RETURN_TYPE_extensionsNotCertSignAndSkiSubAlt837 RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon838;
    #undef	RETURN_TYPE_keyUsageCommon838
    #define	RETURN_TYPE_keyUsageCommon838 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring839;
    #undef	RETURN_TYPE_bitstring839
    #define	RETURN_TYPE_bitstring839 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsNoPathLenSubAlt_return extensionsNoPathLenSubAlt840;
    #undef	RETURN_TYPE_extensionsNoPathLenSubAlt840
    #define	RETURN_TYPE_extensionsNoPathLenSubAlt840 RFC5280Parser_extensionsNoPathLenSubAlt_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign841;
    #undef	RETURN_TYPE_bitstringCertSign841
    #define	RETURN_TYPE_bitstringCertSign841 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsMustBeCAandSkiSubAlt_return extensionsMustBeCAandSkiSubAlt842;
    #undef	RETURN_TYPE_extensionsMustBeCAandSkiSubAlt842
    #define	RETURN_TYPE_extensionsMustBeCAandSkiSubAlt842 RFC5280Parser_extensionsMustBeCAandSkiSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension843;
    #undef	RETURN_TYPE_dependentExtension843
    #define	RETURN_TYPE_dependentExtension843 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaAndSkiSubAlt_return extensionsMustBeCaAndSkiSubAlt844;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSkiSubAlt844
    #define	RETURN_TYPE_extensionsMustBeCaAndSkiSubAlt844 RFC5280Parser_extensionsMustBeCaAndSkiSubAlt_return

    RFC5280Parser_subjectKeyId_return subjectKeyId845;
    #undef	RETURN_TYPE_subjectKeyId845
    #define	RETURN_TYPE_subjectKeyId845 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNoSkiSubAlt_return extensionsNoSkiSubAlt846;
    #undef	RETURN_TYPE_extensionsNoSkiSubAlt846
    #define	RETURN_TYPE_extensionsNoSkiSubAlt846 RFC5280Parser_extensionsNoSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical847;
    #undef	RETURN_TYPE_subAltNameCritical847
    #define	RETURN_TYPE_subAltNameCritical847 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensions_return extensions848;
    #undef	RETURN_TYPE_extensions848
    #define	RETURN_TYPE_extensions848 RFC5280Parser_extensions_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    if(cert->extensions == NULL)
    		cert->extensions = sk_x509_EXTENSION_new_null();
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    	
    extensionNoSubAlt819.tree = NULL;

    extensionsWithSubAlt820.tree = NULL;

    basicConstraintsNotCritical821.tree = NULL;

    truevalue822.tree = NULL;

    constructedOctetString823.tree = NULL;

    sequenceTag824.tree = NULL;

    falsevalue825.tree = NULL;

    notDependentExtsSubAlt826.tree = NULL;

    truevalue827.tree = NULL;

    extensionsNotBCSubAlt828.tree = NULL;

    integer829.tree = NULL;

    extensionsCertSignAndSkiSubAlt830.tree = NULL;

    falsevalue831.tree = NULL;

    constructedOctetString832.tree = NULL;

    sequenceTag833.tree = NULL;

    falsevalue834.tree = NULL;

    notDependentExtsSubAlt835.tree = NULL;

    truevalue836.tree = NULL;

    extensionsNotCertSignAndSkiSubAlt837.tree = NULL;

    keyUsageCommon838.tree = NULL;

    bitstring839.tree = NULL;

    extensionsNoPathLenSubAlt840.tree = NULL;

    bitstringCertSign841.tree = NULL;

    extensionsMustBeCAandSkiSubAlt842.tree = NULL;

    dependentExtension843.tree = NULL;

    extensionsMustBeCaAndSkiSubAlt844.tree = NULL;

    subjectKeyId845.tree = NULL;

    extensionsNoSkiSubAlt846.tree = NULL;

    subAltNameCritical847.tree = NULL;

    extensions848.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2202:2: ( extensionNoSubAlt extensionsWithSubAlt | basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignAndSkiSubAlt ) ) | keyUsageCommon ( bitstring extensionsNoPathLenSubAlt | bitstringCertSign extensionsMustBeCAandSkiSubAlt ) | dependentExtension extensionsMustBeCaAndSkiSubAlt | subjectKeyId extensionsNoSkiSubAlt | subAltNameCritical extensions )

            ANTLR3_UINT32 alt205;

            alt205=6;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt205=1;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt205=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt205=3;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt205=4;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt205=5;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt205=6;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 205;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsWithSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 205;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsWithSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 205;
                EXCEPTION->state        = 0;


                goto ruleextensionsWithSubAltEx;

            }

            switch (alt205)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2202:4: extensionNoSubAlt extensionsWithSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsWithSubAlt3762);
        	        extensionNoSubAlt819=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt819.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsWithSubAlt_in_extensionsWithSubAlt3764);
        	        extensionsWithSubAlt820=extensionsWithSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsWithSubAlt820.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2203:4: basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignAndSkiSubAlt ) )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraintsNotCritical_in_extensionsWithSubAlt3769);
        	        basicConstraintsNotCritical821=basicConstraintsNotCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraintsNotCritical821.tree);

        	        // Grammar/RFC5280.g:2203:32: ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignAndSkiSubAlt ) )
        	        {
        	            int alt203=2;
        	            switch ( LA(1) )
        	            {
        	            case TrueTag:
        	            	{
        	            		alt203=1;
        	            	}
        	                break;
        	            case ConstructedOctetTag:
        	            case FalseTag:
        	            	{
        	            		alt203=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 203;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsWithSubAltEx;

        	            }

        	            switch (alt203)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2203:34: truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) )
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsWithSubAlt3773);
        	        	        truevalue822=truevalue(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsWithSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue822.tree);

        	        	        {
        	        	            bc_ext->critical=1;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsWithSubAlt3777);
        	        	        constructedOctetString823=constructedOctetString(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsWithSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString823.tree);

        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsWithSubAlt3779);
        	        	        sequenceTag824=sequenceTag(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsWithSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag824.tree);

        	        	        // Grammar/RFC5280.g:2203:101: ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) )
        	        	        {
        	        	            int alt199=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case FalseTag:
        	        	            case SequenceTag:
        	        	            	{
        	        	            		alt199=1;
        	        	            	}
        	        	                break;
        	        	            case TrueTag:
        	        	            	{
        	        	            		alt199=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 199;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsWithSubAltEx;

        	        	            }

        	        	            switch (alt199)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2203:103: ( falsevalue )? notDependentExtsSubAlt
        	        	        	    {
        	        	        	        // Grammar/RFC5280.g:2203:103: ( falsevalue )?
        	        	        	        {
        	        	        	            int alt197=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	                case FalseTag:
        	        	        	                	{
        	        	        	                		alt197=1;
        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt197)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2203:103: falsevalue
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsWithSubAlt3783);
        	        	        	        	        falsevalue825=falsevalue(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue825.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3786);
        	        	        	        notDependentExtsSubAlt826=notDependentExtsSubAlt(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExtsSubAlt826.tree);

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2203:140: truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt )
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsWithSubAlt3790);
        	        	        	        truevalue827=truevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue827.tree);

        	        	        	        {
        	        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        	        }


        	        	        	        // Grammar/RFC5280.g:2203:197: ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt )
        	        	        	        {
        	        	        	            int alt198=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case SequenceTag:
        	        	        	            	{
        	        	        	            		alt198=1;
        	        	        	            	}
        	        	        	                break;
        	        	        	            case Int0:
        	        	        	            case Int1:
        	        	        	            case Int2:
        	        	        	            case IntTag:
        	        	        	            	{
        	        	        	            		alt198=2;
        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                CONSTRUCTEX();
        	        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	                EXCEPTION->message      = (void *)"";
        	        	        	                EXCEPTION->decisionNum  = 198;
        	        	        	                EXCEPTION->state        = 0;


        	        	        	                goto ruleextensionsWithSubAltEx;

        	        	        	            }

        	        	        	            switch (alt198)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2203:199: extensionsNotBCSubAlt
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCSubAlt_in_extensionsWithSubAlt3796);
        	        	        	        	        extensionsNotBCSubAlt828=extensionsNotBCSubAlt(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCSubAlt828.tree);

        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // Grammar/RFC5280.g:2203:223: integer extensionsCertSignAndSkiSubAlt
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_integer_in_extensionsWithSubAlt3800);
        	        	        	        	        integer829=integer(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, integer829.tree);

        	        	        	        	        {
        	        	        	        	            bc_ext->value->basic_constraints->pathlen=integer829.text
        	        	        	        	            ;
        	        	        	        	        }


        	        	        	        	        FOLLOWPUSH(FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsWithSubAlt3804);
        	        	        	        	        extensionsCertSignAndSkiSubAlt830=extensionsCertSignAndSkiSubAlt(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignAndSkiSubAlt830.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2204:6: ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignAndSkiSubAlt )
        	        	    {
        	        	        // Grammar/RFC5280.g:2204:6: ( falsevalue )?
        	        	        {
        	        	            int alt200=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case FalseTag:
        	        	                	{
        	        	                		alt200=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt200)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2204:6: falsevalue
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsWithSubAlt3814);
        	        	        	        falsevalue831=falsevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue831.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsWithSubAlt3817);
        	        	        constructedOctetString832=constructedOctetString(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsWithSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString832.tree);

        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsWithSubAlt3819);
        	        	        sequenceTag833=sequenceTag(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsWithSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag833.tree);

        	        	        // Grammar/RFC5280.g:2204:53: ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignAndSkiSubAlt )
        	        	        {
        	        	            int alt202=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case FalseTag:
        	        	            case SequenceTag:
        	        	            	{
        	        	            		alt202=1;
        	        	            	}
        	        	                break;
        	        	            case TrueTag:
        	        	            	{
        	        	            		alt202=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 202;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsWithSubAltEx;

        	        	            }

        	        	            switch (alt202)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2204:55: ( falsevalue )? notDependentExtsSubAlt
        	        	        	    {
        	        	        	        // Grammar/RFC5280.g:2204:55: ( falsevalue )?
        	        	        	        {
        	        	        	            int alt201=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	                case FalseTag:
        	        	        	                	{
        	        	        	                		alt201=1;
        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt201)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2204:55: falsevalue
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsWithSubAlt3823);
        	        	        	        	        falsevalue834=falsevalue(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue834.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExtsSubAlt_in_extensionsWithSubAlt3826);
        	        	        	        notDependentExtsSubAlt835=notDependentExtsSubAlt(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExtsSubAlt835.tree);

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2204:92: truevalue extensionsNotCertSignAndSkiSubAlt
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsWithSubAlt3830);
        	        	        	        truevalue836=truevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue836.tree);

        	        	        	        {
        	        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        	        }


        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsWithSubAlt3834);
        	        	        	        extensionsNotCertSignAndSkiSubAlt837=extensionsNotCertSignAndSkiSubAlt(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsWithSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignAndSkiSubAlt837.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2205:4: keyUsageCommon ( bitstring extensionsNoPathLenSubAlt | bitstringCertSign extensionsMustBeCAandSkiSubAlt )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsWithSubAlt3843);
        	        keyUsageCommon838=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon838.tree);

        	        // Grammar/RFC5280.g:2205:19: ( bitstring extensionsNoPathLenSubAlt | bitstringCertSign extensionsMustBeCAandSkiSubAlt )
        	        {
        	            int alt204=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt204=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt204=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt204=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 204;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsWithSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 204;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsWithSubAltEx;

        	            }

        	            switch (alt204)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2205:20: bitstring extensionsNoPathLenSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsWithSubAlt3846);
        	        	        bitstring839=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsWithSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring839.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring839.text
        	        	            ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLenSubAlt_in_extensionsWithSubAlt3850);
        	        	        extensionsNoPathLenSubAlt840=extensionsNoPathLenSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsWithSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLenSubAlt840.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2205:110: bitstringCertSign extensionsMustBeCAandSkiSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsWithSubAlt3854);
        	        	        bitstringCertSign841=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsWithSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign841.tree);

        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsWithSubAlt3856);
        	        	        extensionsMustBeCAandSkiSubAlt842=extensionsMustBeCAandSkiSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsWithSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCAandSkiSubAlt842.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2206:4: dependentExtension extensionsMustBeCaAndSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsWithSubAlt3862);
        	        dependentExtension843=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension843.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsWithSubAlt3864);
        	        extensionsMustBeCaAndSkiSubAlt844=extensionsMustBeCaAndSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSkiSubAlt844.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:2207:4: subjectKeyId extensionsNoSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsWithSubAlt3869);
        	        subjectKeyId845=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId845.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNoSkiSubAlt_in_extensionsWithSubAlt3871);
        	        extensionsNoSkiSubAlt846=extensionsNoSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoSkiSubAlt846.tree);

        	    }
        	    break;
        	case 6:
        	    // Grammar/RFC5280.g:2208:4: subAltNameCritical extensions
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsWithSubAlt3876);
        	        subAltNameCritical847=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical847.tree);

        	        FOLLOWPUSH(FOLLOW_extensions_in_extensionsWithSubAlt3878);
        	        extensions848=extensions(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsWithSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions848.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsWithSubAltEx; /* Prevent compiler warnings */
    ruleextensionsWithSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsWithSubAlt */

/**
 * $ANTLR start extensionsNoSkiSubAlt
 * Grammar/RFC5280.g:2211:1: extensionsNoSkiSubAlt : ( extensionNoSubAlt extensionsNoSkiSubAlt | basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignSubAlt ) ) | keyUsageCommon ( bitstring extensionsNoPathLenNoSkiSubAlt | bitstringCertSign extensionsMustBeCASubAlt ) | dependentExtension extensionsMustBeCaSubAlt | subAltNameCritical (| extensionsNoSki ) );
 */
static RFC5280Parser_extensionsNoSkiSubAlt_return
extensionsNoSkiSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNoSkiSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt849;
    #undef	RETURN_TYPE_extensionNoSubAlt849
    #define	RETURN_TYPE_extensionNoSubAlt849 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNoSkiSubAlt_return extensionsNoSkiSubAlt850;
    #undef	RETURN_TYPE_extensionsNoSkiSubAlt850
    #define	RETURN_TYPE_extensionsNoSkiSubAlt850 RFC5280Parser_extensionsNoSkiSubAlt_return

    RFC5280Parser_basicConstraintsNotCritical_return basicConstraintsNotCritical851;
    #undef	RETURN_TYPE_basicConstraintsNotCritical851
    #define	RETURN_TYPE_basicConstraintsNotCritical851 RFC5280Parser_basicConstraintsNotCritical_return

    RFC5280Parser_truevalue_return truevalue852;
    #undef	RETURN_TYPE_truevalue852
    #define	RETURN_TYPE_truevalue852 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString853;
    #undef	RETURN_TYPE_constructedOctetString853
    #define	RETURN_TYPE_constructedOctetString853 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag854;
    #undef	RETURN_TYPE_sequenceTag854
    #define	RETURN_TYPE_sequenceTag854 RFC5280Parser_sequenceTag_return

    RFC5280Parser_falsevalue_return falsevalue855;
    #undef	RETURN_TYPE_falsevalue855
    #define	RETURN_TYPE_falsevalue855 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExtsSubAlt_return notDependentExtsSubAlt856;
    #undef	RETURN_TYPE_notDependentExtsSubAlt856
    #define	RETURN_TYPE_notDependentExtsSubAlt856 RFC5280Parser_notDependentExtsSubAlt_return

    RFC5280Parser_truevalue_return truevalue857;
    #undef	RETURN_TYPE_truevalue857
    #define	RETURN_TYPE_truevalue857 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotSkiSubAlt_return extensionsNotBCNotSkiSubAlt858;
    #undef	RETURN_TYPE_extensionsNotBCNotSkiSubAlt858
    #define	RETURN_TYPE_extensionsNotBCNotSkiSubAlt858 RFC5280Parser_extensionsNotBCNotSkiSubAlt_return

    RFC5280Parser_integer_return integer859;
    #undef	RETURN_TYPE_integer859
    #define	RETURN_TYPE_integer859 RFC5280Parser_integer_return

    RFC5280Parser_extensionsCertSignSubAlt_return extensionsCertSignSubAlt860;
    #undef	RETURN_TYPE_extensionsCertSignSubAlt860
    #define	RETURN_TYPE_extensionsCertSignSubAlt860 RFC5280Parser_extensionsCertSignSubAlt_return

    RFC5280Parser_falsevalue_return falsevalue861;
    #undef	RETURN_TYPE_falsevalue861
    #define	RETURN_TYPE_falsevalue861 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString862;
    #undef	RETURN_TYPE_constructedOctetString862
    #define	RETURN_TYPE_constructedOctetString862 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag863;
    #undef	RETURN_TYPE_sequenceTag863
    #define	RETURN_TYPE_sequenceTag863 RFC5280Parser_sequenceTag_return

    RFC5280Parser_falsevalue_return falsevalue864;
    #undef	RETURN_TYPE_falsevalue864
    #define	RETURN_TYPE_falsevalue864 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExtsSubAlt_return notDependentExtsSubAlt865;
    #undef	RETURN_TYPE_notDependentExtsSubAlt865
    #define	RETURN_TYPE_notDependentExtsSubAlt865 RFC5280Parser_notDependentExtsSubAlt_return

    RFC5280Parser_truevalue_return truevalue866;
    #undef	RETURN_TYPE_truevalue866
    #define	RETURN_TYPE_truevalue866 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotCertSignSubAlt_return extensionsNotCertSignSubAlt867;
    #undef	RETURN_TYPE_extensionsNotCertSignSubAlt867
    #define	RETURN_TYPE_extensionsNotCertSignSubAlt867 RFC5280Parser_extensionsNotCertSignSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon868;
    #undef	RETURN_TYPE_keyUsageCommon868
    #define	RETURN_TYPE_keyUsageCommon868 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring869;
    #undef	RETURN_TYPE_bitstring869
    #define	RETURN_TYPE_bitstring869 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsNoPathLenNoSkiSubAlt_return extensionsNoPathLenNoSkiSubAlt870;
    #undef	RETURN_TYPE_extensionsNoPathLenNoSkiSubAlt870
    #define	RETURN_TYPE_extensionsNoPathLenNoSkiSubAlt870 RFC5280Parser_extensionsNoPathLenNoSkiSubAlt_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign871;
    #undef	RETURN_TYPE_bitstringCertSign871
    #define	RETURN_TYPE_bitstringCertSign871 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsMustBeCASubAlt_return extensionsMustBeCASubAlt872;
    #undef	RETURN_TYPE_extensionsMustBeCASubAlt872
    #define	RETURN_TYPE_extensionsMustBeCASubAlt872 RFC5280Parser_extensionsMustBeCASubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension873;
    #undef	RETURN_TYPE_dependentExtension873
    #define	RETURN_TYPE_dependentExtension873 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaSubAlt_return extensionsMustBeCaSubAlt874;
    #undef	RETURN_TYPE_extensionsMustBeCaSubAlt874
    #define	RETURN_TYPE_extensionsMustBeCaSubAlt874 RFC5280Parser_extensionsMustBeCaSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical875;
    #undef	RETURN_TYPE_subAltNameCritical875
    #define	RETURN_TYPE_subAltNameCritical875 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNoSki_return extensionsNoSki876;
    #undef	RETURN_TYPE_extensionsNoSki876
    #define	RETURN_TYPE_extensionsNoSki876 RFC5280Parser_extensionsNoSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt849.tree = NULL;

    extensionsNoSkiSubAlt850.tree = NULL;

    basicConstraintsNotCritical851.tree = NULL;

    truevalue852.tree = NULL;

    constructedOctetString853.tree = NULL;

    sequenceTag854.tree = NULL;

    falsevalue855.tree = NULL;

    notDependentExtsSubAlt856.tree = NULL;

    truevalue857.tree = NULL;

    extensionsNotBCNotSkiSubAlt858.tree = NULL;

    integer859.tree = NULL;

    extensionsCertSignSubAlt860.tree = NULL;

    falsevalue861.tree = NULL;

    constructedOctetString862.tree = NULL;

    sequenceTag863.tree = NULL;

    falsevalue864.tree = NULL;

    notDependentExtsSubAlt865.tree = NULL;

    truevalue866.tree = NULL;

    extensionsNotCertSignSubAlt867.tree = NULL;

    keyUsageCommon868.tree = NULL;

    bitstring869.tree = NULL;

    extensionsNoPathLenNoSkiSubAlt870.tree = NULL;

    bitstringCertSign871.tree = NULL;

    extensionsMustBeCASubAlt872.tree = NULL;

    dependentExtension873.tree = NULL;

    extensionsMustBeCaSubAlt874.tree = NULL;

    subAltNameCritical875.tree = NULL;

    extensionsNoSki876.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2218:2: ( extensionNoSubAlt extensionsNoSkiSubAlt | basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignSubAlt ) ) | keyUsageCommon ( bitstring extensionsNoPathLenNoSkiSubAlt | bitstringCertSign extensionsMustBeCASubAlt ) | dependentExtension extensionsMustBeCaSubAlt | subAltNameCritical (| extensionsNoSki ) )

            ANTLR3_UINT32 alt215;

            alt215=5;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt215=1;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt215=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt215=3;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt215=4;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt215=5;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 215;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNoSkiSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 215;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNoSkiSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 215;
                EXCEPTION->state        = 0;


                goto ruleextensionsNoSkiSubAltEx;

            }

            switch (alt215)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2219:3: extensionNoSubAlt extensionsNoSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNoSkiSubAlt3902);
        	        extensionNoSubAlt849=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt849.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNoSkiSubAlt_in_extensionsNoSkiSubAlt3904);
        	        extensionsNoSkiSubAlt850=extensionsNoSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoSkiSubAlt850.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2220:4: basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignSubAlt ) )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraintsNotCritical_in_extensionsNoSkiSubAlt3909);
        	        basicConstraintsNotCritical851=basicConstraintsNotCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraintsNotCritical851.tree);

        	        // Grammar/RFC5280.g:2220:32: ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignSubAlt ) )
        	        {
        	            int alt212=2;
        	            switch ( LA(1) )
        	            {
        	            case TrueTag:
        	            	{
        	            		alt212=1;
        	            	}
        	                break;
        	            case ConstructedOctetTag:
        	            case FalseTag:
        	            	{
        	            		alt212=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 212;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoSkiSubAltEx;

        	            }

        	            switch (alt212)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2220:34: truevalue constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) )
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoSkiSubAlt3913);
        	        	        truevalue852=truevalue(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue852.tree);

        	        	        {
        	        	            bc_ext->critical=1;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3917);
        	        	        constructedOctetString853=constructedOctetString(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString853.tree);

        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3919);
        	        	        sequenceTag854=sequenceTag(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag854.tree);

        	        	        // Grammar/RFC5280.g:2220:101: ( ( falsevalue )? notDependentExtsSubAlt | truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) )
        	        	        {
        	        	            int alt208=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case FalseTag:
        	        	            case SequenceTag:
        	        	            	{
        	        	            		alt208=1;
        	        	            	}
        	        	                break;
        	        	            case TrueTag:
        	        	            	{
        	        	            		alt208=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 208;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsNoSkiSubAltEx;

        	        	            }

        	        	            switch (alt208)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2220:103: ( falsevalue )? notDependentExtsSubAlt
        	        	        	    {
        	        	        	        // Grammar/RFC5280.g:2220:103: ( falsevalue )?
        	        	        	        {
        	        	        	            int alt206=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	                case FalseTag:
        	        	        	                	{
        	        	        	                		alt206=1;
        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt206)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2220:103: falsevalue
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3923);
        	        	        	        	        falsevalue855=falsevalue(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue855.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3926);
        	        	        	        notDependentExtsSubAlt856=notDependentExtsSubAlt(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExtsSubAlt856.tree);

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2220:140: truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt )
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoSkiSubAlt3930);
        	        	        	        truevalue857=truevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue857.tree);

        	        	        	        {
        	        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        	        }


        	        	        	        // Grammar/RFC5280.g:2220:197: ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt )
        	        	        	        {
        	        	        	            int alt207=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case SequenceTag:
        	        	        	            	{
        	        	        	            		alt207=1;
        	        	        	            	}
        	        	        	                break;
        	        	        	            case Int0:
        	        	        	            case Int1:
        	        	        	            case Int2:
        	        	        	            case IntTag:
        	        	        	            	{
        	        	        	            		alt207=2;
        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                CONSTRUCTEX();
        	        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	                EXCEPTION->message      = (void *)"";
        	        	        	                EXCEPTION->decisionNum  = 207;
        	        	        	                EXCEPTION->state        = 0;


        	        	        	                goto ruleextensionsNoSkiSubAltEx;

        	        	        	            }

        	        	        	            switch (alt207)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2220:199: extensionsNotBCNotSkiSubAlt
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNoSkiSubAlt3936);
        	        	        	        	        extensionsNotBCNotSkiSubAlt858=extensionsNotBCNotSkiSubAlt(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSkiSubAlt858.tree);

        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // Grammar/RFC5280.g:2220:229: integer extensionsCertSignSubAlt
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_integer_in_extensionsNoSkiSubAlt3940);
        	        	        	        	        integer859=integer(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, integer859.tree);

        	        	        	        	        {
        	        	        	        	            bc_ext->value->basic_constraints->pathlen=integer859.text
        	        	        	        	            ;
        	        	        	        	        }


        	        	        	        	        FOLLOWPUSH(FOLLOW_extensionsCertSignSubAlt_in_extensionsNoSkiSubAlt3944);
        	        	        	        	        extensionsCertSignSubAlt860=extensionsCertSignSubAlt(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignSubAlt860.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2221:6: ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignSubAlt )
        	        	    {
        	        	        // Grammar/RFC5280.g:2221:6: ( falsevalue )?
        	        	        {
        	        	            int alt209=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case FalseTag:
        	        	                	{
        	        	                		alt209=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt209)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2221:6: falsevalue
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3954);
        	        	        	        falsevalue861=falsevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue861.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsNoSkiSubAlt3957);
        	        	        constructedOctetString862=constructedOctetString(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString862.tree);

        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsNoSkiSubAlt3959);
        	        	        sequenceTag863=sequenceTag(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag863.tree);

        	        	        // Grammar/RFC5280.g:2221:53: ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotCertSignSubAlt )
        	        	        {
        	        	            int alt211=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case FalseTag:
        	        	            case SequenceTag:
        	        	            	{
        	        	            		alt211=1;
        	        	            	}
        	        	                break;
        	        	            case TrueTag:
        	        	            	{
        	        	            		alt211=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 211;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsNoSkiSubAltEx;

        	        	            }

        	        	            switch (alt211)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2221:55: ( falsevalue )? notDependentExtsSubAlt
        	        	        	    {
        	        	        	        // Grammar/RFC5280.g:2221:55: ( falsevalue )?
        	        	        	        {
        	        	        	            int alt210=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	                case FalseTag:
        	        	        	                	{
        	        	        	                		alt210=1;
        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt210)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2221:55: falsevalue
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoSkiSubAlt3963);
        	        	        	        	        falsevalue864=falsevalue(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue864.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExtsSubAlt_in_extensionsNoSkiSubAlt3966);
        	        	        	        notDependentExtsSubAlt865=notDependentExtsSubAlt(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExtsSubAlt865.tree);

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2221:92: truevalue extensionsNotCertSignSubAlt
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoSkiSubAlt3970);
        	        	        	        truevalue866=truevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue866.tree);

        	        	        	        {
        	        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        	        }


        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNoSkiSubAlt3974);
        	        	        	        extensionsNotCertSignSubAlt867=extensionsNotCertSignSubAlt(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignSubAlt867.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2222:4: keyUsageCommon ( bitstring extensionsNoPathLenNoSkiSubAlt | bitstringCertSign extensionsMustBeCASubAlt )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNoSkiSubAlt3983);
        	        keyUsageCommon868=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon868.tree);

        	        // Grammar/RFC5280.g:2222:19: ( bitstring extensionsNoPathLenNoSkiSubAlt | bitstringCertSign extensionsMustBeCASubAlt )
        	        {
        	            int alt213=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt213=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt213=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt213=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 213;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsNoSkiSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 213;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoSkiSubAltEx;

        	            }

        	            switch (alt213)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2222:20: bitstring extensionsNoPathLenNoSkiSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNoSkiSubAlt3986);
        	        	        bitstring869=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring869.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring869.text
        	        	            ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoSkiSubAlt3990);
        	        	        extensionsNoPathLenNoSkiSubAlt870=extensionsNoPathLenNoSkiSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLenNoSkiSubAlt870.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2222:115: bitstringCertSign extensionsMustBeCASubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsNoSkiSubAlt3994);
        	        	        bitstringCertSign871=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign871.tree);

        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCASubAlt_in_extensionsNoSkiSubAlt3996);
        	        	        extensionsMustBeCASubAlt872=extensionsMustBeCASubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCASubAlt872.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2223:4: dependentExtension extensionsMustBeCaSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNoSkiSubAlt4002);
        	        dependentExtension873=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension873.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaSubAlt_in_extensionsNoSkiSubAlt4004);
        	        extensionsMustBeCaSubAlt874=extensionsMustBeCaSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaSubAlt874.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:2224:4: subAltNameCritical (| extensionsNoSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsNoSkiSubAlt4009);
        	        subAltNameCritical875=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical875.tree);

        	        // Grammar/RFC5280.g:2224:23: (| extensionsNoSki )
        	        {
        	            int alt214=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt214=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDBC:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt214=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 214;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNoSkiSubAltEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 214;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNoSkiSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 214;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoSkiSubAltEx;

        	            }

        	            switch (alt214)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2224:25: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2224:26: extensionsNoSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNoSki_in_extensionsNoSkiSubAlt4014);
        	        	        extensionsNoSki876=extensionsNoSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoSki876.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNoSkiSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNoSkiSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNoSkiSubAlt */

/**
 * $ANTLR start extensions
 * Grammar/RFC5280.g:2227:1: extensions : ( extension (| extensions ) | basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotCertSignAndSki ) ) | keyUsageCommon ( bitstring (| extensionsNoPathLen ) | bitstringCertSign extensionsMustBeCAandSki ) | dependentExtension extensionsMustBeCaAndSki | subjectKeyId ( extensionsNoSki )? );
 */
static RFC5280Parser_extensions_return
extensions(pRFC5280Parser ctx)
{
    RFC5280Parser_extensions_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension877;
    #undef	RETURN_TYPE_extension877
    #define	RETURN_TYPE_extension877 RFC5280Parser_extension_return

    RFC5280Parser_extensions_return extensions878;
    #undef	RETURN_TYPE_extensions878
    #define	RETURN_TYPE_extensions878 RFC5280Parser_extensions_return

    RFC5280Parser_basicConstraintsNotCritical_return basicConstraintsNotCritical879;
    #undef	RETURN_TYPE_basicConstraintsNotCritical879
    #define	RETURN_TYPE_basicConstraintsNotCritical879 RFC5280Parser_basicConstraintsNotCritical_return

    RFC5280Parser_truevalue_return truevalue880;
    #undef	RETURN_TYPE_truevalue880
    #define	RETURN_TYPE_truevalue880 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString881;
    #undef	RETURN_TYPE_constructedOctetString881
    #define	RETURN_TYPE_constructedOctetString881 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag882;
    #undef	RETURN_TYPE_sequenceTag882
    #define	RETURN_TYPE_sequenceTag882 RFC5280Parser_sequenceTag_return

    RFC5280Parser_falsevalue_return falsevalue883;
    #undef	RETURN_TYPE_falsevalue883
    #define	RETURN_TYPE_falsevalue883 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExts_return notDependentExts884;
    #undef	RETURN_TYPE_notDependentExts884
    #define	RETURN_TYPE_notDependentExts884 RFC5280Parser_notDependentExts_return

    RFC5280Parser_truevalue_return truevalue885;
    #undef	RETURN_TYPE_truevalue885
    #define	RETURN_TYPE_truevalue885 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBC_return extensionsNotBC886;
    #undef	RETURN_TYPE_extensionsNotBC886
    #define	RETURN_TYPE_extensionsNotBC886 RFC5280Parser_extensionsNotBC_return

    RFC5280Parser_integer_return integer887;
    #undef	RETURN_TYPE_integer887
    #define	RETURN_TYPE_integer887 RFC5280Parser_integer_return

    RFC5280Parser_extensionsCertSignAndSki_return extensionsCertSignAndSki888;
    #undef	RETURN_TYPE_extensionsCertSignAndSki888
    #define	RETURN_TYPE_extensionsCertSignAndSki888 RFC5280Parser_extensionsCertSignAndSki_return

    RFC5280Parser_falsevalue_return falsevalue889;
    #undef	RETURN_TYPE_falsevalue889
    #define	RETURN_TYPE_falsevalue889 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString890;
    #undef	RETURN_TYPE_constructedOctetString890
    #define	RETURN_TYPE_constructedOctetString890 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag891;
    #undef	RETURN_TYPE_sequenceTag891
    #define	RETURN_TYPE_sequenceTag891 RFC5280Parser_sequenceTag_return

    RFC5280Parser_falsevalue_return falsevalue892;
    #undef	RETURN_TYPE_falsevalue892
    #define	RETURN_TYPE_falsevalue892 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExts_return notDependentExts893;
    #undef	RETURN_TYPE_notDependentExts893
    #define	RETURN_TYPE_notDependentExts893 RFC5280Parser_notDependentExts_return

    RFC5280Parser_truevalue_return truevalue894;
    #undef	RETURN_TYPE_truevalue894
    #define	RETURN_TYPE_truevalue894 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotCertSignAndSki_return extensionsNotCertSignAndSki895;
    #undef	RETURN_TYPE_extensionsNotCertSignAndSki895
    #define	RETURN_TYPE_extensionsNotCertSignAndSki895 RFC5280Parser_extensionsNotCertSignAndSki_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon896;
    #undef	RETURN_TYPE_keyUsageCommon896
    #define	RETURN_TYPE_keyUsageCommon896 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring897;
    #undef	RETURN_TYPE_bitstring897
    #define	RETURN_TYPE_bitstring897 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsNoPathLen_return extensionsNoPathLen898;
    #undef	RETURN_TYPE_extensionsNoPathLen898
    #define	RETURN_TYPE_extensionsNoPathLen898 RFC5280Parser_extensionsNoPathLen_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign899;
    #undef	RETURN_TYPE_bitstringCertSign899
    #define	RETURN_TYPE_bitstringCertSign899 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsMustBeCAandSki_return extensionsMustBeCAandSki900;
    #undef	RETURN_TYPE_extensionsMustBeCAandSki900
    #define	RETURN_TYPE_extensionsMustBeCAandSki900 RFC5280Parser_extensionsMustBeCAandSki_return

    RFC5280Parser_dependentExtension_return dependentExtension901;
    #undef	RETURN_TYPE_dependentExtension901
    #define	RETURN_TYPE_dependentExtension901 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaAndSki_return extensionsMustBeCaAndSki902;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSki902
    #define	RETURN_TYPE_extensionsMustBeCaAndSki902 RFC5280Parser_extensionsMustBeCaAndSki_return

    RFC5280Parser_subjectKeyId_return subjectKeyId903;
    #undef	RETURN_TYPE_subjectKeyId903
    #define	RETURN_TYPE_subjectKeyId903 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNoSki_return extensionsNoSki904;
    #undef	RETURN_TYPE_extensionsNoSki904
    #define	RETURN_TYPE_extensionsNoSki904 RFC5280Parser_extensionsNoSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    if(cert->extensions == NULL)
    		cert->extensions = sk_x509_EXTENSION_new_null();
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif	
    	
    extension877.tree = NULL;

    extensions878.tree = NULL;

    basicConstraintsNotCritical879.tree = NULL;

    truevalue880.tree = NULL;

    constructedOctetString881.tree = NULL;

    sequenceTag882.tree = NULL;

    falsevalue883.tree = NULL;

    notDependentExts884.tree = NULL;

    truevalue885.tree = NULL;

    extensionsNotBC886.tree = NULL;

    integer887.tree = NULL;

    extensionsCertSignAndSki888.tree = NULL;

    falsevalue889.tree = NULL;

    constructedOctetString890.tree = NULL;

    sequenceTag891.tree = NULL;

    falsevalue892.tree = NULL;

    notDependentExts893.tree = NULL;

    truevalue894.tree = NULL;

    extensionsNotCertSignAndSki895.tree = NULL;

    keyUsageCommon896.tree = NULL;

    bitstring897.tree = NULL;

    extensionsNoPathLen898.tree = NULL;

    bitstringCertSign899.tree = NULL;

    extensionsMustBeCAandSki900.tree = NULL;

    dependentExtension901.tree = NULL;

    extensionsMustBeCaAndSki902.tree = NULL;

    subjectKeyId903.tree = NULL;

    extensionsNoSki904.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2236:2: ( extension (| extensions ) | basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotCertSignAndSki ) ) | keyUsageCommon ( bitstring (| extensionsNoPathLen ) | bitstringCertSign extensionsMustBeCAandSki ) | dependentExtension extensionsMustBeCaAndSki | subjectKeyId ( extensionsNoSki )? )

            ANTLR3_UINT32 alt229;

            alt229=5;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt229=1;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt229=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt229=3;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt229=4;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt229=5;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 229;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 229;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 229;
                EXCEPTION->state        = 0;


                goto ruleextensionsEx;

            }

            switch (alt229)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2236:4: extension (| extensions )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensions4036);
        	        extension877=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension877.tree);

        	        // Grammar/RFC5280.g:2236:14: (| extensions )
        	        {
        	            int alt216=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt216=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDBC:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSKI:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt216=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 216;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 216;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 216;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsEx;

        	            }

        	            switch (alt216)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2236:16: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2236:17: extensions
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensions_in_extensions4041);
        	        	        extensions878=extensions(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensions878.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2237:4: basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotCertSignAndSki ) )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraintsNotCritical_in_extensions4047);
        	        basicConstraintsNotCritical879=basicConstraintsNotCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraintsNotCritical879.tree);

        	        // Grammar/RFC5280.g:2237:32: ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotCertSignAndSki ) )
        	        {
        	            int alt225=2;
        	            switch ( LA(1) )
        	            {
        	            case TrueTag:
        	            	{
        	            		alt225=1;
        	            	}
        	                break;
        	            case ConstructedOctetTag:
        	            case FalseTag:
        	            	{
        	            		alt225=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 225;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsEx;

        	            }

        	            switch (alt225)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2237:34: truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) )
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensions4051);
        	        	        truevalue880=truevalue(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue880.tree);

        	        	        {
        	        	            bc_ext->critical=1;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensions4055);
        	        	        constructedOctetString881=constructedOctetString(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString881.tree);

        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensions4057);
        	        	        sequenceTag882=sequenceTag(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag882.tree);

        	        	        // Grammar/RFC5280.g:2237:101: ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) )
        	        	        {
        	        	            int alt220=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case FalseTag:
        	        	            case SequenceTag:
        	        	            	{
        	        	            		alt220=1;
        	        	            	}
        	        	                break;
        	        	            case TrueTag:
        	        	            	{
        	        	            		alt220=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 220;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsEx;

        	        	            }

        	        	            switch (alt220)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2237:103: ( falsevalue )? (| notDependentExts )
        	        	        	    {
        	        	        	        // Grammar/RFC5280.g:2237:103: ( falsevalue )?
        	        	        	        {
        	        	        	            int alt217=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	                case FalseTag:
        	        	        	                	{
        	        	        	                		alt217=1;
        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt217)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2237:103: falsevalue
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensions4061);
        	        	        	        	        falsevalue883=falsevalue(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue883.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	        // Grammar/RFC5280.g:2237:115: (| notDependentExts )
        	        	        	        {
        	        	        	            int alt218=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case SequenceTag:
        	        	        	            	{
        	        	        	            		switch ( LA(2) )
        	        	        	            		{
        	        	        	            		case OIDTag:
        	        	        	            			{
        	        	        	            				switch ( LA(3) )
        	        	        	            				{
        	        	        	            				case GOST01SIGN:
        	        	        	            				case GOST94SIGN:
        	        	        	            				case MD2RSAOID:
        	        	        	            				case MD5RSAOID:
        	        	        	            				case RSAPSSOID:
        	        	        	            				case SHA1DSAOID:
        	        	        	            				case SHA1ECOID:
        	        	        	            				case SHA1RSAOID:
        	        	        	            				case SHA224DSAOID:
        	        	        	            				case SHA224ECOID:
        	        	        	            				case SHA224RSAOID:
        	        	        	            				case SHA256DSAOID:
        	        	        	            				case SHA256ECOID:
        	        	        	            				case SHA256RSAOID:
        	        	        	            				case SHA384ECOID:
        	        	        	            				case SHA384RSAOID:
        	        	        	            				case SHA512ECOID:
        	        	        	            				case SHA512RSAOID:
        	        	        	            					{
        	        	        	            						alt218=1;
        	        	        	            					}
        	        	        	            				    break;
        	        	        	            				case AIAOID:
        	        	        	            				case OIDAKI:
        	        	        	            				case OIDCERTPOL:
        	        	        	            				case OIDCRL:
        	        	        	            				case OIDEXTKEY:
        	        	        	            				case OIDFRESHCRL:
        	        	        	            				case OIDISSALT:
        	        	        	            				case OIDKEYUS:
        	        	        	            				case OIDSKI:
        	        	        	            				case OIDSUBALT:
        	        	        	            				case OIDSUBDIR:
        	        	        	            				case PRINTABLE:
        	        	        	            				case SIAOID:
        	        	        	            				case VALUE:
        	        	        	            					{
        	        	        	            						alt218=2;
        	        	        	            					}
        	        	        	            				    break;

        	        	        	            				default:
        	        	        	            				    CONSTRUCTEX();
        	        	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	            				    EXCEPTION->message      = (void *)"";
        	        	        	            				    EXCEPTION->decisionNum  = 218;
        	        	        	            				    EXCEPTION->state        = 2;


        	        	        	            				    goto ruleextensionsEx;

        	        	        	            				}

        	        	        	            			}
        	        	        	            		    break;

        	        	        	            		default:
        	        	        	            		    CONSTRUCTEX();
        	        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	            		    EXCEPTION->message      = (void *)"";
        	        	        	            		    EXCEPTION->decisionNum  = 218;
        	        	        	            		    EXCEPTION->state        = 1;


        	        	        	            		    goto ruleextensionsEx;

        	        	        	            		}

        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                CONSTRUCTEX();
        	        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	                EXCEPTION->message      = (void *)"";
        	        	        	                EXCEPTION->decisionNum  = 218;
        	        	        	                EXCEPTION->state        = 0;


        	        	        	                goto ruleextensionsEx;

        	        	        	            }

        	        	        	            switch (alt218)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2237:117: 
        	        	        	        	    {
        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // Grammar/RFC5280.g:2237:118: notDependentExts
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExts_in_extensions4067);
        	        	        	        	        notDependentExts884=notDependentExts(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExts884.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2237:138: truevalue ( extensionsNotBC | integer extensionsCertSignAndSki )
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensions4072);
        	        	        	        truevalue885=truevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue885.tree);

        	        	        	        {
        	        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        	        }


        	        	        	        // Grammar/RFC5280.g:2237:195: ( extensionsNotBC | integer extensionsCertSignAndSki )
        	        	        	        {
        	        	        	            int alt219=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case SequenceTag:
        	        	        	            	{
        	        	        	            		alt219=1;
        	        	        	            	}
        	        	        	                break;
        	        	        	            case Int0:
        	        	        	            case Int1:
        	        	        	            case Int2:
        	        	        	            case IntTag:
        	        	        	            	{
        	        	        	            		alt219=2;
        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                CONSTRUCTEX();
        	        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	                EXCEPTION->message      = (void *)"";
        	        	        	                EXCEPTION->decisionNum  = 219;
        	        	        	                EXCEPTION->state        = 0;


        	        	        	                goto ruleextensionsEx;

        	        	        	            }

        	        	        	            switch (alt219)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2237:197: extensionsNotBC
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBC_in_extensions4078);
        	        	        	        	        extensionsNotBC886=extensionsNotBC(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBC886.tree);

        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // Grammar/RFC5280.g:2237:215: integer extensionsCertSignAndSki
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_integer_in_extensions4082);
        	        	        	        	        integer887=integer(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, integer887.tree);

        	        	        	        	        {
        	        	        	        	            bc_ext->value->basic_constraints->pathlen=integer887.text
        	        	        	        	            ;
        	        	        	        	        }


        	        	        	        	        FOLLOWPUSH(FOLLOW_extensionsCertSignAndSki_in_extensions4086);
        	        	        	        	        extensionsCertSignAndSki888=extensionsCertSignAndSki(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignAndSki888.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2238:6: ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotCertSignAndSki )
        	        	    {
        	        	        // Grammar/RFC5280.g:2238:6: ( falsevalue )?
        	        	        {
        	        	            int alt221=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case FalseTag:
        	        	                	{
        	        	                		alt221=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt221)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2238:6: falsevalue
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensions4096);
        	        	        	        falsevalue889=falsevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue889.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensions4099);
        	        	        constructedOctetString890=constructedOctetString(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString890.tree);

        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensions4101);
        	        	        sequenceTag891=sequenceTag(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag891.tree);

        	        	        // Grammar/RFC5280.g:2238:53: ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotCertSignAndSki )
        	        	        {
        	        	            int alt224=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case FalseTag:
        	        	            case SequenceTag:
        	        	            	{
        	        	            		alt224=1;
        	        	            	}
        	        	                break;
        	        	            case TrueTag:
        	        	            	{
        	        	            		alt224=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 224;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsEx;

        	        	            }

        	        	            switch (alt224)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2238:55: ( falsevalue )? (| notDependentExts )
        	        	        	    {
        	        	        	        // Grammar/RFC5280.g:2238:55: ( falsevalue )?
        	        	        	        {
        	        	        	            int alt222=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	                case FalseTag:
        	        	        	                	{
        	        	        	                		alt222=1;
        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt222)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2238:55: falsevalue
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensions4105);
        	        	        	        	        falsevalue892=falsevalue(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue892.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	        // Grammar/RFC5280.g:2238:67: (| notDependentExts )
        	        	        	        {
        	        	        	            int alt223=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case SequenceTag:
        	        	        	            	{
        	        	        	            		switch ( LA(2) )
        	        	        	            		{
        	        	        	            		case OIDTag:
        	        	        	            			{
        	        	        	            				switch ( LA(3) )
        	        	        	            				{
        	        	        	            				case GOST01SIGN:
        	        	        	            				case GOST94SIGN:
        	        	        	            				case MD2RSAOID:
        	        	        	            				case MD5RSAOID:
        	        	        	            				case RSAPSSOID:
        	        	        	            				case SHA1DSAOID:
        	        	        	            				case SHA1ECOID:
        	        	        	            				case SHA1RSAOID:
        	        	        	            				case SHA224DSAOID:
        	        	        	            				case SHA224ECOID:
        	        	        	            				case SHA224RSAOID:
        	        	        	            				case SHA256DSAOID:
        	        	        	            				case SHA256ECOID:
        	        	        	            				case SHA256RSAOID:
        	        	        	            				case SHA384ECOID:
        	        	        	            				case SHA384RSAOID:
        	        	        	            				case SHA512ECOID:
        	        	        	            				case SHA512RSAOID:
        	        	        	            					{
        	        	        	            						alt223=1;
        	        	        	            					}
        	        	        	            				    break;
        	        	        	            				case AIAOID:
        	        	        	            				case OIDAKI:
        	        	        	            				case OIDCERTPOL:
        	        	        	            				case OIDCRL:
        	        	        	            				case OIDEXTKEY:
        	        	        	            				case OIDFRESHCRL:
        	        	        	            				case OIDISSALT:
        	        	        	            				case OIDKEYUS:
        	        	        	            				case OIDSKI:
        	        	        	            				case OIDSUBALT:
        	        	        	            				case OIDSUBDIR:
        	        	        	            				case PRINTABLE:
        	        	        	            				case SIAOID:
        	        	        	            				case VALUE:
        	        	        	            					{
        	        	        	            						alt223=2;
        	        	        	            					}
        	        	        	            				    break;

        	        	        	            				default:
        	        	        	            				    CONSTRUCTEX();
        	        	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	            				    EXCEPTION->message      = (void *)"";
        	        	        	            				    EXCEPTION->decisionNum  = 223;
        	        	        	            				    EXCEPTION->state        = 2;


        	        	        	            				    goto ruleextensionsEx;

        	        	        	            				}

        	        	        	            			}
        	        	        	            		    break;

        	        	        	            		default:
        	        	        	            		    CONSTRUCTEX();
        	        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	            		    EXCEPTION->message      = (void *)"";
        	        	        	            		    EXCEPTION->decisionNum  = 223;
        	        	        	            		    EXCEPTION->state        = 1;


        	        	        	            		    goto ruleextensionsEx;

        	        	        	            		}

        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                CONSTRUCTEX();
        	        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	                EXCEPTION->message      = (void *)"";
        	        	        	                EXCEPTION->decisionNum  = 223;
        	        	        	                EXCEPTION->state        = 0;


        	        	        	                goto ruleextensionsEx;

        	        	        	            }

        	        	        	            switch (alt223)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2238:69: 
        	        	        	        	    {
        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // Grammar/RFC5280.g:2238:70: notDependentExts
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExts_in_extensions4111);
        	        	        	        	        notDependentExts893=notDependentExts(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExts893.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2238:90: truevalue extensionsNotCertSignAndSki
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensions4116);
        	        	        	        truevalue894=truevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue894.tree);

        	        	        	        {
        	        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        	        }


        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignAndSki_in_extensions4120);
        	        	        	        extensionsNotCertSignAndSki895=extensionsNotCertSignAndSki(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignAndSki895.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2239:4: keyUsageCommon ( bitstring (| extensionsNoPathLen ) | bitstringCertSign extensionsMustBeCAandSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensions4129);
        	        keyUsageCommon896=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon896.tree);

        	        // Grammar/RFC5280.g:2239:19: ( bitstring (| extensionsNoPathLen ) | bitstringCertSign extensionsMustBeCAandSki )
        	        {
        	            int alt227=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt227=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt227=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt227=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 227;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 227;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsEx;

        	            }

        	            switch (alt227)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2239:20: bitstring (| extensionsNoPathLen )
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensions4132);
        	        	        bitstring897=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring897.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring897.text
        	        	            ;
        	        	        }


        	        	        // Grammar/RFC5280.g:2239:82: (| extensionsNoPathLen )
        	        	        {
        	        	            int alt226=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case SequenceTag:
        	        	            	{
        	        	            		switch ( LA(2) )
        	        	            		{
        	        	            		case OIDTag:
        	        	            			{
        	        	            				switch ( LA(3) )
        	        	            				{
        	        	            				case GOST01SIGN:
        	        	            				case GOST94SIGN:
        	        	            				case MD2RSAOID:
        	        	            				case MD5RSAOID:
        	        	            				case RSAPSSOID:
        	        	            				case SHA1DSAOID:
        	        	            				case SHA1ECOID:
        	        	            				case SHA1RSAOID:
        	        	            				case SHA224DSAOID:
        	        	            				case SHA224ECOID:
        	        	            				case SHA224RSAOID:
        	        	            				case SHA256DSAOID:
        	        	            				case SHA256ECOID:
        	        	            				case SHA256RSAOID:
        	        	            				case SHA384ECOID:
        	        	            				case SHA384RSAOID:
        	        	            				case SHA512ECOID:
        	        	            				case SHA512RSAOID:
        	        	            					{
        	        	            						alt226=1;
        	        	            					}
        	        	            				    break;
        	        	            				case AIAOID:
        	        	            				case OIDAKI:
        	        	            				case OIDBC:
        	        	            				case OIDCERTPOL:
        	        	            				case OIDCRL:
        	        	            				case OIDEXTKEY:
        	        	            				case OIDFRESHCRL:
        	        	            				case OIDINHIBIT:
        	        	            				case OIDISSALT:
        	        	            				case OIDNAME:
        	        	            				case OIDPOLCONST:
        	        	            				case OIDPOLMAP:
        	        	            				case OIDSKI:
        	        	            				case OIDSUBALT:
        	        	            				case OIDSUBDIR:
        	        	            				case PRINTABLE:
        	        	            				case SIAOID:
        	        	            				case VALUE:
        	        	            					{
        	        	            						alt226=2;
        	        	            					}
        	        	            				    break;

        	        	            				default:
        	        	            				    CONSTRUCTEX();
        	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            				    EXCEPTION->message      = (void *)"";
        	        	            				    EXCEPTION->decisionNum  = 226;
        	        	            				    EXCEPTION->state        = 2;


        	        	            				    goto ruleextensionsEx;

        	        	            				}

        	        	            			}
        	        	            		    break;

        	        	            		default:
        	        	            		    CONSTRUCTEX();
        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            		    EXCEPTION->message      = (void *)"";
        	        	            		    EXCEPTION->decisionNum  = 226;
        	        	            		    EXCEPTION->state        = 1;


        	        	            		    goto ruleextensionsEx;

        	        	            		}

        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 226;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsEx;

        	        	            }

        	        	            switch (alt226)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2239:84: 
        	        	        	    {
        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2239:85: extensionsNoPathLen
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLen_in_extensions4139);
        	        	        	        extensionsNoPathLen898=extensionsNoPathLen(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLen898.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2239:108: bitstringCertSign extensionsMustBeCAandSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensions4144);
        	        	        bitstringCertSign899=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign899.tree);

        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCAandSki_in_extensions4146);
        	        	        extensionsMustBeCAandSki900=extensionsMustBeCAandSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCAandSki900.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2240:4: dependentExtension extensionsMustBeCaAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensions4152);
        	        dependentExtension901=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension901.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSki_in_extensions4154);
        	        extensionsMustBeCaAndSki902=extensionsMustBeCaAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSki902.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:2241:4: subjectKeyId ( extensionsNoSki )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensions4159);
        	        subjectKeyId903=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId903.tree);

        	        // Grammar/RFC5280.g:2241:17: ( extensionsNoSki )?
        	        {
        	            int alt228=2;
        	            switch ( LA(1) )
        	            {
        	                case SequenceTag:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case OIDTag:
        	                		    	{
        	                		    		switch ( LA(3) )
        	                		    		{
        	                		    		    case AIAOID:
        	                		    		    case OIDAKI:
        	                		    		    case OIDBC:
        	                		    		    case OIDCERTPOL:
        	                		    		    case OIDCRL:
        	                		    		    case OIDEXTKEY:
        	                		    		    case OIDFRESHCRL:
        	                		    		    case OIDINHIBIT:
        	                		    		    case OIDISSALT:
        	                		    		    case OIDKEYUS:
        	                		    		    case OIDNAME:
        	                		    		    case OIDPOLCONST:
        	                		    		    case OIDPOLMAP:
        	                		    		    case OIDSUBALT:
        	                		    		    case OIDSUBDIR:
        	                		    		    case PRINTABLE:
        	                		    		    case SIAOID:
        	                		    		    case VALUE:
        	                		    		    	{
        	                		    		    		alt228=1;
        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt228)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2241:17: extensionsNoSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNoSki_in_extensions4161);
        	        	        extensionsNoSki904=extensionsNoSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoSki904.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsEx; /* Prevent compiler warnings */
    ruleextensionsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensions */

/**
 * $ANTLR start extensionsNoSki
 * Grammar/RFC5280.g:2244:1: extensionsNoSki : ( extension (| extensionsNoSki ) | basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotCertSign )? ) ) | keyUsageCommon ( bitstring (| extensionsNoPathLenNoSki ) | bitstringCertSign extensionsMustBeCA ) | dependentExtension extensionsMustBeCa );
 */
static RFC5280Parser_extensionsNoSki_return
extensionsNoSki(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNoSki_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension905;
    #undef	RETURN_TYPE_extension905
    #define	RETURN_TYPE_extension905 RFC5280Parser_extension_return

    RFC5280Parser_extensionsNoSki_return extensionsNoSki906;
    #undef	RETURN_TYPE_extensionsNoSki906
    #define	RETURN_TYPE_extensionsNoSki906 RFC5280Parser_extensionsNoSki_return

    RFC5280Parser_basicConstraintsNotCritical_return basicConstraintsNotCritical907;
    #undef	RETURN_TYPE_basicConstraintsNotCritical907
    #define	RETURN_TYPE_basicConstraintsNotCritical907 RFC5280Parser_basicConstraintsNotCritical_return

    RFC5280Parser_truevalue_return truevalue908;
    #undef	RETURN_TYPE_truevalue908
    #define	RETURN_TYPE_truevalue908 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString909;
    #undef	RETURN_TYPE_constructedOctetString909
    #define	RETURN_TYPE_constructedOctetString909 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag910;
    #undef	RETURN_TYPE_sequenceTag910
    #define	RETURN_TYPE_sequenceTag910 RFC5280Parser_sequenceTag_return

    RFC5280Parser_falsevalue_return falsevalue911;
    #undef	RETURN_TYPE_falsevalue911
    #define	RETURN_TYPE_falsevalue911 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExts_return notDependentExts912;
    #undef	RETURN_TYPE_notDependentExts912
    #define	RETURN_TYPE_notDependentExts912 RFC5280Parser_notDependentExts_return

    RFC5280Parser_truevalue_return truevalue913;
    #undef	RETURN_TYPE_truevalue913
    #define	RETURN_TYPE_truevalue913 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotSki_return extensionsNotBCNotSki914;
    #undef	RETURN_TYPE_extensionsNotBCNotSki914
    #define	RETURN_TYPE_extensionsNotBCNotSki914 RFC5280Parser_extensionsNotBCNotSki_return

    RFC5280Parser_integer_return integer915;
    #undef	RETURN_TYPE_integer915
    #define	RETURN_TYPE_integer915 RFC5280Parser_integer_return

    RFC5280Parser_extensionsCertSign_return extensionsCertSign916;
    #undef	RETURN_TYPE_extensionsCertSign916
    #define	RETURN_TYPE_extensionsCertSign916 RFC5280Parser_extensionsCertSign_return

    RFC5280Parser_falsevalue_return falsevalue917;
    #undef	RETURN_TYPE_falsevalue917
    #define	RETURN_TYPE_falsevalue917 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString918;
    #undef	RETURN_TYPE_constructedOctetString918
    #define	RETURN_TYPE_constructedOctetString918 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag919;
    #undef	RETURN_TYPE_sequenceTag919
    #define	RETURN_TYPE_sequenceTag919 RFC5280Parser_sequenceTag_return

    RFC5280Parser_falsevalue_return falsevalue920;
    #undef	RETURN_TYPE_falsevalue920
    #define	RETURN_TYPE_falsevalue920 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExts_return notDependentExts921;
    #undef	RETURN_TYPE_notDependentExts921
    #define	RETURN_TYPE_notDependentExts921 RFC5280Parser_notDependentExts_return

    RFC5280Parser_truevalue_return truevalue922;
    #undef	RETURN_TYPE_truevalue922
    #define	RETURN_TYPE_truevalue922 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotCertSign_return extensionsNotCertSign923;
    #undef	RETURN_TYPE_extensionsNotCertSign923
    #define	RETURN_TYPE_extensionsNotCertSign923 RFC5280Parser_extensionsNotCertSign_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon924;
    #undef	RETURN_TYPE_keyUsageCommon924
    #define	RETURN_TYPE_keyUsageCommon924 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring925;
    #undef	RETURN_TYPE_bitstring925
    #define	RETURN_TYPE_bitstring925 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsNoPathLenNoSki_return extensionsNoPathLenNoSki926;
    #undef	RETURN_TYPE_extensionsNoPathLenNoSki926
    #define	RETURN_TYPE_extensionsNoPathLenNoSki926 RFC5280Parser_extensionsNoPathLenNoSki_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign927;
    #undef	RETURN_TYPE_bitstringCertSign927
    #define	RETURN_TYPE_bitstringCertSign927 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsMustBeCA_return extensionsMustBeCA928;
    #undef	RETURN_TYPE_extensionsMustBeCA928
    #define	RETURN_TYPE_extensionsMustBeCA928 RFC5280Parser_extensionsMustBeCA_return

    RFC5280Parser_dependentExtension_return dependentExtension929;
    #undef	RETURN_TYPE_dependentExtension929
    #define	RETURN_TYPE_dependentExtension929 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCa_return extensionsMustBeCa930;
    #undef	RETURN_TYPE_extensionsMustBeCa930
    #define	RETURN_TYPE_extensionsMustBeCa930 RFC5280Parser_extensionsMustBeCa_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension905.tree = NULL;

    extensionsNoSki906.tree = NULL;

    basicConstraintsNotCritical907.tree = NULL;

    truevalue908.tree = NULL;

    constructedOctetString909.tree = NULL;

    sequenceTag910.tree = NULL;

    falsevalue911.tree = NULL;

    notDependentExts912.tree = NULL;

    truevalue913.tree = NULL;

    extensionsNotBCNotSki914.tree = NULL;

    integer915.tree = NULL;

    extensionsCertSign916.tree = NULL;

    falsevalue917.tree = NULL;

    constructedOctetString918.tree = NULL;

    sequenceTag919.tree = NULL;

    falsevalue920.tree = NULL;

    notDependentExts921.tree = NULL;

    truevalue922.tree = NULL;

    extensionsNotCertSign923.tree = NULL;

    keyUsageCommon924.tree = NULL;

    bitstring925.tree = NULL;

    extensionsNoPathLenNoSki926.tree = NULL;

    bitstringCertSign927.tree = NULL;

    extensionsMustBeCA928.tree = NULL;

    dependentExtension929.tree = NULL;

    extensionsMustBeCa930.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2250:9: ( extension (| extensionsNoSki ) | basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotCertSign )? ) ) | keyUsageCommon ( bitstring (| extensionsNoPathLenNoSki ) | bitstringCertSign extensionsMustBeCA ) | dependentExtension extensionsMustBeCa )

            ANTLR3_UINT32 alt244;

            alt244=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt244=1;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt244=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt244=3;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt244=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 244;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNoSkiEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 244;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNoSkiEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 244;
                EXCEPTION->state        = 0;


                goto ruleextensionsNoSkiEx;

            }

            switch (alt244)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2251:3: extension (| extensionsNoSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsNoSki4185);
        	        extension905=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension905.tree);

        	        // Grammar/RFC5280.g:2251:13: (| extensionsNoSki )
        	        {
        	            int alt230=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt230=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDBC:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt230=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 230;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNoSkiEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 230;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNoSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 230;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoSkiEx;

        	            }

        	            switch (alt230)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2251:15: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2251:16: extensionsNoSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNoSki_in_extensionsNoSki4190);
        	        	        extensionsNoSki906=extensionsNoSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoSki906.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2252:4: basicConstraintsNotCritical ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotCertSign )? ) )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraintsNotCritical_in_extensionsNoSki4196);
        	        basicConstraintsNotCritical907=basicConstraintsNotCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraintsNotCritical907.tree);

        	        // Grammar/RFC5280.g:2252:32: ( truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) ) | ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotCertSign )? ) )
        	        {
        	            int alt241=2;
        	            switch ( LA(1) )
        	            {
        	            case TrueTag:
        	            	{
        	            		alt241=1;
        	            	}
        	                break;
        	            case ConstructedOctetTag:
        	            case FalseTag:
        	            	{
        	            		alt241=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 241;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoSkiEx;

        	            }

        	            switch (alt241)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2252:34: truevalue constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) )
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoSki4200);
        	        	        truevalue908=truevalue(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue908.tree);

        	        	        {
        	        	            bc_ext->critical=1;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsNoSki4204);
        	        	        constructedOctetString909=constructedOctetString(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString909.tree);

        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsNoSki4206);
        	        	        sequenceTag910=sequenceTag(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag910.tree);

        	        	        // Grammar/RFC5280.g:2252:101: ( ( falsevalue )? (| notDependentExts ) | truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) )
        	        	        {
        	        	            int alt235=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case FalseTag:
        	        	            case SequenceTag:
        	        	            	{
        	        	            		alt235=1;
        	        	            	}
        	        	                break;
        	        	            case TrueTag:
        	        	            	{
        	        	            		alt235=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 235;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsNoSkiEx;

        	        	            }

        	        	            switch (alt235)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2252:103: ( falsevalue )? (| notDependentExts )
        	        	        	    {
        	        	        	        // Grammar/RFC5280.g:2252:103: ( falsevalue )?
        	        	        	        {
        	        	        	            int alt231=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	                case FalseTag:
        	        	        	                	{
        	        	        	                		alt231=1;
        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt231)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2252:103: falsevalue
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoSki4210);
        	        	        	        	        falsevalue911=falsevalue(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue911.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	        // Grammar/RFC5280.g:2252:115: (| notDependentExts )
        	        	        	        {
        	        	        	            int alt232=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case SequenceTag:
        	        	        	            	{
        	        	        	            		switch ( LA(2) )
        	        	        	            		{
        	        	        	            		case OIDTag:
        	        	        	            			{
        	        	        	            				switch ( LA(3) )
        	        	        	            				{
        	        	        	            				case GOST01SIGN:
        	        	        	            				case GOST94SIGN:
        	        	        	            				case MD2RSAOID:
        	        	        	            				case MD5RSAOID:
        	        	        	            				case RSAPSSOID:
        	        	        	            				case SHA1DSAOID:
        	        	        	            				case SHA1ECOID:
        	        	        	            				case SHA1RSAOID:
        	        	        	            				case SHA224DSAOID:
        	        	        	            				case SHA224ECOID:
        	        	        	            				case SHA224RSAOID:
        	        	        	            				case SHA256DSAOID:
        	        	        	            				case SHA256ECOID:
        	        	        	            				case SHA256RSAOID:
        	        	        	            				case SHA384ECOID:
        	        	        	            				case SHA384RSAOID:
        	        	        	            				case SHA512ECOID:
        	        	        	            				case SHA512RSAOID:
        	        	        	            					{
        	        	        	            						alt232=1;
        	        	        	            					}
        	        	        	            				    break;
        	        	        	            				case AIAOID:
        	        	        	            				case OIDAKI:
        	        	        	            				case OIDCERTPOL:
        	        	        	            				case OIDCRL:
        	        	        	            				case OIDEXTKEY:
        	        	        	            				case OIDFRESHCRL:
        	        	        	            				case OIDISSALT:
        	        	        	            				case OIDKEYUS:
        	        	        	            				case OIDSKI:
        	        	        	            				case OIDSUBALT:
        	        	        	            				case OIDSUBDIR:
        	        	        	            				case PRINTABLE:
        	        	        	            				case SIAOID:
        	        	        	            				case VALUE:
        	        	        	            					{
        	        	        	            						alt232=2;
        	        	        	            					}
        	        	        	            				    break;

        	        	        	            				default:
        	        	        	            				    CONSTRUCTEX();
        	        	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	            				    EXCEPTION->message      = (void *)"";
        	        	        	            				    EXCEPTION->decisionNum  = 232;
        	        	        	            				    EXCEPTION->state        = 2;


        	        	        	            				    goto ruleextensionsNoSkiEx;

        	        	        	            				}

        	        	        	            			}
        	        	        	            		    break;

        	        	        	            		default:
        	        	        	            		    CONSTRUCTEX();
        	        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	            		    EXCEPTION->message      = (void *)"";
        	        	        	            		    EXCEPTION->decisionNum  = 232;
        	        	        	            		    EXCEPTION->state        = 1;


        	        	        	            		    goto ruleextensionsNoSkiEx;

        	        	        	            		}

        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                CONSTRUCTEX();
        	        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	                EXCEPTION->message      = (void *)"";
        	        	        	                EXCEPTION->decisionNum  = 232;
        	        	        	                EXCEPTION->state        = 0;


        	        	        	                goto ruleextensionsNoSkiEx;

        	        	        	            }

        	        	        	            switch (alt232)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2252:117: 
        	        	        	        	    {
        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // Grammar/RFC5280.g:2252:118: notDependentExts
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExts_in_extensionsNoSki4216);
        	        	        	        	        notDependentExts912=notDependentExts(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExts912.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2252:138: truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign )
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoSki4221);
        	        	        	        truevalue913=truevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue913.tree);

        	        	        	        {
        	        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        	        }


        	        	        	        // Grammar/RFC5280.g:2252:195: ( ( extensionsNotBCNotSki )? | integer extensionsCertSign )
        	        	        	        {
        	        	        	            int alt234=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case SequenceTag:
        	        	        	            	{
        	        	        	            		alt234=1;
        	        	        	            	}
        	        	        	                break;
        	        	        	            case Int0:
        	        	        	            case Int1:
        	        	        	            case Int2:
        	        	        	            case IntTag:
        	        	        	            	{
        	        	        	            		alt234=2;
        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                CONSTRUCTEX();
        	        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	                EXCEPTION->message      = (void *)"";
        	        	        	                EXCEPTION->decisionNum  = 234;
        	        	        	                EXCEPTION->state        = 0;


        	        	        	                goto ruleextensionsNoSkiEx;

        	        	        	            }

        	        	        	            switch (alt234)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2252:197: ( extensionsNotBCNotSki )?
        	        	        	        	    {
        	        	        	        	        // Grammar/RFC5280.g:2252:197: ( extensionsNotBCNotSki )?
        	        	        	        	        {
        	        	        	        	            int alt233=2;
        	        	        	        	            switch ( LA(1) )
        	        	        	        	            {
        	        	        	        	                case SequenceTag:
        	        	        	        	                	{
        	        	        	        	                		switch ( LA(2) )
        	        	        	        	                		{
        	        	        	        	                		    case OIDTag:
        	        	        	        	                		    	{
        	        	        	        	                		    		switch ( LA(3) )
        	        	        	        	                		    		{
        	        	        	        	                		    		    case AIAOID:
        	        	        	        	                		    		    case OIDAKI:
        	        	        	        	                		    		    case OIDCERTPOL:
        	        	        	        	                		    		    case OIDCRL:
        	        	        	        	                		    		    case OIDEXTKEY:
        	        	        	        	                		    		    case OIDFRESHCRL:
        	        	        	        	                		    		    case OIDINHIBIT:
        	        	        	        	                		    		    case OIDISSALT:
        	        	        	        	                		    		    case OIDKEYUS:
        	        	        	        	                		    		    case OIDNAME:
        	        	        	        	                		    		    case OIDPOLCONST:
        	        	        	        	                		    		    case OIDPOLMAP:
        	        	        	        	                		    		    case OIDSUBALT:
        	        	        	        	                		    		    case OIDSUBDIR:
        	        	        	        	                		    		    case PRINTABLE:
        	        	        	        	                		    		    case SIAOID:
        	        	        	        	                		    		    case VALUE:
        	        	        	        	                		    		    	{
        	        	        	        	                		    		    		alt233=1;
        	        	        	        	                		    		    	}
        	        	        	        	                		    		        break;
        	        	        	        	                		    		}

        	        	        	        	                		    	}
        	        	        	        	                		        break;
        	        	        	        	                		}

        	        	        	        	                	}
        	        	        	        	                    break;
        	        	        	        	            }

        	        	        	        	            switch (alt233)
        	        	        	        	            {
        	        	        	        	        	case 1:
        	        	        	        	        	    // Grammar/RFC5280.g:2252:197: extensionsNotBCNotSki
        	        	        	        	        	    {
        	        	        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSki_in_extensionsNoSki4227);
        	        	        	        	        	        extensionsNotBCNotSki914=extensionsNotBCNotSki(ctx);

        	        	        	        	        	        FOLLOWPOP();
        	        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        	        {
        	        	        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        	        	        }

        	        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSki914.tree);

        	        	        	        	        	    }
        	        	        	        	        	    break;

        	        	        	        	            }
        	        	        	        	        }

        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // Grammar/RFC5280.g:2252:222: integer extensionsCertSign
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_integer_in_extensionsNoSki4232);
        	        	        	        	        integer915=integer(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, integer915.tree);

        	        	        	        	        {
        	        	        	        	            bc_ext->value->basic_constraints->pathlen=integer915.text
        	        	        	        	            ;
        	        	        	        	        }


        	        	        	        	        FOLLOWPUSH(FOLLOW_extensionsCertSign_in_extensionsNoSki4236);
        	        	        	        	        extensionsCertSign916=extensionsCertSign(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSign916.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2253:6: ( falsevalue )? constructedOctetString sequenceTag ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotCertSign )? )
        	        	    {
        	        	        // Grammar/RFC5280.g:2253:6: ( falsevalue )?
        	        	        {
        	        	            int alt236=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case FalseTag:
        	        	                	{
        	        	                		alt236=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt236)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2253:6: falsevalue
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoSki4246);
        	        	        	        falsevalue917=falsevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue917.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsNoSki4249);
        	        	        constructedOctetString918=constructedOctetString(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString918.tree);

        	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsNoSki4251);
        	        	        sequenceTag919=sequenceTag(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag919.tree);

        	        	        // Grammar/RFC5280.g:2253:53: ( ( falsevalue )? (| notDependentExts ) | truevalue ( extensionsNotCertSign )? )
        	        	        {
        	        	            int alt240=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case FalseTag:
        	        	            case SequenceTag:
        	        	            	{
        	        	            		alt240=1;
        	        	            	}
        	        	                break;
        	        	            case TrueTag:
        	        	            	{
        	        	            		alt240=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 240;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsNoSkiEx;

        	        	            }

        	        	            switch (alt240)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2253:55: ( falsevalue )? (| notDependentExts )
        	        	        	    {
        	        	        	        // Grammar/RFC5280.g:2253:55: ( falsevalue )?
        	        	        	        {
        	        	        	            int alt237=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	                case FalseTag:
        	        	        	                	{
        	        	        	                		alt237=1;
        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt237)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2253:55: falsevalue
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoSki4255);
        	        	        	        	        falsevalue920=falsevalue(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue920.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	        // Grammar/RFC5280.g:2253:67: (| notDependentExts )
        	        	        	        {
        	        	        	            int alt238=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	            case SequenceTag:
        	        	        	            	{
        	        	        	            		switch ( LA(2) )
        	        	        	            		{
        	        	        	            		case OIDTag:
        	        	        	            			{
        	        	        	            				switch ( LA(3) )
        	        	        	            				{
        	        	        	            				case GOST01SIGN:
        	        	        	            				case GOST94SIGN:
        	        	        	            				case MD2RSAOID:
        	        	        	            				case MD5RSAOID:
        	        	        	            				case RSAPSSOID:
        	        	        	            				case SHA1DSAOID:
        	        	        	            				case SHA1ECOID:
        	        	        	            				case SHA1RSAOID:
        	        	        	            				case SHA224DSAOID:
        	        	        	            				case SHA224ECOID:
        	        	        	            				case SHA224RSAOID:
        	        	        	            				case SHA256DSAOID:
        	        	        	            				case SHA256ECOID:
        	        	        	            				case SHA256RSAOID:
        	        	        	            				case SHA384ECOID:
        	        	        	            				case SHA384RSAOID:
        	        	        	            				case SHA512ECOID:
        	        	        	            				case SHA512RSAOID:
        	        	        	            					{
        	        	        	            						alt238=1;
        	        	        	            					}
        	        	        	            				    break;
        	        	        	            				case AIAOID:
        	        	        	            				case OIDAKI:
        	        	        	            				case OIDCERTPOL:
        	        	        	            				case OIDCRL:
        	        	        	            				case OIDEXTKEY:
        	        	        	            				case OIDFRESHCRL:
        	        	        	            				case OIDISSALT:
        	        	        	            				case OIDKEYUS:
        	        	        	            				case OIDSKI:
        	        	        	            				case OIDSUBALT:
        	        	        	            				case OIDSUBDIR:
        	        	        	            				case PRINTABLE:
        	        	        	            				case SIAOID:
        	        	        	            				case VALUE:
        	        	        	            					{
        	        	        	            						alt238=2;
        	        	        	            					}
        	        	        	            				    break;

        	        	        	            				default:
        	        	        	            				    CONSTRUCTEX();
        	        	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	            				    EXCEPTION->message      = (void *)"";
        	        	        	            				    EXCEPTION->decisionNum  = 238;
        	        	        	            				    EXCEPTION->state        = 2;


        	        	        	            				    goto ruleextensionsNoSkiEx;

        	        	        	            				}

        	        	        	            			}
        	        	        	            		    break;

        	        	        	            		default:
        	        	        	            		    CONSTRUCTEX();
        	        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	            		    EXCEPTION->message      = (void *)"";
        	        	        	            		    EXCEPTION->decisionNum  = 238;
        	        	        	            		    EXCEPTION->state        = 1;


        	        	        	            		    goto ruleextensionsNoSkiEx;

        	        	        	            		}

        	        	        	            	}
        	        	        	                break;

        	        	        	            default:
        	        	        	                CONSTRUCTEX();
        	        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	        	                EXCEPTION->message      = (void *)"";
        	        	        	                EXCEPTION->decisionNum  = 238;
        	        	        	                EXCEPTION->state        = 0;


        	        	        	                goto ruleextensionsNoSkiEx;

        	        	        	            }

        	        	        	            switch (alt238)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2253:69: 
        	        	        	        	    {
        	        	        	        	    }
        	        	        	        	    break;
        	        	        	        	case 2:
        	        	        	        	    // Grammar/RFC5280.g:2253:70: notDependentExts
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExts_in_extensionsNoSki4261);
        	        	        	        	        notDependentExts921=notDependentExts(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExts921.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2253:90: truevalue ( extensionsNotCertSign )?
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoSki4266);
        	        	        	        truevalue922=truevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue922.tree);

        	        	        	        {
        	        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        	        }


        	        	        	        // Grammar/RFC5280.g:2253:147: ( extensionsNotCertSign )?
        	        	        	        {
        	        	        	            int alt239=2;
        	        	        	            switch ( LA(1) )
        	        	        	            {
        	        	        	                case SequenceTag:
        	        	        	                	{
        	        	        	                		switch ( LA(2) )
        	        	        	                		{
        	        	        	                		    case OIDTag:
        	        	        	                		    	{
        	        	        	                		    		switch ( LA(3) )
        	        	        	                		    		{
        	        	        	                		    		    case AIAOID:
        	        	        	                		    		    case OIDAKI:
        	        	        	                		    		    case OIDCERTPOL:
        	        	        	                		    		    case OIDCRL:
        	        	        	                		    		    case OIDEXTKEY:
        	        	        	                		    		    case OIDFRESHCRL:
        	        	        	                		    		    case OIDINHIBIT:
        	        	        	                		    		    case OIDISSALT:
        	        	        	                		    		    case OIDKEYUS:
        	        	        	                		    		    case OIDNAME:
        	        	        	                		    		    case OIDPOLCONST:
        	        	        	                		    		    case OIDPOLMAP:
        	        	        	                		    		    case OIDSUBALT:
        	        	        	                		    		    case OIDSUBDIR:
        	        	        	                		    		    case PRINTABLE:
        	        	        	                		    		    case SIAOID:
        	        	        	                		    		    case VALUE:
        	        	        	                		    		    	{
        	        	        	                		    		    		alt239=1;
        	        	        	                		    		    	}
        	        	        	                		    		        break;
        	        	        	                		    		}

        	        	        	                		    	}
        	        	        	                		        break;
        	        	        	                		}

        	        	        	                	}
        	        	        	                    break;
        	        	        	            }

        	        	        	            switch (alt239)
        	        	        	            {
        	        	        	        	case 1:
        	        	        	        	    // Grammar/RFC5280.g:2253:147: extensionsNotCertSign
        	        	        	        	    {
        	        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSign_in_extensionsNoSki4270);
        	        	        	        	        extensionsNotCertSign923=extensionsNotCertSign(ctx);

        	        	        	        	        FOLLOWPOP();
        	        	        	        	        if  (HASEXCEPTION())
        	        	        	        	        {
        	        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        	        }

        	        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSign923.tree);

        	        	        	        	    }
        	        	        	        	    break;

        	        	        	            }
        	        	        	        }

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2254:4: keyUsageCommon ( bitstring (| extensionsNoPathLenNoSki ) | bitstringCertSign extensionsMustBeCA )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNoSki4280);
        	        keyUsageCommon924=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon924.tree);

        	        // Grammar/RFC5280.g:2254:19: ( bitstring (| extensionsNoPathLenNoSki ) | bitstringCertSign extensionsMustBeCA )
        	        {
        	            int alt243=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt243=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt243=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt243=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 243;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsNoSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 243;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoSkiEx;

        	            }

        	            switch (alt243)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2254:20: bitstring (| extensionsNoPathLenNoSki )
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNoSki4283);
        	        	        bitstring925=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring925.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring925.text
        	        	            ;
        	        	        }


        	        	        // Grammar/RFC5280.g:2254:82: (| extensionsNoPathLenNoSki )
        	        	        {
        	        	            int alt242=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case SequenceTag:
        	        	            	{
        	        	            		switch ( LA(2) )
        	        	            		{
        	        	            		case OIDTag:
        	        	            			{
        	        	            				switch ( LA(3) )
        	        	            				{
        	        	            				case GOST01SIGN:
        	        	            				case GOST94SIGN:
        	        	            				case MD2RSAOID:
        	        	            				case MD5RSAOID:
        	        	            				case RSAPSSOID:
        	        	            				case SHA1DSAOID:
        	        	            				case SHA1ECOID:
        	        	            				case SHA1RSAOID:
        	        	            				case SHA224DSAOID:
        	        	            				case SHA224ECOID:
        	        	            				case SHA224RSAOID:
        	        	            				case SHA256DSAOID:
        	        	            				case SHA256ECOID:
        	        	            				case SHA256RSAOID:
        	        	            				case SHA384ECOID:
        	        	            				case SHA384RSAOID:
        	        	            				case SHA512ECOID:
        	        	            				case SHA512RSAOID:
        	        	            					{
        	        	            						alt242=1;
        	        	            					}
        	        	            				    break;
        	        	            				case AIAOID:
        	        	            				case OIDAKI:
        	        	            				case OIDBC:
        	        	            				case OIDCERTPOL:
        	        	            				case OIDCRL:
        	        	            				case OIDEXTKEY:
        	        	            				case OIDFRESHCRL:
        	        	            				case OIDINHIBIT:
        	        	            				case OIDISSALT:
        	        	            				case OIDNAME:
        	        	            				case OIDPOLCONST:
        	        	            				case OIDPOLMAP:
        	        	            				case OIDSUBALT:
        	        	            				case OIDSUBDIR:
        	        	            				case PRINTABLE:
        	        	            				case SIAOID:
        	        	            				case VALUE:
        	        	            					{
        	        	            						alt242=2;
        	        	            					}
        	        	            				    break;

        	        	            				default:
        	        	            				    CONSTRUCTEX();
        	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            				    EXCEPTION->message      = (void *)"";
        	        	            				    EXCEPTION->decisionNum  = 242;
        	        	            				    EXCEPTION->state        = 2;


        	        	            				    goto ruleextensionsNoSkiEx;

        	        	            				}

        	        	            			}
        	        	            		    break;

        	        	            		default:
        	        	            		    CONSTRUCTEX();
        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            		    EXCEPTION->message      = (void *)"";
        	        	            		    EXCEPTION->decisionNum  = 242;
        	        	            		    EXCEPTION->state        = 1;


        	        	            		    goto ruleextensionsNoSkiEx;

        	        	            		}

        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 242;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsNoSkiEx;

        	        	            }

        	        	            switch (alt242)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2254:84: 
        	        	        	    {
        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2254:85: extensionsNoPathLenNoSki
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoSki4290);
        	        	        	        extensionsNoPathLenNoSki926=extensionsNoPathLenNoSki(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoSkiEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLenNoSki926.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2254:113: bitstringCertSign extensionsMustBeCA
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsNoSki4295);
        	        	        bitstringCertSign927=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign927.tree);

        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCA_in_extensionsNoSki4297);
        	        	        extensionsMustBeCA928=extensionsMustBeCA(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCA928.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2255:4: dependentExtension extensionsMustBeCa
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNoSki4303);
        	        dependentExtension929=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension929.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCa_in_extensionsNoSki4305);
        	        extensionsMustBeCa930=extensionsMustBeCa(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCa930.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNoSkiEx; /* Prevent compiler warnings */
    ruleextensionsNoSkiEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNoSki */

/**
 * $ANTLR start extensionsNoPathLenSubAlt
 * Grammar/RFC5280.g:2258:1: extensionsNoPathLenSubAlt : ( extensionNoSubAlt extensionsNoPathLenSubAlt | basicConstraints ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotBCNotKeyUsageSubAlt ) | dependentExtension extensionsMustBeCaAndSkiNoPathLenSubAlt | subjectKeyId extensionsNoPathLenNoSkiSubAlt | subAltNameCritical (| extensionsNoPathLen ) );
 */
static RFC5280Parser_extensionsNoPathLenSubAlt_return
extensionsNoPathLenSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNoPathLenSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt931;
    #undef	RETURN_TYPE_extensionNoSubAlt931
    #define	RETURN_TYPE_extensionNoSubAlt931 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNoPathLenSubAlt_return extensionsNoPathLenSubAlt932;
    #undef	RETURN_TYPE_extensionsNoPathLenSubAlt932
    #define	RETURN_TYPE_extensionsNoPathLenSubAlt932 RFC5280Parser_extensionsNoPathLenSubAlt_return

    RFC5280Parser_basicConstraints_return basicConstraints933;
    #undef	RETURN_TYPE_basicConstraints933
    #define	RETURN_TYPE_basicConstraints933 RFC5280Parser_basicConstraints_return

    RFC5280Parser_falsevalue_return falsevalue934;
    #undef	RETURN_TYPE_falsevalue934
    #define	RETURN_TYPE_falsevalue934 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExtsSubAlt_return notDependentExtsSubAlt935;
    #undef	RETURN_TYPE_notDependentExtsSubAlt935
    #define	RETURN_TYPE_notDependentExtsSubAlt935 RFC5280Parser_notDependentExtsSubAlt_return

    RFC5280Parser_truevalue_return truevalue936;
    #undef	RETURN_TYPE_truevalue936
    #define	RETURN_TYPE_truevalue936 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return extensionsNotBCNotKeyUsageSubAlt937;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt937
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt937 RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension938;
    #undef	RETURN_TYPE_dependentExtension938
    #define	RETURN_TYPE_dependentExtension938 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaAndSkiNoPathLenSubAlt_return extensionsMustBeCaAndSkiNoPathLenSubAlt939;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLenSubAlt939
    #define	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLenSubAlt939 RFC5280Parser_extensionsMustBeCaAndSkiNoPathLenSubAlt_return

    RFC5280Parser_subjectKeyId_return subjectKeyId940;
    #undef	RETURN_TYPE_subjectKeyId940
    #define	RETURN_TYPE_subjectKeyId940 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNoPathLenNoSkiSubAlt_return extensionsNoPathLenNoSkiSubAlt941;
    #undef	RETURN_TYPE_extensionsNoPathLenNoSkiSubAlt941
    #define	RETURN_TYPE_extensionsNoPathLenNoSkiSubAlt941 RFC5280Parser_extensionsNoPathLenNoSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical942;
    #undef	RETURN_TYPE_subAltNameCritical942
    #define	RETURN_TYPE_subAltNameCritical942 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNoPathLen_return extensionsNoPathLen943;
    #undef	RETURN_TYPE_extensionsNoPathLen943
    #define	RETURN_TYPE_extensionsNoPathLen943 RFC5280Parser_extensionsNoPathLen_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt931.tree = NULL;

    extensionsNoPathLenSubAlt932.tree = NULL;

    basicConstraints933.tree = NULL;

    falsevalue934.tree = NULL;

    notDependentExtsSubAlt935.tree = NULL;

    truevalue936.tree = NULL;

    extensionsNotBCNotKeyUsageSubAlt937.tree = NULL;

    dependentExtension938.tree = NULL;

    extensionsMustBeCaAndSkiNoPathLenSubAlt939.tree = NULL;

    subjectKeyId940.tree = NULL;

    extensionsNoPathLenNoSkiSubAlt941.tree = NULL;

    subAltNameCritical942.tree = NULL;

    extensionsNoPathLen943.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2265:2: ( extensionNoSubAlt extensionsNoPathLenSubAlt | basicConstraints ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotBCNotKeyUsageSubAlt ) | dependentExtension extensionsMustBeCaAndSkiNoPathLenSubAlt | subjectKeyId extensionsNoPathLenNoSkiSubAlt | subAltNameCritical (| extensionsNoPathLen ) )

            ANTLR3_UINT32 alt248;

            alt248=5;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt248=1;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt248=2;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt248=3;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt248=4;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt248=5;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 248;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNoPathLenSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 248;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNoPathLenSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 248;
                EXCEPTION->state        = 0;


                goto ruleextensionsNoPathLenSubAltEx;

            }

            switch (alt248)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2266:3: extensionNoSubAlt extensionsNoPathLenSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenSubAlt4330);
        	        extensionNoSubAlt931=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt931.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4332);
        	        extensionsNoPathLenSubAlt932=extensionsNoPathLenSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLenSubAlt932.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2267:4: basicConstraints ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotBCNotKeyUsageSubAlt )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraints_in_extensionsNoPathLenSubAlt4337);
        	        basicConstraints933=basicConstraints(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraints933.tree);

        	        // Grammar/RFC5280.g:2267:21: ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotBCNotKeyUsageSubAlt )
        	        {
        	            int alt246=2;
        	            switch ( LA(1) )
        	            {
        	            case FalseTag:
        	            case SequenceTag:
        	            	{
        	            		alt246=1;
        	            	}
        	                break;
        	            case TrueTag:
        	            	{
        	            		alt246=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 246;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoPathLenSubAltEx;

        	            }

        	            switch (alt246)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2267:23: ( falsevalue )? notDependentExtsSubAlt
        	        	    {
        	        	        // Grammar/RFC5280.g:2267:23: ( falsevalue )?
        	        	        {
        	        	            int alt245=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case FalseTag:
        	        	                	{
        	        	                		alt245=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt245)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2267:23: falsevalue
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoPathLenSubAlt4341);
        	        	        	        falsevalue934=falsevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoPathLenSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue934.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        FOLLOWPUSH(FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenSubAlt4344);
        	        	        notDependentExtsSubAlt935=notDependentExtsSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExtsSubAlt935.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2267:60: truevalue extensionsNotBCNotKeyUsageSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoPathLenSubAlt4348);
        	        	        truevalue936=truevalue(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue936.tree);

        	        	        {
        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNoPathLenSubAlt4352);
        	        	        extensionsNotBCNotKeyUsageSubAlt937=extensionsNotBCNotKeyUsageSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageSubAlt937.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2268:4: dependentExtension extensionsMustBeCaAndSkiNoPathLenSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNoPathLenSubAlt4359);
        	        dependentExtension938=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension938.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsNoPathLenSubAlt4361);
        	        extensionsMustBeCaAndSkiNoPathLenSubAlt939=extensionsMustBeCaAndSkiNoPathLenSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSkiNoPathLenSubAlt939.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2269:4: subjectKeyId extensionsNoPathLenNoSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsNoPathLenSubAlt4366);
        	        subjectKeyId940=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId940.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenSubAlt4368);
        	        extensionsNoPathLenNoSkiSubAlt941=extensionsNoPathLenNoSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLenNoSkiSubAlt941.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:2270:4: subAltNameCritical (| extensionsNoPathLen )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsNoPathLenSubAlt4373);
        	        subAltNameCritical942=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical942.tree);

        	        // Grammar/RFC5280.g:2270:23: (| extensionsNoPathLen )
        	        {
        	            int alt247=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt247=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDBC:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSKI:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt247=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 247;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNoPathLenSubAltEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 247;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNoPathLenSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 247;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoPathLenSubAltEx;

        	            }

        	            switch (alt247)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2270:25: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2270:26: extensionsNoPathLen
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLen_in_extensionsNoPathLenSubAlt4378);
        	        	        extensionsNoPathLen943=extensionsNoPathLen(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLen943.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNoPathLenSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNoPathLenSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNoPathLenSubAlt */

/**
 * $ANTLR start extensionsNoPathLen
 * Grammar/RFC5280.g:2274:1: extensionsNoPathLen : ( extension (| extensionsNoPathLen ) | basicConstraints ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotBCNotKeyUsage ) | dependentExtension extensionsMustBeCaAndSkiNoPathLen | subjectKeyId (| extensionsNoPathLenNoSki ) );
 */
static RFC5280Parser_extensionsNoPathLen_return
extensionsNoPathLen(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNoPathLen_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension944;
    #undef	RETURN_TYPE_extension944
    #define	RETURN_TYPE_extension944 RFC5280Parser_extension_return

    RFC5280Parser_extensionsNoPathLen_return extensionsNoPathLen945;
    #undef	RETURN_TYPE_extensionsNoPathLen945
    #define	RETURN_TYPE_extensionsNoPathLen945 RFC5280Parser_extensionsNoPathLen_return

    RFC5280Parser_basicConstraints_return basicConstraints946;
    #undef	RETURN_TYPE_basicConstraints946
    #define	RETURN_TYPE_basicConstraints946 RFC5280Parser_basicConstraints_return

    RFC5280Parser_falsevalue_return falsevalue947;
    #undef	RETURN_TYPE_falsevalue947
    #define	RETURN_TYPE_falsevalue947 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExts_return notDependentExts948;
    #undef	RETURN_TYPE_notDependentExts948
    #define	RETURN_TYPE_notDependentExts948 RFC5280Parser_notDependentExts_return

    RFC5280Parser_truevalue_return truevalue949;
    #undef	RETURN_TYPE_truevalue949
    #define	RETURN_TYPE_truevalue949 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage950;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage950
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage950 RFC5280Parser_extensionsNotBCNotKeyUsage_return

    RFC5280Parser_dependentExtension_return dependentExtension951;
    #undef	RETURN_TYPE_dependentExtension951
    #define	RETURN_TYPE_dependentExtension951 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaAndSkiNoPathLen_return extensionsMustBeCaAndSkiNoPathLen952;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLen952
    #define	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLen952 RFC5280Parser_extensionsMustBeCaAndSkiNoPathLen_return

    RFC5280Parser_subjectKeyId_return subjectKeyId953;
    #undef	RETURN_TYPE_subjectKeyId953
    #define	RETURN_TYPE_subjectKeyId953 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNoPathLenNoSki_return extensionsNoPathLenNoSki954;
    #undef	RETURN_TYPE_extensionsNoPathLenNoSki954
    #define	RETURN_TYPE_extensionsNoPathLenNoSki954 RFC5280Parser_extensionsNoPathLenNoSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension944.tree = NULL;

    extensionsNoPathLen945.tree = NULL;

    basicConstraints946.tree = NULL;

    falsevalue947.tree = NULL;

    notDependentExts948.tree = NULL;

    truevalue949.tree = NULL;

    extensionsNotBCNotKeyUsage950.tree = NULL;

    dependentExtension951.tree = NULL;

    extensionsMustBeCaAndSkiNoPathLen952.tree = NULL;

    subjectKeyId953.tree = NULL;

    extensionsNoPathLenNoSki954.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2281:2: ( extension (| extensionsNoPathLen ) | basicConstraints ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotBCNotKeyUsage ) | dependentExtension extensionsMustBeCaAndSkiNoPathLen | subjectKeyId (| extensionsNoPathLenNoSki ) )

            ANTLR3_UINT32 alt254;

            alt254=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt254=1;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt254=2;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt254=3;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt254=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 254;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNoPathLenEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 254;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNoPathLenEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 254;
                EXCEPTION->state        = 0;


                goto ruleextensionsNoPathLenEx;

            }

            switch (alt254)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2282:3: extension (| extensionsNoPathLen )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsNoPathLen4405);
        	        extension944=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension944.tree);

        	        // Grammar/RFC5280.g:2282:13: (| extensionsNoPathLen )
        	        {
        	            int alt249=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt249=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDBC:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSKI:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt249=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 249;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNoPathLenEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 249;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNoPathLenEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 249;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoPathLenEx;

        	            }

        	            switch (alt249)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2282:15: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2282:16: extensionsNoPathLen
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLen_in_extensionsNoPathLen4410);
        	        	        extensionsNoPathLen945=extensionsNoPathLen(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLen945.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2283:4: basicConstraints ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotBCNotKeyUsage )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraints_in_extensionsNoPathLen4416);
        	        basicConstraints946=basicConstraints(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraints946.tree);

        	        // Grammar/RFC5280.g:2283:21: ( ( falsevalue )? (| notDependentExts ) | truevalue extensionsNotBCNotKeyUsage )
        	        {
        	            int alt252=2;
        	            switch ( LA(1) )
        	            {
        	            case FalseTag:
        	            case SequenceTag:
        	            	{
        	            		alt252=1;
        	            	}
        	                break;
        	            case TrueTag:
        	            	{
        	            		alt252=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 252;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoPathLenEx;

        	            }

        	            switch (alt252)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2283:23: ( falsevalue )? (| notDependentExts )
        	        	    {
        	        	        // Grammar/RFC5280.g:2283:23: ( falsevalue )?
        	        	        {
        	        	            int alt250=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case FalseTag:
        	        	                	{
        	        	                		alt250=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt250)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2283:23: falsevalue
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoPathLen4420);
        	        	        	        falsevalue947=falsevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoPathLenEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue947.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        // Grammar/RFC5280.g:2283:35: (| notDependentExts )
        	        	        {
        	        	            int alt251=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case SequenceTag:
        	        	            	{
        	        	            		switch ( LA(2) )
        	        	            		{
        	        	            		case OIDTag:
        	        	            			{
        	        	            				switch ( LA(3) )
        	        	            				{
        	        	            				case GOST01SIGN:
        	        	            				case GOST94SIGN:
        	        	            				case MD2RSAOID:
        	        	            				case MD5RSAOID:
        	        	            				case RSAPSSOID:
        	        	            				case SHA1DSAOID:
        	        	            				case SHA1ECOID:
        	        	            				case SHA1RSAOID:
        	        	            				case SHA224DSAOID:
        	        	            				case SHA224ECOID:
        	        	            				case SHA224RSAOID:
        	        	            				case SHA256DSAOID:
        	        	            				case SHA256ECOID:
        	        	            				case SHA256RSAOID:
        	        	            				case SHA384ECOID:
        	        	            				case SHA384RSAOID:
        	        	            				case SHA512ECOID:
        	        	            				case SHA512RSAOID:
        	        	            					{
        	        	            						alt251=1;
        	        	            					}
        	        	            				    break;
        	        	            				case AIAOID:
        	        	            				case OIDAKI:
        	        	            				case OIDCERTPOL:
        	        	            				case OIDCRL:
        	        	            				case OIDEXTKEY:
        	        	            				case OIDFRESHCRL:
        	        	            				case OIDISSALT:
        	        	            				case OIDKEYUS:
        	        	            				case OIDSKI:
        	        	            				case OIDSUBALT:
        	        	            				case OIDSUBDIR:
        	        	            				case PRINTABLE:
        	        	            				case SIAOID:
        	        	            				case VALUE:
        	        	            					{
        	        	            						alt251=2;
        	        	            					}
        	        	            				    break;

        	        	            				default:
        	        	            				    CONSTRUCTEX();
        	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            				    EXCEPTION->message      = (void *)"";
        	        	            				    EXCEPTION->decisionNum  = 251;
        	        	            				    EXCEPTION->state        = 2;


        	        	            				    goto ruleextensionsNoPathLenEx;

        	        	            				}

        	        	            			}
        	        	            		    break;

        	        	            		default:
        	        	            		    CONSTRUCTEX();
        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            		    EXCEPTION->message      = (void *)"";
        	        	            		    EXCEPTION->decisionNum  = 251;
        	        	            		    EXCEPTION->state        = 1;


        	        	            		    goto ruleextensionsNoPathLenEx;

        	        	            		}

        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 251;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsNoPathLenEx;

        	        	            }

        	        	            switch (alt251)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2283:37: 
        	        	        	    {
        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2283:38: notDependentExts
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExts_in_extensionsNoPathLen4426);
        	        	        	        notDependentExts948=notDependentExts(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoPathLenEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExts948.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2283:58: truevalue extensionsNotBCNotKeyUsage
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoPathLen4431);
        	        	        truevalue949=truevalue(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue949.tree);

        	        	        {
        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNoPathLen4435);
        	        	        extensionsNotBCNotKeyUsage950=extensionsNotBCNotKeyUsage(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage950.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2284:4: dependentExtension extensionsMustBeCaAndSkiNoPathLen
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNoPathLen4442);
        	        dependentExtension951=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension951.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsNoPathLen4444);
        	        extensionsMustBeCaAndSkiNoPathLen952=extensionsMustBeCaAndSkiNoPathLen(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSkiNoPathLen952.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2285:4: subjectKeyId (| extensionsNoPathLenNoSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsNoPathLen4449);
        	        subjectKeyId953=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId953.tree);

        	        // Grammar/RFC5280.g:2285:17: (| extensionsNoPathLenNoSki )
        	        {
        	            int alt253=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt253=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDBC:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt253=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 253;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNoPathLenEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 253;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNoPathLenEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 253;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoPathLenEx;

        	            }

        	            switch (alt253)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2285:19: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2285:20: extensionsNoPathLenNoSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLen4454);
        	        	        extensionsNoPathLenNoSki954=extensionsNoPathLenNoSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLenNoSki954.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNoPathLenEx; /* Prevent compiler warnings */
    ruleextensionsNoPathLenEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNoPathLen */

/**
 * $ANTLR start extensionsNoPathLenNoSkiSubAlt
 * Grammar/RFC5280.g:2288:1: extensionsNoPathLenNoSkiSubAlt : ( extensionNoSubAlt extensionsNoPathLenNoSkiSubAlt | basicConstraints ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotBCNotKeyUsageNotSkiSubAlt ) | dependentExtension extensionsMustBeCaNoPathLenSubAlt | subAltNameCritical (| extensionsNoPathLenNoSki ) );
 */
static RFC5280Parser_extensionsNoPathLenNoSkiSubAlt_return
extensionsNoPathLenNoSkiSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNoPathLenNoSkiSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt955;
    #undef	RETURN_TYPE_extensionNoSubAlt955
    #define	RETURN_TYPE_extensionNoSubAlt955 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNoPathLenNoSkiSubAlt_return extensionsNoPathLenNoSkiSubAlt956;
    #undef	RETURN_TYPE_extensionsNoPathLenNoSkiSubAlt956
    #define	RETURN_TYPE_extensionsNoPathLenNoSkiSubAlt956 RFC5280Parser_extensionsNoPathLenNoSkiSubAlt_return

    RFC5280Parser_basicConstraints_return basicConstraints957;
    #undef	RETURN_TYPE_basicConstraints957
    #define	RETURN_TYPE_basicConstraints957 RFC5280Parser_basicConstraints_return

    RFC5280Parser_falsevalue_return falsevalue958;
    #undef	RETURN_TYPE_falsevalue958
    #define	RETURN_TYPE_falsevalue958 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExtsSubAlt_return notDependentExtsSubAlt959;
    #undef	RETURN_TYPE_notDependentExtsSubAlt959
    #define	RETURN_TYPE_notDependentExtsSubAlt959 RFC5280Parser_notDependentExtsSubAlt_return

    RFC5280Parser_truevalue_return truevalue960;
    #undef	RETURN_TYPE_truevalue960
    #define	RETURN_TYPE_truevalue960 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return extensionsNotBCNotKeyUsageNotSkiSubAlt961;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt961
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt961 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension962;
    #undef	RETURN_TYPE_dependentExtension962
    #define	RETURN_TYPE_dependentExtension962 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return extensionsMustBeCaNoPathLenSubAlt963;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt963
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt963 RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical964;
    #undef	RETURN_TYPE_subAltNameCritical964
    #define	RETURN_TYPE_subAltNameCritical964 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNoPathLenNoSki_return extensionsNoPathLenNoSki965;
    #undef	RETURN_TYPE_extensionsNoPathLenNoSki965
    #define	RETURN_TYPE_extensionsNoPathLenNoSki965 RFC5280Parser_extensionsNoPathLenNoSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt955.tree = NULL;

    extensionsNoPathLenNoSkiSubAlt956.tree = NULL;

    basicConstraints957.tree = NULL;

    falsevalue958.tree = NULL;

    notDependentExtsSubAlt959.tree = NULL;

    truevalue960.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiSubAlt961.tree = NULL;

    dependentExtension962.tree = NULL;

    extensionsMustBeCaNoPathLenSubAlt963.tree = NULL;

    subAltNameCritical964.tree = NULL;

    extensionsNoPathLenNoSki965.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2294:9: ( extensionNoSubAlt extensionsNoPathLenNoSkiSubAlt | basicConstraints ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotBCNotKeyUsageNotSkiSubAlt ) | dependentExtension extensionsMustBeCaNoPathLenSubAlt | subAltNameCritical (| extensionsNoPathLenNoSki ) )

            ANTLR3_UINT32 alt258;

            alt258=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt258=1;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt258=2;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt258=3;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt258=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 258;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNoPathLenNoSkiSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 258;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNoPathLenNoSkiSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 258;
                EXCEPTION->state        = 0;


                goto ruleextensionsNoPathLenNoSkiSubAltEx;

            }

            switch (alt258)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2295:3: extensionNoSubAlt extensionsNoPathLenNoSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNoPathLenNoSkiSubAlt4479);
        	        extensionNoSubAlt955=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt955.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLenNoSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4481);
        	        extensionsNoPathLenNoSkiSubAlt956=extensionsNoPathLenNoSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLenNoSkiSubAlt956.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2296:4: basicConstraints ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotBCNotKeyUsageNotSkiSubAlt )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraints_in_extensionsNoPathLenNoSkiSubAlt4486);
        	        basicConstraints957=basicConstraints(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraints957.tree);

        	        // Grammar/RFC5280.g:2296:21: ( ( falsevalue )? notDependentExtsSubAlt | truevalue extensionsNotBCNotKeyUsageNotSkiSubAlt )
        	        {
        	            int alt256=2;
        	            switch ( LA(1) )
        	            {
        	            case FalseTag:
        	            case SequenceTag:
        	            	{
        	            		alt256=1;
        	            	}
        	                break;
        	            case TrueTag:
        	            	{
        	            		alt256=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 256;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoPathLenNoSkiSubAltEx;

        	            }

        	            switch (alt256)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2296:23: ( falsevalue )? notDependentExtsSubAlt
        	        	    {
        	        	        // Grammar/RFC5280.g:2296:23: ( falsevalue )?
        	        	        {
        	        	            int alt255=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case FalseTag:
        	        	                	{
        	        	                		alt255=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt255)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2296:23: falsevalue
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoPathLenNoSkiSubAlt4490);
        	        	        	        falsevalue958=falsevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue958.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        FOLLOWPUSH(FOLLOW_notDependentExtsSubAlt_in_extensionsNoPathLenNoSkiSubAlt4493);
        	        	        notDependentExtsSubAlt959=notDependentExtsSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExtsSubAlt959.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2296:60: truevalue extensionsNotBCNotKeyUsageNotSkiSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoPathLenNoSkiSubAlt4497);
        	        	        truevalue960=truevalue(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue960.tree);

        	        	        {
        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNoPathLenNoSkiSubAlt4501);
        	        	        extensionsNotBCNotKeyUsageNotSkiSubAlt961=extensionsNotBCNotKeyUsageNotSkiSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiSubAlt961.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2297:4: dependentExtension extensionsMustBeCaNoPathLenSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNoPathLenNoSkiSubAlt4508);
        	        dependentExtension962=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension962.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsNoPathLenNoSkiSubAlt4510);
        	        extensionsMustBeCaNoPathLenSubAlt963=extensionsMustBeCaNoPathLenSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLenSubAlt963.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2298:4: subAltNameCritical (| extensionsNoPathLenNoSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsNoPathLenNoSkiSubAlt4515);
        	        subAltNameCritical964=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical964.tree);

        	        // Grammar/RFC5280.g:2298:23: (| extensionsNoPathLenNoSki )
        	        {
        	            int alt257=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt257=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDBC:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt257=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 257;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNoPathLenNoSkiSubAltEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 257;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNoPathLenNoSkiSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 257;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoPathLenNoSkiSubAltEx;

        	            }

        	            switch (alt257)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2298:25: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2298:26: extensionsNoPathLenNoSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSkiSubAlt4520);
        	        	        extensionsNoPathLenNoSki965=extensionsNoPathLenNoSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenNoSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLenNoSki965.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNoPathLenNoSkiSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNoPathLenNoSkiSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNoPathLenNoSkiSubAlt */

/**
 * $ANTLR start extensionsNoPathLenNoSki
 * Grammar/RFC5280.g:2301:1: extensionsNoPathLenNoSki : ( extension (| extensionsNoPathLenNoSki ) | basicConstraints ( ( falsevalue )? (| notDependentExts ) | truevalue (| extensionsNotBCNotKeyUsageNotSki ) ) | dependentExtension extensionsMustBeCaNoPathLen );
 */
static RFC5280Parser_extensionsNoPathLenNoSki_return
extensionsNoPathLenNoSki(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNoPathLenNoSki_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension966;
    #undef	RETURN_TYPE_extension966
    #define	RETURN_TYPE_extension966 RFC5280Parser_extension_return

    RFC5280Parser_extensionsNoPathLenNoSki_return extensionsNoPathLenNoSki967;
    #undef	RETURN_TYPE_extensionsNoPathLenNoSki967
    #define	RETURN_TYPE_extensionsNoPathLenNoSki967 RFC5280Parser_extensionsNoPathLenNoSki_return

    RFC5280Parser_basicConstraints_return basicConstraints968;
    #undef	RETURN_TYPE_basicConstraints968
    #define	RETURN_TYPE_basicConstraints968 RFC5280Parser_basicConstraints_return

    RFC5280Parser_falsevalue_return falsevalue969;
    #undef	RETURN_TYPE_falsevalue969
    #define	RETURN_TYPE_falsevalue969 RFC5280Parser_falsevalue_return

    RFC5280Parser_notDependentExts_return notDependentExts970;
    #undef	RETURN_TYPE_notDependentExts970
    #define	RETURN_TYPE_notDependentExts970 RFC5280Parser_notDependentExts_return

    RFC5280Parser_truevalue_return truevalue971;
    #undef	RETURN_TYPE_truevalue971
    #define	RETURN_TYPE_truevalue971 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki972;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki972
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki972 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return

    RFC5280Parser_dependentExtension_return dependentExtension973;
    #undef	RETURN_TYPE_dependentExtension973
    #define	RETURN_TYPE_dependentExtension973 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaNoPathLen_return extensionsMustBeCaNoPathLen974;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLen974
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLen974 RFC5280Parser_extensionsMustBeCaNoPathLen_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension966.tree = NULL;

    extensionsNoPathLenNoSki967.tree = NULL;

    basicConstraints968.tree = NULL;

    falsevalue969.tree = NULL;

    notDependentExts970.tree = NULL;

    truevalue971.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki972.tree = NULL;

    dependentExtension973.tree = NULL;

    extensionsMustBeCaNoPathLen974.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2307:9: ( extension (| extensionsNoPathLenNoSki ) | basicConstraints ( ( falsevalue )? (| notDependentExts ) | truevalue (| extensionsNotBCNotKeyUsageNotSki ) ) | dependentExtension extensionsMustBeCaNoPathLen )

            ANTLR3_UINT32 alt264;

            alt264=3;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt264=1;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt264=2;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt264=3;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 264;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNoPathLenNoSkiEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 264;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNoPathLenNoSkiEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 264;
                EXCEPTION->state        = 0;


                goto ruleextensionsNoPathLenNoSkiEx;

            }

            switch (alt264)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2308:3: extension (| extensionsNoPathLenNoSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsNoPathLenNoSki4545);
        	        extension966=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension966.tree);

        	        // Grammar/RFC5280.g:2308:13: (| extensionsNoPathLenNoSki )
        	        {
        	            int alt259=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt259=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDBC:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt259=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 259;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNoPathLenNoSkiEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 259;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNoPathLenNoSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 259;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoPathLenNoSkiEx;

        	            }

        	            switch (alt259)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2308:15: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2308:16: extensionsNoPathLenNoSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNoPathLenNoSki_in_extensionsNoPathLenNoSki4550);
        	        	        extensionsNoPathLenNoSki967=extensionsNoPathLenNoSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNoPathLenNoSki967.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2309:4: basicConstraints ( ( falsevalue )? (| notDependentExts ) | truevalue (| extensionsNotBCNotKeyUsageNotSki ) )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraints_in_extensionsNoPathLenNoSki4556);
        	        basicConstraints968=basicConstraints(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraints968.tree);

        	        // Grammar/RFC5280.g:2309:21: ( ( falsevalue )? (| notDependentExts ) | truevalue (| extensionsNotBCNotKeyUsageNotSki ) )
        	        {
        	            int alt263=2;
        	            switch ( LA(1) )
        	            {
        	            case FalseTag:
        	            case SequenceTag:
        	            	{
        	            		alt263=1;
        	            	}
        	                break;
        	            case TrueTag:
        	            	{
        	            		alt263=2;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 263;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNoPathLenNoSkiEx;

        	            }

        	            switch (alt263)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2309:23: ( falsevalue )? (| notDependentExts )
        	        	    {
        	        	        // Grammar/RFC5280.g:2309:23: ( falsevalue )?
        	        	        {
        	        	            int alt260=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	                case FalseTag:
        	        	                	{
        	        	                		alt260=1;
        	        	                	}
        	        	                    break;
        	        	            }

        	        	            switch (alt260)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2309:23: falsevalue
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_extensionsNoPathLenNoSki4560);
        	        	        	        falsevalue969=falsevalue(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoPathLenNoSkiEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue969.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        // Grammar/RFC5280.g:2309:35: (| notDependentExts )
        	        	        {
        	        	            int alt261=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case SequenceTag:
        	        	            	{
        	        	            		switch ( LA(2) )
        	        	            		{
        	        	            		case OIDTag:
        	        	            			{
        	        	            				switch ( LA(3) )
        	        	            				{
        	        	            				case GOST01SIGN:
        	        	            				case GOST94SIGN:
        	        	            				case MD2RSAOID:
        	        	            				case MD5RSAOID:
        	        	            				case RSAPSSOID:
        	        	            				case SHA1DSAOID:
        	        	            				case SHA1ECOID:
        	        	            				case SHA1RSAOID:
        	        	            				case SHA224DSAOID:
        	        	            				case SHA224ECOID:
        	        	            				case SHA224RSAOID:
        	        	            				case SHA256DSAOID:
        	        	            				case SHA256ECOID:
        	        	            				case SHA256RSAOID:
        	        	            				case SHA384ECOID:
        	        	            				case SHA384RSAOID:
        	        	            				case SHA512ECOID:
        	        	            				case SHA512RSAOID:
        	        	            					{
        	        	            						alt261=1;
        	        	            					}
        	        	            				    break;
        	        	            				case AIAOID:
        	        	            				case OIDAKI:
        	        	            				case OIDCERTPOL:
        	        	            				case OIDCRL:
        	        	            				case OIDEXTKEY:
        	        	            				case OIDFRESHCRL:
        	        	            				case OIDISSALT:
        	        	            				case OIDKEYUS:
        	        	            				case OIDSKI:
        	        	            				case OIDSUBALT:
        	        	            				case OIDSUBDIR:
        	        	            				case PRINTABLE:
        	        	            				case SIAOID:
        	        	            				case VALUE:
        	        	            					{
        	        	            						alt261=2;
        	        	            					}
        	        	            				    break;

        	        	            				default:
        	        	            				    CONSTRUCTEX();
        	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            				    EXCEPTION->message      = (void *)"";
        	        	            				    EXCEPTION->decisionNum  = 261;
        	        	            				    EXCEPTION->state        = 2;


        	        	            				    goto ruleextensionsNoPathLenNoSkiEx;

        	        	            				}

        	        	            			}
        	        	            		    break;

        	        	            		default:
        	        	            		    CONSTRUCTEX();
        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            		    EXCEPTION->message      = (void *)"";
        	        	            		    EXCEPTION->decisionNum  = 261;
        	        	            		    EXCEPTION->state        = 1;


        	        	            		    goto ruleextensionsNoPathLenNoSkiEx;

        	        	            		}

        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 261;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsNoPathLenNoSkiEx;

        	        	            }

        	        	            switch (alt261)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2309:37: 
        	        	        	    {
        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2309:38: notDependentExts
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_notDependentExts_in_extensionsNoPathLenNoSki4566);
        	        	        	        notDependentExts970=notDependentExts(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoPathLenNoSkiEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExts970.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2309:58: truevalue (| extensionsNotBCNotKeyUsageNotSki )
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsNoPathLenNoSki4571);
        	        	        truevalue971=truevalue(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNoPathLenNoSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue971.tree);

        	        	        {
        	        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        	        }


        	        	        // Grammar/RFC5280.g:2309:115: (| extensionsNotBCNotKeyUsageNotSki )
        	        	        {
        	        	            int alt262=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case SequenceTag:
        	        	            	{
        	        	            		switch ( LA(2) )
        	        	            		{
        	        	            		case OIDTag:
        	        	            			{
        	        	            				switch ( LA(3) )
        	        	            				{
        	        	            				case GOST01SIGN:
        	        	            				case GOST94SIGN:
        	        	            				case MD2RSAOID:
        	        	            				case MD5RSAOID:
        	        	            				case RSAPSSOID:
        	        	            				case SHA1DSAOID:
        	        	            				case SHA1ECOID:
        	        	            				case SHA1RSAOID:
        	        	            				case SHA224DSAOID:
        	        	            				case SHA224ECOID:
        	        	            				case SHA224RSAOID:
        	        	            				case SHA256DSAOID:
        	        	            				case SHA256ECOID:
        	        	            				case SHA256RSAOID:
        	        	            				case SHA384ECOID:
        	        	            				case SHA384RSAOID:
        	        	            				case SHA512ECOID:
        	        	            				case SHA512RSAOID:
        	        	            					{
        	        	            						alt262=1;
        	        	            					}
        	        	            				    break;
        	        	            				case AIAOID:
        	        	            				case OIDAKI:
        	        	            				case OIDCERTPOL:
        	        	            				case OIDCRL:
        	        	            				case OIDEXTKEY:
        	        	            				case OIDFRESHCRL:
        	        	            				case OIDINHIBIT:
        	        	            				case OIDISSALT:
        	        	            				case OIDNAME:
        	        	            				case OIDPOLCONST:
        	        	            				case OIDPOLMAP:
        	        	            				case OIDSUBALT:
        	        	            				case OIDSUBDIR:
        	        	            				case PRINTABLE:
        	        	            				case SIAOID:
        	        	            				case VALUE:
        	        	            					{
        	        	            						alt262=2;
        	        	            					}
        	        	            				    break;

        	        	            				default:
        	        	            				    CONSTRUCTEX();
        	        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            				    EXCEPTION->message      = (void *)"";
        	        	            				    EXCEPTION->decisionNum  = 262;
        	        	            				    EXCEPTION->state        = 2;


        	        	            				    goto ruleextensionsNoPathLenNoSkiEx;

        	        	            				}

        	        	            			}
        	        	            		    break;

        	        	            		default:
        	        	            		    CONSTRUCTEX();
        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            		    EXCEPTION->message      = (void *)"";
        	        	            		    EXCEPTION->decisionNum  = 262;
        	        	            		    EXCEPTION->state        = 1;


        	        	            		    goto ruleextensionsNoPathLenNoSkiEx;

        	        	            		}

        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 262;
        	        	                EXCEPTION->state        = 0;


        	        	                goto ruleextensionsNoPathLenNoSkiEx;

        	        	            }

        	        	            switch (alt262)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:2309:117: 
        	        	        	    {
        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:2309:118: extensionsNotBCNotKeyUsageNotSki
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNoPathLenNoSki4578);
        	        	        	        extensionsNotBCNotKeyUsageNotSki972=extensionsNotBCNotKeyUsageNotSki(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto ruleextensionsNoPathLenNoSkiEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki972.tree);

        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2310:4: dependentExtension extensionsMustBeCaNoPathLen
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNoPathLenNoSki4586);
        	        dependentExtension973=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension973.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsNoPathLenNoSki4588);
        	        extensionsMustBeCaNoPathLen974=extensionsMustBeCaNoPathLen(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNoPathLenNoSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLen974.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNoPathLenNoSkiEx; /* Prevent compiler warnings */
    ruleextensionsNoPathLenNoSkiEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNoPathLenNoSki */

/**
 * $ANTLR start notDependentExtsSubAlt
 * Grammar/RFC5280.g:2313:1: notDependentExtsSubAlt : ( ( extensionNoSubAlt | keyUsage | subjectKeyId ) notDependentExtsSubAlt | subAltNameCritical (| notDependentExts ) );
 */
static RFC5280Parser_notDependentExtsSubAlt_return
notDependentExtsSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_notDependentExtsSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt975;
    #undef	RETURN_TYPE_extensionNoSubAlt975
    #define	RETURN_TYPE_extensionNoSubAlt975 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_keyUsage_return keyUsage976;
    #undef	RETURN_TYPE_keyUsage976
    #define	RETURN_TYPE_keyUsage976 RFC5280Parser_keyUsage_return

    RFC5280Parser_subjectKeyId_return subjectKeyId977;
    #undef	RETURN_TYPE_subjectKeyId977
    #define	RETURN_TYPE_subjectKeyId977 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_notDependentExtsSubAlt_return notDependentExtsSubAlt978;
    #undef	RETURN_TYPE_notDependentExtsSubAlt978
    #define	RETURN_TYPE_notDependentExtsSubAlt978 RFC5280Parser_notDependentExtsSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical979;
    #undef	RETURN_TYPE_subAltNameCritical979
    #define	RETURN_TYPE_subAltNameCritical979 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_notDependentExts_return notDependentExts980;
    #undef	RETURN_TYPE_notDependentExts980
    #define	RETURN_TYPE_notDependentExts980 RFC5280Parser_notDependentExts_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt975.tree = NULL;

    keyUsage976.tree = NULL;

    subjectKeyId977.tree = NULL;

    notDependentExtsSubAlt978.tree = NULL;

    subAltNameCritical979.tree = NULL;

    notDependentExts980.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2319:9: ( ( extensionNoSubAlt | keyUsage | subjectKeyId ) notDependentExtsSubAlt | subAltNameCritical (| notDependentExts ) )

            ANTLR3_UINT32 alt267;

            alt267=2;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDKEYUS:
            				case OIDSKI:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt267=1;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt267=2;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 267;
            				    EXCEPTION->state        = 2;


            				    goto rulenotDependentExtsSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 267;
            		    EXCEPTION->state        = 1;


            		    goto rulenotDependentExtsSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 267;
                EXCEPTION->state        = 0;


                goto rulenotDependentExtsSubAltEx;

            }

            switch (alt267)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2320:3: ( extensionNoSubAlt | keyUsage | subjectKeyId ) notDependentExtsSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        // Grammar/RFC5280.g:2320:3: ( extensionNoSubAlt | keyUsage | subjectKeyId )
        	        {
        	            int alt265=3;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDISSALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt265=1;
        	            					}
        	            				    break;
        	            				case OIDKEYUS:
        	            					{
        	            						alt265=2;
        	            					}
        	            				    break;
        	            				case OIDSKI:
        	            					{
        	            						alt265=3;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 265;
        	            				    EXCEPTION->state        = 2;


        	            				    goto rulenotDependentExtsSubAltEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 265;
        	            		    EXCEPTION->state        = 1;


        	            		    goto rulenotDependentExtsSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 265;
        	                EXCEPTION->state        = 0;


        	                goto rulenotDependentExtsSubAltEx;

        	            }

        	            switch (alt265)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2320:4: extensionNoSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_notDependentExtsSubAlt4611);
        	        	        extensionNoSubAlt975=extensionNoSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulenotDependentExtsSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt975.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2320:24: keyUsage
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_keyUsage_in_notDependentExtsSubAlt4615);
        	        	        keyUsage976=keyUsage(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulenotDependentExtsSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsage976.tree);

        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // Grammar/RFC5280.g:2320:35: subjectKeyId
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_notDependentExtsSubAlt4619);
        	        	        subjectKeyId977=subjectKeyId(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulenotDependentExtsSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId977.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_notDependentExtsSubAlt_in_notDependentExtsSubAlt4622);
        	        notDependentExtsSubAlt978=notDependentExtsSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenotDependentExtsSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExtsSubAlt978.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2321:4: subAltNameCritical (| notDependentExts )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_notDependentExtsSubAlt4627);
        	        subAltNameCritical979=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenotDependentExtsSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical979.tree);

        	        // Grammar/RFC5280.g:2321:23: (| notDependentExts )
        	        {
        	            int alt266=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt266=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDSKI:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt266=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 266;
        	            				    EXCEPTION->state        = 2;


        	            				    goto rulenotDependentExtsSubAltEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 266;
        	            		    EXCEPTION->state        = 1;


        	            		    goto rulenotDependentExtsSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 266;
        	                EXCEPTION->state        = 0;


        	                goto rulenotDependentExtsSubAltEx;

        	            }

        	            switch (alt266)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2321:25: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2321:26: notDependentExts
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_notDependentExts_in_notDependentExtsSubAlt4632);
        	        	        notDependentExts980=notDependentExts(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulenotDependentExtsSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExts980.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulenotDependentExtsSubAltEx; /* Prevent compiler warnings */
    rulenotDependentExtsSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end notDependentExtsSubAlt */

/**
 * $ANTLR start notDependentExts
 * Grammar/RFC5280.g:2323:1: notDependentExts : ( extension | keyUsage | subjectKeyId ) (| notDependentExts ) ;
 */
static RFC5280Parser_notDependentExts_return
notDependentExts(pRFC5280Parser ctx)
{
    RFC5280Parser_notDependentExts_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension981;
    #undef	RETURN_TYPE_extension981
    #define	RETURN_TYPE_extension981 RFC5280Parser_extension_return

    RFC5280Parser_keyUsage_return keyUsage982;
    #undef	RETURN_TYPE_keyUsage982
    #define	RETURN_TYPE_keyUsage982 RFC5280Parser_keyUsage_return

    RFC5280Parser_subjectKeyId_return subjectKeyId983;
    #undef	RETURN_TYPE_subjectKeyId983
    #define	RETURN_TYPE_subjectKeyId983 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_notDependentExts_return notDependentExts984;
    #undef	RETURN_TYPE_notDependentExts984
    #define	RETURN_TYPE_notDependentExts984 RFC5280Parser_notDependentExts_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension981.tree = NULL;

    keyUsage982.tree = NULL;

    subjectKeyId983.tree = NULL;

    notDependentExts984.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2329:9: ( ( extension | keyUsage | subjectKeyId ) (| notDependentExts ) )
        // Grammar/RFC5280.g:2330:3: ( extension | keyUsage | subjectKeyId ) (| notDependentExts )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // Grammar/RFC5280.g:2330:3: ( extension | keyUsage | subjectKeyId )
            {
                int alt268=3;
                switch ( LA(1) )
                {
                case SequenceTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDTag:
                			{
                				switch ( LA(3) )
                				{
                				case AIAOID:
                				case OIDAKI:
                				case OIDCERTPOL:
                				case OIDCRL:
                				case OIDEXTKEY:
                				case OIDFRESHCRL:
                				case OIDISSALT:
                				case OIDSUBALT:
                				case OIDSUBDIR:
                				case PRINTABLE:
                				case SIAOID:
                				case VALUE:
                					{
                						alt268=1;
                					}
                				    break;
                				case OIDKEYUS:
                					{
                						alt268=2;
                					}
                				    break;
                				case OIDSKI:
                					{
                						alt268=3;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 268;
                				    EXCEPTION->state        = 2;


                				    goto rulenotDependentExtsEx;

                				}

                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 268;
                		    EXCEPTION->state        = 1;


                		    goto rulenotDependentExtsEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 268;
                    EXCEPTION->state        = 0;


                    goto rulenotDependentExtsEx;

                }

                switch (alt268)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2330:4: extension
            	    {
            	        FOLLOWPUSH(FOLLOW_extension_in_notDependentExts4655);
            	        extension981=extension(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenotDependentExtsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extension981.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2330:16: keyUsage
            	    {
            	        FOLLOWPUSH(FOLLOW_keyUsage_in_notDependentExts4659);
            	        keyUsage982=keyUsage(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenotDependentExtsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsage982.tree);

            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:2330:27: subjectKeyId
            	    {
            	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_notDependentExts4663);
            	        subjectKeyId983=subjectKeyId(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenotDependentExtsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId983.tree);

            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:2330:41: (| notDependentExts )
            {
                int alt269=2;
                switch ( LA(1) )
                {
                case SequenceTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDTag:
                			{
                				switch ( LA(3) )
                				{
                				case GOST01SIGN:
                				case GOST94SIGN:
                				case MD2RSAOID:
                				case MD5RSAOID:
                				case RSAPSSOID:
                				case SHA1DSAOID:
                				case SHA1ECOID:
                				case SHA1RSAOID:
                				case SHA224DSAOID:
                				case SHA224ECOID:
                				case SHA224RSAOID:
                				case SHA256DSAOID:
                				case SHA256ECOID:
                				case SHA256RSAOID:
                				case SHA384ECOID:
                				case SHA384RSAOID:
                				case SHA512ECOID:
                				case SHA512RSAOID:
                					{
                						alt269=1;
                					}
                				    break;
                				case AIAOID:
                				case OIDAKI:
                				case OIDCERTPOL:
                				case OIDCRL:
                				case OIDEXTKEY:
                				case OIDFRESHCRL:
                				case OIDISSALT:
                				case OIDKEYUS:
                				case OIDSKI:
                				case OIDSUBALT:
                				case OIDSUBDIR:
                				case PRINTABLE:
                				case SIAOID:
                				case VALUE:
                					{
                						alt269=2;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 269;
                				    EXCEPTION->state        = 2;


                				    goto rulenotDependentExtsEx;

                				}

                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 269;
                		    EXCEPTION->state        = 1;


                		    goto rulenotDependentExtsEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 269;
                    EXCEPTION->state        = 0;


                    goto rulenotDependentExtsEx;

                }

                switch (alt269)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2330:43: 
            	    {
            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2330:44: notDependentExts
            	    {
            	        FOLLOWPUSH(FOLLOW_notDependentExts_in_notDependentExts4669);
            	        notDependentExts984=notDependentExts(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenotDependentExtsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, notDependentExts984.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulenotDependentExtsEx; /* Prevent compiler warnings */
    rulenotDependentExtsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end notDependentExts */

/**
 * $ANTLR start extensionsCertSignSubAlt
 * Grammar/RFC5280.g:2332:1: extensionsCertSignSubAlt : ( extensionNoSubAlt extensionsCertSignSubAlt | dependentExtension extensionsCertSignSubAlt | keyUsageCommon bitstringCertSign extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical extensionsCertSign );
 */
static RFC5280Parser_extensionsCertSignSubAlt_return
extensionsCertSignSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsCertSignSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt985;
    #undef	RETURN_TYPE_extensionNoSubAlt985
    #define	RETURN_TYPE_extensionNoSubAlt985 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsCertSignSubAlt_return extensionsCertSignSubAlt986;
    #undef	RETURN_TYPE_extensionsCertSignSubAlt986
    #define	RETURN_TYPE_extensionsCertSignSubAlt986 RFC5280Parser_extensionsCertSignSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension987;
    #undef	RETURN_TYPE_dependentExtension987
    #define	RETURN_TYPE_dependentExtension987 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsCertSignSubAlt_return extensionsCertSignSubAlt988;
    #undef	RETURN_TYPE_extensionsCertSignSubAlt988
    #define	RETURN_TYPE_extensionsCertSignSubAlt988 RFC5280Parser_extensionsCertSignSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon989;
    #undef	RETURN_TYPE_keyUsageCommon989
    #define	RETURN_TYPE_keyUsageCommon989 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign990;
    #undef	RETURN_TYPE_bitstringCertSign990
    #define	RETURN_TYPE_bitstringCertSign990 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return extensionsNotBCNotKeyUsageNotSkiSubAlt991;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt991
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt991 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical992;
    #undef	RETURN_TYPE_subAltNameCritical992
    #define	RETURN_TYPE_subAltNameCritical992 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsCertSign_return extensionsCertSign993;
    #undef	RETURN_TYPE_extensionsCertSign993
    #define	RETURN_TYPE_extensionsCertSign993 RFC5280Parser_extensionsCertSign_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt985.tree = NULL;

    extensionsCertSignSubAlt986.tree = NULL;

    dependentExtension987.tree = NULL;

    extensionsCertSignSubAlt988.tree = NULL;

    keyUsageCommon989.tree = NULL;

    bitstringCertSign990.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiSubAlt991.tree = NULL;

    subAltNameCritical992.tree = NULL;

    extensionsCertSign993.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2339:2: ( extensionNoSubAlt extensionsCertSignSubAlt | dependentExtension extensionsCertSignSubAlt | keyUsageCommon bitstringCertSign extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical extensionsCertSign )

            ANTLR3_UINT32 alt270;

            alt270=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt270=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt270=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt270=3;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt270=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 270;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsCertSignSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 270;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsCertSignSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 270;
                EXCEPTION->state        = 0;


                goto ruleextensionsCertSignSubAltEx;

            }

            switch (alt270)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2340:3: extensionNoSubAlt extensionsCertSignSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsCertSignSubAlt4692);
        	        extensionNoSubAlt985=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt985.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4694);
        	        extensionsCertSignSubAlt986=extensionsCertSignSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignSubAlt986.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2341:4: dependentExtension extensionsCertSignSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsCertSignSubAlt4699);
        	        dependentExtension987=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension987.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignSubAlt4701);
        	        extensionsCertSignSubAlt988=extensionsCertSignSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignSubAlt988.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2342:4: keyUsageCommon bitstringCertSign extensionsNotBCNotKeyUsageNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsCertSignSubAlt4706);
        	        keyUsageCommon989=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon989.tree);

        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsCertSignSubAlt4708);
        	        bitstringCertSign990=bitstringCertSign(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign990.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsCertSignSubAlt4710);
        	        extensionsNotBCNotKeyUsageNotSkiSubAlt991=extensionsNotBCNotKeyUsageNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiSubAlt991.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2343:4: subAltNameCritical extensionsCertSign
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsCertSignSubAlt4715);
        	        subAltNameCritical992=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical992.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSign_in_extensionsCertSignSubAlt4717);
        	        extensionsCertSign993=extensionsCertSign(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSign993.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsCertSignSubAltEx; /* Prevent compiler warnings */
    ruleextensionsCertSignSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsCertSignSubAlt */

/**
 * $ANTLR start extensionsCertSign
 * Grammar/RFC5280.g:2345:1: extensionsCertSign : ( extension extensionsCertSign | dependentExtension extensionsCertSign | keyUsageCommon bitstringCertSign ( extensionsNotBCNotKeyUsageNotSki )? );
 */
static RFC5280Parser_extensionsCertSign_return
extensionsCertSign(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsCertSign_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension994;
    #undef	RETURN_TYPE_extension994
    #define	RETURN_TYPE_extension994 RFC5280Parser_extension_return

    RFC5280Parser_extensionsCertSign_return extensionsCertSign995;
    #undef	RETURN_TYPE_extensionsCertSign995
    #define	RETURN_TYPE_extensionsCertSign995 RFC5280Parser_extensionsCertSign_return

    RFC5280Parser_dependentExtension_return dependentExtension996;
    #undef	RETURN_TYPE_dependentExtension996
    #define	RETURN_TYPE_dependentExtension996 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsCertSign_return extensionsCertSign997;
    #undef	RETURN_TYPE_extensionsCertSign997
    #define	RETURN_TYPE_extensionsCertSign997 RFC5280Parser_extensionsCertSign_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon998;
    #undef	RETURN_TYPE_keyUsageCommon998
    #define	RETURN_TYPE_keyUsageCommon998 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign999;
    #undef	RETURN_TYPE_bitstringCertSign999
    #define	RETURN_TYPE_bitstringCertSign999 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1000;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1000
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1000 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension994.tree = NULL;

    extensionsCertSign995.tree = NULL;

    dependentExtension996.tree = NULL;

    extensionsCertSign997.tree = NULL;

    keyUsageCommon998.tree = NULL;

    bitstringCertSign999.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1000.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2352:2: ( extension extensionsCertSign | dependentExtension extensionsCertSign | keyUsageCommon bitstringCertSign ( extensionsNotBCNotKeyUsageNotSki )? )

            ANTLR3_UINT32 alt272;

            alt272=3;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt272=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt272=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt272=3;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 272;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsCertSignEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 272;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsCertSignEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 272;
                EXCEPTION->state        = 0;


                goto ruleextensionsCertSignEx;

            }

            switch (alt272)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2353:3: extension extensionsCertSign
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsCertSign4740);
        	        extension994=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension994.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSign_in_extensionsCertSign4742);
        	        extensionsCertSign995=extensionsCertSign(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSign995.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2354:4: dependentExtension extensionsCertSign
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsCertSign4747);
        	        dependentExtension996=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension996.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSign_in_extensionsCertSign4749);
        	        extensionsCertSign997=extensionsCertSign(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSign997.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2355:4: keyUsageCommon bitstringCertSign ( extensionsNotBCNotKeyUsageNotSki )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsCertSign4754);
        	        keyUsageCommon998=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon998.tree);

        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsCertSign4756);
        	        bitstringCertSign999=bitstringCertSign(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign999.tree);

        	        // Grammar/RFC5280.g:2355:37: ( extensionsNotBCNotKeyUsageNotSki )?
        	        {
        	            int alt271=2;
        	            switch ( LA(1) )
        	            {
        	                case SequenceTag:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case OIDTag:
        	                		    	{
        	                		    		switch ( LA(3) )
        	                		    		{
        	                		    		    case AIAOID:
        	                		    		    case OIDAKI:
        	                		    		    case OIDCERTPOL:
        	                		    		    case OIDCRL:
        	                		    		    case OIDEXTKEY:
        	                		    		    case OIDFRESHCRL:
        	                		    		    case OIDINHIBIT:
        	                		    		    case OIDISSALT:
        	                		    		    case OIDNAME:
        	                		    		    case OIDPOLCONST:
        	                		    		    case OIDPOLMAP:
        	                		    		    case OIDSUBALT:
        	                		    		    case OIDSUBDIR:
        	                		    		    case PRINTABLE:
        	                		    		    case SIAOID:
        	                		    		    case VALUE:
        	                		    		    	{
        	                		    		    		alt271=1;
        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt271)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2355:37: extensionsNotBCNotKeyUsageNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsCertSign4758);
        	        	        extensionsNotBCNotKeyUsageNotSki1000=extensionsNotBCNotKeyUsageNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsCertSignEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1000.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsCertSignEx; /* Prevent compiler warnings */
    ruleextensionsCertSignEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsCertSign */

/**
 * $ANTLR start extensionsCertSignAndSkiSubAlt
 * Grammar/RFC5280.g:2357:1: extensionsCertSignAndSkiSubAlt : ( extensionNoSubAlt extensionsCertSignAndSkiSubAlt | dependentExtension extensionsCertSignAndSkiSubAlt | keyUsageCommon bitstringCertSign extensionsNotBCNotKeyUsage | subjectKeyId extensionsCertSignSubAlt | subAltNameCritical extensionsCertSignAndSki );
 */
static RFC5280Parser_extensionsCertSignAndSkiSubAlt_return
extensionsCertSignAndSkiSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsCertSignAndSkiSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1001;
    #undef	RETURN_TYPE_extensionNoSubAlt1001
    #define	RETURN_TYPE_extensionNoSubAlt1001 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsCertSignAndSkiSubAlt_return extensionsCertSignAndSkiSubAlt1002;
    #undef	RETURN_TYPE_extensionsCertSignAndSkiSubAlt1002
    #define	RETURN_TYPE_extensionsCertSignAndSkiSubAlt1002 RFC5280Parser_extensionsCertSignAndSkiSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1003;
    #undef	RETURN_TYPE_dependentExtension1003
    #define	RETURN_TYPE_dependentExtension1003 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsCertSignAndSkiSubAlt_return extensionsCertSignAndSkiSubAlt1004;
    #undef	RETURN_TYPE_extensionsCertSignAndSkiSubAlt1004
    #define	RETURN_TYPE_extensionsCertSignAndSkiSubAlt1004 RFC5280Parser_extensionsCertSignAndSkiSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1005;
    #undef	RETURN_TYPE_keyUsageCommon1005
    #define	RETURN_TYPE_keyUsageCommon1005 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1006;
    #undef	RETURN_TYPE_bitstringCertSign1006
    #define	RETURN_TYPE_bitstringCertSign1006 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage1007;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage1007
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage1007 RFC5280Parser_extensionsNotBCNotKeyUsage_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1008;
    #undef	RETURN_TYPE_subjectKeyId1008
    #define	RETURN_TYPE_subjectKeyId1008 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsCertSignSubAlt_return extensionsCertSignSubAlt1009;
    #undef	RETURN_TYPE_extensionsCertSignSubAlt1009
    #define	RETURN_TYPE_extensionsCertSignSubAlt1009 RFC5280Parser_extensionsCertSignSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1010;
    #undef	RETURN_TYPE_subAltNameCritical1010
    #define	RETURN_TYPE_subAltNameCritical1010 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsCertSignAndSki_return extensionsCertSignAndSki1011;
    #undef	RETURN_TYPE_extensionsCertSignAndSki1011
    #define	RETURN_TYPE_extensionsCertSignAndSki1011 RFC5280Parser_extensionsCertSignAndSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1001.tree = NULL;

    extensionsCertSignAndSkiSubAlt1002.tree = NULL;

    dependentExtension1003.tree = NULL;

    extensionsCertSignAndSkiSubAlt1004.tree = NULL;

    keyUsageCommon1005.tree = NULL;

    bitstringCertSign1006.tree = NULL;

    extensionsNotBCNotKeyUsage1007.tree = NULL;

    subjectKeyId1008.tree = NULL;

    extensionsCertSignSubAlt1009.tree = NULL;

    subAltNameCritical1010.tree = NULL;

    extensionsCertSignAndSki1011.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2364:2: ( extensionNoSubAlt extensionsCertSignAndSkiSubAlt | dependentExtension extensionsCertSignAndSkiSubAlt | keyUsageCommon bitstringCertSign extensionsNotBCNotKeyUsage | subjectKeyId extensionsCertSignSubAlt | subAltNameCritical extensionsCertSignAndSki )

            ANTLR3_UINT32 alt273;

            alt273=5;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt273=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt273=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt273=3;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt273=4;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt273=5;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 273;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsCertSignAndSkiSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 273;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsCertSignAndSkiSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 273;
                EXCEPTION->state        = 0;


                goto ruleextensionsCertSignAndSkiSubAltEx;

            }

            switch (alt273)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2365:3: extensionNoSubAlt extensionsCertSignAndSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsCertSignAndSkiSubAlt4782);
        	        extensionNoSubAlt1001=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1001.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4784);
        	        extensionsCertSignAndSkiSubAlt1002=extensionsCertSignAndSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignAndSkiSubAlt1002.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2366:4: dependentExtension extensionsCertSignAndSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsCertSignAndSkiSubAlt4789);
        	        dependentExtension1003=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1003.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSignAndSkiSubAlt_in_extensionsCertSignAndSkiSubAlt4791);
        	        extensionsCertSignAndSkiSubAlt1004=extensionsCertSignAndSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignAndSkiSubAlt1004.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2367:4: keyUsageCommon bitstringCertSign extensionsNotBCNotKeyUsage
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsCertSignAndSkiSubAlt4796);
        	        keyUsageCommon1005=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1005.tree);

        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsCertSignAndSkiSubAlt4798);
        	        bitstringCertSign1006=bitstringCertSign(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1006.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSkiSubAlt4800);
        	        extensionsNotBCNotKeyUsage1007=extensionsNotBCNotKeyUsage(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage1007.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2368:4: subjectKeyId extensionsCertSignSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsCertSignAndSkiSubAlt4805);
        	        subjectKeyId1008=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1008.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSignSubAlt_in_extensionsCertSignAndSkiSubAlt4807);
        	        extensionsCertSignSubAlt1009=extensionsCertSignSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignSubAlt1009.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:2369:4: subAltNameCritical extensionsCertSignAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsCertSignAndSkiSubAlt4812);
        	        subAltNameCritical1010=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1010.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSkiSubAlt4814);
        	        extensionsCertSignAndSki1011=extensionsCertSignAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignAndSki1011.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsCertSignAndSkiSubAltEx; /* Prevent compiler warnings */
    ruleextensionsCertSignAndSkiSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsCertSignAndSkiSubAlt */

/**
 * $ANTLR start extensionsCertSignAndSki
 * Grammar/RFC5280.g:2373:1: extensionsCertSignAndSki : ( extension extensionsCertSignAndSki | dependentExtension extensionsCertSignAndSki | keyUsageCommon bitstringCertSign extensionsNotBCNotKeyUsage | subjectKeyId extensionsCertSign );
 */
static RFC5280Parser_extensionsCertSignAndSki_return
extensionsCertSignAndSki(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsCertSignAndSki_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1012;
    #undef	RETURN_TYPE_extension1012
    #define	RETURN_TYPE_extension1012 RFC5280Parser_extension_return

    RFC5280Parser_extensionsCertSignAndSki_return extensionsCertSignAndSki1013;
    #undef	RETURN_TYPE_extensionsCertSignAndSki1013
    #define	RETURN_TYPE_extensionsCertSignAndSki1013 RFC5280Parser_extensionsCertSignAndSki_return

    RFC5280Parser_dependentExtension_return dependentExtension1014;
    #undef	RETURN_TYPE_dependentExtension1014
    #define	RETURN_TYPE_dependentExtension1014 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsCertSignAndSki_return extensionsCertSignAndSki1015;
    #undef	RETURN_TYPE_extensionsCertSignAndSki1015
    #define	RETURN_TYPE_extensionsCertSignAndSki1015 RFC5280Parser_extensionsCertSignAndSki_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1016;
    #undef	RETURN_TYPE_keyUsageCommon1016
    #define	RETURN_TYPE_keyUsageCommon1016 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1017;
    #undef	RETURN_TYPE_bitstringCertSign1017
    #define	RETURN_TYPE_bitstringCertSign1017 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage1018;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage1018
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage1018 RFC5280Parser_extensionsNotBCNotKeyUsage_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1019;
    #undef	RETURN_TYPE_subjectKeyId1019
    #define	RETURN_TYPE_subjectKeyId1019 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsCertSign_return extensionsCertSign1020;
    #undef	RETURN_TYPE_extensionsCertSign1020
    #define	RETURN_TYPE_extensionsCertSign1020 RFC5280Parser_extensionsCertSign_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1012.tree = NULL;

    extensionsCertSignAndSki1013.tree = NULL;

    dependentExtension1014.tree = NULL;

    extensionsCertSignAndSki1015.tree = NULL;

    keyUsageCommon1016.tree = NULL;

    bitstringCertSign1017.tree = NULL;

    extensionsNotBCNotKeyUsage1018.tree = NULL;

    subjectKeyId1019.tree = NULL;

    extensionsCertSign1020.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2379:9: ( extension extensionsCertSignAndSki | dependentExtension extensionsCertSignAndSki | keyUsageCommon bitstringCertSign extensionsNotBCNotKeyUsage | subjectKeyId extensionsCertSign )

            ANTLR3_UINT32 alt274;

            alt274=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt274=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt274=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt274=3;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt274=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 274;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsCertSignAndSkiEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 274;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsCertSignAndSkiEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 274;
                EXCEPTION->state        = 0;


                goto ruleextensionsCertSignAndSkiEx;

            }

            switch (alt274)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2380:3: extension extensionsCertSignAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsCertSignAndSki4837);
        	        extension1012=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1012.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4839);
        	        extensionsCertSignAndSki1013=extensionsCertSignAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignAndSki1013.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2381:4: dependentExtension extensionsCertSignAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsCertSignAndSki4844);
        	        dependentExtension1014=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1014.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSignAndSki_in_extensionsCertSignAndSki4846);
        	        extensionsCertSignAndSki1015=extensionsCertSignAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignAndSki1015.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2382:4: keyUsageCommon bitstringCertSign extensionsNotBCNotKeyUsage
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsCertSignAndSki4851);
        	        keyUsageCommon1016=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1016.tree);

        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsCertSignAndSki4853);
        	        bitstringCertSign1017=bitstringCertSign(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1017.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsCertSignAndSki4855);
        	        extensionsNotBCNotKeyUsage1018=extensionsNotBCNotKeyUsage(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage1018.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2383:4: subjectKeyId extensionsCertSign
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsCertSignAndSki4860);
        	        subjectKeyId1019=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1019.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsCertSign_in_extensionsCertSignAndSki4862);
        	        extensionsCertSign1020=extensionsCertSign(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSign1020.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsCertSignAndSkiEx; /* Prevent compiler warnings */
    ruleextensionsCertSignAndSkiEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsCertSignAndSki */

/**
 * $ANTLR start extensionsNotCertSignSubAlt
 * Grammar/RFC5280.g:2385:1: extensionsNotCertSignSubAlt : ( extensionNoSubAlt extensionsNotCertSignSubAlt | dependentExtension extensionsNotCertSignSubAlt | keyUsageCommon bitstring extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical extensionsNotCertSign );
 */
static RFC5280Parser_extensionsNotCertSignSubAlt_return
extensionsNotCertSignSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotCertSignSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1021;
    #undef	RETURN_TYPE_extensionNoSubAlt1021
    #define	RETURN_TYPE_extensionNoSubAlt1021 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNotCertSignSubAlt_return extensionsNotCertSignSubAlt1022;
    #undef	RETURN_TYPE_extensionsNotCertSignSubAlt1022
    #define	RETURN_TYPE_extensionsNotCertSignSubAlt1022 RFC5280Parser_extensionsNotCertSignSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1023;
    #undef	RETURN_TYPE_dependentExtension1023
    #define	RETURN_TYPE_dependentExtension1023 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotCertSignSubAlt_return extensionsNotCertSignSubAlt1024;
    #undef	RETURN_TYPE_extensionsNotCertSignSubAlt1024
    #define	RETURN_TYPE_extensionsNotCertSignSubAlt1024 RFC5280Parser_extensionsNotCertSignSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1025;
    #undef	RETURN_TYPE_keyUsageCommon1025
    #define	RETURN_TYPE_keyUsageCommon1025 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1026;
    #undef	RETURN_TYPE_bitstring1026
    #define	RETURN_TYPE_bitstring1026 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return extensionsNotBCNotKeyUsageNotSkiSubAlt1027;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1027
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1027 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1028;
    #undef	RETURN_TYPE_subAltNameCritical1028
    #define	RETURN_TYPE_subAltNameCritical1028 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNotCertSign_return extensionsNotCertSign1029;
    #undef	RETURN_TYPE_extensionsNotCertSign1029
    #define	RETURN_TYPE_extensionsNotCertSign1029 RFC5280Parser_extensionsNotCertSign_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1021.tree = NULL;

    extensionsNotCertSignSubAlt1022.tree = NULL;

    dependentExtension1023.tree = NULL;

    extensionsNotCertSignSubAlt1024.tree = NULL;

    keyUsageCommon1025.tree = NULL;

    bitstring1026.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiSubAlt1027.tree = NULL;

    subAltNameCritical1028.tree = NULL;

    extensionsNotCertSign1029.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2391:9: ( extensionNoSubAlt extensionsNotCertSignSubAlt | dependentExtension extensionsNotCertSignSubAlt | keyUsageCommon bitstring extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical extensionsNotCertSign )

            ANTLR3_UINT32 alt275;

            alt275=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt275=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt275=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt275=3;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt275=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 275;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotCertSignSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 275;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotCertSignSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 275;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotCertSignSubAltEx;

            }

            switch (alt275)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2392:3: extensionNoSubAlt extensionsNotCertSignSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignSubAlt4883);
        	        extensionNoSubAlt1021=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1021.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4885);
        	        extensionsNotCertSignSubAlt1022=extensionsNotCertSignSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignSubAlt1022.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2393:4: dependentExtension extensionsNotCertSignSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotCertSignSubAlt4890);
        	        dependentExtension1023=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1023.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignSubAlt4892);
        	        extensionsNotCertSignSubAlt1024=extensionsNotCertSignSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignSubAlt1024.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2394:4: keyUsageCommon bitstring extensionsNotBCNotKeyUsageNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNotCertSignSubAlt4897);
        	        keyUsageCommon1025=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1025.tree);

        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNotCertSignSubAlt4899);
        	        bitstring1026=bitstring(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1026.tree);

        	        {
        	            key_usage_ext->value->keyusage = bitstring1026.text
        	            ;
        	        }


        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotCertSignSubAlt4903);
        	        extensionsNotBCNotKeyUsageNotSkiSubAlt1027=extensionsNotBCNotKeyUsageNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiSubAlt1027.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2395:4: subAltNameCritical extensionsNotCertSign
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsNotCertSignSubAlt4908);
        	        subAltNameCritical1028=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1028.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignSubAlt4910);
        	        extensionsNotCertSign1029=extensionsNotCertSign(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSign1029.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotCertSignSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNotCertSignSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotCertSignSubAlt */

/**
 * $ANTLR start extensionsNotCertSign
 * Grammar/RFC5280.g:2397:1: extensionsNotCertSign : ( extension (| extensionsNotCertSign ) | dependentExtension (| extensionsNotCertSign ) | keyUsageCommon bitstring ( extensionsNotBCNotKeyUsageNotSki )? );
 */
static RFC5280Parser_extensionsNotCertSign_return
extensionsNotCertSign(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotCertSign_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1030;
    #undef	RETURN_TYPE_extension1030
    #define	RETURN_TYPE_extension1030 RFC5280Parser_extension_return

    RFC5280Parser_extensionsNotCertSign_return extensionsNotCertSign1031;
    #undef	RETURN_TYPE_extensionsNotCertSign1031
    #define	RETURN_TYPE_extensionsNotCertSign1031 RFC5280Parser_extensionsNotCertSign_return

    RFC5280Parser_dependentExtension_return dependentExtension1032;
    #undef	RETURN_TYPE_dependentExtension1032
    #define	RETURN_TYPE_dependentExtension1032 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotCertSign_return extensionsNotCertSign1033;
    #undef	RETURN_TYPE_extensionsNotCertSign1033
    #define	RETURN_TYPE_extensionsNotCertSign1033 RFC5280Parser_extensionsNotCertSign_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1034;
    #undef	RETURN_TYPE_keyUsageCommon1034
    #define	RETURN_TYPE_keyUsageCommon1034 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1035;
    #undef	RETURN_TYPE_bitstring1035
    #define	RETURN_TYPE_bitstring1035 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1036;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1036
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1036 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1030.tree = NULL;

    extensionsNotCertSign1031.tree = NULL;

    dependentExtension1032.tree = NULL;

    extensionsNotCertSign1033.tree = NULL;

    keyUsageCommon1034.tree = NULL;

    bitstring1035.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1036.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2404:2: ( extension (| extensionsNotCertSign ) | dependentExtension (| extensionsNotCertSign ) | keyUsageCommon bitstring ( extensionsNotBCNotKeyUsageNotSki )? )

            ANTLR3_UINT32 alt279;

            alt279=3;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt279=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt279=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt279=3;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 279;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotCertSignEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 279;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotCertSignEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 279;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotCertSignEx;

            }

            switch (alt279)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2405:3: extension (| extensionsNotCertSign )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsNotCertSign4934);
        	        extension1030=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1030.tree);

        	        // Grammar/RFC5280.g:2405:13: (| extensionsNotCertSign )
        	        {
        	            int alt276=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt276=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt276=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 276;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotCertSignEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 276;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotCertSignEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 276;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotCertSignEx;

        	            }

        	            switch (alt276)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2405:15: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2405:16: extensionsNotCertSign
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4939);
        	        	        extensionsNotCertSign1031=extensionsNotCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotCertSignEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSign1031.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2406:4: dependentExtension (| extensionsNotCertSign )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotCertSign4945);
        	        dependentExtension1032=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1032.tree);

        	        // Grammar/RFC5280.g:2406:23: (| extensionsNotCertSign )
        	        {
        	            int alt277=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt277=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt277=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 277;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotCertSignEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 277;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotCertSignEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 277;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotCertSignEx;

        	            }

        	            switch (alt277)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2406:25: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:2406:26: extensionsNotCertSign
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSign_in_extensionsNotCertSign4950);
        	        	        extensionsNotCertSign1033=extensionsNotCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotCertSignEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSign1033.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2407:4: keyUsageCommon bitstring ( extensionsNotBCNotKeyUsageNotSki )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNotCertSign4956);
        	        keyUsageCommon1034=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1034.tree);

        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNotCertSign4958);
        	        bitstring1035=bitstring(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1035.tree);

        	        {
        	            key_usage_ext->value->keyusage = bitstring1035.text
        	            ;
        	        }


        	        // Grammar/RFC5280.g:2407:81: ( extensionsNotBCNotKeyUsageNotSki )?
        	        {
        	            int alt278=2;
        	            switch ( LA(1) )
        	            {
        	                case SequenceTag:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case OIDTag:
        	                		    	{
        	                		    		switch ( LA(3) )
        	                		    		{
        	                		    		    case AIAOID:
        	                		    		    case OIDAKI:
        	                		    		    case OIDCERTPOL:
        	                		    		    case OIDCRL:
        	                		    		    case OIDEXTKEY:
        	                		    		    case OIDFRESHCRL:
        	                		    		    case OIDINHIBIT:
        	                		    		    case OIDISSALT:
        	                		    		    case OIDNAME:
        	                		    		    case OIDPOLCONST:
        	                		    		    case OIDPOLMAP:
        	                		    		    case OIDSUBALT:
        	                		    		    case OIDSUBDIR:
        	                		    		    case PRINTABLE:
        	                		    		    case SIAOID:
        	                		    		    case VALUE:
        	                		    		    	{
        	                		    		    		alt278=1;
        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt278)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2407:81: extensionsNotBCNotKeyUsageNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotCertSign4962);
        	        	        extensionsNotBCNotKeyUsageNotSki1036=extensionsNotBCNotKeyUsageNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotCertSignEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1036.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotCertSignEx; /* Prevent compiler warnings */
    ruleextensionsNotCertSignEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotCertSign */

/**
 * $ANTLR start extensionsNotCertSignAndSkiSubAlt
 * Grammar/RFC5280.g:2409:1: extensionsNotCertSignAndSkiSubAlt : ( extensionNoSubAlt extensionsNotCertSignAndSkiSubAlt | dependentExtension extensionsNotCertSignAndSkiSubAlt | keyUsageCommon bitstring extensionsNotBCNotKeyUsageSubAlt | subjectKeyId extensionsNotCertSignSubAlt | subAltNameCritical extensionsNotCertSignAndSki );
 */
static RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return
extensionsNotCertSignAndSkiSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1037;
    #undef	RETURN_TYPE_extensionNoSubAlt1037
    #define	RETURN_TYPE_extensionNoSubAlt1037 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return extensionsNotCertSignAndSkiSubAlt1038;
    #undef	RETURN_TYPE_extensionsNotCertSignAndSkiSubAlt1038
    #define	RETURN_TYPE_extensionsNotCertSignAndSkiSubAlt1038 RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1039;
    #undef	RETURN_TYPE_dependentExtension1039
    #define	RETURN_TYPE_dependentExtension1039 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return extensionsNotCertSignAndSkiSubAlt1040;
    #undef	RETURN_TYPE_extensionsNotCertSignAndSkiSubAlt1040
    #define	RETURN_TYPE_extensionsNotCertSignAndSkiSubAlt1040 RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1041;
    #undef	RETURN_TYPE_keyUsageCommon1041
    #define	RETURN_TYPE_keyUsageCommon1041 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1042;
    #undef	RETURN_TYPE_bitstring1042
    #define	RETURN_TYPE_bitstring1042 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return extensionsNotBCNotKeyUsageSubAlt1043;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1043
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1043 RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1044;
    #undef	RETURN_TYPE_subjectKeyId1044
    #define	RETURN_TYPE_subjectKeyId1044 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNotCertSignSubAlt_return extensionsNotCertSignSubAlt1045;
    #undef	RETURN_TYPE_extensionsNotCertSignSubAlt1045
    #define	RETURN_TYPE_extensionsNotCertSignSubAlt1045 RFC5280Parser_extensionsNotCertSignSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1046;
    #undef	RETURN_TYPE_subAltNameCritical1046
    #define	RETURN_TYPE_subAltNameCritical1046 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNotCertSignAndSki_return extensionsNotCertSignAndSki1047;
    #undef	RETURN_TYPE_extensionsNotCertSignAndSki1047
    #define	RETURN_TYPE_extensionsNotCertSignAndSki1047 RFC5280Parser_extensionsNotCertSignAndSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1037.tree = NULL;

    extensionsNotCertSignAndSkiSubAlt1038.tree = NULL;

    dependentExtension1039.tree = NULL;

    extensionsNotCertSignAndSkiSubAlt1040.tree = NULL;

    keyUsageCommon1041.tree = NULL;

    bitstring1042.tree = NULL;

    extensionsNotBCNotKeyUsageSubAlt1043.tree = NULL;

    subjectKeyId1044.tree = NULL;

    extensionsNotCertSignSubAlt1045.tree = NULL;

    subAltNameCritical1046.tree = NULL;

    extensionsNotCertSignAndSki1047.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2416:2: ( extensionNoSubAlt extensionsNotCertSignAndSkiSubAlt | dependentExtension extensionsNotCertSignAndSkiSubAlt | keyUsageCommon bitstring extensionsNotBCNotKeyUsageSubAlt | subjectKeyId extensionsNotCertSignSubAlt | subAltNameCritical extensionsNotCertSignAndSki )

            ANTLR3_UINT32 alt280;

            alt280=5;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt280=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt280=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt280=3;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt280=4;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt280=5;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 280;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotCertSignAndSkiSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 280;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotCertSignAndSkiSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 280;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotCertSignAndSkiSubAltEx;

            }

            switch (alt280)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2417:3: extensionNoSubAlt extensionsNotCertSignAndSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNotCertSignAndSkiSubAlt4985);
        	        extensionNoSubAlt1037=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1037.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4987);
        	        extensionsNotCertSignAndSkiSubAlt1038=extensionsNotCertSignAndSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignAndSkiSubAlt1038.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2418:4: dependentExtension extensionsNotCertSignAndSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotCertSignAndSkiSubAlt4992);
        	        dependentExtension1039=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1039.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_extensionsNotCertSignAndSkiSubAlt4994);
        	        extensionsNotCertSignAndSkiSubAlt1040=extensionsNotCertSignAndSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignAndSkiSubAlt1040.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2419:4: keyUsageCommon bitstring extensionsNotBCNotKeyUsageSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSkiSubAlt4999);
        	        keyUsageCommon1041=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1041.tree);

        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNotCertSignAndSkiSubAlt5001);
        	        bitstring1042=bitstring(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1042.tree);

        	        {
        	            key_usage_ext->value->keyusage = bitstring1042.text
        	            ;
        	        }


        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotCertSignAndSkiSubAlt5005);
        	        extensionsNotBCNotKeyUsageSubAlt1043=extensionsNotBCNotKeyUsageSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageSubAlt1043.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2420:4: subjectKeyId extensionsNotCertSignSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSkiSubAlt5010);
        	        subjectKeyId1044=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1044.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignSubAlt_in_extensionsNotCertSignAndSkiSubAlt5012);
        	        extensionsNotCertSignSubAlt1045=extensionsNotCertSignSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignSubAlt1045.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:2421:4: subAltNameCritical extensionsNotCertSignAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsNotCertSignAndSkiSubAlt5017);
        	        subAltNameCritical1046=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1046.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSkiSubAlt5019);
        	        extensionsNotCertSignAndSki1047=extensionsNotCertSignAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignAndSki1047.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotCertSignAndSkiSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNotCertSignAndSkiSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotCertSignAndSkiSubAlt */

/**
 * $ANTLR start extensionsNotCertSignAndSki
 * Grammar/RFC5280.g:2423:1: extensionsNotCertSignAndSki : ( extension extensionsNotCertSignAndSki | dependentExtension extensionsNotCertSignAndSki | keyUsageCommon bitstring extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotCertSign )? );
 */
static RFC5280Parser_extensionsNotCertSignAndSki_return
extensionsNotCertSignAndSki(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotCertSignAndSki_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1048;
    #undef	RETURN_TYPE_extension1048
    #define	RETURN_TYPE_extension1048 RFC5280Parser_extension_return

    RFC5280Parser_extensionsNotCertSignAndSki_return extensionsNotCertSignAndSki1049;
    #undef	RETURN_TYPE_extensionsNotCertSignAndSki1049
    #define	RETURN_TYPE_extensionsNotCertSignAndSki1049 RFC5280Parser_extensionsNotCertSignAndSki_return

    RFC5280Parser_dependentExtension_return dependentExtension1050;
    #undef	RETURN_TYPE_dependentExtension1050
    #define	RETURN_TYPE_dependentExtension1050 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotCertSignAndSki_return extensionsNotCertSignAndSki1051;
    #undef	RETURN_TYPE_extensionsNotCertSignAndSki1051
    #define	RETURN_TYPE_extensionsNotCertSignAndSki1051 RFC5280Parser_extensionsNotCertSignAndSki_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1052;
    #undef	RETURN_TYPE_keyUsageCommon1052
    #define	RETURN_TYPE_keyUsageCommon1052 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1053;
    #undef	RETURN_TYPE_bitstring1053
    #define	RETURN_TYPE_bitstring1053 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage1054;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage1054
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage1054 RFC5280Parser_extensionsNotBCNotKeyUsage_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1055;
    #undef	RETURN_TYPE_subjectKeyId1055
    #define	RETURN_TYPE_subjectKeyId1055 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNotCertSign_return extensionsNotCertSign1056;
    #undef	RETURN_TYPE_extensionsNotCertSign1056
    #define	RETURN_TYPE_extensionsNotCertSign1056 RFC5280Parser_extensionsNotCertSign_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1048.tree = NULL;

    extensionsNotCertSignAndSki1049.tree = NULL;

    dependentExtension1050.tree = NULL;

    extensionsNotCertSignAndSki1051.tree = NULL;

    keyUsageCommon1052.tree = NULL;

    bitstring1053.tree = NULL;

    extensionsNotBCNotKeyUsage1054.tree = NULL;

    subjectKeyId1055.tree = NULL;

    extensionsNotCertSign1056.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2430:2: ( extension extensionsNotCertSignAndSki | dependentExtension extensionsNotCertSignAndSki | keyUsageCommon bitstring extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotCertSign )? )

            ANTLR3_UINT32 alt282;

            alt282=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt282=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt282=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt282=3;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt282=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 282;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotCertSignAndSkiEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 282;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotCertSignAndSkiEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 282;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotCertSignAndSkiEx;

            }

            switch (alt282)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2431:3: extension extensionsNotCertSignAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsNotCertSignAndSki5043);
        	        extension1048=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1048.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5045);
        	        extensionsNotCertSignAndSki1049=extensionsNotCertSignAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignAndSki1049.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2432:4: dependentExtension extensionsNotCertSignAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotCertSignAndSki5050);
        	        dependentExtension1050=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1050.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignAndSki_in_extensionsNotCertSignAndSki5052);
        	        extensionsNotCertSignAndSki1051=extensionsNotCertSignAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignAndSki1051.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2433:4: keyUsageCommon bitstring extensionsNotBCNotKeyUsage
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNotCertSignAndSki5057);
        	        keyUsageCommon1052=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1052.tree);

        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNotCertSignAndSki5059);
        	        bitstring1053=bitstring(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1053.tree);

        	        {
        	            key_usage_ext->value->keyusage = bitstring1053.text
        	            ;
        	        }


        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotCertSignAndSki5063);
        	        extensionsNotBCNotKeyUsage1054=extensionsNotBCNotKeyUsage(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage1054.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2434:4: subjectKeyId ( extensionsNotCertSign )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsNotCertSignAndSki5068);
        	        subjectKeyId1055=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotCertSignAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1055.tree);

        	        // Grammar/RFC5280.g:2434:17: ( extensionsNotCertSign )?
        	        {
        	            int alt281=2;
        	            switch ( LA(1) )
        	            {
        	                case SequenceTag:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case OIDTag:
        	                		    	{
        	                		    		switch ( LA(3) )
        	                		    		{
        	                		    		    case AIAOID:
        	                		    		    case OIDAKI:
        	                		    		    case OIDCERTPOL:
        	                		    		    case OIDCRL:
        	                		    		    case OIDEXTKEY:
        	                		    		    case OIDFRESHCRL:
        	                		    		    case OIDINHIBIT:
        	                		    		    case OIDISSALT:
        	                		    		    case OIDKEYUS:
        	                		    		    case OIDNAME:
        	                		    		    case OIDPOLCONST:
        	                		    		    case OIDPOLMAP:
        	                		    		    case OIDSUBALT:
        	                		    		    case OIDSUBDIR:
        	                		    		    case PRINTABLE:
        	                		    		    case SIAOID:
        	                		    		    case VALUE:
        	                		    		    	{
        	                		    		    		alt281=1;
        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt281)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:2434:17: extensionsNotCertSign
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSign_in_extensionsNotCertSignAndSki5070);
        	        	        extensionsNotCertSign1056=extensionsNotCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotCertSignAndSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSign1056.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotCertSignAndSkiEx; /* Prevent compiler warnings */
    ruleextensionsNotCertSignAndSkiEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotCertSignAndSki */

/**
 * $ANTLR start extension
 * Grammar/RFC5280.g:2436:1: extension : sequenceTag ( authKeyId | certPolicies | subAltName | issuerAltName | subDirAttr | extendKeyUsage | crldp | sia | aia | freshcrl | genericExt ) ;
 */
static RFC5280Parser_extension_return
extension(pRFC5280Parser ctx)
{
    RFC5280Parser_extension_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1057;
    #undef	RETURN_TYPE_sequenceTag1057
    #define	RETURN_TYPE_sequenceTag1057 RFC5280Parser_sequenceTag_return

    RFC5280Parser_authKeyId_return authKeyId1058;
    #undef	RETURN_TYPE_authKeyId1058
    #define	RETURN_TYPE_authKeyId1058 RFC5280Parser_authKeyId_return

    RFC5280Parser_certPolicies_return certPolicies1059;
    #undef	RETURN_TYPE_certPolicies1059
    #define	RETURN_TYPE_certPolicies1059 RFC5280Parser_certPolicies_return

    RFC5280Parser_subAltName_return subAltName1060;
    #undef	RETURN_TYPE_subAltName1060
    #define	RETURN_TYPE_subAltName1060 RFC5280Parser_subAltName_return

    RFC5280Parser_issuerAltName_return issuerAltName1061;
    #undef	RETURN_TYPE_issuerAltName1061
    #define	RETURN_TYPE_issuerAltName1061 RFC5280Parser_issuerAltName_return

    RFC5280Parser_subDirAttr_return subDirAttr1062;
    #undef	RETURN_TYPE_subDirAttr1062
    #define	RETURN_TYPE_subDirAttr1062 RFC5280Parser_subDirAttr_return

    RFC5280Parser_extendKeyUsage_return extendKeyUsage1063;
    #undef	RETURN_TYPE_extendKeyUsage1063
    #define	RETURN_TYPE_extendKeyUsage1063 RFC5280Parser_extendKeyUsage_return

    RFC5280Parser_crldp_return crldp1064;
    #undef	RETURN_TYPE_crldp1064
    #define	RETURN_TYPE_crldp1064 RFC5280Parser_crldp_return

    RFC5280Parser_sia_return sia1065;
    #undef	RETURN_TYPE_sia1065
    #define	RETURN_TYPE_sia1065 RFC5280Parser_sia_return

    RFC5280Parser_aia_return aia1066;
    #undef	RETURN_TYPE_aia1066
    #define	RETURN_TYPE_aia1066 RFC5280Parser_aia_return

    RFC5280Parser_freshcrl_return freshcrl1067;
    #undef	RETURN_TYPE_freshcrl1067
    #define	RETURN_TYPE_freshcrl1067 RFC5280Parser_freshcrl_return

    RFC5280Parser_genericExt_return genericExt1068;
    #undef	RETURN_TYPE_genericExt1068
    #define	RETURN_TYPE_genericExt1068 RFC5280Parser_genericExt_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1057.tree = NULL;

    authKeyId1058.tree = NULL;

    certPolicies1059.tree = NULL;

    subAltName1060.tree = NULL;

    issuerAltName1061.tree = NULL;

    subDirAttr1062.tree = NULL;

    extendKeyUsage1063.tree = NULL;

    crldp1064.tree = NULL;

    sia1065.tree = NULL;

    aia1066.tree = NULL;

    freshcrl1067.tree = NULL;

    genericExt1068.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2439:2: ( sequenceTag ( authKeyId | certPolicies | subAltName | issuerAltName | subDirAttr | extendKeyUsage | crldp | sia | aia | freshcrl | genericExt ) )
        // Grammar/RFC5280.g:2439:3: sequenceTag ( authKeyId | certPolicies | subAltName | issuerAltName | subDirAttr | extendKeyUsage | crldp | sia | aia | freshcrl | genericExt )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                printf("It's ext \n");
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_extension5089);
            sequenceTag1057=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1057.tree);

            // Grammar/RFC5280.g:2442:40: ( authKeyId | certPolicies | subAltName | issuerAltName | subDirAttr | extendKeyUsage | crldp | sia | aia | freshcrl | genericExt )
            {
                int alt283=11;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDAKI:
                			{
                				alt283=1;
                			}
                		    break;
                		case OIDCERTPOL:
                			{
                				alt283=2;
                			}
                		    break;
                		case OIDSUBALT:
                			{
                				alt283=3;
                			}
                		    break;
                		case OIDISSALT:
                			{
                				alt283=4;
                			}
                		    break;
                		case OIDSUBDIR:
                			{
                				alt283=5;
                			}
                		    break;
                		case OIDEXTKEY:
                			{
                				alt283=6;
                			}
                		    break;
                		case OIDCRL:
                			{
                				alt283=7;
                			}
                		    break;
                		case SIAOID:
                			{
                				alt283=8;
                			}
                		    break;
                		case AIAOID:
                			{
                				alt283=9;
                			}
                		    break;
                		case OIDFRESHCRL:
                			{
                				alt283=10;
                			}
                		    break;
                		case PRINTABLE:
                		case VALUE:
                			{
                				alt283=11;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 283;
                		    EXCEPTION->state        = 1;


                		    goto ruleextensionEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 283;
                    EXCEPTION->state        = 0;


                    goto ruleextensionEx;

                }

                switch (alt283)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2442:41: authKeyId
            	    {
            	        FOLLOWPUSH(FOLLOW_authKeyId_in_extension5093);
            	        authKeyId1058=authKeyId(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, authKeyId1058.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2442:54: certPolicies
            	    {
            	        FOLLOWPUSH(FOLLOW_certPolicies_in_extension5098);
            	        certPolicies1059=certPolicies(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, certPolicies1059.tree);

            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:2442:69: subAltName
            	    {
            	        FOLLOWPUSH(FOLLOW_subAltName_in_extension5102);
            	        subAltName1060=subAltName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subAltName1060.tree);

            	    }
            	    break;
            	case 4:
            	    // Grammar/RFC5280.g:2442:82: issuerAltName
            	    {
            	        FOLLOWPUSH(FOLLOW_issuerAltName_in_extension5106);
            	        issuerAltName1061=issuerAltName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, issuerAltName1061.tree);

            	    }
            	    break;
            	case 5:
            	    // Grammar/RFC5280.g:2442:98: subDirAttr
            	    {
            	        FOLLOWPUSH(FOLLOW_subDirAttr_in_extension5110);
            	        subDirAttr1062=subDirAttr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subDirAttr1062.tree);

            	    }
            	    break;
            	case 6:
            	    // Grammar/RFC5280.g:2442:110: extendKeyUsage
            	    {
            	        FOLLOWPUSH(FOLLOW_extendKeyUsage_in_extension5113);
            	        extendKeyUsage1063=extendKeyUsage(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extendKeyUsage1063.tree);

            	    }
            	    break;
            	case 7:
            	    // Grammar/RFC5280.g:2442:127: crldp
            	    {
            	        FOLLOWPUSH(FOLLOW_crldp_in_extension5117);
            	        crldp1064=crldp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, crldp1064.tree);

            	    }
            	    break;
            	case 8:
            	    // Grammar/RFC5280.g:2442:135: sia
            	    {
            	        FOLLOWPUSH(FOLLOW_sia_in_extension5121);
            	        sia1065=sia(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sia1065.tree);

            	    }
            	    break;
            	case 9:
            	    // Grammar/RFC5280.g:2442:141: aia
            	    {
            	        FOLLOWPUSH(FOLLOW_aia_in_extension5125);
            	        aia1066=aia(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, aia1066.tree);

            	    }
            	    break;
            	case 10:
            	    // Grammar/RFC5280.g:2442:147: freshcrl
            	    {
            	        FOLLOWPUSH(FOLLOW_freshcrl_in_extension5129);
            	        freshcrl1067=freshcrl(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, freshcrl1067.tree);

            	    }
            	    break;
            	case 11:
            	    // Grammar/RFC5280.g:2442:158: genericExt
            	    {
            	        FOLLOWPUSH(FOLLOW_genericExt_in_extension5133);
            	        genericExt1068=genericExt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, genericExt1068.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionEx; /* Prevent compiler warnings */
    ruleextensionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extension */

/**
 * $ANTLR start extensionNoSubAlt
 * Grammar/RFC5280.g:2444:1: extensionNoSubAlt : sequenceTag ( authKeyId | certPolicies | issuerAltName | subDirAttr | extendKeyUsage | crldp | sia | aia | freshcrl | genericExt ) ;
 */
static RFC5280Parser_extensionNoSubAlt_return
extensionNoSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionNoSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1069;
    #undef	RETURN_TYPE_sequenceTag1069
    #define	RETURN_TYPE_sequenceTag1069 RFC5280Parser_sequenceTag_return

    RFC5280Parser_authKeyId_return authKeyId1070;
    #undef	RETURN_TYPE_authKeyId1070
    #define	RETURN_TYPE_authKeyId1070 RFC5280Parser_authKeyId_return

    RFC5280Parser_certPolicies_return certPolicies1071;
    #undef	RETURN_TYPE_certPolicies1071
    #define	RETURN_TYPE_certPolicies1071 RFC5280Parser_certPolicies_return

    RFC5280Parser_issuerAltName_return issuerAltName1072;
    #undef	RETURN_TYPE_issuerAltName1072
    #define	RETURN_TYPE_issuerAltName1072 RFC5280Parser_issuerAltName_return

    RFC5280Parser_subDirAttr_return subDirAttr1073;
    #undef	RETURN_TYPE_subDirAttr1073
    #define	RETURN_TYPE_subDirAttr1073 RFC5280Parser_subDirAttr_return

    RFC5280Parser_extendKeyUsage_return extendKeyUsage1074;
    #undef	RETURN_TYPE_extendKeyUsage1074
    #define	RETURN_TYPE_extendKeyUsage1074 RFC5280Parser_extendKeyUsage_return

    RFC5280Parser_crldp_return crldp1075;
    #undef	RETURN_TYPE_crldp1075
    #define	RETURN_TYPE_crldp1075 RFC5280Parser_crldp_return

    RFC5280Parser_sia_return sia1076;
    #undef	RETURN_TYPE_sia1076
    #define	RETURN_TYPE_sia1076 RFC5280Parser_sia_return

    RFC5280Parser_aia_return aia1077;
    #undef	RETURN_TYPE_aia1077
    #define	RETURN_TYPE_aia1077 RFC5280Parser_aia_return

    RFC5280Parser_freshcrl_return freshcrl1078;
    #undef	RETURN_TYPE_freshcrl1078
    #define	RETURN_TYPE_freshcrl1078 RFC5280Parser_freshcrl_return

    RFC5280Parser_genericExt_return genericExt1079;
    #undef	RETURN_TYPE_genericExt1079
    #define	RETURN_TYPE_genericExt1079 RFC5280Parser_genericExt_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1069.tree = NULL;

    authKeyId1070.tree = NULL;

    certPolicies1071.tree = NULL;

    issuerAltName1072.tree = NULL;

    subDirAttr1073.tree = NULL;

    extendKeyUsage1074.tree = NULL;

    crldp1075.tree = NULL;

    sia1076.tree = NULL;

    aia1077.tree = NULL;

    freshcrl1078.tree = NULL;

    genericExt1079.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2447:2: ( sequenceTag ( authKeyId | certPolicies | issuerAltName | subDirAttr | extendKeyUsage | crldp | sia | aia | freshcrl | genericExt ) )
        // Grammar/RFC5280.g:2447:3: sequenceTag ( authKeyId | certPolicies | issuerAltName | subDirAttr | extendKeyUsage | crldp | sia | aia | freshcrl | genericExt )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                printf("It's ext \n");
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionNoSubAlt5153);
            sequenceTag1069=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionNoSubAltEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1069.tree);

            // Grammar/RFC5280.g:2450:40: ( authKeyId | certPolicies | issuerAltName | subDirAttr | extendKeyUsage | crldp | sia | aia | freshcrl | genericExt )
            {
                int alt284=10;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDAKI:
                			{
                				alt284=1;
                			}
                		    break;
                		case OIDCERTPOL:
                			{
                				alt284=2;
                			}
                		    break;
                		case OIDISSALT:
                			{
                				alt284=3;
                			}
                		    break;
                		case OIDSUBDIR:
                			{
                				alt284=4;
                			}
                		    break;
                		case OIDEXTKEY:
                			{
                				alt284=5;
                			}
                		    break;
                		case OIDCRL:
                			{
                				alt284=6;
                			}
                		    break;
                		case SIAOID:
                			{
                				alt284=7;
                			}
                		    break;
                		case AIAOID:
                			{
                				alt284=8;
                			}
                		    break;
                		case OIDFRESHCRL:
                			{
                				alt284=9;
                			}
                		    break;
                		case PRINTABLE:
                		case VALUE:
                			{
                				alt284=10;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 284;
                		    EXCEPTION->state        = 1;


                		    goto ruleextensionNoSubAltEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 284;
                    EXCEPTION->state        = 0;


                    goto ruleextensionNoSubAltEx;

                }

                switch (alt284)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2450:41: authKeyId
            	    {
            	        FOLLOWPUSH(FOLLOW_authKeyId_in_extensionNoSubAlt5157);
            	        authKeyId1070=authKeyId(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, authKeyId1070.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2450:54: certPolicies
            	    {
            	        FOLLOWPUSH(FOLLOW_certPolicies_in_extensionNoSubAlt5162);
            	        certPolicies1071=certPolicies(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, certPolicies1071.tree);

            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:2450:69: issuerAltName
            	    {
            	        FOLLOWPUSH(FOLLOW_issuerAltName_in_extensionNoSubAlt5166);
            	        issuerAltName1072=issuerAltName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, issuerAltName1072.tree);

            	    }
            	    break;
            	case 4:
            	    // Grammar/RFC5280.g:2450:85: subDirAttr
            	    {
            	        FOLLOWPUSH(FOLLOW_subDirAttr_in_extensionNoSubAlt5170);
            	        subDirAttr1073=subDirAttr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subDirAttr1073.tree);

            	    }
            	    break;
            	case 5:
            	    // Grammar/RFC5280.g:2450:97: extendKeyUsage
            	    {
            	        FOLLOWPUSH(FOLLOW_extendKeyUsage_in_extensionNoSubAlt5173);
            	        extendKeyUsage1074=extendKeyUsage(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extendKeyUsage1074.tree);

            	    }
            	    break;
            	case 6:
            	    // Grammar/RFC5280.g:2450:114: crldp
            	    {
            	        FOLLOWPUSH(FOLLOW_crldp_in_extensionNoSubAlt5177);
            	        crldp1075=crldp(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, crldp1075.tree);

            	    }
            	    break;
            	case 7:
            	    // Grammar/RFC5280.g:2450:122: sia
            	    {
            	        FOLLOWPUSH(FOLLOW_sia_in_extensionNoSubAlt5181);
            	        sia1076=sia(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sia1076.tree);

            	    }
            	    break;
            	case 8:
            	    // Grammar/RFC5280.g:2450:128: aia
            	    {
            	        FOLLOWPUSH(FOLLOW_aia_in_extensionNoSubAlt5185);
            	        aia1077=aia(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, aia1077.tree);

            	    }
            	    break;
            	case 9:
            	    // Grammar/RFC5280.g:2450:134: freshcrl
            	    {
            	        FOLLOWPUSH(FOLLOW_freshcrl_in_extensionNoSubAlt5189);
            	        freshcrl1078=freshcrl(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, freshcrl1078.tree);

            	    }
            	    break;
            	case 10:
            	    // Grammar/RFC5280.g:2450:145: genericExt
            	    {
            	        FOLLOWPUSH(FOLLOW_genericExt_in_extensionNoSubAlt5193);
            	        genericExt1079=genericExt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionNoSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, genericExt1079.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionNoSubAltEx; /* Prevent compiler warnings */
    ruleextensionNoSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionNoSubAlt */

/**
 * $ANTLR start genericExt
 * Grammar/RFC5280.g:2453:1: genericExt : oid ( critical )? octetstring ;
 */
static RFC5280Parser_genericExt_return
genericExt(pRFC5280Parser ctx)
{
    RFC5280Parser_genericExt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_oid_return oid1080;
    #undef	RETURN_TYPE_oid1080
    #define	RETURN_TYPE_oid1080 RFC5280Parser_oid_return

    RFC5280Parser_critical_return critical1081;
    #undef	RETURN_TYPE_critical1081
    #define	RETURN_TYPE_critical1081 RFC5280Parser_critical_return

    RFC5280Parser_octetstring_return octetstring1082;
    #undef	RETURN_TYPE_octetstring1082
    #define	RETURN_TYPE_octetstring1082 RFC5280Parser_octetstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext=malloc(sizeof(x509_EXTENSION));
    oid1080.tree = NULL;

    critical1081.tree = NULL;

    octetstring1082.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2456:10: ( oid ( critical )? octetstring )
        // Grammar/RFC5280.g:2456:11: oid ( critical )? octetstring
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_oid_in_genericExt5218);
            oid1080=oid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegenericExtEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, oid1080.tree);

            {

                	printf("It's genericext \n");
                	mpz_t index;
                	mpz_init(index);
                	compute_index(oid1080.text
                ->oid,oid1080.text
                ->len,index);
                	insert_extension(index);
                	ext->oid=oid1080.text
                ->obj;
                	ext->critical=0;
                	ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	
            }


            // Grammar/RFC5280.g:2469:2: ( critical )?
            {
                int alt285=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt285=1;
                    	}
                        break;
                }

                switch (alt285)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2469:3: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_genericExt5224);
            	        critical1081=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulegenericExtEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1081.tree);

            	        {
            	            ext->critical=critical1081.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_octetstring_in_genericExt5230);
            octetstring1082=octetstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegenericExtEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, octetstring1082.tree);

            {
                ext->value->octet=octetstring1082.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegenericExtEx; /* Prevent compiler warnings */
    rulegenericExtEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end genericExt */

/**
 * $ANTLR start authKeyId
 * Grammar/RFC5280.g:2473:1: authKeyId : akioid ( falsevalue )? constructedOctetString sequenceTag ( tag0 )? ( constructedTag1 generalNames )? ( tag2 )? ;
 */
static RFC5280Parser_authKeyId_return
authKeyId(pRFC5280Parser ctx)
{
    RFC5280Parser_authKeyId_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_akioid_return akioid1083;
    #undef	RETURN_TYPE_akioid1083
    #define	RETURN_TYPE_akioid1083 RFC5280Parser_akioid_return

    RFC5280Parser_falsevalue_return falsevalue1084;
    #undef	RETURN_TYPE_falsevalue1084
    #define	RETURN_TYPE_falsevalue1084 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1085;
    #undef	RETURN_TYPE_constructedOctetString1085
    #define	RETURN_TYPE_constructedOctetString1085 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1086;
    #undef	RETURN_TYPE_sequenceTag1086
    #define	RETURN_TYPE_sequenceTag1086 RFC5280Parser_sequenceTag_return

    RFC5280Parser_tag0_return tag01087;
    #undef	RETURN_TYPE_tag01087
    #define	RETURN_TYPE_tag01087 RFC5280Parser_tag0_return

    RFC5280Parser_constructedTag1_return constructedTag11088;
    #undef	RETURN_TYPE_constructedTag11088
    #define	RETURN_TYPE_constructedTag11088 RFC5280Parser_constructedTag1_return

    RFC5280Parser_generalNames_return generalNames1089;
    #undef	RETURN_TYPE_generalNames1089
    #define	RETURN_TYPE_generalNames1089 RFC5280Parser_generalNames_return

    RFC5280Parser_tag2_return tag21090;
    #undef	RETURN_TYPE_tag21090
    #define	RETURN_TYPE_tag21090 RFC5280Parser_tag2_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    AUTH_KEY_ID *aki;
    akioid1083.tree = NULL;

    falsevalue1084.tree = NULL;

    constructedOctetString1085.tree = NULL;

    sequenceTag1086.tree = NULL;

    tag01087.tree = NULL;

    constructedTag11088.tree = NULL;

    generalNames1089.tree = NULL;

    tag21090.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2477:2: ( akioid ( falsevalue )? constructedOctetString sequenceTag ( tag0 )? ( constructedTag1 generalNames )? ( tag2 )? )
        // Grammar/RFC5280.g:2477:3: akioid ( falsevalue )? constructedOctetString sequenceTag ( tag0 )? ( constructedTag1 generalNames )? ( tag2 )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_akioid_in_authKeyId5254);
            akioid1083=akioid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauthKeyIdEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, akioid1083.tree);

            // Grammar/RFC5280.g:2480:10: ( falsevalue )?
            {
                int alt286=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    	{
                    		alt286=1;
                    	}
                        break;
                }

                switch (alt286)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2480:10: falsevalue
            	    {
            	        FOLLOWPUSH(FOLLOW_falsevalue_in_authKeyId5256);
            	        falsevalue1084=falsevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthKeyIdEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1084.tree);

            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_authKeyId5259);
            constructedOctetString1085=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauthKeyIdEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1085.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_authKeyId5261);
            sequenceTag1086=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleauthKeyIdEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1086.tree);

            {
                 
                		aki=malloc(sizeof(AUTH_KEY_ID));aki->key_id=NULL;aki->auth_cert_issuer=NULL;aki->cert_serial_number=NULL;
            }


            // Grammar/RFC5280.g:2482:3: ( tag0 )?
            {
                int alt287=2;
                switch ( LA(1) )
                {
                    case Tag0:
                    case TagInt1:
                    case TagInt10:
                    case TagInt11:
                    case TagInt12:
                    case TagInt13:
                    case TagInt14:
                    case TagInt15:
                    case TagInt16:
                    case TagInt17:
                    case TagInt18:
                    case TagInt19:
                    case TagInt2:
                    case TagInt20:
                    case TagInt21:
                    case TagInt22:
                    case TagInt23:
                    case TagInt3:
                    case TagInt4:
                    case TagInt5:
                    case TagInt6:
                    case TagInt7:
                    case TagInt8:
                    case TagInt9:
                    	{
                    		alt287=1;
                    	}
                        break;
                }

                switch (alt287)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2482:4: tag0
            	    {
            	        FOLLOWPUSH(FOLLOW_tag0_in_authKeyId5269);
            	        tag01087=tag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthKeyIdEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag01087.tree);

            	        {
            	            aki->key_id=(ASN1_OCTET_STRING *) new_asn1_string(4,tag01087.text
            	            ->length,tag01087.text
            	            ->value);cert->key_id=1;
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:2483:3: ( constructedTag1 generalNames )?
            {
                int alt288=2;
                switch ( LA(1) )
                {
                    case ConstructedTag1:
                    	{
                    		alt288=1;
                    	}
                        break;
                }

                switch (alt288)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2483:4: constructedTag1 generalNames
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_authKeyId5279);
            	        constructedTag11088=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthKeyIdEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11088.tree);

            	        FOLLOWPUSH(FOLLOW_generalNames_in_authKeyId5281);
            	        generalNames1089=generalNames(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthKeyIdEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, generalNames1089.tree);

            	        {
            	            aki->auth_cert_issuer=generalNames1089.text
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:2484:3: ( tag2 )?
            {
                int alt289=2;
                switch ( LA(1) )
                {
                    case Tag2:
                    	{
                    		alt289=1;
                    	}
                        break;
                }

                switch (alt289)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2484:4: tag2
            	    {
            	        FOLLOWPUSH(FOLLOW_tag2_in_authKeyId5291);
            	        tag21090=tag2(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleauthKeyIdEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag21090.tree);

            	        {
            	            aki->cert_serial_number=(ASN1_INTEGER *) new_asn1_string(2,tag21090.text
            	            ->length,tag21090.text
            	            ->value);
            	        }


            	    }
            	    break;

                }
            }

            {

                		x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
                		ext->oid = akioid1083.obj
                ;
                		ext->critical = 0;
                		ext->value = malloc(sizeof(X509_EXTENSION_VALUE));
                		ext->value->aki=aki;
                		sk_x509_EXTENSION_push(cert->extensions,ext);
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleauthKeyIdEx; /* Prevent compiler warnings */
    ruleauthKeyIdEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end authKeyId */

/**
 * $ANTLR start subjectKeyId
 * Grammar/RFC5280.g:2494:1: subjectKeyId : sequenceTag skioid ( falsevalue )? constructedOctetString octetstring ;
 */
static RFC5280Parser_subjectKeyId_return
subjectKeyId(pRFC5280Parser ctx)
{
    RFC5280Parser_subjectKeyId_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1091;
    #undef	RETURN_TYPE_sequenceTag1091
    #define	RETURN_TYPE_sequenceTag1091 RFC5280Parser_sequenceTag_return

    RFC5280Parser_skioid_return skioid1092;
    #undef	RETURN_TYPE_skioid1092
    #define	RETURN_TYPE_skioid1092 RFC5280Parser_skioid_return

    RFC5280Parser_falsevalue_return falsevalue1093;
    #undef	RETURN_TYPE_falsevalue1093
    #define	RETURN_TYPE_falsevalue1093 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1094;
    #undef	RETURN_TYPE_constructedOctetString1094
    #define	RETURN_TYPE_constructedOctetString1094 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_octetstring_return octetstring1095;
    #undef	RETURN_TYPE_octetstring1095
    #define	RETURN_TYPE_octetstring1095 RFC5280Parser_octetstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1091.tree = NULL;

    skioid1092.tree = NULL;

    falsevalue1093.tree = NULL;

    constructedOctetString1094.tree = NULL;

    octetstring1095.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2497:2: ( sequenceTag skioid ( falsevalue )? constructedOctetString octetstring )
        // Grammar/RFC5280.g:2497:3: sequenceTag skioid ( falsevalue )? constructedOctetString octetstring
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_subjectKeyId5315);
            sequenceTag1091=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubjectKeyIdEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1091.tree);

            FOLLOWPUSH(FOLLOW_skioid_in_subjectKeyId5317);
            skioid1092=skioid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubjectKeyIdEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, skioid1092.tree);

            // Grammar/RFC5280.g:2500:22: ( falsevalue )?
            {
                int alt290=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    	{
                    		alt290=1;
                    	}
                        break;
                }

                switch (alt290)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2500:22: falsevalue
            	    {
            	        FOLLOWPUSH(FOLLOW_falsevalue_in_subjectKeyId5319);
            	        falsevalue1093=falsevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubjectKeyIdEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1093.tree);

            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_subjectKeyId5322);
            constructedOctetString1094=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubjectKeyIdEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1094.tree);

            FOLLOWPUSH(FOLLOW_octetstring_in_subjectKeyId5324);
            octetstring1095=octetstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubjectKeyIdEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, octetstring1095.tree);

            {
                x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
                		ext->oid = skioid1092.obj
                ;
                		ext->critical = 0;
                		ext->value = malloc(sizeof(X509_EXTENSION_VALUE));
                		ext->value->octet=octetstring1095.text
                ;
                		sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubjectKeyIdEx; /* Prevent compiler warnings */
    rulesubjectKeyIdEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subjectKeyId */

/**
 * $ANTLR start keyUsage
 * Grammar/RFC5280.g:2507:1: keyUsage : sequenceTag keyusageoid ( critical )? constructedOctetString bitstring ;
 */
static RFC5280Parser_keyUsage_return
keyUsage(pRFC5280Parser ctx)
{
    RFC5280Parser_keyUsage_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1096;
    #undef	RETURN_TYPE_sequenceTag1096
    #define	RETURN_TYPE_sequenceTag1096 RFC5280Parser_sequenceTag_return

    RFC5280Parser_keyusageoid_return keyusageoid1097;
    #undef	RETURN_TYPE_keyusageoid1097
    #define	RETURN_TYPE_keyusageoid1097 RFC5280Parser_keyusageoid_return

    RFC5280Parser_critical_return critical1098;
    #undef	RETURN_TYPE_critical1098
    #define	RETURN_TYPE_critical1098 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1099;
    #undef	RETURN_TYPE_constructedOctetString1099
    #define	RETURN_TYPE_constructedOctetString1099 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_bitstring_return bitstring1100;
    #undef	RETURN_TYPE_bitstring1100
    #define	RETURN_TYPE_bitstring1100 RFC5280Parser_bitstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1096.tree = NULL;

    keyusageoid1097.tree = NULL;

    critical1098.tree = NULL;

    constructedOctetString1099.tree = NULL;

    bitstring1100.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2510:2: ( sequenceTag keyusageoid ( critical )? constructedOctetString bitstring )
        // Grammar/RFC5280.g:2510:3: sequenceTag keyusageoid ( critical )? constructedOctetString bitstring
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_keyUsage5342);
            sequenceTag1096=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekeyUsageEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1096.tree);

            FOLLOWPUSH(FOLLOW_keyusageoid_in_keyUsage5344);
            keyusageoid1097=keyusageoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekeyUsageEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, keyusageoid1097.tree);

            {
                key_usage_ext=malloc(sizeof(x509_EXTENSION));key_usage_ext->oid=keyusageoid1097.obj
                ;key_usage_ext->critical=0;key_usage_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
            }


            // Grammar/RFC5280.g:2514:3: ( critical )?
            {
                int alt291=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt291=1;
                    	}
                        break;
                }

                switch (alt291)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2514:4: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_keyUsage5351);
            	        critical1098=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulekeyUsageEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1098.tree);

            	        {
            	            key_usage_ext->critical=critical1098.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_keyUsage5357);
            constructedOctetString1099=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekeyUsageEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1099.tree);

            FOLLOWPUSH(FOLLOW_bitstring_in_keyUsage5359);
            bitstring1100=bitstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekeyUsageEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bitstring1100.tree);

            {
                key_usage_ext->value->keyusage = bitstring1100.text
                ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeyUsageEx; /* Prevent compiler warnings */
    rulekeyUsageEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end keyUsage */

/**
 * $ANTLR start keyUsageCommon
 * Grammar/RFC5280.g:2516:1: keyUsageCommon : sequenceTag keyusageoid ( critical )? constructedOctetString ;
 */
static RFC5280Parser_keyUsageCommon_return
keyUsageCommon(pRFC5280Parser ctx)
{
    RFC5280Parser_keyUsageCommon_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1101;
    #undef	RETURN_TYPE_sequenceTag1101
    #define	RETURN_TYPE_sequenceTag1101 RFC5280Parser_sequenceTag_return

    RFC5280Parser_keyusageoid_return keyusageoid1102;
    #undef	RETURN_TYPE_keyusageoid1102
    #define	RETURN_TYPE_keyusageoid1102 RFC5280Parser_keyusageoid_return

    RFC5280Parser_critical_return critical1103;
    #undef	RETURN_TYPE_critical1103
    #define	RETURN_TYPE_critical1103 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1104;
    #undef	RETURN_TYPE_constructedOctetString1104
    #define	RETURN_TYPE_constructedOctetString1104 RFC5280Parser_constructedOctetString_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1101.tree = NULL;

    keyusageoid1102.tree = NULL;

    critical1103.tree = NULL;

    constructedOctetString1104.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2519:2: ( sequenceTag keyusageoid ( critical )? constructedOctetString )
        // Grammar/RFC5280.g:2519:3: sequenceTag keyusageoid ( critical )? constructedOctetString
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_keyUsageCommon5378);
            sequenceTag1101=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekeyUsageCommonEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1101.tree);

            FOLLOWPUSH(FOLLOW_keyusageoid_in_keyUsageCommon5380);
            keyusageoid1102=keyusageoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekeyUsageCommonEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, keyusageoid1102.tree);

            {
                key_usage_ext=malloc(sizeof(x509_EXTENSION));key_usage_ext->oid=keyusageoid1102.obj
                ;key_usage_ext->critical=0;
                		key_usage_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));key_usage_ext->value->keyusage=NULL;
            }


            // Grammar/RFC5280.g:2524:3: ( critical )?
            {
                int alt292=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt292=1;
                    	}
                        break;
                }

                switch (alt292)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2524:4: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_keyUsageCommon5388);
            	        critical1103=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulekeyUsageCommonEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1103.tree);

            	        {
            	            key_usage_ext->critical=critical1103.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_keyUsageCommon5394);
            constructedOctetString1104=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekeyUsageCommonEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1104.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeyUsageCommonEx; /* Prevent compiler warnings */
    rulekeyUsageCommonEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end keyUsageCommon */

/**
 * $ANTLR start certPolicies
 * Grammar/RFC5280.g:2526:1: certPolicies : certpolioid ( critical )? constructedOctetString sequenceTag policies ;
 */
static RFC5280Parser_certPolicies_return
certPolicies(pRFC5280Parser ctx)
{
    RFC5280Parser_certPolicies_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_certpolioid_return certpolioid1105;
    #undef	RETURN_TYPE_certpolioid1105
    #define	RETURN_TYPE_certpolioid1105 RFC5280Parser_certpolioid_return

    RFC5280Parser_critical_return critical1106;
    #undef	RETURN_TYPE_critical1106
    #define	RETURN_TYPE_critical1106 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1107;
    #undef	RETURN_TYPE_constructedOctetString1107
    #define	RETURN_TYPE_constructedOctetString1107 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1108;
    #undef	RETURN_TYPE_sequenceTag1108
    #define	RETURN_TYPE_sequenceTag1108 RFC5280Parser_sequenceTag_return

    RFC5280Parser_policies_return policies1109;
    #undef	RETURN_TYPE_policies1109
    #define	RETURN_TYPE_policies1109 RFC5280Parser_policies_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    certpolioid1105.tree = NULL;

    critical1106.tree = NULL;

    constructedOctetString1107.tree = NULL;

    sequenceTag1108.tree = NULL;

    policies1109.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2530:2: ( certpolioid ( critical )? constructedOctetString sequenceTag policies )
        // Grammar/RFC5280.g:2530:3: certpolioid ( critical )? constructedOctetString sequenceTag policies
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_certpolioid_in_certPolicies5416);
            certpolioid1105=certpolioid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecertPoliciesEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, certpolioid1105.tree);

            {
                ext->oid=certpolioid1105.obj
                ;ext->critical=0;
            }


            // Grammar/RFC5280.g:2534:3: ( critical )?
            {
                int alt293=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt293=1;
                    	}
                        break;
                }

                switch (alt293)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2534:4: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_certPolicies5424);
            	        critical1106=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecertPoliciesEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1106.tree);

            	        {
            	            ext->critical=critical1106.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_certPolicies5432);
            constructedOctetString1107=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecertPoliciesEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1107.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_certPolicies5434);
            sequenceTag1108=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecertPoliciesEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1108.tree);

            FOLLOWPUSH(FOLLOW_policies_in_certPolicies5436);
            policies1109=policies(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecertPoliciesEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, policies1109.tree);

            {
                ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                		ext->value->policies = policies1109.text
                ;
                		sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecertPoliciesEx; /* Prevent compiler warnings */
    rulecertPoliciesEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end certPolicies */

/**
 * $ANTLR start policies
 * Grammar/RFC5280.g:2539:1: policies returns [STACK_OF(POLICY_INFO) *text] : ( policyInfo )+ ;
 */
static RFC5280Parser_policies_return
policies(pRFC5280Parser ctx)
{
    RFC5280Parser_policies_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_policyInfo_return policyInfo1110;
    #undef	RETURN_TYPE_policyInfo1110
    #define	RETURN_TYPE_policyInfo1110 RFC5280Parser_policyInfo_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text=sk_POLICY_INFO_new_null();

    policyInfo1110.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2543:2: ( ( policyInfo )+ )
        // Grammar/RFC5280.g:2543:3: ( policyInfo )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:2546:3: ( policyInfo )+
            {
                int cnt294=0;

                for (;;)
                {
                    int alt294=2;
            	alt294 = cdfa294.predict(ctx, RECOGNIZER, ISTREAM, &cdfa294);
            	if  (HASEXCEPTION())
            	{
            	    goto rulepoliciesEx;
            	}

            	switch (alt294)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:2546:4: policyInfo
            	        {
            	            FOLLOWPUSH(FOLLOW_policyInfo_in_policies5464);
            	            policyInfo1110=policyInfo(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepoliciesEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, policyInfo1110.tree);

            	            {
            	                sk_POLICY_INFO_push(retval.text
            	                ,policyInfo1110.text
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt294 >= 1 )
            		{
            		    goto loop294;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepoliciesEx;
            	}
            	cnt294++;
                }
                loop294: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulepoliciesEx; /* Prevent compiler warnings */
    rulepoliciesEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end policies */

/**
 * $ANTLR start policyInfo
 * Grammar/RFC5280.g:2548:1: policyInfo returns [POLICY_INFO *text] : sequenceTag ( oid ( sequenceTag policyQualifiers )? | anypolicyoid ( sequenceTag policyQualifiersAnyPolicy )? ) ;
 */
static RFC5280Parser_policyInfo_return
policyInfo(pRFC5280Parser ctx)
{
    RFC5280Parser_policyInfo_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1111;
    #undef	RETURN_TYPE_sequenceTag1111
    #define	RETURN_TYPE_sequenceTag1111 RFC5280Parser_sequenceTag_return

    RFC5280Parser_oid_return oid1112;
    #undef	RETURN_TYPE_oid1112
    #define	RETURN_TYPE_oid1112 RFC5280Parser_oid_return

    RFC5280Parser_sequenceTag_return sequenceTag1113;
    #undef	RETURN_TYPE_sequenceTag1113
    #define	RETURN_TYPE_sequenceTag1113 RFC5280Parser_sequenceTag_return

    RFC5280Parser_policyQualifiers_return policyQualifiers1114;
    #undef	RETURN_TYPE_policyQualifiers1114
    #define	RETURN_TYPE_policyQualifiers1114 RFC5280Parser_policyQualifiers_return

    RFC5280Parser_anypolicyoid_return anypolicyoid1115;
    #undef	RETURN_TYPE_anypolicyoid1115
    #define	RETURN_TYPE_anypolicyoid1115 RFC5280Parser_anypolicyoid_return

    RFC5280Parser_sequenceTag_return sequenceTag1116;
    #undef	RETURN_TYPE_sequenceTag1116
    #define	RETURN_TYPE_sequenceTag1116 RFC5280Parser_sequenceTag_return

    RFC5280Parser_policyQualifiersAnyPolicy_return policyQualifiersAnyPolicy1117;
    #undef	RETURN_TYPE_policyQualifiersAnyPolicy1117
    #define	RETURN_TYPE_policyQualifiersAnyPolicy1117 RFC5280Parser_policyQualifiersAnyPolicy_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1111.tree = NULL;

    oid1112.tree = NULL;

    sequenceTag1113.tree = NULL;

    policyQualifiers1114.tree = NULL;

    anypolicyoid1115.tree = NULL;

    sequenceTag1116.tree = NULL;

    policyQualifiersAnyPolicy1117.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2552:2: ( sequenceTag ( oid ( sequenceTag policyQualifiers )? | anypolicyoid ( sequenceTag policyQualifiersAnyPolicy )? ) )
        // Grammar/RFC5280.g:2552:3: sequenceTag ( oid ( sequenceTag policyQualifiers )? | anypolicyoid ( sequenceTag policyQualifiersAnyPolicy )? )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_policyInfo5490);
            sequenceTag1111=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepolicyInfoEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1111.tree);

            {
                sequence_pointer = counter_list;retval.text=malloc(sizeof(POLICY_INFO));

            }


            // Grammar/RFC5280.g:2555:84: ( oid ( sequenceTag policyQualifiers )? | anypolicyoid ( sequenceTag policyQualifiersAnyPolicy )? )
            {
                int alt297=2;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case ANYPOLICYOID:
                			{
                				alt297=2;
                			}
                		    break;
                		case PRINTABLE:
                		case VALUE:
                			{
                				alt297=1;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 297;
                		    EXCEPTION->state        = 1;


                		    goto rulepolicyInfoEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 297;
                    EXCEPTION->state        = 0;


                    goto rulepolicyInfoEx;

                }

                switch (alt297)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2555:85: oid ( sequenceTag policyQualifiers )?
            	    {
            	        FOLLOWPUSH(FOLLOW_oid_in_policyInfo5495);
            	        oid1112=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepolicyInfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, oid1112.tree);

            	        {
            	            retval.text
            	            ->oid=oid1112.text
            	            ->obj;retval.text
            	            ->qualifiers=NULL;
            	            	mpz_t index;
            	            	mpz_init(index);
            	            	compute_index(oid1112.text
            	            ->oid,oid1112.text
            	            ->len,index);
            	            	insert_policy(index);	
            	            	
            	        }


            	        // Grammar/RFC5280.g:2560:3: ( sequenceTag policyQualifiers )?
            	        {
            	            int alt295=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case SequenceTag:
            	                		    	{
            	                		    		alt295=1;
            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt295)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:2560:4: sequenceTag policyQualifiers
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_policyInfo5499);
            	        	        sequenceTag1113=sequenceTag(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepolicyInfoEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1113.tree);

            	        	        FOLLOWPUSH(FOLLOW_policyQualifiers_in_policyInfo5501);
            	        	        policyQualifiers1114=policyQualifiers(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepolicyInfoEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, policyQualifiers1114.tree);

            	        	        {
            	        	            retval.text
            	        	            ->qualifiers=policyQualifiers1114.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2561:3: anypolicyoid ( sequenceTag policyQualifiersAnyPolicy )?
            	    {
            	        FOLLOWPUSH(FOLLOW_anypolicyoid_in_policyInfo5509);
            	        anypolicyoid1115=anypolicyoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepolicyInfoEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, anypolicyoid1115.tree);

            	        {
            	            retval.text
            	            ->oid=anypolicyoid1115.obj
            	            ;retval.text
            	            ->qualifiers=NULL;
            	            	mpz_t index;
            	            	mpz_init_set_ui(index,2058699496953);
            	            	insert_policy(index);
            	            	
            	        }


            	        // Grammar/RFC5280.g:2565:3: ( sequenceTag policyQualifiersAnyPolicy )?
            	        {
            	            int alt296=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case SequenceTag:
            	                		    	{
            	                		    		alt296=1;
            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt296)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:2565:4: sequenceTag policyQualifiersAnyPolicy
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_policyInfo5513);
            	        	        sequenceTag1116=sequenceTag(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepolicyInfoEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1116.tree);

            	        	        FOLLOWPUSH(FOLLOW_policyQualifiersAnyPolicy_in_policyInfo5515);
            	        	        policyQualifiersAnyPolicy1117=policyQualifiersAnyPolicy(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepolicyInfoEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, policyQualifiersAnyPolicy1117.tree);

            	        	        {
            	        	            retval.text
            	        	            ->qualifiers=policyQualifiersAnyPolicy1117.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulepolicyInfoEx; /* Prevent compiler warnings */
    rulepolicyInfoEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end policyInfo */

/**
 * $ANTLR start policyQualifiers
 * Grammar/RFC5280.g:2568:1: policyQualifiers returns [STACK_OF(POLICY_QUALIFIER) *text] : ( qualifier )+ ;
 */
static RFC5280Parser_policyQualifiers_return
policyQualifiers(pRFC5280Parser ctx)
{
    RFC5280Parser_policyQualifiers_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_qualifier_return qualifier1118;
    #undef	RETURN_TYPE_qualifier1118
    #define	RETURN_TYPE_qualifier1118 RFC5280Parser_qualifier_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    qualifier1118.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2572:2: ( ( qualifier )+ )
        // Grammar/RFC5280.g:2572:3: ( qualifier )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                retval.text=sk_POLICY_QUALIFIER_new_null();

            }


            // Grammar/RFC5280.g:2575:42: ( qualifier )+
            {
                int cnt298=0;

                for (;;)
                {
                    int alt298=2;
            	alt298 = cdfa298.predict(ctx, RECOGNIZER, ISTREAM, &cdfa298);
            	if  (HASEXCEPTION())
            	{
            	    goto rulepolicyQualifiersEx;
            	}

            	switch (alt298)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:2575:43: qualifier
            	        {
            	            FOLLOWPUSH(FOLLOW_qualifier_in_policyQualifiers5545);
            	            qualifier1118=qualifier(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepolicyQualifiersEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, qualifier1118.tree);

            	            {
            	                sk_POLICY_QUALIFIER_push(retval.text
            	                ,qualifier1118.text
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt298 >= 1 )
            		{
            		    goto loop298;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepolicyQualifiersEx;
            	}
            	cnt298++;
                }
                loop298: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulepolicyQualifiersEx; /* Prevent compiler warnings */
    rulepolicyQualifiersEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end policyQualifiers */

/**
 * $ANTLR start qualifier
 * Grammar/RFC5280.g:2577:1: qualifier returns [POLICY_QUALIFIER *text] :{...}? => ( sequenceTag ( cps | unotice | oid any ) ) ;
 */
static RFC5280Parser_qualifier_return
qualifier(pRFC5280Parser ctx)
{
    RFC5280Parser_qualifier_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1119;
    #undef	RETURN_TYPE_sequenceTag1119
    #define	RETURN_TYPE_sequenceTag1119 RFC5280Parser_sequenceTag_return

    RFC5280Parser_cps_return cps1120;
    #undef	RETURN_TYPE_cps1120
    #define	RETURN_TYPE_cps1120 RFC5280Parser_cps_return

    RFC5280Parser_unotice_return unotice1121;
    #undef	RETURN_TYPE_unotice1121
    #define	RETURN_TYPE_unotice1121 RFC5280Parser_unotice_return

    RFC5280Parser_oid_return oid1122;
    #undef	RETURN_TYPE_oid1122
    #define	RETURN_TYPE_oid1122 RFC5280Parser_oid_return

    RFC5280Parser_any_return any1123;
    #undef	RETURN_TYPE_any1123
    #define	RETURN_TYPE_any1123 RFC5280Parser_any_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    sequenceTag1119.tree = NULL;

    cps1120.tree = NULL;

    unotice1121.tree = NULL;

    oid1122.tree = NULL;

    any1123.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2584:2: ({...}? => ( sequenceTag ( cps | unotice | oid any ) ) )
        // Grammar/RFC5280.g:2585:2: {...}? => ( sequenceTag ( cps | unotice | oid any ) )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((sequence_pointer != NULL)) )
            {
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"sequence_pointer != NULL";
                    EXCEPTION->ruleName	 = (void *)"qualifier";


            }

            // Grammar/RFC5280.g:2586:4: ( sequenceTag ( cps | unotice | oid any ) )
            // Grammar/RFC5280.g:2586:6: sequenceTag ( cps | unotice | oid any )
            {
                FOLLOWPUSH(FOLLOW_sequenceTag_in_qualifier5580);
                sequenceTag1119=sequenceTag(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulequalifierEx;
                }

                ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1119.tree);

                {
                    retval.text=malloc(sizeof(POLICY_QUALIFIER));
                    retval.text
                    ->qualifier=malloc(sizeof(QUALIFIER));
                }


                // Grammar/RFC5280.g:2587:3: ( cps | unotice | oid any )
                {
                    int alt299=3;
                    switch ( LA(1) )
                    {
                    case OIDTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		case CPSOID:
                    			{
                    				alt299=1;
                    			}
                    		    break;
                    		case UNOTICEOID:
                    			{
                    				alt299=2;
                    			}
                    		    break;
                    		case PRINTABLE:
                    		case VALUE:
                    			{
                    				alt299=3;
                    			}
                    		    break;

                    		default:
                    		    CONSTRUCTEX();
                    		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    		    EXCEPTION->message      = (void *)"";
                    		    EXCEPTION->decisionNum  = 299;
                    		    EXCEPTION->state        = 1;


                    		    goto rulequalifierEx;

                    		}

                    	}
                        break;

                    default:
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 299;
                        EXCEPTION->state        = 0;


                        goto rulequalifierEx;

                    }

                    switch (alt299)
                    {
                	case 1:
                	    // Grammar/RFC5280.g:2587:4: cps
                	    {
                	        FOLLOWPUSH(FOLLOW_cps_in_qualifier5588);
                	        cps1120=cps(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulequalifierEx;
                	        }

                	        ADAPTOR->addChild(ADAPTOR, root_0, cps1120.tree);

                	        {
                	            retval.text
                	            ->oid=OBJ_nid2obj(NID_id_qt_cps);retval.text
                	            ->qualifier->cps=cps1120.text
                	            ;
                	        }


                	    }
                	    break;
                	case 2:
                	    // Grammar/RFC5280.g:2587:83: unotice
                	    {
                	        FOLLOWPUSH(FOLLOW_unotice_in_qualifier5594);
                	        unotice1121=unotice(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulequalifierEx;
                	        }

                	        ADAPTOR->addChild(ADAPTOR, root_0, unotice1121.tree);

                	        {
                	            retval.text
                	            ->oid=OBJ_nid2obj(NID_id_qt_unotice);retval.text
                	            ->qualifier->unotice=unotice1121.text
                	            ;
                	        }


                	    }
                	    break;
                	case 3:
                	    // Grammar/RFC5280.g:2588:5: oid any
                	    {
                	        FOLLOWPUSH(FOLLOW_oid_in_qualifier5602);
                	        oid1122=oid(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulequalifierEx;
                	        }

                	        ADAPTOR->addChild(ADAPTOR, root_0, oid1122.tree);

                	        FOLLOWPUSH(FOLLOW_any_in_qualifier5604);
                	        any1123=any(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulequalifierEx;
                	        }

                	        ADAPTOR->addChild(ADAPTOR, root_0, any1123.tree);

                	        {
                	            retval.text
                	            ->oid=oid1122.text
                	            ->obj;retval.text
                	            ->qualifier->any=any1123.text
                	            ;
                	        }


                	    }
                	    break;

                    }
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulequalifierEx; /* Prevent compiler warnings */
    rulequalifierEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end qualifier */

/**
 * $ANTLR start policyQualifiersAnyPolicy
 * Grammar/RFC5280.g:2590:1: policyQualifiersAnyPolicy returns [STACK_OF(POLICY_QUALIFIER) *text] : ( qualifierAnyPolicy )+ ;
 */
static RFC5280Parser_policyQualifiersAnyPolicy_return
policyQualifiersAnyPolicy(pRFC5280Parser ctx)
{
    RFC5280Parser_policyQualifiersAnyPolicy_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_qualifierAnyPolicy_return qualifierAnyPolicy1124;
    #undef	RETURN_TYPE_qualifierAnyPolicy1124
    #define	RETURN_TYPE_qualifierAnyPolicy1124 RFC5280Parser_qualifierAnyPolicy_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    qualifierAnyPolicy1124.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2594:2: ( ( qualifierAnyPolicy )+ )
        // Grammar/RFC5280.g:2594:3: ( qualifierAnyPolicy )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                retval.text=sk_POLICY_QUALIFIER_new_null();

            }


            // Grammar/RFC5280.g:2597:42: ( qualifierAnyPolicy )+
            {
                int cnt300=0;

                for (;;)
                {
                    int alt300=2;
            	switch ( LA(1) )
            	{
            	case SequenceTag:
            		{
            			switch ( LA(2) )
            			{
            			case OIDTag:
            				{
            					{
            					   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            					    */
            					    int LA300_2 = LA(3);
            					    if ( ((sequence_pointer != NULL)) && (LA300_2 == CPSOID || LA300_2 == UNOTICEOID))
            					    {
            					        alt300=1;
            					    }

            					}
            				}
            			    break;

            			}

            		}
            	    break;

            	}

            	switch (alt300)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:2597:43: qualifierAnyPolicy
            	        {
            	            FOLLOWPUSH(FOLLOW_qualifierAnyPolicy_in_policyQualifiersAnyPolicy5632);
            	            qualifierAnyPolicy1124=qualifierAnyPolicy(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulepolicyQualifiersAnyPolicyEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, qualifierAnyPolicy1124.tree);

            	            {
            	                sk_POLICY_QUALIFIER_push(retval.text
            	                ,qualifierAnyPolicy1124.text
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt300 >= 1 )
            		{
            		    goto loop300;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulepolicyQualifiersAnyPolicyEx;
            	}
            	cnt300++;
                }
                loop300: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulepolicyQualifiersAnyPolicyEx; /* Prevent compiler warnings */
    rulepolicyQualifiersAnyPolicyEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end policyQualifiersAnyPolicy */

/**
 * $ANTLR start qualifierAnyPolicy
 * Grammar/RFC5280.g:2599:1: qualifierAnyPolicy returns [POLICY_QUALIFIER *text] :{...}? => ( sequenceTag ( cps | unotice ) ) ;
 */
static RFC5280Parser_qualifierAnyPolicy_return
qualifierAnyPolicy(pRFC5280Parser ctx)
{
    RFC5280Parser_qualifierAnyPolicy_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1125;
    #undef	RETURN_TYPE_sequenceTag1125
    #define	RETURN_TYPE_sequenceTag1125 RFC5280Parser_sequenceTag_return

    RFC5280Parser_cps_return cps1126;
    #undef	RETURN_TYPE_cps1126
    #define	RETURN_TYPE_cps1126 RFC5280Parser_cps_return

    RFC5280Parser_unotice_return unotice1127;
    #undef	RETURN_TYPE_unotice1127
    #define	RETURN_TYPE_unotice1127 RFC5280Parser_unotice_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    sequenceTag1125.tree = NULL;

    cps1126.tree = NULL;

    unotice1127.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2606:2: ({...}? => ( sequenceTag ( cps | unotice ) ) )
        // Grammar/RFC5280.g:2607:2: {...}? => ( sequenceTag ( cps | unotice ) )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((sequence_pointer != NULL)) )
            {
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"sequence_pointer != NULL";
                    EXCEPTION->ruleName	 = (void *)"qualifierAnyPolicy";


            }

            // Grammar/RFC5280.g:2608:4: ( sequenceTag ( cps | unotice ) )
            // Grammar/RFC5280.g:2608:6: sequenceTag ( cps | unotice )
            {
                FOLLOWPUSH(FOLLOW_sequenceTag_in_qualifierAnyPolicy5667);
                sequenceTag1125=sequenceTag(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulequalifierAnyPolicyEx;
                }

                ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1125.tree);

                {
                    retval.text=malloc(sizeof(POLICY_QUALIFIER));
                    retval.text
                    ->qualifier=malloc(sizeof(QUALIFIER));
                }


                // Grammar/RFC5280.g:2609:3: ( cps | unotice )
                {
                    int alt301=2;
                    switch ( LA(1) )
                    {
                    case OIDTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		case CPSOID:
                    			{
                    				alt301=1;
                    			}
                    		    break;
                    		case UNOTICEOID:
                    			{
                    				alt301=2;
                    			}
                    		    break;

                    		default:
                    		    CONSTRUCTEX();
                    		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    		    EXCEPTION->message      = (void *)"";
                    		    EXCEPTION->decisionNum  = 301;
                    		    EXCEPTION->state        = 1;


                    		    goto rulequalifierAnyPolicyEx;

                    		}

                    	}
                        break;

                    default:
                        CONSTRUCTEX();
                        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                        EXCEPTION->message      = (void *)"";
                        EXCEPTION->decisionNum  = 301;
                        EXCEPTION->state        = 0;


                        goto rulequalifierAnyPolicyEx;

                    }

                    switch (alt301)
                    {
                	case 1:
                	    // Grammar/RFC5280.g:2609:4: cps
                	    {
                	        FOLLOWPUSH(FOLLOW_cps_in_qualifierAnyPolicy5675);
                	        cps1126=cps(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulequalifierAnyPolicyEx;
                	        }

                	        ADAPTOR->addChild(ADAPTOR, root_0, cps1126.tree);

                	        {
                	            retval.text
                	            ->oid=OBJ_nid2obj(NID_id_qt_cps);retval.text
                	            ->qualifier->cps=cps1126.text
                	            ;
                	        }


                	    }
                	    break;
                	case 2:
                	    // Grammar/RFC5280.g:2609:83: unotice
                	    {
                	        FOLLOWPUSH(FOLLOW_unotice_in_qualifierAnyPolicy5681);
                	        unotice1127=unotice(ctx);

                	        FOLLOWPOP();
                	        if  (HASEXCEPTION())
                	        {
                	            goto rulequalifierAnyPolicyEx;
                	        }

                	        ADAPTOR->addChild(ADAPTOR, root_0, unotice1127.tree);

                	        {
                	            retval.text
                	            ->oid=OBJ_nid2obj(NID_id_qt_unotice);retval.text
                	            ->qualifier->unotice=unotice1127.text
                	            ;
                	        }


                	    }
                	    break;

                    }
                }

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulequalifierAnyPolicyEx; /* Prevent compiler warnings */
    rulequalifierAnyPolicyEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end qualifierAnyPolicy */

/**
 * $ANTLR start cps
 * Grammar/RFC5280.g:2612:1: cps returns [ASN1_IA5STRING *text] : cpsoid ia5String ;
 */
static RFC5280Parser_cps_return
cps(pRFC5280Parser ctx)
{
    RFC5280Parser_cps_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_cpsoid_return cpsoid1128;
    #undef	RETURN_TYPE_cpsoid1128
    #define	RETURN_TYPE_cpsoid1128 RFC5280Parser_cpsoid_return

    RFC5280Parser_ia5String_return ia5String1129;
    #undef	RETURN_TYPE_ia5String1129
    #define	RETURN_TYPE_ia5String1129 RFC5280Parser_ia5String_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    cpsoid1128.tree = NULL;

    ia5String1129.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2615:2: ( cpsoid ia5String )
        // Grammar/RFC5280.g:2615:3: cpsoid ia5String
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_cpsoid_in_cps5705);
            cpsoid1128=cpsoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecpsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, cpsoid1128.tree);

            FOLLOWPUSH(FOLLOW_ia5String_in_cps5707);
            ia5String1129=ia5String(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecpsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, ia5String1129.tree);

            {
                retval.text=
                ia5String1129.text
                ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecpsEx; /* Prevent compiler warnings */
    rulecpsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end cps */

/**
 * $ANTLR start unotice
 * Grammar/RFC5280.g:2619:1: unotice returns [USERNOTICE *text] : unoticeoid sequenceTag ( noticeref )? ( displayTextString )? ;
 */
static RFC5280Parser_unotice_return
unotice(pRFC5280Parser ctx)
{
    RFC5280Parser_unotice_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_unoticeoid_return unoticeoid1130;
    #undef	RETURN_TYPE_unoticeoid1130
    #define	RETURN_TYPE_unoticeoid1130 RFC5280Parser_unoticeoid_return

    RFC5280Parser_sequenceTag_return sequenceTag1131;
    #undef	RETURN_TYPE_sequenceTag1131
    #define	RETURN_TYPE_sequenceTag1131 RFC5280Parser_sequenceTag_return

    RFC5280Parser_noticeref_return noticeref1132;
    #undef	RETURN_TYPE_noticeref1132
    #define	RETURN_TYPE_noticeref1132 RFC5280Parser_noticeref_return

    RFC5280Parser_displayTextString_return displayTextString1133;
    #undef	RETURN_TYPE_displayTextString1133
    #define	RETURN_TYPE_displayTextString1133 RFC5280Parser_displayTextString_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    unoticeoid1130.tree = NULL;

    sequenceTag1131.tree = NULL;

    noticeref1132.tree = NULL;

    displayTextString1133.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2623:2: ( unoticeoid sequenceTag ( noticeref )? ( displayTextString )? )
        // Grammar/RFC5280.g:2623:3: unoticeoid sequenceTag ( noticeref )? ( displayTextString )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_unoticeoid_in_unotice5730);
            unoticeoid1130=unoticeoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleunoticeEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, unoticeoid1130.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_unotice5732);
            sequenceTag1131=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleunoticeEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1131.tree);

            {
                retval.text=malloc(sizeof(USERNOTICE));
                retval.text
                ->noticeref=NULL;retval.text
                ->exptext=NULL;
            }


            // Grammar/RFC5280.g:2627:3: ( noticeref )?
            {
                int alt302=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case BMPTag:
                    		    case IA5StringTag:
                    		    case UTF8Tag:
                    		    case VisibleStringTag:
                    		    	{
                    		    		alt302=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt302)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2627:4: noticeref
            	    {
            	        FOLLOWPUSH(FOLLOW_noticeref_in_unotice5740);
            	        noticeref1132=noticeref(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunoticeEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, noticeref1132.tree);

            	        {
            	            retval.text
            	            ->noticeref=noticeref1132.text
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:2627:52: ( displayTextString )?
            {
                int alt303=2;
                switch ( LA(1) )
                {
                    case BMPTag:
                    case IA5StringTag:
                    case UTF8Tag:
                    case VisibleStringTag:
                    	{
                    		alt303=1;
                    	}
                        break;
                }

                switch (alt303)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2627:53: displayTextString
            	    {
            	        FOLLOWPUSH(FOLLOW_displayTextString_in_unotice5747);
            	        displayTextString1133=displayTextString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunoticeEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, displayTextString1133.tree);

            	        {
            	            retval.text
            	            ->exptext=displayTextString1133.text
            	            ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunoticeEx; /* Prevent compiler warnings */
    ruleunoticeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end unotice */

/**
 * $ANTLR start displayTextString
 * Grammar/RFC5280.g:2629:1: displayTextString returns [ASN1_STRING *text] : ( ia5String | visibleString | bmpString | utf8String ) ;
 */
static RFC5280Parser_displayTextString_return
displayTextString(pRFC5280Parser ctx)
{
    RFC5280Parser_displayTextString_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_ia5String_return ia5String1134;
    #undef	RETURN_TYPE_ia5String1134
    #define	RETURN_TYPE_ia5String1134 RFC5280Parser_ia5String_return

    RFC5280Parser_visibleString_return visibleString1135;
    #undef	RETURN_TYPE_visibleString1135
    #define	RETURN_TYPE_visibleString1135 RFC5280Parser_visibleString_return

    RFC5280Parser_bmpString_return bmpString1136;
    #undef	RETURN_TYPE_bmpString1136
    #define	RETURN_TYPE_bmpString1136 RFC5280Parser_bmpString_return

    RFC5280Parser_utf8String_return utf8String1137;
    #undef	RETURN_TYPE_utf8String1137
    #define	RETURN_TYPE_utf8String1137 RFC5280Parser_utf8String_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    unsigned long mask;
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    ia5String1134.tree = NULL;

    visibleString1135.tree = NULL;

    bmpString1136.tree = NULL;

    utf8String1137.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2637:2: ( ( ia5String | visibleString | bmpString | utf8String ) )
        // Grammar/RFC5280.g:2638:3: ( ia5String | visibleString | bmpString | utf8String )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // Grammar/RFC5280.g:2638:3: ( ia5String | visibleString | bmpString | utf8String )
            {
                int alt304=4;
                switch ( LA(1) )
                {
                case IA5StringTag:
                	{
                		alt304=1;
                	}
                    break;
                case VisibleStringTag:
                	{
                		alt304=2;
                	}
                    break;
                case BMPTag:
                	{
                		alt304=3;
                	}
                    break;
                case UTF8Tag:
                	{
                		alt304=4;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 304;
                    EXCEPTION->state        = 0;


                    goto ruledisplayTextStringEx;

                }

                switch (alt304)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2638:4: ia5String
            	    {
            	        FOLLOWPUSH(FOLLOW_ia5String_in_displayTextString5775);
            	        ia5String1134=ia5String(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledisplayTextStringEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, ia5String1134.tree);

            	        {
            	            ia5String1134.text
            	            ->type=MBSTRING_ASC;mask=B_ASN1_IA5STRING;retval.text=
            	            ia5String1134.text
            	            ;

            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2639:4: visibleString
            	    {
            	        FOLLOWPUSH(FOLLOW_visibleString_in_displayTextString5782);
            	        visibleString1135=visibleString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledisplayTextStringEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, visibleString1135.tree);

            	        {
            	            visibleString1135.text
            	            ->type=MBSTRING_ASC;mask=B_ASN1_VISIBLESTRING;retval.text=
            	            visibleString1135.text
            	            ;

            	        }


            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:2640:4: bmpString
            	    {
            	        FOLLOWPUSH(FOLLOW_bmpString_in_displayTextString5789);
            	        bmpString1136=bmpString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledisplayTextStringEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, bmpString1136.tree);

            	        {
            	            bmpString1136.text
            	            ->type=MBSTRING_BMP;mask=B_ASN1_BMPSTRING;retval.text=
            	            bmpString1136.text
            	            ;

            	        }


            	    }
            	    break;
            	case 4:
            	    // Grammar/RFC5280.g:2641:4: utf8String
            	    {
            	        FOLLOWPUSH(FOLLOW_utf8String_in_displayTextString5796);
            	        utf8String1137=utf8String(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledisplayTextStringEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, utf8String1137.tree);

            	        {
            	            utf8String1137.text
            	            ->type=MBSTRING_UTF8;mask=B_ASN1_UTF8STRING;retval.text=
            	            utf8String1137.text
            	            ;

            	        }


            	    }
            	    break;

                }
            }

            {

                	ASN1_STRING *out = malloc(sizeof(ASN1_STRING));
                	out->data = NULL;
                	if(ASN1_mbstring_ncopy(&out,retval.text
                ->data,retval.text
                ->length,retval.text
                ->type,mask,1,200) == -1)
                	{
                		printf("Display Text String length constraint not satisfied \n");
                		warning|=DISPLAY_STRING_LENGTH_WARNING;
                	}	
                	free(retval.text
                );
                	retval.text=out;

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledisplayTextStringEx; /* Prevent compiler warnings */
    ruledisplayTextStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end displayTextString */

/**
 * $ANTLR start noticeref
 * Grammar/RFC5280.g:2655:1: noticeref returns [NOTICEREF *text] : sequenceTag displayTextString sequenceTag noticeNumbers ;
 */
static RFC5280Parser_noticeref_return
noticeref(pRFC5280Parser ctx)
{
    RFC5280Parser_noticeref_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1138;
    #undef	RETURN_TYPE_sequenceTag1138
    #define	RETURN_TYPE_sequenceTag1138 RFC5280Parser_sequenceTag_return

    RFC5280Parser_displayTextString_return displayTextString1139;
    #undef	RETURN_TYPE_displayTextString1139
    #define	RETURN_TYPE_displayTextString1139 RFC5280Parser_displayTextString_return

    RFC5280Parser_sequenceTag_return sequenceTag1140;
    #undef	RETURN_TYPE_sequenceTag1140
    #define	RETURN_TYPE_sequenceTag1140 RFC5280Parser_sequenceTag_return

    RFC5280Parser_noticeNumbers_return noticeNumbers1141;
    #undef	RETURN_TYPE_noticeNumbers1141
    #define	RETURN_TYPE_noticeNumbers1141 RFC5280Parser_noticeNumbers_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1138.tree = NULL;

    displayTextString1139.tree = NULL;

    sequenceTag1140.tree = NULL;

    noticeNumbers1141.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2659:3: ( sequenceTag displayTextString sequenceTag noticeNumbers )
        // Grammar/RFC5280.g:2659:4: sequenceTag displayTextString sequenceTag noticeNumbers
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_noticeref5827);
            sequenceTag1138=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenoticerefEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1138.tree);

            FOLLOWPUSH(FOLLOW_displayTextString_in_noticeref5829);
            displayTextString1139=displayTextString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenoticerefEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, displayTextString1139.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_noticeref5831);
            sequenceTag1140=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenoticerefEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1140.tree);

            FOLLOWPUSH(FOLLOW_noticeNumbers_in_noticeref5833);
            noticeNumbers1141=noticeNumbers(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenoticerefEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, noticeNumbers1141.tree);

            {
                retval.text=malloc(sizeof(NOTICEREF));
                retval.text
                ->organization=displayTextString1139.text
                ;retval.text
                ->noticenos=noticeNumbers1141.text
                ;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenoticerefEx; /* Prevent compiler warnings */
    rulenoticerefEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end noticeref */

/**
 * $ANTLR start noticeNumbers
 * Grammar/RFC5280.g:2664:1: noticeNumbers returns [STACK_OF(ASN1_INTEGER) *text] : ( integer )* ;
 */
static RFC5280Parser_noticeNumbers_return
noticeNumbers(pRFC5280Parser ctx)
{
    RFC5280Parser_noticeNumbers_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return integer1142;
    #undef	RETURN_TYPE_integer1142
    #define	RETURN_TYPE_integer1142 RFC5280Parser_integer_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text=NULL;

    integer1142.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2668:2: ( ( integer )* )
        // Grammar/RFC5280.g:2668:3: ( integer )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:2671:3: ( integer )*

            for (;;)
            {
                int alt305=2;
                switch ( LA(1) )
                {
                case Int0:
                case Int1:
                case Int2:
                case IntTag:
                	{
                		alt305=1;
                	}
                    break;

                }

                switch (alt305)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2671:4: integer
            	    {
            	        FOLLOWPUSH(FOLLOW_integer_in_noticeNumbers5861);
            	        integer1142=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenoticeNumbersEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, integer1142.tree);

            	        {

            	            	if(retval.text
            	             == NULL)
            	            		retval.text= sk_ASN1_INTEGER_new_null();

            	            	sk_ASN1_INTEGER_push(retval.text
            	            ,integer1142.text
            	            );
            	            	
            	        }


            	    }
            	    break;

            	default:
            	    goto loop305;	/* break out of the loop */
            	    break;
                }
            }
            loop305: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenoticeNumbersEx; /* Prevent compiler warnings */
    rulenoticeNumbersEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end noticeNumbers */

/**
 * $ANTLR start subAltName
 * Grammar/RFC5280.g:2678:1: subAltName : subaltoid ( critical )? constructedOctetString sequenceTag generalNames ;
 */
static RFC5280Parser_subAltName_return
subAltName(pRFC5280Parser ctx)
{
    RFC5280Parser_subAltName_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_subaltoid_return subaltoid1143;
    #undef	RETURN_TYPE_subaltoid1143
    #define	RETURN_TYPE_subaltoid1143 RFC5280Parser_subaltoid_return

    RFC5280Parser_critical_return critical1144;
    #undef	RETURN_TYPE_critical1144
    #define	RETURN_TYPE_critical1144 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1145;
    #undef	RETURN_TYPE_constructedOctetString1145
    #define	RETURN_TYPE_constructedOctetString1145 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1146;
    #undef	RETURN_TYPE_sequenceTag1146
    #define	RETURN_TYPE_sequenceTag1146 RFC5280Parser_sequenceTag_return

    RFC5280Parser_generalNames_return generalNames1147;
    #undef	RETURN_TYPE_generalNames1147
    #define	RETURN_TYPE_generalNames1147 RFC5280Parser_generalNames_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    subaltoid1143.tree = NULL;

    critical1144.tree = NULL;

    constructedOctetString1145.tree = NULL;

    sequenceTag1146.tree = NULL;

    generalNames1147.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2682:2: ( subaltoid ( critical )? constructedOctetString sequenceTag generalNames )
        // Grammar/RFC5280.g:2682:3: subaltoid ( critical )? constructedOctetString sequenceTag generalNames
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_subaltoid_in_subAltName5886);
            subaltoid1143=subaltoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, subaltoid1143.tree);

            {
                ext->oid=subaltoid1143.obj
                ;ext->critical=0;
            }


            // Grammar/RFC5280.g:2685:54: ( critical )?
            {
                int alt306=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt306=1;
                    	}
                        break;
                }

                switch (alt306)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2685:55: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_subAltName5890);
            	        critical1144=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubAltNameEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1144.tree);

            	        {
            	            ext->critical=critical1144.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_subAltName5898);
            constructedOctetString1145=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1145.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_subAltName5900);
            sequenceTag1146=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1146.tree);

            FOLLOWPUSH(FOLLOW_generalNames_in_subAltName5902);
            generalNames1147=generalNames(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, generalNames1147.tree);

            {
                ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->gen_names=generalNames1147.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubAltNameEx; /* Prevent compiler warnings */
    rulesubAltNameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subAltName */

/**
 * $ANTLR start subAltNameCritical
 * Grammar/RFC5280.g:2691:1: subAltNameCritical : sequenceTag subaltoid truevalue constructedOctetString sequenceTag generalNames ;
 */
static RFC5280Parser_subAltNameCritical_return
subAltNameCritical(pRFC5280Parser ctx)
{
    RFC5280Parser_subAltNameCritical_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1148;
    #undef	RETURN_TYPE_sequenceTag1148
    #define	RETURN_TYPE_sequenceTag1148 RFC5280Parser_sequenceTag_return

    RFC5280Parser_subaltoid_return subaltoid1149;
    #undef	RETURN_TYPE_subaltoid1149
    #define	RETURN_TYPE_subaltoid1149 RFC5280Parser_subaltoid_return

    RFC5280Parser_truevalue_return truevalue1150;
    #undef	RETURN_TYPE_truevalue1150
    #define	RETURN_TYPE_truevalue1150 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1151;
    #undef	RETURN_TYPE_constructedOctetString1151
    #define	RETURN_TYPE_constructedOctetString1151 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1152;
    #undef	RETURN_TYPE_sequenceTag1152
    #define	RETURN_TYPE_sequenceTag1152 RFC5280Parser_sequenceTag_return

    RFC5280Parser_generalNames_return generalNames1153;
    #undef	RETURN_TYPE_generalNames1153
    #define	RETURN_TYPE_generalNames1153 RFC5280Parser_generalNames_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1148.tree = NULL;

    subaltoid1149.tree = NULL;

    truevalue1150.tree = NULL;

    constructedOctetString1151.tree = NULL;

    sequenceTag1152.tree = NULL;

    generalNames1153.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2695:2: ( sequenceTag subaltoid truevalue constructedOctetString sequenceTag generalNames )
        // Grammar/RFC5280.g:2695:3: sequenceTag subaltoid truevalue constructedOctetString sequenceTag generalNames
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_subAltNameCritical5924);
            sequenceTag1148=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameCriticalEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1148.tree);

            FOLLOWPUSH(FOLLOW_subaltoid_in_subAltNameCritical5926);
            subaltoid1149=subaltoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameCriticalEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, subaltoid1149.tree);

            FOLLOWPUSH(FOLLOW_truevalue_in_subAltNameCritical5928);
            truevalue1150=truevalue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameCriticalEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, truevalue1150.tree);

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_subAltNameCritical5930);
            constructedOctetString1151=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameCriticalEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1151.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_subAltNameCritical5932);
            sequenceTag1152=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameCriticalEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1152.tree);

            FOLLOWPUSH(FOLLOW_generalNames_in_subAltNameCritical5934);
            generalNames1153=generalNames(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubAltNameCriticalEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, generalNames1153.tree);

            {
                x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
                		ext->oid = subaltoid1149.obj
                ;
                		ext->critical = 1;
                		ext->value = malloc(sizeof(X509_EXTENSION_VALUE));
                		ext->value->gen_names=generalNames1153.text
                ;
                		sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubAltNameCriticalEx; /* Prevent compiler warnings */
    rulesubAltNameCriticalEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subAltNameCritical */

/**
 * $ANTLR start issuerAltName
 * Grammar/RFC5280.g:2705:1: issuerAltName : issaltoid ( critical )? constructedOctetString sequenceTag generalNames ;
 */
static RFC5280Parser_issuerAltName_return
issuerAltName(pRFC5280Parser ctx)
{
    RFC5280Parser_issuerAltName_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_issaltoid_return issaltoid1154;
    #undef	RETURN_TYPE_issaltoid1154
    #define	RETURN_TYPE_issaltoid1154 RFC5280Parser_issaltoid_return

    RFC5280Parser_critical_return critical1155;
    #undef	RETURN_TYPE_critical1155
    #define	RETURN_TYPE_critical1155 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1156;
    #undef	RETURN_TYPE_constructedOctetString1156
    #define	RETURN_TYPE_constructedOctetString1156 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1157;
    #undef	RETURN_TYPE_sequenceTag1157
    #define	RETURN_TYPE_sequenceTag1157 RFC5280Parser_sequenceTag_return

    RFC5280Parser_generalNames_return generalNames1158;
    #undef	RETURN_TYPE_generalNames1158
    #define	RETURN_TYPE_generalNames1158 RFC5280Parser_generalNames_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    issaltoid1154.tree = NULL;

    critical1155.tree = NULL;

    constructedOctetString1156.tree = NULL;

    sequenceTag1157.tree = NULL;

    generalNames1158.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2709:2: ( issaltoid ( critical )? constructedOctetString sequenceTag generalNames )
        // Grammar/RFC5280.g:2709:3: issaltoid ( critical )? constructedOctetString sequenceTag generalNames
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_issaltoid_in_issuerAltName5958);
            issaltoid1154=issaltoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleissuerAltNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, issaltoid1154.tree);

            {
                ext->oid=issaltoid1154.obj
                ;ext->critical=0;
            }


            // Grammar/RFC5280.g:2712:55: ( critical )?
            {
                int alt307=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt307=1;
                    	}
                        break;
                }

                switch (alt307)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2712:56: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_issuerAltName5962);
            	        critical1155=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleissuerAltNameEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1155.tree);

            	        {
            	            ext->critical=critical1155.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_issuerAltName5970);
            constructedOctetString1156=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleissuerAltNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1156.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_issuerAltName5972);
            sequenceTag1157=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleissuerAltNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1157.tree);

            FOLLOWPUSH(FOLLOW_generalNames_in_issuerAltName5974);
            generalNames1158=generalNames(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleissuerAltNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, generalNames1158.tree);

            {
                ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->gen_names=generalNames1158.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleissuerAltNameEx; /* Prevent compiler warnings */
    ruleissuerAltNameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end issuerAltName */

/**
 * $ANTLR start subDirAttr
 * Grammar/RFC5280.g:2717:1: subDirAttr : subdiroid ( critical )? constructedOctetString sequenceTag attributes ;
 */
static RFC5280Parser_subDirAttr_return
subDirAttr(pRFC5280Parser ctx)
{
    RFC5280Parser_subDirAttr_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_subdiroid_return subdiroid1159;
    #undef	RETURN_TYPE_subdiroid1159
    #define	RETURN_TYPE_subdiroid1159 RFC5280Parser_subdiroid_return

    RFC5280Parser_critical_return critical1160;
    #undef	RETURN_TYPE_critical1160
    #define	RETURN_TYPE_critical1160 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1161;
    #undef	RETURN_TYPE_constructedOctetString1161
    #define	RETURN_TYPE_constructedOctetString1161 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1162;
    #undef	RETURN_TYPE_sequenceTag1162
    #define	RETURN_TYPE_sequenceTag1162 RFC5280Parser_sequenceTag_return

    RFC5280Parser_attributes_return attributes1163;
    #undef	RETURN_TYPE_attributes1163
    #define	RETURN_TYPE_attributes1163 RFC5280Parser_attributes_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    subdiroid1159.tree = NULL;

    critical1160.tree = NULL;

    constructedOctetString1161.tree = NULL;

    sequenceTag1162.tree = NULL;

    attributes1163.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2721:2: ( subdiroid ( critical )? constructedOctetString sequenceTag attributes )
        // Grammar/RFC5280.g:2721:3: subdiroid ( critical )? constructedOctetString sequenceTag attributes
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_subdiroid_in_subDirAttr5999);
            subdiroid1159=subdiroid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubDirAttrEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, subdiroid1159.tree);

            {
                ext->oid=subdiroid1159.obj
                ;ext->critical=0;
            }


            // Grammar/RFC5280.g:2724:56: ( critical )?
            {
                int alt308=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt308=1;
                    	}
                        break;
                }

                switch (alt308)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2724:57: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_subDirAttr6004);
            	        critical1160=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubDirAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1160.tree);

            	        {
            	            ext->critical=critical1160.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_subDirAttr6009);
            constructedOctetString1161=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubDirAttrEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1161.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_subDirAttr6011);
            sequenceTag1162=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubDirAttrEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1162.tree);

            {
                sequence_pointer=counter_list;
            }


            FOLLOWPUSH(FOLLOW_attributes_in_subDirAttr6018);
            attributes1163=attributes(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubDirAttrEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, attributes1163.tree);

            {

                	ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->subject_directory=attributes1163.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubDirAttrEx; /* Prevent compiler warnings */
    rulesubDirAttrEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subDirAttr */

/**
 * $ANTLR start attributes
 * Grammar/RFC5280.g:2730:1: attributes returns [STACK_OF(SUBJECT_DIRECTORY_ATTRIBUTES) *text] : ( attribute )+ ;
 */
static RFC5280Parser_attributes_return
attributes(pRFC5280Parser ctx)
{
    RFC5280Parser_attributes_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_attribute_return attribute1164;
    #undef	RETURN_TYPE_attribute1164
    #define	RETURN_TYPE_attribute1164 RFC5280Parser_attribute_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text=sk_SUBJECT_DIRECTORY_ATTRIBUTES_new_null();

    attribute1164.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2734:2: ( ( attribute )+ )
        // Grammar/RFC5280.g:2734:3: ( attribute )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:2737:3: ( attribute )+
            {
                int cnt309=0;

                for (;;)
                {
                    int alt309=2;
            	alt309 = cdfa309.predict(ctx, RECOGNIZER, ISTREAM, &cdfa309);
            	if  (HASEXCEPTION())
            	{
            	    goto ruleattributesEx;
            	}

            	switch (alt309)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:2737:4: attribute
            	        {
            	            FOLLOWPUSH(FOLLOW_attribute_in_attributes6045);
            	            attribute1164=attribute(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleattributesEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, attribute1164.tree);

            	            {
            	                sk_SUBJECT_DIRECTORY_ATTRIBUTES_push(retval.text
            	                ,attribute1164.text
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt309 >= 1 )
            		{
            		    goto loop309;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleattributesEx;
            	}
            	cnt309++;
                }
                loop309: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleattributesEx; /* Prevent compiler warnings */
    ruleattributesEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end attributes */

/**
 * $ANTLR start attribute
 * Grammar/RFC5280.g:2739:1: attribute returns [SUBJECT_DIRECTORY_ATTRIBUTES *text] :{...}? => sequenceTag ( ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) set ( directoryString )+ | oid any | ( dnoid | countryoid | serialoid ) set ( printString )+ ) ;
 */
static RFC5280Parser_attribute_return
attribute(pRFC5280Parser ctx)
{
    RFC5280Parser_attribute_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1165;
    #undef	RETURN_TYPE_sequenceTag1165
    #define	RETURN_TYPE_sequenceTag1165 RFC5280Parser_sequenceTag_return

    RFC5280Parser_cnoid_return cnoid1166;
    #undef	RETURN_TYPE_cnoid1166
    #define	RETURN_TYPE_cnoid1166 RFC5280Parser_cnoid_return

    RFC5280Parser_oidon_return oidon1167;
    #undef	RETURN_TYPE_oidon1167
    #define	RETURN_TYPE_oidon1167 RFC5280Parser_oidon_return

    RFC5280Parser_oidname_return oidname1168;
    #undef	RETURN_TYPE_oidname1168
    #define	RETURN_TYPE_oidname1168 RFC5280Parser_oidname_return

    RFC5280Parser_surnameoid_return surnameoid1169;
    #undef	RETURN_TYPE_surnameoid1169
    #define	RETURN_TYPE_surnameoid1169 RFC5280Parser_surnameoid_return

    RFC5280Parser_givenoid_return givenoid1170;
    #undef	RETURN_TYPE_givenoid1170
    #define	RETURN_TYPE_givenoid1170 RFC5280Parser_givenoid_return

    RFC5280Parser_initoid_return initoid1171;
    #undef	RETURN_TYPE_initoid1171
    #define	RETURN_TYPE_initoid1171 RFC5280Parser_initoid_return

    RFC5280Parser_genqualifieroid_return genqualifieroid1172;
    #undef	RETURN_TYPE_genqualifieroid1172
    #define	RETURN_TYPE_genqualifieroid1172 RFC5280Parser_genqualifieroid_return

    RFC5280Parser_localoid_return localoid1173;
    #undef	RETURN_TYPE_localoid1173
    #define	RETURN_TYPE_localoid1173 RFC5280Parser_localoid_return

    RFC5280Parser_ouoid_return ouoid1174;
    #undef	RETURN_TYPE_ouoid1174
    #define	RETURN_TYPE_ouoid1174 RFC5280Parser_ouoid_return

    RFC5280Parser_sorpoid_return sorpoid1175;
    #undef	RETURN_TYPE_sorpoid1175
    #define	RETURN_TYPE_sorpoid1175 RFC5280Parser_sorpoid_return

    RFC5280Parser_titleoid_return titleoid1176;
    #undef	RETURN_TYPE_titleoid1176
    #define	RETURN_TYPE_titleoid1176 RFC5280Parser_titleoid_return

    RFC5280Parser_pseudooid_return pseudooid1177;
    #undef	RETURN_TYPE_pseudooid1177
    #define	RETURN_TYPE_pseudooid1177 RFC5280Parser_pseudooid_return

    RFC5280Parser_set_return set1178;
    #undef	RETURN_TYPE_set1178
    #define	RETURN_TYPE_set1178 RFC5280Parser_set_return

    RFC5280Parser_directoryString_return directoryString1179;
    #undef	RETURN_TYPE_directoryString1179
    #define	RETURN_TYPE_directoryString1179 RFC5280Parser_directoryString_return

    RFC5280Parser_oid_return oid1180;
    #undef	RETURN_TYPE_oid1180
    #define	RETURN_TYPE_oid1180 RFC5280Parser_oid_return

    RFC5280Parser_any_return any1181;
    #undef	RETURN_TYPE_any1181
    #define	RETURN_TYPE_any1181 RFC5280Parser_any_return

    RFC5280Parser_dnoid_return dnoid1182;
    #undef	RETURN_TYPE_dnoid1182
    #define	RETURN_TYPE_dnoid1182 RFC5280Parser_dnoid_return

    RFC5280Parser_countryoid_return countryoid1183;
    #undef	RETURN_TYPE_countryoid1183
    #define	RETURN_TYPE_countryoid1183 RFC5280Parser_countryoid_return

    RFC5280Parser_serialoid_return serialoid1184;
    #undef	RETURN_TYPE_serialoid1184
    #define	RETURN_TYPE_serialoid1184 RFC5280Parser_serialoid_return

    RFC5280Parser_set_return set1185;
    #undef	RETURN_TYPE_set1185
    #define	RETURN_TYPE_set1185 RFC5280Parser_set_return

    RFC5280Parser_printString_return printString1186;
    #undef	RETURN_TYPE_printString1186
    #define	RETURN_TYPE_printString1186 RFC5280Parser_printString_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text=malloc(sizeof(SUBJECT_DIRECTORY_ATTRIBUTES));
    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    sequenceTag1165.tree = NULL;

    cnoid1166.tree = NULL;

    oidon1167.tree = NULL;

    oidname1168.tree = NULL;

    surnameoid1169.tree = NULL;

    givenoid1170.tree = NULL;

    initoid1171.tree = NULL;

    genqualifieroid1172.tree = NULL;

    localoid1173.tree = NULL;

    ouoid1174.tree = NULL;

    sorpoid1175.tree = NULL;

    titleoid1176.tree = NULL;

    pseudooid1177.tree = NULL;

    set1178.tree = NULL;

    directoryString1179.tree = NULL;

    oid1180.tree = NULL;

    any1181.tree = NULL;

    dnoid1182.tree = NULL;

    countryoid1183.tree = NULL;

    serialoid1184.tree = NULL;

    set1185.tree = NULL;

    printString1186.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2745:2: ({...}? => sequenceTag ( ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) set ( directoryString )+ | oid any | ( dnoid | countryoid | serialoid ) set ( printString )+ ) )
        // Grammar/RFC5280.g:2746:2: {...}? => sequenceTag ( ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) set ( directoryString )+ | oid any | ( dnoid | countryoid | serialoid ) set ( printString )+ )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((sequence_pointer != NULL)) )
            {
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"sequence_pointer != NULL";
                    EXCEPTION->ruleName	 = (void *)"attribute";


            }

            FOLLOWPUSH(FOLLOW_sequenceTag_in_attribute6077);
            sequenceTag1165=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleattributeEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1165.tree);

            // Grammar/RFC5280.g:2746:43: ( ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) set ( directoryString )+ | oid any | ( dnoid | countryoid | serialoid ) set ( printString )+ )
            {
                int alt314=3;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case NAMEOID:
                		case OIDCN:
                		case OIDGENQUALIFIER:
                		case OIDGIVENAME:
                		case OIDINIT:
                		case OIDLOCAL:
                		case OIDON:
                		case OIDOU:
                		case OIDPSEUDO:
                		case OIDSORP:
                		case OIDTITLE:
                		case SURNAMEOID:
                			{
                				alt314=1;
                			}
                		    break;
                		case OIDCOUNTRY:
                		case OIDDNQUALIFIER:
                		case OIDSERIAL:
                			{
                				alt314=3;
                			}
                		    break;
                		case PRINTABLE:
                		case VALUE:
                			{
                				alt314=2;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 314;
                		    EXCEPTION->state        = 1;


                		    goto ruleattributeEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 314;
                    EXCEPTION->state        = 0;


                    goto ruleattributeEx;

                }

                switch (alt314)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2746:45: ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) set ( directoryString )+
            	    {
            	        // Grammar/RFC5280.g:2746:45: ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid )
            	        {
            	            int alt310=12;
            	            switch ( LA(1) )
            	            {
            	            case OIDTag:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case OIDCN:
            	            			{
            	            				alt310=1;
            	            			}
            	            		    break;
            	            		case OIDON:
            	            			{
            	            				alt310=2;
            	            			}
            	            		    break;
            	            		case NAMEOID:
            	            			{
            	            				alt310=3;
            	            			}
            	            		    break;
            	            		case SURNAMEOID:
            	            			{
            	            				alt310=4;
            	            			}
            	            		    break;
            	            		case OIDGIVENAME:
            	            			{
            	            				alt310=5;
            	            			}
            	            		    break;
            	            		case OIDINIT:
            	            			{
            	            				alt310=6;
            	            			}
            	            		    break;
            	            		case OIDGENQUALIFIER:
            	            			{
            	            				alt310=7;
            	            			}
            	            		    break;
            	            		case OIDLOCAL:
            	            			{
            	            				alt310=8;
            	            			}
            	            		    break;
            	            		case OIDOU:
            	            			{
            	            				alt310=9;
            	            			}
            	            		    break;
            	            		case OIDSORP:
            	            			{
            	            				alt310=10;
            	            			}
            	            		    break;
            	            		case OIDTITLE:
            	            			{
            	            				alt310=11;
            	            			}
            	            		    break;
            	            		case OIDPSEUDO:
            	            			{
            	            				alt310=12;
            	            			}
            	            		    break;

            	            		default:
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 310;
            	            		    EXCEPTION->state        = 1;


            	            		    goto ruleattributeEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 310;
            	                EXCEPTION->state        = 0;


            	                goto ruleattributeEx;

            	            }

            	            switch (alt310)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:2746:46: cnoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_cnoid_in_attribute6081);
            	        	        cnoid1166=cnoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, cnoid1166.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=cnoid1166.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:2746:79: oidon
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_oidon_in_attribute6087);
            	        	        oidon1167=oidon(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, oidon1167.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=oidon1167.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // Grammar/RFC5280.g:2746:111: oidname
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_oidname_in_attribute6092);
            	        	        oidname1168=oidname(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, oidname1168.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=oidname1168.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // Grammar/RFC5280.g:2746:147: surnameoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_surnameoid_in_attribute6097);
            	        	        surnameoid1169=surnameoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, surnameoid1169.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=surnameoid1169.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // Grammar/RFC5280.g:2746:189: givenoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_givenoid_in_attribute6102);
            	        	        givenoid1170=givenoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, givenoid1170.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=givenoid1170.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // Grammar/RFC5280.g:2747:4: initoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_initoid_in_attribute6109);
            	        	        initoid1171=initoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, initoid1171.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=initoid1171.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 7:
            	        	    // Grammar/RFC5280.g:2747:40: genqualifieroid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_genqualifieroid_in_attribute6114);
            	        	        genqualifieroid1172=genqualifieroid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, genqualifieroid1172.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=genqualifieroid1172.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 8:
            	        	    // Grammar/RFC5280.g:2747:92: localoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_localoid_in_attribute6119);
            	        	        localoid1173=localoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, localoid1173.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=localoid1173.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 9:
            	        	    // Grammar/RFC5280.g:2747:130: ouoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_ouoid_in_attribute6124);
            	        	        ouoid1174=ouoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, ouoid1174.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=ouoid1174.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 10:
            	        	    // Grammar/RFC5280.g:2748:4: sorpoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sorpoid_in_attribute6131);
            	        	        sorpoid1175=sorpoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, sorpoid1175.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=sorpoid1175.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 11:
            	        	    // Grammar/RFC5280.g:2748:40: titleoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_titleoid_in_attribute6136);
            	        	        titleoid1176=titleoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, titleoid1176.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=titleoid1176.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 12:
            	        	    // Grammar/RFC5280.g:2748:78: pseudooid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_pseudooid_in_attribute6141);
            	        	        pseudooid1177=pseudooid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, pseudooid1177.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=pseudooid1177.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	            retval.text
            	            ->value=malloc(sizeof(SUB_DIR_ATTRS_VALUE));
            	            	retval.text
            	            ->value->str_value = sk_STRING_POINTER_new_null();
            	        }


            	        FOLLOWPUSH(FOLLOW_set_in_attribute6150);
            	        set1178=set(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleattributeEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, set1178.tree);

            	        // Grammar/RFC5280.g:2750:6: ( directoryString )+
            	        {
            	            int cnt311=0;

            	            for (;;)
            	            {
            	                int alt311=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case BMPTag:
            	        	case IA5StringTag:
            	        	case PrintStringTag:
            	        	case TeletexTag:
            	        	case UTF8Tag:
            	        	case UniverStringTag:
            	        		{
            	        			alt311=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt311)
            	        	{
            	        	    case 1:
            	        	        // Grammar/RFC5280.g:2750:7: directoryString
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_directoryString_in_attribute6153);
            	        	            directoryString1179=directoryString(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruleattributeEx;
            	        	            }

            	        	            ADAPTOR->addChild(ADAPTOR, root_0, directoryString1179.tree);

            	        	            {

            	        	                	ASN1_STRING *out = malloc(sizeof(ASN1_STRING));
            	        	                	out->data = NULL;
            	        	                	ASN1_STRING_TABLE *tbl = ASN1_STRING_TABLE_get(OBJ_obj2nid(retval.text
            	        	                ->oid));
            	        	                	if(ASN1_mbstring_ncopy(&out,directoryString1179.text
            	        	                ->data,directoryString1179.text
            	        	                ->length,directoryString1179.text
            	        	                ->type,tbl->mask,tbl->minsize,tbl->maxsize) == -1)
            	        	                	{
            	        	                		printf("Attribute String length constraint not satisfied \n");
            	        	                		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	                	}	
            	        	                	sk_STRING_POINTER_push(retval.text
            	        	                ->value->str_value,out);
            	        	                	
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt311 >= 1 )
            	        		{
            	        		    goto loop311;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto ruleattributeEx;
            	        	}
            	        	cnt311++;
            	            }
            	            loop311: ;	/* Jump to here if this rule does not match */
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2762:3: oid any
            	    {
            	        FOLLOWPUSH(FOLLOW_oid_in_attribute6163);
            	        oid1180=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleattributeEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, oid1180.tree);

            	        FOLLOWPUSH(FOLLOW_any_in_attribute6165);
            	        any1181=any(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleattributeEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, any1181.tree);

            	        {
            	            retval.text
            	            ->oid=oid1180.text
            	            ->obj;retval.text
            	            ->value=malloc(sizeof(SUB_DIR_ATTRS_VALUE));retval.text
            	            ->value->any_value=any1181.text
            	            ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:2763:4: ( dnoid | countryoid | serialoid ) set ( printString )+
            	    {
            	        // Grammar/RFC5280.g:2763:4: ( dnoid | countryoid | serialoid )
            	        {
            	            int alt312=3;
            	            switch ( LA(1) )
            	            {
            	            case OIDTag:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case OIDDNQUALIFIER:
            	            			{
            	            				alt312=1;
            	            			}
            	            		    break;
            	            		case OIDCOUNTRY:
            	            			{
            	            				alt312=2;
            	            			}
            	            		    break;
            	            		case OIDSERIAL:
            	            			{
            	            				alt312=3;
            	            			}
            	            		    break;

            	            		default:
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 312;
            	            		    EXCEPTION->state        = 1;


            	            		    goto ruleattributeEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 312;
            	                EXCEPTION->state        = 0;


            	                goto ruleattributeEx;

            	            }

            	            switch (alt312)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:2763:5: dnoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_dnoid_in_attribute6173);
            	        	        dnoid1182=dnoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, dnoid1182.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=dnoid1182.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:2763:38: countryoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_countryoid_in_attribute6179);
            	        	        countryoid1183=countryoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, countryoid1183.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=countryoid1183.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // Grammar/RFC5280.g:2763:80: serialoid
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_serialoid_in_attribute6184);
            	        	        serialoid1184=serialoid(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleattributeEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, serialoid1184.tree);

            	        	        {
            	        	            retval.text
            	        	            ->oid=serialoid1184.obj
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	            retval.text
            	            ->value=malloc(sizeof(SUB_DIR_ATTRS_VALUE));
            	            	retval.text
            	            ->value->str_value = sk_STRING_POINTER_new_null();
            	        }


            	        FOLLOWPUSH(FOLLOW_set_in_attribute6193);
            	        set1185=set(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleattributeEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, set1185.tree);

            	        // Grammar/RFC5280.g:2765:6: ( printString )+
            	        {
            	            int cnt313=0;

            	            for (;;)
            	            {
            	                int alt313=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case PrintStringTag:
            	        		{
            	        			alt313=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt313)
            	        	{
            	        	    case 1:
            	        	        // Grammar/RFC5280.g:2765:7: printString
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_printString_in_attribute6196);
            	        	            printString1186=printString(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruleattributeEx;
            	        	            }

            	        	            ADAPTOR->addChild(ADAPTOR, root_0, printString1186.tree);

            	        	            {

            	        	                	ASN1_STRING *out = malloc(sizeof(ASN1_STRING));
            	        	                	out->data = NULL;
            	        	                	ASN1_STRING_TABLE *tbl = ASN1_STRING_TABLE_get(OBJ_obj2nid(retval.text
            	        	                ->oid));
            	        	                	if(ASN1_mbstring_ncopy(&out,printString1186.text
            	        	                ->data,printString1186.text
            	        	                ->length,MBSTRING_ASC,tbl->mask,tbl->minsize,tbl->maxsize) == -1)
            	        	                	{
            	        	                		printf("Attribute String length constraint not satisfied \n");
            	        	                		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	                	}
            	        	                	sk_STRING_POINTER_push(retval.text
            	        	                ->value->str_value,out);
            	        	                	
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt313 >= 1 )
            	        		{
            	        		    goto loop313;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto ruleattributeEx;
            	        	}
            	        	cnt313++;
            	            }
            	            loop313: ;	/* Jump to here if this rule does not match */
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleattributeEx; /* Prevent compiler warnings */
    ruleattributeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end attribute */

/**
 * $ANTLR start basicConstraints
 * Grammar/RFC5280.g:2779:1: basicConstraints : sequenceTag bcoid ( critical )? constructedOctetString sequenceTag ;
 */
static RFC5280Parser_basicConstraints_return
basicConstraints(pRFC5280Parser ctx)
{
    RFC5280Parser_basicConstraints_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1187;
    #undef	RETURN_TYPE_sequenceTag1187
    #define	RETURN_TYPE_sequenceTag1187 RFC5280Parser_sequenceTag_return

    RFC5280Parser_bcoid_return bcoid1188;
    #undef	RETURN_TYPE_bcoid1188
    #define	RETURN_TYPE_bcoid1188 RFC5280Parser_bcoid_return

    RFC5280Parser_critical_return critical1189;
    #undef	RETURN_TYPE_critical1189
    #define	RETURN_TYPE_critical1189 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1190;
    #undef	RETURN_TYPE_constructedOctetString1190
    #define	RETURN_TYPE_constructedOctetString1190 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1191;
    #undef	RETURN_TYPE_sequenceTag1191
    #define	RETURN_TYPE_sequenceTag1191 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1187.tree = NULL;

    bcoid1188.tree = NULL;

    critical1189.tree = NULL;

    constructedOctetString1190.tree = NULL;

    sequenceTag1191.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2783:2: ( sequenceTag bcoid ( critical )? constructedOctetString sequenceTag )
        // Grammar/RFC5280.g:2783:3: sequenceTag bcoid ( critical )? constructedOctetString sequenceTag
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraints6224);
            sequenceTag1187=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1187.tree);

            FOLLOWPUSH(FOLLOW_bcoid_in_basicConstraints6226);
            bcoid1188=bcoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bcoid1188.tree);

            {
                bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bcoid1188.obj
                ;bc_ext->critical=0;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                		bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            }


            // Grammar/RFC5280.g:2788:3: ( critical )?
            {
                int alt315=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt315=1;
                    	}
                        break;
                }

                switch (alt315)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2788:4: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_basicConstraints6233);
            	        critical1189=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1189.tree);

            	        {
            	            bc_ext->critical=critical1189.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_basicConstraints6239);
            constructedOctetString1190=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1190.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraints6241);
            sequenceTag1191=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1191.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebasicConstraintsEx; /* Prevent compiler warnings */
    rulebasicConstraintsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end basicConstraints */

/**
 * $ANTLR start basicConstraintsNotCritical
 * Grammar/RFC5280.g:2790:1: basicConstraintsNotCritical : sequenceTag bcoid ;
 */
static RFC5280Parser_basicConstraintsNotCritical_return
basicConstraintsNotCritical(pRFC5280Parser ctx)
{
    RFC5280Parser_basicConstraintsNotCritical_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1192;
    #undef	RETURN_TYPE_sequenceTag1192
    #define	RETURN_TYPE_sequenceTag1192 RFC5280Parser_sequenceTag_return

    RFC5280Parser_bcoid_return bcoid1193;
    #undef	RETURN_TYPE_bcoid1193
    #define	RETURN_TYPE_bcoid1193 RFC5280Parser_bcoid_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1192.tree = NULL;

    bcoid1193.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2794:2: ( sequenceTag bcoid )
        // Grammar/RFC5280.g:2794:3: sequenceTag bcoid
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsNotCritical6260);
            sequenceTag1192=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsNotCriticalEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1192.tree);

            FOLLOWPUSH(FOLLOW_bcoid_in_basicConstraintsNotCritical6262);
            bcoid1193=bcoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsNotCriticalEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bcoid1193.tree);

            {
                bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bcoid1193.obj
                ;bc_ext->critical=0;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                		bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebasicConstraintsNotCriticalEx; /* Prevent compiler warnings */
    rulebasicConstraintsNotCriticalEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end basicConstraintsNotCritical */

/**
 * $ANTLR start extendKeyUsage
 * Grammar/RFC5280.g:2800:1: extendKeyUsage : ekuoid ( critical )? constructedOctetString sequenceTag usages ;
 */
static RFC5280Parser_extendKeyUsage_return
extendKeyUsage(pRFC5280Parser ctx)
{
    RFC5280Parser_extendKeyUsage_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_ekuoid_return ekuoid1194;
    #undef	RETURN_TYPE_ekuoid1194
    #define	RETURN_TYPE_ekuoid1194 RFC5280Parser_ekuoid_return

    RFC5280Parser_critical_return critical1195;
    #undef	RETURN_TYPE_critical1195
    #define	RETURN_TYPE_critical1195 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1196;
    #undef	RETURN_TYPE_constructedOctetString1196
    #define	RETURN_TYPE_constructedOctetString1196 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1197;
    #undef	RETURN_TYPE_sequenceTag1197
    #define	RETURN_TYPE_sequenceTag1197 RFC5280Parser_sequenceTag_return

    RFC5280Parser_usages_return usages1198;
    #undef	RETURN_TYPE_usages1198
    #define	RETURN_TYPE_usages1198 RFC5280Parser_usages_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    ekuoid1194.tree = NULL;

    critical1195.tree = NULL;

    constructedOctetString1196.tree = NULL;

    sequenceTag1197.tree = NULL;

    usages1198.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2804:2: ( ekuoid ( critical )? constructedOctetString sequenceTag usages )
        // Grammar/RFC5280.g:2804:3: ekuoid ( critical )? constructedOctetString sequenceTag usages
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_ekuoid_in_extendKeyUsage6286);
            ekuoid1194=ekuoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextendKeyUsageEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, ekuoid1194.tree);

            {
                ext->oid=ekuoid1194.obj
                ;ext->critical=0;
            }


            // Grammar/RFC5280.g:2807:50: ( critical )?
            {
                int alt316=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt316=1;
                    	}
                        break;
                }

                switch (alt316)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2807:51: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_extendKeyUsage6291);
            	        critical1195=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextendKeyUsageEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1195.tree);

            	        {
            	            ext->critical=critical1195.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_extendKeyUsage6296);
            constructedOctetString1196=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextendKeyUsageEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1196.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_extendKeyUsage6298);
            sequenceTag1197=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextendKeyUsageEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1197.tree);

            FOLLOWPUSH(FOLLOW_usages_in_extendKeyUsage6300);
            usages1198=usages(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextendKeyUsageEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, usages1198.tree);

            {
                ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->ext_key_usage=usages1198.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextendKeyUsageEx; /* Prevent compiler warnings */
    ruleextendKeyUsageEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extendKeyUsage */

/**
 * $ANTLR start usages
 * Grammar/RFC5280.g:2814:1: usages returns [EXTENDED_KEY_USAGE *text] : ( usage )+ ;
 */
static RFC5280Parser_usages_return
usages(pRFC5280Parser ctx)
{
    RFC5280Parser_usages_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_usage_return usage1199;
    #undef	RETURN_TYPE_usage1199
    #define	RETURN_TYPE_usage1199 RFC5280Parser_usage_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text= sk_ASN1_OBJECT_new_null();

    usage1199.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2818:2: ( ( usage )+ )
        // Grammar/RFC5280.g:2818:3: ( usage )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:2821:3: ( usage )+
            {
                int cnt317=0;

                for (;;)
                {
                    int alt317=2;
            	switch ( LA(1) )
            	{
            	case OIDTag:
            		{
            			alt317=1;
            		}
            	    break;

            	}

            	switch (alt317)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:2821:4: usage
            	        {
            	            FOLLOWPUSH(FOLLOW_usage_in_usages6332);
            	            usage1199=usage(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleusagesEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, usage1199.tree);

            	            {
            	                sk_ASN1_OBJECT_push(retval.text
            	                ,usage1199.obj
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt317 >= 1 )
            		{
            		    goto loop317;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleusagesEx;
            	}
            	cnt317++;
                }
                loop317: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleusagesEx; /* Prevent compiler warnings */
    ruleusagesEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end usages */

/**
 * $ANTLR start usage
 * Grammar/RFC5280.g:2823:1: usage returns [ASN1_OBJECT *obj] : ( oid | serverauthoid | clientauthoid | codesignoid | emailprotectoid | timestampoid | ocspsignoid | anyusageoid );
 */
static RFC5280Parser_usage_return
usage(pRFC5280Parser ctx)
{
    RFC5280Parser_usage_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_oid_return oid1200;
    #undef	RETURN_TYPE_oid1200
    #define	RETURN_TYPE_oid1200 RFC5280Parser_oid_return

    RFC5280Parser_serverauthoid_return serverauthoid1201;
    #undef	RETURN_TYPE_serverauthoid1201
    #define	RETURN_TYPE_serverauthoid1201 RFC5280Parser_serverauthoid_return

    RFC5280Parser_clientauthoid_return clientauthoid1202;
    #undef	RETURN_TYPE_clientauthoid1202
    #define	RETURN_TYPE_clientauthoid1202 RFC5280Parser_clientauthoid_return

    RFC5280Parser_codesignoid_return codesignoid1203;
    #undef	RETURN_TYPE_codesignoid1203
    #define	RETURN_TYPE_codesignoid1203 RFC5280Parser_codesignoid_return

    RFC5280Parser_emailprotectoid_return emailprotectoid1204;
    #undef	RETURN_TYPE_emailprotectoid1204
    #define	RETURN_TYPE_emailprotectoid1204 RFC5280Parser_emailprotectoid_return

    RFC5280Parser_timestampoid_return timestampoid1205;
    #undef	RETURN_TYPE_timestampoid1205
    #define	RETURN_TYPE_timestampoid1205 RFC5280Parser_timestampoid_return

    RFC5280Parser_ocspsignoid_return ocspsignoid1206;
    #undef	RETURN_TYPE_ocspsignoid1206
    #define	RETURN_TYPE_ocspsignoid1206 RFC5280Parser_ocspsignoid_return

    RFC5280Parser_anyusageoid_return anyusageoid1207;
    #undef	RETURN_TYPE_anyusageoid1207
    #define	RETURN_TYPE_anyusageoid1207 RFC5280Parser_anyusageoid_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    	
    oid1200.tree = NULL;

    serverauthoid1201.tree = NULL;

    clientauthoid1202.tree = NULL;

    codesignoid1203.tree = NULL;

    emailprotectoid1204.tree = NULL;

    timestampoid1205.tree = NULL;

    ocspsignoid1206.tree = NULL;

    anyusageoid1207.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:2831:2: ( oid | serverauthoid | clientauthoid | codesignoid | emailprotectoid | timestampoid | ocspsignoid | anyusageoid )

            ANTLR3_UINT32 alt318;

            alt318=8;

            switch ( LA(1) )
            {
            case OIDTag:
            	{
            		switch ( LA(2) )
            		{
            		case SERVERAUTHOID:
            			{
            				alt318=2;
            			}
            		    break;
            		case CLIENTAUTHOID:
            			{
            				alt318=3;
            			}
            		    break;
            		case CODESIGNOID:
            			{
            				alt318=4;
            			}
            		    break;
            		case EMAILPROTECTOID:
            			{
            				alt318=5;
            			}
            		    break;
            		case TIMESTAMPOID:
            			{
            				alt318=6;
            			}
            		    break;
            		case OCSPSIGNOID:
            			{
            				alt318=7;
            			}
            		    break;
            		case ANYUSAGEOID:
            			{
            				alt318=8;
            			}
            		    break;
            		case PRINTABLE:
            		case VALUE:
            			{
            				alt318=1;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 318;
            		    EXCEPTION->state        = 1;


            		    goto ruleusageEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 318;
                EXCEPTION->state        = 0;


                goto ruleusageEx;

            }

            switch (alt318)
            {
        	case 1:
        	    // Grammar/RFC5280.g:2832:3: oid
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_oid_in_usage6362);
        	        oid1200=oid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleusageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, oid1200.tree);

        	        {
        	            retval.obj=
        	            oid1200.text
        	            ->obj;
        	            cert->eku_mask &=255;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:2832:53: serverauthoid
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_serverauthoid_in_usage6368);
        	        serverauthoid1201=serverauthoid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleusageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, serverauthoid1201.tree);

        	        {
        	            retval.obj=
        	            serverauthoid1201.obj
        	            ;
        	            cert->eku_mask &=168;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:2833:5: clientauthoid
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_clientauthoid_in_usage6377);
        	        clientauthoid1202=clientauthoid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleusageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, clientauthoid1202.tree);

        	        {
        	            retval.obj=
        	            clientauthoid1202.obj
        	            ;
        	            cert->eku_mask &=136;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:2833:68: codesignoid
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_codesignoid_in_usage6382);
        	        codesignoid1203=codesignoid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleusageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, codesignoid1203.tree);

        	        {
        	            retval.obj=
        	            codesignoid1203.obj
        	            ;
        	            cert->eku_mask &=128;
        	        }


        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:2834:5: emailprotectoid
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_emailprotectoid_in_usage6390);
        	        emailprotectoid1204=emailprotectoid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleusageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, emailprotectoid1204.tree);

        	        {
        	            retval.obj=
        	            emailprotectoid1204.obj
        	            ;
        	            cert->eku_mask &=232;
        	        }


        	    }
        	    break;
        	case 6:
        	    // Grammar/RFC5280.g:2834:72: timestampoid
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_timestampoid_in_usage6395);
        	        timestampoid1205=timestampoid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleusageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, timestampoid1205.tree);

        	        {
        	            retval.obj=
        	            timestampoid1205.obj
        	            ;
        	            cert->eku_mask &=192;
        	        }


        	    }
        	    break;
        	case 7:
        	    // Grammar/RFC5280.g:2835:5: ocspsignoid
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_ocspsignoid_in_usage6403);
        	        ocspsignoid1206=ocspsignoid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleusageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, ocspsignoid1206.tree);

        	        {
        	            retval.obj=
        	            ocspsignoid1206.obj
        	            ;
        	            cert->eku_mask &=192;
        	        }


        	    }
        	    break;
        	case 8:
        	    // Grammar/RFC5280.g:2835:64: anyusageoid
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_anyusageoid_in_usage6408);
        	        anyusageoid1207=anyusageoid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleusageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, anyusageoid1207.tree);

        	        {
        	            retval.obj=
        	            anyusageoid1207.obj
        	            ;
        	            eku_mask=255;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleusageEx; /* Prevent compiler warnings */
    ruleusageEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end usage */

/**
 * $ANTLR start crldp
 * Grammar/RFC5280.g:2837:1: crldp : crldpoid ( critical )? constructedOctetString sequenceTag dps ;
 */
static RFC5280Parser_crldp_return
crldp(pRFC5280Parser ctx)
{
    RFC5280Parser_crldp_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_crldpoid_return crldpoid1208;
    #undef	RETURN_TYPE_crldpoid1208
    #define	RETURN_TYPE_crldpoid1208 RFC5280Parser_crldpoid_return

    RFC5280Parser_critical_return critical1209;
    #undef	RETURN_TYPE_critical1209
    #define	RETURN_TYPE_critical1209 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1210;
    #undef	RETURN_TYPE_constructedOctetString1210
    #define	RETURN_TYPE_constructedOctetString1210 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1211;
    #undef	RETURN_TYPE_sequenceTag1211
    #define	RETURN_TYPE_sequenceTag1211 RFC5280Parser_sequenceTag_return

    RFC5280Parser_dps_return dps1212;
    #undef	RETURN_TYPE_dps1212
    #define	RETURN_TYPE_dps1212 RFC5280Parser_dps_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    crldpoid1208.tree = NULL;

    critical1209.tree = NULL;

    constructedOctetString1210.tree = NULL;

    sequenceTag1211.tree = NULL;

    dps1212.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2841:2: ( crldpoid ( critical )? constructedOctetString sequenceTag dps )
        // Grammar/RFC5280.g:2841:3: crldpoid ( critical )? constructedOctetString sequenceTag dps
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_crldpoid_in_crldp6432);
            crldpoid1208=crldpoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecrldpEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, crldpoid1208.tree);

            {
                ext->oid=crldpoid1208.obj
                ;ext->critical=0;ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
            }


            // Grammar/RFC5280.g:2844:101: ( critical )?
            {
                int alt319=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt319=1;
                    	}
                        break;
                }

                switch (alt319)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2844:102: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_crldp6436);
            	        critical1209=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecrldpEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1209.tree);

            	        {
            	            ext->critical=critical1209.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_crldp6444);
            constructedOctetString1210=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecrldpEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1210.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_crldp6446);
            sequenceTag1211=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecrldpEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1211.tree);

            FOLLOWPUSH(FOLLOW_dps_in_crldp6448);
            dps1212=dps(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecrldpEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, dps1212.tree);

            {
                ext->value->crl_dps=dps1212.text
                ;sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecrldpEx; /* Prevent compiler warnings */
    rulecrldpEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end crldp */

/**
 * $ANTLR start dps
 * Grammar/RFC5280.g:2847:1: dps returns [STACK_OF(CRL_DISTRIBUTION_POINT) *text] : ( dp )+ ;
 */
static RFC5280Parser_dps_return
dps(pRFC5280Parser ctx)
{
    RFC5280Parser_dps_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_dp_return dp1213;
    #undef	RETURN_TYPE_dp1213
    #define	RETURN_TYPE_dp1213 RFC5280Parser_dp_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text= sk_CRL_DISTRIBUTION_POINT_new_null();

    dp1213.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2851:2: ( ( dp )+ )
        // Grammar/RFC5280.g:2851:3: ( dp )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:2854:3: ( dp )+
            {
                int cnt320=0;

                for (;;)
                {
                    int alt320=2;
            	switch ( LA(1) )
            	{
            	case SequenceTag:
            		{
            			switch ( LA(2) )
            			{
            			case ConstructedTag0:
            			case ConstructedTag2:
            			case Tag1:
            				{
            					alt320=1;
            				}
            			    break;

            			}

            		}
            	    break;

            	}

            	switch (alt320)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:2854:4: dp
            	        {
            	            FOLLOWPUSH(FOLLOW_dp_in_dps6475);
            	            dp1213=dp(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledpsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, dp1213.tree);

            	            {
            	                sk_CRL_DISTRIBUTION_POINT_push(retval.text
            	                ,dp1213.text
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt320 >= 1 )
            		{
            		    goto loop320;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruledpsEx;
            	}
            	cnt320++;
                }
                loop320: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledpsEx; /* Prevent compiler warnings */
    ruledpsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dps */

/**
 * $ANTLR start dp
 * Grammar/RFC5280.g:2856:1: dp returns [CRL_DISTRIBUTION_POINT *text] : sequenceTag ( constructedTag0 ( constructedTag0 fn= generalNames (t1= tag1 )? ( constructedTag2 gn= generalNames )? | constructedTag1 rdn (t1= tag1 )? ( constructedTag2 generalName )? ) | (t1= tag1 )? constructedTag2 gn= generalNames ) ;
 */
static RFC5280Parser_dp_return
dp(pRFC5280Parser ctx)
{
    RFC5280Parser_dp_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_generalNames_return fn;
    #undef	RETURN_TYPE_fn
    #define	RETURN_TYPE_fn RFC5280Parser_generalNames_return

    RFC5280Parser_tag1_return t1;
    #undef	RETURN_TYPE_t1
    #define	RETURN_TYPE_t1 RFC5280Parser_tag1_return

    RFC5280Parser_generalNames_return gn;
    #undef	RETURN_TYPE_gn
    #define	RETURN_TYPE_gn RFC5280Parser_generalNames_return

    RFC5280Parser_sequenceTag_return sequenceTag1214;
    #undef	RETURN_TYPE_sequenceTag1214
    #define	RETURN_TYPE_sequenceTag1214 RFC5280Parser_sequenceTag_return

    RFC5280Parser_constructedTag0_return constructedTag01215;
    #undef	RETURN_TYPE_constructedTag01215
    #define	RETURN_TYPE_constructedTag01215 RFC5280Parser_constructedTag0_return

    RFC5280Parser_constructedTag0_return constructedTag01216;
    #undef	RETURN_TYPE_constructedTag01216
    #define	RETURN_TYPE_constructedTag01216 RFC5280Parser_constructedTag0_return

    RFC5280Parser_constructedTag2_return constructedTag21217;
    #undef	RETURN_TYPE_constructedTag21217
    #define	RETURN_TYPE_constructedTag21217 RFC5280Parser_constructedTag2_return

    RFC5280Parser_constructedTag1_return constructedTag11218;
    #undef	RETURN_TYPE_constructedTag11218
    #define	RETURN_TYPE_constructedTag11218 RFC5280Parser_constructedTag1_return

    RFC5280Parser_rdn_return rdn1219;
    #undef	RETURN_TYPE_rdn1219
    #define	RETURN_TYPE_rdn1219 RFC5280Parser_rdn_return

    RFC5280Parser_constructedTag2_return constructedTag21220;
    #undef	RETURN_TYPE_constructedTag21220
    #define	RETURN_TYPE_constructedTag21220 RFC5280Parser_constructedTag2_return

    RFC5280Parser_generalName_return generalName1221;
    #undef	RETURN_TYPE_generalName1221
    #define	RETURN_TYPE_generalName1221 RFC5280Parser_generalName_return

    RFC5280Parser_constructedTag2_return constructedTag21222;
    #undef	RETURN_TYPE_constructedTag21222
    #define	RETURN_TYPE_constructedTag21222 RFC5280Parser_constructedTag2_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text= malloc(sizeof(CRL_DISTRIBUTION_POINT));
    retval.text
    ->dp_name=NULL;retval.text
    ->reason_flags=NULL;retval.text
    ->crl_issuer=NULL;
    fn.tree = NULL;

    t1.tree = NULL;

    gn.tree = NULL;

    sequenceTag1214.tree = NULL;

    constructedTag01215.tree = NULL;

    constructedTag01216.tree = NULL;

    constructedTag21217.tree = NULL;

    constructedTag11218.tree = NULL;

    rdn1219.tree = NULL;

    constructedTag21220.tree = NULL;

    generalName1221.tree = NULL;

    constructedTag21222.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2860:2: ( sequenceTag ( constructedTag0 ( constructedTag0 fn= generalNames (t1= tag1 )? ( constructedTag2 gn= generalNames )? | constructedTag1 rdn (t1= tag1 )? ( constructedTag2 generalName )? ) | (t1= tag1 )? constructedTag2 gn= generalNames ) )
        // Grammar/RFC5280.g:2860:3: sequenceTag ( constructedTag0 ( constructedTag0 fn= generalNames (t1= tag1 )? ( constructedTag2 gn= generalNames )? | constructedTag1 rdn (t1= tag1 )? ( constructedTag2 generalName )? ) | (t1= tag1 )? constructedTag2 gn= generalNames )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_dp6505);
            sequenceTag1214=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledpEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1214.tree);

            // Grammar/RFC5280.g:2863:15: ( constructedTag0 ( constructedTag0 fn= generalNames (t1= tag1 )? ( constructedTag2 gn= generalNames )? | constructedTag1 rdn (t1= tag1 )? ( constructedTag2 generalName )? ) | (t1= tag1 )? constructedTag2 gn= generalNames )
            {
                int alt327=2;
                switch ( LA(1) )
                {
                case ConstructedTag0:
                	{
                		alt327=1;
                	}
                    break;
                case ConstructedTag2:
                case Tag1:
                	{
                		alt327=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 327;
                    EXCEPTION->state        = 0;


                    goto ruledpEx;

                }

                switch (alt327)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2863:16: constructedTag0 ( constructedTag0 fn= generalNames (t1= tag1 )? ( constructedTag2 gn= generalNames )? | constructedTag1 rdn (t1= tag1 )? ( constructedTag2 generalName )? )
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag0_in_dp6508);
            	        constructedTag01215=constructedTag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledpEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag01215.tree);

            	        {
            	            retval.text
            	            ->dp_name=malloc(sizeof(DP_NAME));
            	        }


            	        // Grammar/RFC5280.g:2863:73: ( constructedTag0 fn= generalNames (t1= tag1 )? ( constructedTag2 gn= generalNames )? | constructedTag1 rdn (t1= tag1 )? ( constructedTag2 generalName )? )
            	        {
            	            int alt325=2;
            	            switch ( LA(1) )
            	            {
            	            case ConstructedTag0:
            	            	{
            	            		alt325=1;
            	            	}
            	                break;
            	            case ConstructedTag1:
            	            	{
            	            		alt325=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 325;
            	                EXCEPTION->state        = 0;


            	                goto ruledpEx;

            	            }

            	            switch (alt325)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:2863:74: constructedTag0 fn= generalNames (t1= tag1 )? ( constructedTag2 gn= generalNames )?
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag0_in_dp6512);
            	        	        constructedTag01216=constructedTag0(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledpEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag01216.tree);

            	        	        FOLLOWPUSH(FOLLOW_generalNames_in_dp6516);
            	        	        fn=generalNames(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledpEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, fn.tree);

            	        	        {
            	        	            retval.text
            	        	            ->dp_name->full_name=fn.text
            	        	            ;
            	        	        }


            	        	        // Grammar/RFC5280.g:2864:3: (t1= tag1 )?
            	        	        {
            	        	            int alt321=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt321=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt321)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:2864:4: t1= tag1
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_tag1_in_dp6525);
            	        	        	        t1=tag1(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruledpEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, t1.tree);

            	        	        	        {
            	        	        	            retval.text
            	        	        	            ->reason_flags=new_asn1_string(3,t1.text
            	        	        	            ->length,t1.text
            	        	        	            ->value);
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:2864:88: ( constructedTag2 gn= generalNames )?
            	        	        {
            	        	            int alt322=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case ConstructedTag2:
            	        	                	{
            	        	                		alt322=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt322)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:2864:89: constructedTag2 gn= generalNames
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag2_in_dp6531);
            	        	        	        constructedTag21217=constructedTag2(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruledpEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag21217.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_generalNames_in_dp6535);
            	        	        	        gn=generalNames(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruledpEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, gn.tree);

            	        	        	        {
            	        	        	            retval.text
            	        	        	            ->crl_issuer = gn.text
            	        	        	            ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:2865:4: constructedTag1 rdn (t1= tag1 )? ( constructedTag2 generalName )?
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag1_in_dp6544);
            	        	        constructedTag11218=constructedTag1(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledpEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11218.tree);

            	        	        {
            	        	            dname=sk_X509_DNAME_ENTRY_new_null();
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_rdn_in_dp6547);
            	        	        rdn1219=rdn(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledpEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, rdn1219.tree);

            	        	        {
            	        	            retval.text
            	        	            ->dp_name->relative_to_crl_issuer=dname;
            	        	        }


            	        	        // Grammar/RFC5280.g:2866:3: (t1= tag1 )?
            	        	        {
            	        	            int alt323=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case Tag1:
            	        	                	{
            	        	                		alt323=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt323)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:2866:4: t1= tag1
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_tag1_in_dp6556);
            	        	        	        t1=tag1(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruledpEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, t1.tree);

            	        	        	        {
            	        	        	            retval.text
            	        	        	            ->reason_flags=new_asn1_string(3,t1.text
            	        	        	            ->length,t1.text
            	        	        	            ->value);
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:2867:3: ( constructedTag2 generalName )?
            	        	        {
            	        	            int alt324=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case ConstructedTag2:
            	        	                	{
            	        	                		alt324=1;
            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt324)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:2867:4: constructedTag2 generalName
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag2_in_dp6565);
            	        	        	        constructedTag21220=constructedTag2(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruledpEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag21220.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_generalName_in_dp6567);
            	        	        	        generalName1221=generalName(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruledpEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, generalName1221.tree);

            	        	        	        {
            	        	        	            STACK_OF(GENERAL_NAME_POINTER) *gn=sk_GENERAL_NAME_POINTER_new_null();sk_GENERAL_NAME_POINTER_push(gn,gen_name);retval.text
            	        	        	            ->crl_issuer = gn;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2868:4: (t1= tag1 )? constructedTag2 gn= generalNames
            	    {
            	        // Grammar/RFC5280.g:2868:4: (t1= tag1 )?
            	        {
            	            int alt326=2;
            	            switch ( LA(1) )
            	            {
            	                case Tag1:
            	                	{
            	                		alt326=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt326)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:2868:5: t1= tag1
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tag1_in_dp6581);
            	        	        t1=tag1(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruledpEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, t1.tree);

            	        	        {
            	        	            retval.text
            	        	            ->reason_flags=new_asn1_string(3,t1.text
            	        	            ->length,t1.text
            	        	            ->value);
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_constructedTag2_in_dp6587);
            	        constructedTag21222=constructedTag2(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledpEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag21222.tree);

            	        FOLLOWPUSH(FOLLOW_generalNames_in_dp6591);
            	        gn=generalNames(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledpEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, gn.tree);

            	        {
            	            retval.text
            	            ->crl_issuer = gn.text
            	            ;
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledpEx; /* Prevent compiler warnings */
    ruledpEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dp */

/**
 * $ANTLR start freshcrl
 * Grammar/RFC5280.g:2879:1: freshcrl : freshcrloid ( falsevalue )? constructedOctetString sequenceTag dps ;
 */
static RFC5280Parser_freshcrl_return
freshcrl(pRFC5280Parser ctx)
{
    RFC5280Parser_freshcrl_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_freshcrloid_return freshcrloid1223;
    #undef	RETURN_TYPE_freshcrloid1223
    #define	RETURN_TYPE_freshcrloid1223 RFC5280Parser_freshcrloid_return

    RFC5280Parser_falsevalue_return falsevalue1224;
    #undef	RETURN_TYPE_falsevalue1224
    #define	RETURN_TYPE_falsevalue1224 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1225;
    #undef	RETURN_TYPE_constructedOctetString1225
    #define	RETURN_TYPE_constructedOctetString1225 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1226;
    #undef	RETURN_TYPE_sequenceTag1226
    #define	RETURN_TYPE_sequenceTag1226 RFC5280Parser_sequenceTag_return

    RFC5280Parser_dps_return dps1227;
    #undef	RETURN_TYPE_dps1227
    #define	RETURN_TYPE_dps1227 RFC5280Parser_dps_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    freshcrloid1223.tree = NULL;

    falsevalue1224.tree = NULL;

    constructedOctetString1225.tree = NULL;

    sequenceTag1226.tree = NULL;

    dps1227.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2882:2: ( freshcrloid ( falsevalue )? constructedOctetString sequenceTag dps )
        // Grammar/RFC5280.g:2882:3: freshcrloid ( falsevalue )? constructedOctetString sequenceTag dps
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_freshcrloid_in_freshcrl6612);
            freshcrloid1223=freshcrloid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefreshcrlEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, freshcrloid1223.tree);

            // Grammar/RFC5280.g:2885:15: ( falsevalue )?
            {
                int alt328=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    	{
                    		alt328=1;
                    	}
                        break;
                }

                switch (alt328)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2885:15: falsevalue
            	    {
            	        FOLLOWPUSH(FOLLOW_falsevalue_in_freshcrl6614);
            	        falsevalue1224=falsevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefreshcrlEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1224.tree);

            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_freshcrl6617);
            constructedOctetString1225=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefreshcrlEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1225.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_freshcrl6619);
            sequenceTag1226=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefreshcrlEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1226.tree);

            FOLLOWPUSH(FOLLOW_dps_in_freshcrl6621);
            dps1227=dps(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefreshcrlEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, dps1227.tree);

            {
                x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
                	ext->oid=freshcrloid1223.obj
                ;
                	ext->critical=0;
                	ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->crl_dps=dps1227.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefreshcrlEx; /* Prevent compiler warnings */
    rulefreshcrlEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end freshcrl */

/**
 * $ANTLR start aia
 * Grammar/RFC5280.g:2893:1: aia : aiaoid ( falsevalue )? constructedOctetString sequenceTag ads ;
 */
static RFC5280Parser_aia_return
aia(pRFC5280Parser ctx)
{
    RFC5280Parser_aia_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_aiaoid_return aiaoid1228;
    #undef	RETURN_TYPE_aiaoid1228
    #define	RETURN_TYPE_aiaoid1228 RFC5280Parser_aiaoid_return

    RFC5280Parser_falsevalue_return falsevalue1229;
    #undef	RETURN_TYPE_falsevalue1229
    #define	RETURN_TYPE_falsevalue1229 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1230;
    #undef	RETURN_TYPE_constructedOctetString1230
    #define	RETURN_TYPE_constructedOctetString1230 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1231;
    #undef	RETURN_TYPE_sequenceTag1231
    #define	RETURN_TYPE_sequenceTag1231 RFC5280Parser_sequenceTag_return

    RFC5280Parser_ads_return ads1232;
    #undef	RETURN_TYPE_ads1232
    #define	RETURN_TYPE_ads1232 RFC5280Parser_ads_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    aiaoid1228.tree = NULL;

    falsevalue1229.tree = NULL;

    constructedOctetString1230.tree = NULL;

    sequenceTag1231.tree = NULL;

    ads1232.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2897:2: ( aiaoid ( falsevalue )? constructedOctetString sequenceTag ads )
        // Grammar/RFC5280.g:2897:3: aiaoid ( falsevalue )? constructedOctetString sequenceTag ads
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_aiaoid_in_aia6645);
            aiaoid1228=aiaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaiaEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, aiaoid1228.tree);

            // Grammar/RFC5280.g:2900:10: ( falsevalue )?
            {
                int alt329=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    	{
                    		alt329=1;
                    	}
                        break;
                }

                switch (alt329)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2900:10: falsevalue
            	    {
            	        FOLLOWPUSH(FOLLOW_falsevalue_in_aia6647);
            	        falsevalue1229=falsevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaiaEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1229.tree);

            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_aia6650);
            constructedOctetString1230=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaiaEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1230.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_aia6652);
            sequenceTag1231=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaiaEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1231.tree);

            FOLLOWPUSH(FOLLOW_ads_in_aia6654);
            ads1232=ads(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaiaEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, ads1232.tree);

            {

                	ext->oid=aiaoid1228.obj
                ;
                	ext->critical=0;
                	ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->access_descriptions=ads1232.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaiaEx; /* Prevent compiler warnings */
    ruleaiaEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end aia */

/**
 * $ANTLR start ads
 * Grammar/RFC5280.g:2908:1: ads returns [STACK_OF(ACCESS_DESCRIPTIONS) *text] : ( ad )+ ;
 */
static RFC5280Parser_ads_return
ads(pRFC5280Parser ctx)
{
    RFC5280Parser_ads_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_ad_return ad1233;
    #undef	RETURN_TYPE_ad1233
    #define	RETURN_TYPE_ad1233 RFC5280Parser_ad_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text= sk_ACCESS_DESCRIPTIONS_new_null();

    ad1233.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2911:2: ( ( ad )+ )
        // Grammar/RFC5280.g:2911:3: ( ad )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:2913:10: ( ad )+
            {
                int cnt330=0;

                for (;;)
                {
                    int alt330=2;
            	alt330 = cdfa330.predict(ctx, RECOGNIZER, ISTREAM, &cdfa330);
            	if  (HASEXCEPTION())
            	{
            	    goto ruleadsEx;
            	}

            	switch (alt330)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:2913:11: ad
            	        {
            	            FOLLOWPUSH(FOLLOW_ad_in_ads6677);
            	            ad1233=ad(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleadsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, ad1233.tree);

            	            {
            	                sk_ACCESS_DESCRIPTIONS_push(retval.text
            	                ,ad1233.text
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt330 >= 1 )
            		{
            		    goto loop330;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleadsEx;
            	}
            	cnt330++;
                }
                loop330: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleadsEx; /* Prevent compiler warnings */
    ruleadsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ads */

/**
 * $ANTLR start ad
 * Grammar/RFC5280.g:2915:1: ad returns [ACCESS_DESCRIPTIONS *text] : sequenceTag ( caissueroid generalName | ocspoid generalName | oid generalName ) ;
 */
static RFC5280Parser_ad_return
ad(pRFC5280Parser ctx)
{
    RFC5280Parser_ad_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1234;
    #undef	RETURN_TYPE_sequenceTag1234
    #define	RETURN_TYPE_sequenceTag1234 RFC5280Parser_sequenceTag_return

    RFC5280Parser_caissueroid_return caissueroid1235;
    #undef	RETURN_TYPE_caissueroid1235
    #define	RETURN_TYPE_caissueroid1235 RFC5280Parser_caissueroid_return

    RFC5280Parser_generalName_return generalName1236;
    #undef	RETURN_TYPE_generalName1236
    #define	RETURN_TYPE_generalName1236 RFC5280Parser_generalName_return

    RFC5280Parser_ocspoid_return ocspoid1237;
    #undef	RETURN_TYPE_ocspoid1237
    #define	RETURN_TYPE_ocspoid1237 RFC5280Parser_ocspoid_return

    RFC5280Parser_generalName_return generalName1238;
    #undef	RETURN_TYPE_generalName1238
    #define	RETURN_TYPE_generalName1238 RFC5280Parser_generalName_return

    RFC5280Parser_oid_return oid1239;
    #undef	RETURN_TYPE_oid1239
    #define	RETURN_TYPE_oid1239 RFC5280Parser_oid_return

    RFC5280Parser_generalName_return generalName1240;
    #undef	RETURN_TYPE_generalName1240
    #define	RETURN_TYPE_generalName1240 RFC5280Parser_generalName_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text= malloc(sizeof(ACCESS_DESCRIPTIONS));

    sequenceTag1234.tree = NULL;

    caissueroid1235.tree = NULL;

    generalName1236.tree = NULL;

    ocspoid1237.tree = NULL;

    generalName1238.tree = NULL;

    oid1239.tree = NULL;

    generalName1240.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2919:2: ( sequenceTag ( caissueroid generalName | ocspoid generalName | oid generalName ) )
        // Grammar/RFC5280.g:2919:3: sequenceTag ( caissueroid generalName | ocspoid generalName | oid generalName )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_ad6706);
            sequenceTag1234=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleadEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1234.tree);

            // Grammar/RFC5280.g:2922:15: ( caissueroid generalName | ocspoid generalName | oid generalName )
            {
                int alt331=3;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case CAISSUEROID:
                			{
                				alt331=1;
                			}
                		    break;
                		case OCSPOID:
                			{
                				alt331=2;
                			}
                		    break;
                		case PRINTABLE:
                		case VALUE:
                			{
                				alt331=3;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 331;
                		    EXCEPTION->state        = 1;


                		    goto ruleadEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 331;
                    EXCEPTION->state        = 0;


                    goto ruleadEx;

                }

                switch (alt331)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2922:16: caissueroid generalName
            	    {
            	        FOLLOWPUSH(FOLLOW_caissueroid_in_ad6709);
            	        caissueroid1235=caissueroid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, caissueroid1235.tree);

            	        FOLLOWPUSH(FOLLOW_generalName_in_ad6711);
            	        generalName1236=generalName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, generalName1236.tree);

            	        {
            	            retval.text
            	            ->access_method=caissueroid1235.obj
            	            ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2923:4: ocspoid generalName
            	    {
            	        FOLLOWPUSH(FOLLOW_ocspoid_in_ad6718);
            	        ocspoid1237=ocspoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, ocspoid1237.tree);

            	        FOLLOWPUSH(FOLLOW_generalName_in_ad6720);
            	        generalName1238=generalName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, generalName1238.tree);

            	        {
            	            retval.text
            	            ->access_method=ocspoid1237.obj
            	            ;
            	        }


            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:2923:62: oid generalName
            	    {
            	        FOLLOWPUSH(FOLLOW_oid_in_ad6725);
            	        oid1239=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, oid1239.tree);

            	        FOLLOWPUSH(FOLLOW_generalName_in_ad6727);
            	        generalName1240=generalName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, generalName1240.tree);

            	        {
            	            retval.text
            	            ->access_method=oid1239.text
            	            ->obj;
            	        }


            	    }
            	    break;

                }
            }

            {
                retval.text
                ->access_location=gen_name;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleadEx; /* Prevent compiler warnings */
    ruleadEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ad */

/**
 * $ANTLR start sia
 * Grammar/RFC5280.g:2926:1: sia : siaoid ( falsevalue )? constructedOctetString sequenceTag siaads ;
 */
static RFC5280Parser_sia_return
sia(pRFC5280Parser ctx)
{
    RFC5280Parser_sia_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_siaoid_return siaoid1241;
    #undef	RETURN_TYPE_siaoid1241
    #define	RETURN_TYPE_siaoid1241 RFC5280Parser_siaoid_return

    RFC5280Parser_falsevalue_return falsevalue1242;
    #undef	RETURN_TYPE_falsevalue1242
    #define	RETURN_TYPE_falsevalue1242 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1243;
    #undef	RETURN_TYPE_constructedOctetString1243
    #define	RETURN_TYPE_constructedOctetString1243 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1244;
    #undef	RETURN_TYPE_sequenceTag1244
    #define	RETURN_TYPE_sequenceTag1244 RFC5280Parser_sequenceTag_return

    RFC5280Parser_siaads_return siaads1245;
    #undef	RETURN_TYPE_siaads1245
    #define	RETURN_TYPE_siaads1245 RFC5280Parser_siaads_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    siaoid1241.tree = NULL;

    falsevalue1242.tree = NULL;

    constructedOctetString1243.tree = NULL;

    sequenceTag1244.tree = NULL;

    siaads1245.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2930:2: ( siaoid ( falsevalue )? constructedOctetString sequenceTag siaads )
        // Grammar/RFC5280.g:2930:3: siaoid ( falsevalue )? constructedOctetString sequenceTag siaads
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_siaoid_in_sia6756);
            siaoid1241=siaoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesiaEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, siaoid1241.tree);

            // Grammar/RFC5280.g:2933:10: ( falsevalue )?
            {
                int alt332=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    	{
                    		alt332=1;
                    	}
                        break;
                }

                switch (alt332)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2933:10: falsevalue
            	    {
            	        FOLLOWPUSH(FOLLOW_falsevalue_in_sia6758);
            	        falsevalue1242=falsevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesiaEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1242.tree);

            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_sia6761);
            constructedOctetString1243=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesiaEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1243.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_sia6763);
            sequenceTag1244=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesiaEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1244.tree);

            FOLLOWPUSH(FOLLOW_siaads_in_sia6765);
            siaads1245=siaads(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesiaEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, siaads1245.tree);

            {

                	ext->oid=siaoid1241.obj
                ;
                	ext->critical=0;
                	ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->access_descriptions=siaads1245.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesiaEx; /* Prevent compiler warnings */
    rulesiaEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sia */

/**
 * $ANTLR start siaads
 * Grammar/RFC5280.g:2941:1: siaads returns [STACK_OF(ACCESS_DESCRIPTIONS) *text] : ( adsia )+ ;
 */
static RFC5280Parser_siaads_return
siaads(pRFC5280Parser ctx)
{
    RFC5280Parser_siaads_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_adsia_return adsia1246;
    #undef	RETURN_TYPE_adsia1246
    #define	RETURN_TYPE_adsia1246 RFC5280Parser_adsia_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text= sk_ACCESS_DESCRIPTIONS_new_null();

    adsia1246.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2944:2: ( ( adsia )+ )
        // Grammar/RFC5280.g:2944:3: ( adsia )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:2946:10: ( adsia )+
            {
                int cnt333=0;

                for (;;)
                {
                    int alt333=2;
            	alt333 = cdfa333.predict(ctx, RECOGNIZER, ISTREAM, &cdfa333);
            	if  (HASEXCEPTION())
            	{
            	    goto rulesiaadsEx;
            	}

            	switch (alt333)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:2946:11: adsia
            	        {
            	            FOLLOWPUSH(FOLLOW_adsia_in_siaads6788);
            	            adsia1246=adsia(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesiaadsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, adsia1246.tree);

            	            {
            	                sk_ACCESS_DESCRIPTIONS_push(retval.text
            	                ,adsia1246.text
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt333 >= 1 )
            		{
            		    goto loop333;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulesiaadsEx;
            	}
            	cnt333++;
                }
                loop333: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesiaadsEx; /* Prevent compiler warnings */
    rulesiaadsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end siaads */

/**
 * $ANTLR start adsia
 * Grammar/RFC5280.g:2948:1: adsia returns [ACCESS_DESCRIPTIONS *text] : sequenceTag ( carepooid generalName | tspoid generalName | oid generalName ) ;
 */
static RFC5280Parser_adsia_return
adsia(pRFC5280Parser ctx)
{
    RFC5280Parser_adsia_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1247;
    #undef	RETURN_TYPE_sequenceTag1247
    #define	RETURN_TYPE_sequenceTag1247 RFC5280Parser_sequenceTag_return

    RFC5280Parser_carepooid_return carepooid1248;
    #undef	RETURN_TYPE_carepooid1248
    #define	RETURN_TYPE_carepooid1248 RFC5280Parser_carepooid_return

    RFC5280Parser_generalName_return generalName1249;
    #undef	RETURN_TYPE_generalName1249
    #define	RETURN_TYPE_generalName1249 RFC5280Parser_generalName_return

    RFC5280Parser_tspoid_return tspoid1250;
    #undef	RETURN_TYPE_tspoid1250
    #define	RETURN_TYPE_tspoid1250 RFC5280Parser_tspoid_return

    RFC5280Parser_generalName_return generalName1251;
    #undef	RETURN_TYPE_generalName1251
    #define	RETURN_TYPE_generalName1251 RFC5280Parser_generalName_return

    RFC5280Parser_oid_return oid1252;
    #undef	RETURN_TYPE_oid1252
    #define	RETURN_TYPE_oid1252 RFC5280Parser_oid_return

    RFC5280Parser_generalName_return generalName1253;
    #undef	RETURN_TYPE_generalName1253
    #define	RETURN_TYPE_generalName1253 RFC5280Parser_generalName_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text= malloc(sizeof(ACCESS_DESCRIPTIONS));

    sequenceTag1247.tree = NULL;

    carepooid1248.tree = NULL;

    generalName1249.tree = NULL;

    tspoid1250.tree = NULL;

    generalName1251.tree = NULL;

    oid1252.tree = NULL;

    generalName1253.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2952:2: ( sequenceTag ( carepooid generalName | tspoid generalName | oid generalName ) )
        // Grammar/RFC5280.g:2952:3: sequenceTag ( carepooid generalName | tspoid generalName | oid generalName )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_adsia6817);
            sequenceTag1247=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleadsiaEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1247.tree);

            // Grammar/RFC5280.g:2955:15: ( carepooid generalName | tspoid generalName | oid generalName )
            {
                int alt334=3;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case CAREPOOID:
                			{
                				alt334=1;
                			}
                		    break;
                		case TSPOID:
                			{
                				alt334=2;
                			}
                		    break;
                		case PRINTABLE:
                		case VALUE:
                			{
                				alt334=3;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 334;
                		    EXCEPTION->state        = 1;


                		    goto ruleadsiaEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 334;
                    EXCEPTION->state        = 0;


                    goto ruleadsiaEx;

                }

                switch (alt334)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2955:16: carepooid generalName
            	    {
            	        FOLLOWPUSH(FOLLOW_carepooid_in_adsia6820);
            	        carepooid1248=carepooid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadsiaEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, carepooid1248.tree);

            	        FOLLOWPUSH(FOLLOW_generalName_in_adsia6822);
            	        generalName1249=generalName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadsiaEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, generalName1249.tree);

            	        {
            	            retval.text
            	            ->access_method=carepooid1248.obj
            	            ;ca_repo=1;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2956:4: tspoid generalName
            	    {
            	        FOLLOWPUSH(FOLLOW_tspoid_in_adsia6829);
            	        tspoid1250=tspoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadsiaEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tspoid1250.tree);

            	        FOLLOWPUSH(FOLLOW_generalName_in_adsia6831);
            	        generalName1251=generalName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadsiaEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, generalName1251.tree);

            	        {
            	            retval.text
            	            ->access_method=tspoid1250.obj
            	            ;tsp=1;
            	        }


            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:2956:66: oid generalName
            	    {
            	        FOLLOWPUSH(FOLLOW_oid_in_adsia6836);
            	        oid1252=oid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadsiaEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, oid1252.tree);

            	        FOLLOWPUSH(FOLLOW_generalName_in_adsia6838);
            	        generalName1253=generalName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadsiaEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, generalName1253.tree);

            	        {
            	            retval.text
            	            ->access_method=oid1252.text
            	            ->obj;
            	        }


            	    }
            	    break;

                }
            }

            {
                retval.text
                ->access_location=gen_name;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleadsiaEx; /* Prevent compiler warnings */
    ruleadsiaEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end adsia */

/**
 * $ANTLR start dependentExtension
 * Grammar/RFC5280.g:2959:1: dependentExtension : sequenceTag ( policyMappings | nameConstraints | policyConstraints | inhibitAnyPolicy ) ;
 */
static RFC5280Parser_dependentExtension_return
dependentExtension(pRFC5280Parser ctx)
{
    RFC5280Parser_dependentExtension_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1254;
    #undef	RETURN_TYPE_sequenceTag1254
    #define	RETURN_TYPE_sequenceTag1254 RFC5280Parser_sequenceTag_return

    RFC5280Parser_policyMappings_return policyMappings1255;
    #undef	RETURN_TYPE_policyMappings1255
    #define	RETURN_TYPE_policyMappings1255 RFC5280Parser_policyMappings_return

    RFC5280Parser_nameConstraints_return nameConstraints1256;
    #undef	RETURN_TYPE_nameConstraints1256
    #define	RETURN_TYPE_nameConstraints1256 RFC5280Parser_nameConstraints_return

    RFC5280Parser_policyConstraints_return policyConstraints1257;
    #undef	RETURN_TYPE_policyConstraints1257
    #define	RETURN_TYPE_policyConstraints1257 RFC5280Parser_policyConstraints_return

    RFC5280Parser_inhibitAnyPolicy_return inhibitAnyPolicy1258;
    #undef	RETURN_TYPE_inhibitAnyPolicy1258
    #define	RETURN_TYPE_inhibitAnyPolicy1258 RFC5280Parser_inhibitAnyPolicy_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1254.tree = NULL;

    policyMappings1255.tree = NULL;

    nameConstraints1256.tree = NULL;

    policyConstraints1257.tree = NULL;

    inhibitAnyPolicy1258.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2963:2: ( sequenceTag ( policyMappings | nameConstraints | policyConstraints | inhibitAnyPolicy ) )
        // Grammar/RFC5280.g:2963:3: sequenceTag ( policyMappings | nameConstraints | policyConstraints | inhibitAnyPolicy )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                printf("dependent parsed \n");
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_dependentExtension6868);
            sequenceTag1254=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledependentExtensionEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1254.tree);

            // Grammar/RFC5280.g:2966:48: ( policyMappings | nameConstraints | policyConstraints | inhibitAnyPolicy )
            {
                int alt335=4;
                switch ( LA(1) )
                {
                case OIDTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDPOLMAP:
                			{
                				alt335=1;
                			}
                		    break;
                		case OIDNAME:
                			{
                				alt335=2;
                			}
                		    break;
                		case OIDPOLCONST:
                			{
                				alt335=3;
                			}
                		    break;
                		case OIDINHIBIT:
                			{
                				alt335=4;
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 335;
                		    EXCEPTION->state        = 1;


                		    goto ruledependentExtensionEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 335;
                    EXCEPTION->state        = 0;


                    goto ruledependentExtensionEx;

                }

                switch (alt335)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2966:49: policyMappings
            	    {
            	        FOLLOWPUSH(FOLLOW_policyMappings_in_dependentExtension6871);
            	        policyMappings1255=policyMappings(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledependentExtensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, policyMappings1255.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2966:66: nameConstraints
            	    {
            	        FOLLOWPUSH(FOLLOW_nameConstraints_in_dependentExtension6875);
            	        nameConstraints1256=nameConstraints(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledependentExtensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, nameConstraints1256.tree);

            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:2966:84: policyConstraints
            	    {
            	        FOLLOWPUSH(FOLLOW_policyConstraints_in_dependentExtension6879);
            	        policyConstraints1257=policyConstraints(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledependentExtensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, policyConstraints1257.tree);

            	    }
            	    break;
            	case 4:
            	    // Grammar/RFC5280.g:2966:104: inhibitAnyPolicy
            	    {
            	        FOLLOWPUSH(FOLLOW_inhibitAnyPolicy_in_dependentExtension6883);
            	        inhibitAnyPolicy1258=inhibitAnyPolicy(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruledependentExtensionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, inhibitAnyPolicy1258.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledependentExtensionEx; /* Prevent compiler warnings */
    ruledependentExtensionEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dependentExtension */

/**
 * $ANTLR start inhibitAnyPolicy
 * Grammar/RFC5280.g:2968:1: inhibitAnyPolicy : inhibitanyoid truevalue constructedOctetString integer ;
 */
static RFC5280Parser_inhibitAnyPolicy_return
inhibitAnyPolicy(pRFC5280Parser ctx)
{
    RFC5280Parser_inhibitAnyPolicy_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_inhibitanyoid_return inhibitanyoid1259;
    #undef	RETURN_TYPE_inhibitanyoid1259
    #define	RETURN_TYPE_inhibitanyoid1259 RFC5280Parser_inhibitanyoid_return

    RFC5280Parser_truevalue_return truevalue1260;
    #undef	RETURN_TYPE_truevalue1260
    #define	RETURN_TYPE_truevalue1260 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1261;
    #undef	RETURN_TYPE_constructedOctetString1261
    #define	RETURN_TYPE_constructedOctetString1261 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_integer_return integer1262;
    #undef	RETURN_TYPE_integer1262
    #define	RETURN_TYPE_integer1262 RFC5280Parser_integer_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    inhibitanyoid1259.tree = NULL;

    truevalue1260.tree = NULL;

    constructedOctetString1261.tree = NULL;

    integer1262.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2972:2: ( inhibitanyoid truevalue constructedOctetString integer )
        // Grammar/RFC5280.g:2972:3: inhibitanyoid truevalue constructedOctetString integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_inhibitanyoid_in_inhibitAnyPolicy6901);
            inhibitanyoid1259=inhibitanyoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinhibitAnyPolicyEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, inhibitanyoid1259.tree);

            FOLLOWPUSH(FOLLOW_truevalue_in_inhibitAnyPolicy6903);
            truevalue1260=truevalue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinhibitAnyPolicyEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, truevalue1260.tree);

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_inhibitAnyPolicy6905);
            constructedOctetString1261=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinhibitAnyPolicyEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1261.tree);

            FOLLOWPUSH(FOLLOW_integer_in_inhibitAnyPolicy6907);
            integer1262=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinhibitAnyPolicyEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, integer1262.tree);

            {
                x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
                	ext->oid=inhibitanyoid1259.obj
                ;
                	ext->critical=1;
                	ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->inhibit_any_policy=integer1262.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinhibitAnyPolicyEx; /* Prevent compiler warnings */
    ruleinhibitAnyPolicyEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end inhibitAnyPolicy */

/**
 * $ANTLR start policyConstraints
 * Grammar/RFC5280.g:2983:1: policyConstraints : polconstraintsoid truevalue constructedOctetString sequenceTag ( tag0 (t1= tag1 )? |t1= tag1 ) ;
 */
static RFC5280Parser_policyConstraints_return
policyConstraints(pRFC5280Parser ctx)
{
    RFC5280Parser_policyConstraints_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_tag1_return t1;
    #undef	RETURN_TYPE_t1
    #define	RETURN_TYPE_t1 RFC5280Parser_tag1_return

    RFC5280Parser_polconstraintsoid_return polconstraintsoid1263;
    #undef	RETURN_TYPE_polconstraintsoid1263
    #define	RETURN_TYPE_polconstraintsoid1263 RFC5280Parser_polconstraintsoid_return

    RFC5280Parser_truevalue_return truevalue1264;
    #undef	RETURN_TYPE_truevalue1264
    #define	RETURN_TYPE_truevalue1264 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1265;
    #undef	RETURN_TYPE_constructedOctetString1265
    #define	RETURN_TYPE_constructedOctetString1265 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1266;
    #undef	RETURN_TYPE_sequenceTag1266
    #define	RETURN_TYPE_sequenceTag1266 RFC5280Parser_sequenceTag_return

    RFC5280Parser_tag0_return tag01267;
    #undef	RETURN_TYPE_tag01267
    #define	RETURN_TYPE_tag01267 RFC5280Parser_tag0_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    t1.tree = NULL;

    polconstraintsoid1263.tree = NULL;

    truevalue1264.tree = NULL;

    constructedOctetString1265.tree = NULL;

    sequenceTag1266.tree = NULL;

    tag01267.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:2987:2: ( polconstraintsoid truevalue constructedOctetString sequenceTag ( tag0 (t1= tag1 )? |t1= tag1 ) )
        // Grammar/RFC5280.g:2987:3: polconstraintsoid truevalue constructedOctetString sequenceTag ( tag0 (t1= tag1 )? |t1= tag1 )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_polconstraintsoid_in_policyConstraints6929);
            polconstraintsoid1263=polconstraintsoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepolicyConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, polconstraintsoid1263.tree);

            FOLLOWPUSH(FOLLOW_truevalue_in_policyConstraints6931);
            truevalue1264=truevalue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepolicyConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, truevalue1264.tree);

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_policyConstraints6933);
            constructedOctetString1265=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepolicyConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1265.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_policyConstraints6935);
            sequenceTag1266=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepolicyConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1266.tree);

            {
                ext->oid=polconstraintsoid1263.obj
                ;ext->critical=1;
                	ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->policy_constraints=malloc(sizeof(POLICY_CONSTRAINTS));
                	ext->value->policy_constraints->requireExplicitPolicy=NULL;
                	ext->value->policy_constraints->inhibitPolicyMapping=NULL;
                	//fprintf(stdout,"%x \n",ext->value->policy_constraints);
                	
            }


            // Grammar/RFC5280.g:2996:3: ( tag0 (t1= tag1 )? |t1= tag1 )
            {
                int alt337=2;
                switch ( LA(1) )
                {
                case Tag0:
                case TagInt1:
                case TagInt10:
                case TagInt11:
                case TagInt12:
                case TagInt13:
                case TagInt14:
                case TagInt15:
                case TagInt16:
                case TagInt17:
                case TagInt18:
                case TagInt19:
                case TagInt2:
                case TagInt20:
                case TagInt21:
                case TagInt22:
                case TagInt23:
                case TagInt3:
                case TagInt4:
                case TagInt5:
                case TagInt6:
                case TagInt7:
                case TagInt8:
                case TagInt9:
                	{
                		alt337=1;
                	}
                    break;
                case Tag1:
                	{
                		alt337=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 337;
                    EXCEPTION->state        = 0;


                    goto rulepolicyConstraintsEx;

                }

                switch (alt337)
                {
            	case 1:
            	    // Grammar/RFC5280.g:2996:4: tag0 (t1= tag1 )?
            	    {
            	        FOLLOWPUSH(FOLLOW_tag0_in_policyConstraints6939);
            	        tag01267=tag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepolicyConstraintsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag01267.tree);

            	        {
            	            ext->value->policy_constraints->requireExplicitPolicy=new_asn1_string(2,tag01267.text
            	            ->length,tag01267.text
            	            ->value);
            	        }


            	        // Grammar/RFC5280.g:2996:121: (t1= tag1 )?
            	        {
            	            int alt336=2;
            	            switch ( LA(1) )
            	            {
            	                case Tag1:
            	                	{
            	                		alt336=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt336)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:2996:122: t1= tag1
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tag1_in_policyConstraints6945);
            	        	        t1=tag1(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulepolicyConstraintsEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, t1.tree);

            	        	        {

            	        	            	ext->value->policy_constraints->inhibitPolicyMapping=new_asn1_string(2,t1.text
            	        	            ->length,t1.text
            	        	            ->value);
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:2998:8: t1= tag1
            	    {
            	        FOLLOWPUSH(FOLLOW_tag1_in_policyConstraints6954);
            	        t1=tag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepolicyConstraintsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, t1.tree);

            	        {
            	            ext->value->policy_constraints->inhibitPolicyMapping=new_asn1_string(2,t1.text
            	            ->length,t1.text
            	            ->value);
            	        }


            	    }
            	    break;

                }
            }

            {
                sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepolicyConstraintsEx; /* Prevent compiler warnings */
    rulepolicyConstraintsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end policyConstraints */

/**
 * $ANTLR start nameConstraints
 * Grammar/RFC5280.g:3002:1: nameConstraints : nameoid truevalue constructedOctetString sequenceTag ( constructedTag0 tree0= generalSubtrees ( constructedTag1 tree1= generalSubtrees )? | constructedTag1 tree1= generalSubtrees ) ;
 */
static RFC5280Parser_nameConstraints_return
nameConstraints(pRFC5280Parser ctx)
{
    RFC5280Parser_nameConstraints_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_generalSubtrees_return tree0;
    #undef	RETURN_TYPE_tree0
    #define	RETURN_TYPE_tree0 RFC5280Parser_generalSubtrees_return

    RFC5280Parser_generalSubtrees_return tree1;
    #undef	RETURN_TYPE_tree1
    #define	RETURN_TYPE_tree1 RFC5280Parser_generalSubtrees_return

    RFC5280Parser_nameoid_return nameoid1268;
    #undef	RETURN_TYPE_nameoid1268
    #define	RETURN_TYPE_nameoid1268 RFC5280Parser_nameoid_return

    RFC5280Parser_truevalue_return truevalue1269;
    #undef	RETURN_TYPE_truevalue1269
    #define	RETURN_TYPE_truevalue1269 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1270;
    #undef	RETURN_TYPE_constructedOctetString1270
    #define	RETURN_TYPE_constructedOctetString1270 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1271;
    #undef	RETURN_TYPE_sequenceTag1271
    #define	RETURN_TYPE_sequenceTag1271 RFC5280Parser_sequenceTag_return

    RFC5280Parser_constructedTag0_return constructedTag01272;
    #undef	RETURN_TYPE_constructedTag01272
    #define	RETURN_TYPE_constructedTag01272 RFC5280Parser_constructedTag0_return

    RFC5280Parser_constructedTag1_return constructedTag11273;
    #undef	RETURN_TYPE_constructedTag11273
    #define	RETURN_TYPE_constructedTag11273 RFC5280Parser_constructedTag1_return

    RFC5280Parser_constructedTag1_return constructedTag11274;
    #undef	RETURN_TYPE_constructedTag11274
    #define	RETURN_TYPE_constructedTag11274 RFC5280Parser_constructedTag1_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    tree0.tree = NULL;

    tree1.tree = NULL;

    nameoid1268.tree = NULL;

    truevalue1269.tree = NULL;

    constructedOctetString1270.tree = NULL;

    sequenceTag1271.tree = NULL;

    constructedTag01272.tree = NULL;

    constructedTag11273.tree = NULL;

    constructedTag11274.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3006:2: ( nameoid truevalue constructedOctetString sequenceTag ( constructedTag0 tree0= generalSubtrees ( constructedTag1 tree1= generalSubtrees )? | constructedTag1 tree1= generalSubtrees ) )
        // Grammar/RFC5280.g:3006:3: nameoid truevalue constructedOctetString sequenceTag ( constructedTag0 tree0= generalSubtrees ( constructedTag1 tree1= generalSubtrees )? | constructedTag1 tree1= generalSubtrees )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_nameoid_in_nameConstraints6983);
            nameoid1268=nameoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenameConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, nameoid1268.tree);

            FOLLOWPUSH(FOLLOW_truevalue_in_nameConstraints6985);
            truevalue1269=truevalue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenameConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, truevalue1269.tree);

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_nameConstraints6987);
            constructedOctetString1270=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenameConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1270.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_nameConstraints6989);
            sequenceTag1271=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenameConstraintsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1271.tree);

            {

                	ext->oid=nameoid1268.obj
                ;ext->critical=1;ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->name_constraints=malloc(sizeof(NAME_CONSTRAINT ));
                	
            }


            // Grammar/RFC5280.g:3012:4: ( constructedTag0 tree0= generalSubtrees ( constructedTag1 tree1= generalSubtrees )? | constructedTag1 tree1= generalSubtrees )
            {
                int alt339=2;
                switch ( LA(1) )
                {
                case ConstructedTag0:
                	{
                		alt339=1;
                	}
                    break;
                case ConstructedTag1:
                	{
                		alt339=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 339;
                    EXCEPTION->state        = 0;


                    goto rulenameConstraintsEx;

                }

                switch (alt339)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3012:5: constructedTag0 tree0= generalSubtrees ( constructedTag1 tree1= generalSubtrees )?
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag0_in_nameConstraints6994);
            	        constructedTag01272=constructedTag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenameConstraintsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag01272.tree);

            	        FOLLOWPUSH(FOLLOW_generalSubtrees_in_nameConstraints6998);
            	        tree0=generalSubtrees(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenameConstraintsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tree0.tree);

            	        {
            	            ext->value->name_constraints->permitted_subtrees=tree0.text
            	            ;
            	            	ext->value->name_constraints->excluded_subtrees=NULL;
            	            	
            	        }


            	        // Grammar/RFC5280.g:3014:3: ( constructedTag1 tree1= generalSubtrees )?
            	        {
            	            int alt338=2;
            	            switch ( LA(1) )
            	            {
            	                case ConstructedTag1:
            	                	{
            	                		alt338=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt338)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3014:4: constructedTag1 tree1= generalSubtrees
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag1_in_nameConstraints7002);
            	        	        constructedTag11273=constructedTag1(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulenameConstraintsEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11273.tree);

            	        	        FOLLOWPUSH(FOLLOW_generalSubtrees_in_nameConstraints7006);
            	        	        tree1=generalSubtrees(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulenameConstraintsEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tree1.tree);

            	        	        {

            	        	            	ext->value->name_constraints->excluded_subtrees=tree1.text
            	        	            ;
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3016:8: constructedTag1 tree1= generalSubtrees
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_nameConstraints7014);
            	        constructedTag11274=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenameConstraintsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11274.tree);

            	        FOLLOWPUSH(FOLLOW_generalSubtrees_in_nameConstraints7018);
            	        tree1=generalSubtrees(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulenameConstraintsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tree1.tree);

            	        {
            	            ext->value->name_constraints->permitted_subtrees=NULL;
            	            	ext->value->name_constraints->excluded_subtrees=tree1.text
            	            ;
            	            	
            	        }


            	    }
            	    break;

                }
            }

            {
                sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenameConstraintsEx; /* Prevent compiler warnings */
    rulenameConstraintsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end nameConstraints */

/**
 * $ANTLR start generalSubtrees
 * Grammar/RFC5280.g:3020:1: generalSubtrees returns [STACK_OF(GENERAL_SUBTREES) *text] : ( subtree )+ ;
 */
static RFC5280Parser_generalSubtrees_return
generalSubtrees(pRFC5280Parser ctx)
{
    RFC5280Parser_generalSubtrees_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_subtree_return subtree1275;
    #undef	RETURN_TYPE_subtree1275
    #define	RETURN_TYPE_subtree1275 RFC5280Parser_subtree_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text=sk_GENERAL_SUBTREES_new_null();

    subtree1275.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3024:2: ( ( subtree )+ )
        // Grammar/RFC5280.g:3024:3: ( subtree )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:3027:3: ( subtree )+
            {
                int cnt340=0;

                for (;;)
                {
                    int alt340=2;
            	switch ( LA(1) )
            	{
            	case SequenceTag:
            		{
            			switch ( LA(2) )
            			{
            			case ConstructedTag0:
            			case ConstructedTag3:
            			case ConstructedTag4:
            			case ConstructedTag5:
            			case Tag1:
            			case Tag2:
            			case Tag6:
            			case Tag7:
            			case Tag8:
            				{
            					alt340=1;
            				}
            			    break;

            			}

            		}
            	    break;

            	}

            	switch (alt340)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:3027:4: subtree
            	        {
            	            FOLLOWPUSH(FOLLOW_subtree_in_generalSubtrees7048);
            	            subtree1275=subtree(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulegeneralSubtreesEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, subtree1275.tree);

            	            {
            	                sk_GENERAL_SUBTREES_push(retval.text
            	                ,subtree1275.text
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt340 >= 1 )
            		{
            		    goto loop340;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulegeneralSubtreesEx;
            	}
            	cnt340++;
                }
                loop340: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulegeneralSubtreesEx; /* Prevent compiler warnings */
    rulegeneralSubtreesEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end generalSubtrees */

/**
 * $ANTLR start subtree
 * Grammar/RFC5280.g:3029:1: subtree returns [GENERAL_SUBTREES *text] : sequenceTag generalName ( tag0 )? ( tag1 )? ;
 */
static RFC5280Parser_subtree_return
subtree(pRFC5280Parser ctx)
{
    RFC5280Parser_subtree_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1276;
    #undef	RETURN_TYPE_sequenceTag1276
    #define	RETURN_TYPE_sequenceTag1276 RFC5280Parser_sequenceTag_return

    RFC5280Parser_generalName_return generalName1277;
    #undef	RETURN_TYPE_generalName1277
    #define	RETURN_TYPE_generalName1277 RFC5280Parser_generalName_return

    RFC5280Parser_tag0_return tag01278;
    #undef	RETURN_TYPE_tag01278
    #define	RETURN_TYPE_tag01278 RFC5280Parser_tag0_return

    RFC5280Parser_tag1_return tag11279;
    #undef	RETURN_TYPE_tag11279
    #define	RETURN_TYPE_tag11279 RFC5280Parser_tag1_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1276.tree = NULL;

    generalName1277.tree = NULL;

    tag01278.tree = NULL;

    tag11279.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3033:2: ( sequenceTag generalName ( tag0 )? ( tag1 )? )
        // Grammar/RFC5280.g:3033:3: sequenceTag generalName ( tag0 )? ( tag1 )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_subtree7073);
            sequenceTag1276=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubtreeEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1276.tree);

            FOLLOWPUSH(FOLLOW_generalName_in_subtree7075);
            generalName1277=generalName(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesubtreeEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, generalName1277.tree);

            {
                retval.text=malloc(sizeof(GENERAL_SUBTREES));

                	retval.text
                ->gen_name=gen_name;
                	retval.text
                ->min_base_distance=new_asn1_string(2,1,min_base_distance);
                	retval.text
                ->max_base_distance=NULL;
                	
            }


            // Grammar/RFC5280.g:3040:3: ( tag0 )?
            {
                int alt341=2;
                switch ( LA(1) )
                {
                    case Tag0:
                    case TagInt1:
                    case TagInt10:
                    case TagInt11:
                    case TagInt12:
                    case TagInt13:
                    case TagInt14:
                    case TagInt15:
                    case TagInt16:
                    case TagInt17:
                    case TagInt18:
                    case TagInt19:
                    case TagInt2:
                    case TagInt20:
                    case TagInt21:
                    case TagInt22:
                    case TagInt23:
                    case TagInt3:
                    case TagInt4:
                    case TagInt5:
                    case TagInt6:
                    case TagInt7:
                    case TagInt8:
                    case TagInt9:
                    	{
                    		alt341=1;
                    	}
                        break;
                }

                switch (alt341)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3040:4: tag0
            	    {
            	        FOLLOWPUSH(FOLLOW_tag0_in_subtree7079);
            	        tag01278=tag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubtreeEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag01278.tree);

            	        {
            	            retval.text
            	            ->min_base_distance=new_asn1_string(2,tag01278.text
            	            ->length,tag01278.text
            	            ->value);
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3040:94: ( tag1 )?
            {
                int alt342=2;
                switch ( LA(1) )
                {
                    case Tag1:
                    	{
                    		alt342=1;
                    	}
                        break;
                }

                switch (alt342)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3040:95: tag1
            	    {
            	        FOLLOWPUSH(FOLLOW_tag1_in_subtree7085);
            	        tag11279=tag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesubtreeEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag11279.tree);

            	        {
            	            retval.text
            	            ->max_base_distance=new_asn1_string(2,tag11279.text
            	            ->length,tag11279.text
            	            ->value);
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubtreeEx; /* Prevent compiler warnings */
    rulesubtreeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subtree */

/**
 * $ANTLR start policyMappings
 * Grammar/RFC5280.g:3042:1: policyMappings : polmapoid ( critical )? constructedOctetString sequenceTag mappings ;
 */
static RFC5280Parser_policyMappings_return
policyMappings(pRFC5280Parser ctx)
{
    RFC5280Parser_policyMappings_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_polmapoid_return polmapoid1280;
    #undef	RETURN_TYPE_polmapoid1280
    #define	RETURN_TYPE_polmapoid1280 RFC5280Parser_polmapoid_return

    RFC5280Parser_critical_return critical1281;
    #undef	RETURN_TYPE_critical1281
    #define	RETURN_TYPE_critical1281 RFC5280Parser_critical_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1282;
    #undef	RETURN_TYPE_constructedOctetString1282
    #define	RETURN_TYPE_constructedOctetString1282 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1283;
    #undef	RETURN_TYPE_sequenceTag1283
    #define	RETURN_TYPE_sequenceTag1283 RFC5280Parser_sequenceTag_return

    RFC5280Parser_mappings_return mappings1284;
    #undef	RETURN_TYPE_mappings1284
    #define	RETURN_TYPE_mappings1284 RFC5280Parser_mappings_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    x509_EXTENSION *ext = malloc(sizeof(x509_EXTENSION));
    polmapoid1280.tree = NULL;

    critical1281.tree = NULL;

    constructedOctetString1282.tree = NULL;

    sequenceTag1283.tree = NULL;

    mappings1284.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3046:2: ( polmapoid ( critical )? constructedOctetString sequenceTag mappings )
        // Grammar/RFC5280.g:3046:3: polmapoid ( critical )? constructedOctetString sequenceTag mappings
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_polmapoid_in_policyMappings7110);
            polmapoid1280=polmapoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepolicyMappingsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, polmapoid1280.tree);

            {
                ext->oid=polmapoid1280.obj
                ;ext->critical=0;
            }


            // Grammar/RFC5280.g:3049:55: ( critical )?
            {
                int alt343=2;
                switch ( LA(1) )
                {
                    case FalseTag:
                    case TrueTag:
                    	{
                    		alt343=1;
                    	}
                        break;
                }

                switch (alt343)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3049:56: critical
            	    {
            	        FOLLOWPUSH(FOLLOW_critical_in_policyMappings7115);
            	        critical1281=critical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepolicyMappingsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, critical1281.tree);

            	        {
            	            ext->critical=critical1281.bool
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_constructedOctetString_in_policyMappings7123);
            constructedOctetString1282=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepolicyMappingsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1282.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_policyMappings7125);
            sequenceTag1283=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepolicyMappingsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1283.tree);

            FOLLOWPUSH(FOLLOW_mappings_in_policyMappings7127);
            mappings1284=mappings(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepolicyMappingsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, mappings1284.tree);

            {
                ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	ext->value->mappings = mappings1284.text
                ;
                	sk_x509_EXTENSION_push(cert->extensions,ext);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepolicyMappingsEx; /* Prevent compiler warnings */
    rulepolicyMappingsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end policyMappings */

/**
 * $ANTLR start mappings
 * Grammar/RFC5280.g:3054:1: mappings returns [POLICY_MAPPINGS *text] : ( sequenceTag iss= oid subj= oid )+ ;
 */
static RFC5280Parser_mappings_return
mappings(pRFC5280Parser ctx)
{
    RFC5280Parser_mappings_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_oid_return iss;
    #undef	RETURN_TYPE_iss
    #define	RETURN_TYPE_iss RFC5280Parser_oid_return

    RFC5280Parser_oid_return subj;
    #undef	RETURN_TYPE_subj
    #define	RETURN_TYPE_subj RFC5280Parser_oid_return

    RFC5280Parser_sequenceTag_return sequenceTag1285;
    #undef	RETURN_TYPE_sequenceTag1285
    #define	RETURN_TYPE_sequenceTag1285 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text=sk_x509_EXTENSION_new_null();

    iss.tree = NULL;

    subj.tree = NULL;

    sequenceTag1285.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3058:2: ( ( sequenceTag iss= oid subj= oid )+ )
        // Grammar/RFC5280.g:3058:3: ( sequenceTag iss= oid subj= oid )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:3061:3: ( sequenceTag iss= oid subj= oid )+
            {
                int cnt344=0;

                for (;;)
                {
                    int alt344=2;
            	alt344 = cdfa344.predict(ctx, RECOGNIZER, ISTREAM, &cdfa344);
            	if  (HASEXCEPTION())
            	{
            	    goto rulemappingsEx;
            	}

            	switch (alt344)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:3061:4: sequenceTag iss= oid subj= oid
            	        {
            	            FOLLOWPUSH(FOLLOW_sequenceTag_in_mappings7155);
            	            sequenceTag1285=sequenceTag(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemappingsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1285.tree);

            	            FOLLOWPUSH(FOLLOW_oid_in_mappings7159);
            	            iss=oid(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemappingsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, iss.tree);

            	            FOLLOWPUSH(FOLLOW_oid_in_mappings7163);
            	            subj=oid(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemappingsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, subj.tree);

            	            {
            	                POLICY_MAPPING *map=malloc(sizeof(POLICY_MAPPING));
            	                	map->issuerDomainPolicy=iss.text
            	                ->obj;
            	                	map->subjectDomainPolicy=subj.text
            	                ->obj;
            	                	sk_POLICY_MAPPING_push(retval.text
            	                ,map);
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt344 >= 1 )
            		{
            		    goto loop344;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulemappingsEx;
            	}
            	cnt344++;
                }
                loop344: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulemappingsEx; /* Prevent compiler warnings */
    rulemappingsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end mappings */

/**
 * $ANTLR start basicConstraintsCA
 * Grammar/RFC5280.g:3066:1: basicConstraintsCA : sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSki ) ;
 */
static RFC5280Parser_basicConstraintsCA_return
basicConstraintsCA(pRFC5280Parser ctx)
{
    RFC5280Parser_basicConstraintsCA_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1286;
    #undef	RETURN_TYPE_sequenceTag1286
    #define	RETURN_TYPE_sequenceTag1286 RFC5280Parser_sequenceTag_return

    RFC5280Parser_bcoid_return bcoid1287;
    #undef	RETURN_TYPE_bcoid1287
    #define	RETURN_TYPE_bcoid1287 RFC5280Parser_bcoid_return

    RFC5280Parser_truevalue_return truevalue1288;
    #undef	RETURN_TYPE_truevalue1288
    #define	RETURN_TYPE_truevalue1288 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1289;
    #undef	RETURN_TYPE_constructedOctetString1289
    #define	RETURN_TYPE_constructedOctetString1289 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1290;
    #undef	RETURN_TYPE_sequenceTag1290
    #define	RETURN_TYPE_sequenceTag1290 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1291;
    #undef	RETURN_TYPE_truevalue1291
    #define	RETURN_TYPE_truevalue1291 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBC_return extensionsNotBC1292;
    #undef	RETURN_TYPE_extensionsNotBC1292
    #define	RETURN_TYPE_extensionsNotBC1292 RFC5280Parser_extensionsNotBC_return

    RFC5280Parser_integer_return integer1293;
    #undef	RETURN_TYPE_integer1293
    #define	RETURN_TYPE_integer1293 RFC5280Parser_integer_return

    RFC5280Parser_extensionsCertSignAndSki_return extensionsCertSignAndSki1294;
    #undef	RETURN_TYPE_extensionsCertSignAndSki1294
    #define	RETURN_TYPE_extensionsCertSignAndSki1294 RFC5280Parser_extensionsCertSignAndSki_return

    RFC5280Parser_falsevalue_return falsevalue1295;
    #undef	RETURN_TYPE_falsevalue1295
    #define	RETURN_TYPE_falsevalue1295 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1296;
    #undef	RETURN_TYPE_constructedOctetString1296
    #define	RETURN_TYPE_constructedOctetString1296 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1297;
    #undef	RETURN_TYPE_sequenceTag1297
    #define	RETURN_TYPE_sequenceTag1297 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1298;
    #undef	RETURN_TYPE_truevalue1298
    #define	RETURN_TYPE_truevalue1298 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotCertSignAndSki_return extensionsNotCertSignAndSki1299;
    #undef	RETURN_TYPE_extensionsNotCertSignAndSki1299
    #define	RETURN_TYPE_extensionsNotCertSignAndSki1299 RFC5280Parser_extensionsNotCertSignAndSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1286.tree = NULL;

    bcoid1287.tree = NULL;

    truevalue1288.tree = NULL;

    constructedOctetString1289.tree = NULL;

    sequenceTag1290.tree = NULL;

    truevalue1291.tree = NULL;

    extensionsNotBC1292.tree = NULL;

    integer1293.tree = NULL;

    extensionsCertSignAndSki1294.tree = NULL;

    falsevalue1295.tree = NULL;

    constructedOctetString1296.tree = NULL;

    sequenceTag1297.tree = NULL;

    truevalue1298.tree = NULL;

    extensionsNotCertSignAndSki1299.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3070:2: ( sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSki ) )
        // Grammar/RFC5280.g:3070:3: sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSki )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                printf("BcCA parsed \n");
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCA7186);
            sequenceTag1286=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsCAEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1286.tree);

            FOLLOWPUSH(FOLLOW_bcoid_in_basicConstraintsCA7188);
            bcoid1287=bcoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsCAEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bcoid1287.tree);

            {
                bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bcoid1287.obj
                ;bc_ext->critical=0;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                		bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            }


            // Grammar/RFC5280.g:3075:3: ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBC | integer extensionsCertSignAndSki ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSki )
            {
                int alt347=2;
                switch ( LA(1) )
                {
                case TrueTag:
                	{
                		alt347=1;
                	}
                    break;
                case ConstructedOctetTag:
                case FalseTag:
                	{
                		alt347=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 347;
                    EXCEPTION->state        = 0;


                    goto rulebasicConstraintsCAEx;

                }

                switch (alt347)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3075:4: truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBC | integer extensionsCertSignAndSki )
            	    {
            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCA7195);
            	        truevalue1288=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1288.tree);

            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_basicConstraintsCA7197);
            	        constructedOctetString1289=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1289.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCA7199);
            	        sequenceTag1290=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1290.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCA7201);
            	        truevalue1291=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1291.tree);

            	        {
            	            bc_ext->critical=1;bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3075:125: ( extensionsNotBC | integer extensionsCertSignAndSki )
            	        {
            	            int alt345=2;
            	            switch ( LA(1) )
            	            {
            	            case SequenceTag:
            	            	{
            	            		alt345=1;
            	            	}
            	                break;
            	            case Int0:
            	            case Int1:
            	            case Int2:
            	            case IntTag:
            	            	{
            	            		alt345=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 345;
            	                EXCEPTION->state        = 0;


            	                goto rulebasicConstraintsCAEx;

            	            }

            	            switch (alt345)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3075:127: extensionsNotBC
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotBC_in_basicConstraintsCA7207);
            	        	        extensionsNotBC1292=extensionsNotBC(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCAEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBC1292.tree);

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3075:144: integer extensionsCertSignAndSki
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_integer_in_basicConstraintsCA7210);
            	        	        integer1293=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCAEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, integer1293.tree);

            	        	        {
            	        	            bc_ext->value->basic_constraints->pathlen=integer1293.text
            	        	            ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_extensionsCertSignAndSki_in_basicConstraintsCA7214);
            	        	        extensionsCertSignAndSki1294=extensionsCertSignAndSki(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCAEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignAndSki1294.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3076:4: ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSki
            	    {
            	        // Grammar/RFC5280.g:3076:4: ( falsevalue )?
            	        {
            	            int alt346=2;
            	            switch ( LA(1) )
            	            {
            	                case FalseTag:
            	                	{
            	                		alt346=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt346)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3076:4: falsevalue
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_basicConstraintsCA7220);
            	        	        falsevalue1295=falsevalue(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCAEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1295.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_basicConstraintsCA7223);
            	        constructedOctetString1296=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1296.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCA7225);
            	        sequenceTag1297=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1297.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCA7227);
            	        truevalue1298=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1298.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignAndSki_in_basicConstraintsCA7231);
            	        extensionsNotCertSignAndSki1299=extensionsNotCertSignAndSki(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignAndSki1299.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebasicConstraintsCAEx; /* Prevent compiler warnings */
    rulebasicConstraintsCAEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end basicConstraintsCA */

/**
 * $ANTLR start basicConstraintsCANoSki
 * Grammar/RFC5280.g:3078:1: basicConstraintsCANoSki : sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) | ( falsevalue )? constructedOctetString sequenceTag truevalue ( extensionsNotCertSign )? ) ;
 */
static RFC5280Parser_basicConstraintsCANoSki_return
basicConstraintsCANoSki(pRFC5280Parser ctx)
{
    RFC5280Parser_basicConstraintsCANoSki_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1300;
    #undef	RETURN_TYPE_sequenceTag1300
    #define	RETURN_TYPE_sequenceTag1300 RFC5280Parser_sequenceTag_return

    RFC5280Parser_bcoid_return bcoid1301;
    #undef	RETURN_TYPE_bcoid1301
    #define	RETURN_TYPE_bcoid1301 RFC5280Parser_bcoid_return

    RFC5280Parser_truevalue_return truevalue1302;
    #undef	RETURN_TYPE_truevalue1302
    #define	RETURN_TYPE_truevalue1302 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1303;
    #undef	RETURN_TYPE_constructedOctetString1303
    #define	RETURN_TYPE_constructedOctetString1303 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1304;
    #undef	RETURN_TYPE_sequenceTag1304
    #define	RETURN_TYPE_sequenceTag1304 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1305;
    #undef	RETURN_TYPE_truevalue1305
    #define	RETURN_TYPE_truevalue1305 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotSki_return extensionsNotBCNotSki1306;
    #undef	RETURN_TYPE_extensionsNotBCNotSki1306
    #define	RETURN_TYPE_extensionsNotBCNotSki1306 RFC5280Parser_extensionsNotBCNotSki_return

    RFC5280Parser_integer_return integer1307;
    #undef	RETURN_TYPE_integer1307
    #define	RETURN_TYPE_integer1307 RFC5280Parser_integer_return

    RFC5280Parser_extensionsCertSign_return extensionsCertSign1308;
    #undef	RETURN_TYPE_extensionsCertSign1308
    #define	RETURN_TYPE_extensionsCertSign1308 RFC5280Parser_extensionsCertSign_return

    RFC5280Parser_falsevalue_return falsevalue1309;
    #undef	RETURN_TYPE_falsevalue1309
    #define	RETURN_TYPE_falsevalue1309 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1310;
    #undef	RETURN_TYPE_constructedOctetString1310
    #define	RETURN_TYPE_constructedOctetString1310 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1311;
    #undef	RETURN_TYPE_sequenceTag1311
    #define	RETURN_TYPE_sequenceTag1311 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1312;
    #undef	RETURN_TYPE_truevalue1312
    #define	RETURN_TYPE_truevalue1312 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotCertSign_return extensionsNotCertSign1313;
    #undef	RETURN_TYPE_extensionsNotCertSign1313
    #define	RETURN_TYPE_extensionsNotCertSign1313 RFC5280Parser_extensionsNotCertSign_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1300.tree = NULL;

    bcoid1301.tree = NULL;

    truevalue1302.tree = NULL;

    constructedOctetString1303.tree = NULL;

    sequenceTag1304.tree = NULL;

    truevalue1305.tree = NULL;

    extensionsNotBCNotSki1306.tree = NULL;

    integer1307.tree = NULL;

    extensionsCertSign1308.tree = NULL;

    falsevalue1309.tree = NULL;

    constructedOctetString1310.tree = NULL;

    sequenceTag1311.tree = NULL;

    truevalue1312.tree = NULL;

    extensionsNotCertSign1313.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3082:2: ( sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) | ( falsevalue )? constructedOctetString sequenceTag truevalue ( extensionsNotCertSign )? ) )
        // Grammar/RFC5280.g:3082:3: sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) | ( falsevalue )? constructedOctetString sequenceTag truevalue ( extensionsNotCertSign )? )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                printf("BcCA parsed \n");
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCANoSki7253);
            sequenceTag1300=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsCANoSkiEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1300.tree);

            FOLLOWPUSH(FOLLOW_bcoid_in_basicConstraintsCANoSki7255);
            bcoid1301=bcoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsCANoSkiEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bcoid1301.tree);

            {
                bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bcoid1301.obj
                ;bc_ext->critical=0;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                		bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            }


            // Grammar/RFC5280.g:3087:3: ( truevalue constructedOctetString sequenceTag truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign ) | ( falsevalue )? constructedOctetString sequenceTag truevalue ( extensionsNotCertSign )? )
            {
                int alt352=2;
                switch ( LA(1) )
                {
                case TrueTag:
                	{
                		alt352=1;
                	}
                    break;
                case ConstructedOctetTag:
                case FalseTag:
                	{
                		alt352=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 352;
                    EXCEPTION->state        = 0;


                    goto rulebasicConstraintsCANoSkiEx;

                }

                switch (alt352)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3087:4: truevalue constructedOctetString sequenceTag truevalue ( ( extensionsNotBCNotSki )? | integer extensionsCertSign )
            	    {
            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCANoSki7262);
            	        truevalue1302=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1302.tree);

            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7264);
            	        constructedOctetString1303=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1303.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCANoSki7266);
            	        sequenceTag1304=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1304.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCANoSki7268);
            	        truevalue1305=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1305.tree);

            	        {
            	            bc_ext->critical=1;bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3087:125: ( ( extensionsNotBCNotSki )? | integer extensionsCertSign )
            	        {
            	            int alt349=2;
            	            switch ( LA(1) )
            	            {
            	            case SequenceTag:
            	            	{
            	            		alt349=1;
            	            	}
            	                break;
            	            case Int0:
            	            case Int1:
            	            case Int2:
            	            case IntTag:
            	            	{
            	            		alt349=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 349;
            	                EXCEPTION->state        = 0;


            	                goto rulebasicConstraintsCANoSkiEx;

            	            }

            	            switch (alt349)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3087:127: ( extensionsNotBCNotSki )?
            	        	    {
            	        	        // Grammar/RFC5280.g:3087:127: ( extensionsNotBCNotSki )?
            	        	        {
            	        	            int alt348=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case SequenceTag:
            	        	                	{
            	        	                		switch ( LA(2) )
            	        	                		{
            	        	                		    case OIDTag:
            	        	                		    	{
            	        	                		    		switch ( LA(3) )
            	        	                		    		{
            	        	                		    		    case AIAOID:
            	        	                		    		    case OIDAKI:
            	        	                		    		    case OIDCERTPOL:
            	        	                		    		    case OIDCRL:
            	        	                		    		    case OIDEXTKEY:
            	        	                		    		    case OIDFRESHCRL:
            	        	                		    		    case OIDINHIBIT:
            	        	                		    		    case OIDISSALT:
            	        	                		    		    case OIDKEYUS:
            	        	                		    		    case OIDNAME:
            	        	                		    		    case OIDPOLCONST:
            	        	                		    		    case OIDPOLMAP:
            	        	                		    		    case OIDSUBALT:
            	        	                		    		    case OIDSUBDIR:
            	        	                		    		    case PRINTABLE:
            	        	                		    		    case SIAOID:
            	        	                		    		    case VALUE:
            	        	                		    		    	{
            	        	                		    		    		alt348=1;
            	        	                		    		    	}
            	        	                		    		        break;
            	        	                		    		}

            	        	                		    	}
            	        	                		        break;
            	        	                		}

            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt348)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:3087:127: extensionsNotBCNotSki
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSki_in_basicConstraintsCANoSki7274);
            	        	        	        extensionsNotBCNotSki1306=extensionsNotBCNotSki(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto rulebasicConstraintsCANoSkiEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSki1306.tree);

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3087:151: integer extensionsCertSign
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_integer_in_basicConstraintsCANoSki7278);
            	        	        integer1307=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCANoSkiEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, integer1307.tree);

            	        	        {
            	        	            bc_ext->value->basic_constraints->pathlen=integer1307.text
            	        	            ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_extensionsCertSign_in_basicConstraintsCANoSki7282);
            	        	        extensionsCertSign1308=extensionsCertSign(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCANoSkiEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSign1308.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3088:4: ( falsevalue )? constructedOctetString sequenceTag truevalue ( extensionsNotCertSign )?
            	    {
            	        // Grammar/RFC5280.g:3088:4: ( falsevalue )?
            	        {
            	            int alt350=2;
            	            switch ( LA(1) )
            	            {
            	                case FalseTag:
            	                	{
            	                		alt350=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt350)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3088:4: falsevalue
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_basicConstraintsCANoSki7288);
            	        	        falsevalue1309=falsevalue(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCANoSkiEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1309.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_basicConstraintsCANoSki7291);
            	        constructedOctetString1310=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1310.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCANoSki7293);
            	        sequenceTag1311=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1311.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCANoSki7295);
            	        truevalue1312=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1312.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3088:108: ( extensionsNotCertSign )?
            	        {
            	            int alt351=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case OIDTag:
            	                		    	{
            	                		    		switch ( LA(3) )
            	                		    		{
            	                		    		    case AIAOID:
            	                		    		    case OIDAKI:
            	                		    		    case OIDCERTPOL:
            	                		    		    case OIDCRL:
            	                		    		    case OIDEXTKEY:
            	                		    		    case OIDFRESHCRL:
            	                		    		    case OIDINHIBIT:
            	                		    		    case OIDISSALT:
            	                		    		    case OIDKEYUS:
            	                		    		    case OIDNAME:
            	                		    		    case OIDPOLCONST:
            	                		    		    case OIDPOLMAP:
            	                		    		    case OIDSUBALT:
            	                		    		    case OIDSUBDIR:
            	                		    		    case PRINTABLE:
            	                		    		    case SIAOID:
            	                		    		    case VALUE:
            	                		    		    	{
            	                		    		    		alt351=1;
            	                		    		    	}
            	                		    		        break;
            	                		    		}

            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt351)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3088:108: extensionsNotCertSign
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotCertSign_in_basicConstraintsCANoSki7299);
            	        	        extensionsNotCertSign1313=extensionsNotCertSign(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCANoSkiEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSign1313.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebasicConstraintsCANoSkiEx; /* Prevent compiler warnings */
    rulebasicConstraintsCANoSkiEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end basicConstraintsCANoSki */

/**
 * $ANTLR start basicConstraintsCANoSkiSubAlt
 * Grammar/RFC5280.g:3091:1: basicConstraintsCANoSkiSubAlt : sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignSubAlt ) ;
 */
static RFC5280Parser_basicConstraintsCANoSkiSubAlt_return
basicConstraintsCANoSkiSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_basicConstraintsCANoSkiSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1314;
    #undef	RETURN_TYPE_sequenceTag1314
    #define	RETURN_TYPE_sequenceTag1314 RFC5280Parser_sequenceTag_return

    RFC5280Parser_bcoid_return bcoid1315;
    #undef	RETURN_TYPE_bcoid1315
    #define	RETURN_TYPE_bcoid1315 RFC5280Parser_bcoid_return

    RFC5280Parser_truevalue_return truevalue1316;
    #undef	RETURN_TYPE_truevalue1316
    #define	RETURN_TYPE_truevalue1316 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1317;
    #undef	RETURN_TYPE_constructedOctetString1317
    #define	RETURN_TYPE_constructedOctetString1317 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1318;
    #undef	RETURN_TYPE_sequenceTag1318
    #define	RETURN_TYPE_sequenceTag1318 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1319;
    #undef	RETURN_TYPE_truevalue1319
    #define	RETURN_TYPE_truevalue1319 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotSkiSubAlt_return extensionsNotBCNotSkiSubAlt1320;
    #undef	RETURN_TYPE_extensionsNotBCNotSkiSubAlt1320
    #define	RETURN_TYPE_extensionsNotBCNotSkiSubAlt1320 RFC5280Parser_extensionsNotBCNotSkiSubAlt_return

    RFC5280Parser_integer_return integer1321;
    #undef	RETURN_TYPE_integer1321
    #define	RETURN_TYPE_integer1321 RFC5280Parser_integer_return

    RFC5280Parser_extensionsCertSignSubAlt_return extensionsCertSignSubAlt1322;
    #undef	RETURN_TYPE_extensionsCertSignSubAlt1322
    #define	RETURN_TYPE_extensionsCertSignSubAlt1322 RFC5280Parser_extensionsCertSignSubAlt_return

    RFC5280Parser_falsevalue_return falsevalue1323;
    #undef	RETURN_TYPE_falsevalue1323
    #define	RETURN_TYPE_falsevalue1323 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1324;
    #undef	RETURN_TYPE_constructedOctetString1324
    #define	RETURN_TYPE_constructedOctetString1324 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1325;
    #undef	RETURN_TYPE_sequenceTag1325
    #define	RETURN_TYPE_sequenceTag1325 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1326;
    #undef	RETURN_TYPE_truevalue1326
    #define	RETURN_TYPE_truevalue1326 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotCertSignSubAlt_return extensionsNotCertSignSubAlt1327;
    #undef	RETURN_TYPE_extensionsNotCertSignSubAlt1327
    #define	RETURN_TYPE_extensionsNotCertSignSubAlt1327 RFC5280Parser_extensionsNotCertSignSubAlt_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1314.tree = NULL;

    bcoid1315.tree = NULL;

    truevalue1316.tree = NULL;

    constructedOctetString1317.tree = NULL;

    sequenceTag1318.tree = NULL;

    truevalue1319.tree = NULL;

    extensionsNotBCNotSkiSubAlt1320.tree = NULL;

    integer1321.tree = NULL;

    extensionsCertSignSubAlt1322.tree = NULL;

    falsevalue1323.tree = NULL;

    constructedOctetString1324.tree = NULL;

    sequenceTag1325.tree = NULL;

    truevalue1326.tree = NULL;

    extensionsNotCertSignSubAlt1327.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3095:2: ( sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignSubAlt ) )
        // Grammar/RFC5280.g:3095:3: sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignSubAlt )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                printf("BcCA parsed \n");
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7323);
            sequenceTag1314=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsCANoSkiSubAltEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1314.tree);

            FOLLOWPUSH(FOLLOW_bcoid_in_basicConstraintsCANoSkiSubAlt7325);
            bcoid1315=bcoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsCANoSkiSubAltEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bcoid1315.tree);

            {
                bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bcoid1315.obj
                ;bc_ext->critical=0;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                		bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            }


            // Grammar/RFC5280.g:3100:2: ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignSubAlt )
            {
                int alt355=2;
                switch ( LA(1) )
                {
                case TrueTag:
                	{
                		alt355=1;
                	}
                    break;
                case ConstructedOctetTag:
                case FalseTag:
                	{
                		alt355=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 355;
                    EXCEPTION->state        = 0;


                    goto rulebasicConstraintsCANoSkiSubAltEx;

                }

                switch (alt355)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3100:3: truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt )
            	    {
            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7331);
            	        truevalue1316=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1316.tree);

            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7333);
            	        constructedOctetString1317=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1317.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7335);
            	        sequenceTag1318=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1318.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7337);
            	        truevalue1319=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1319.tree);

            	        {
            	            bc_ext->critical=1;bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3100:124: ( extensionsNotBCNotSkiSubAlt | integer extensionsCertSignSubAlt )
            	        {
            	            int alt353=2;
            	            switch ( LA(1) )
            	            {
            	            case SequenceTag:
            	            	{
            	            		alt353=1;
            	            	}
            	                break;
            	            case Int0:
            	            case Int1:
            	            case Int2:
            	            case IntTag:
            	            	{
            	            		alt353=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 353;
            	                EXCEPTION->state        = 0;


            	                goto rulebasicConstraintsCANoSkiSubAltEx;

            	            }

            	            switch (alt353)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3100:126: extensionsNotBCNotSkiSubAlt
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSkiSubAlt_in_basicConstraintsCANoSkiSubAlt7343);
            	        	        extensionsNotBCNotSkiSubAlt1320=extensionsNotBCNotSkiSubAlt(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSkiSubAlt1320.tree);

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3100:155: integer extensionsCertSignSubAlt
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_integer_in_basicConstraintsCANoSkiSubAlt7346);
            	        	        integer1321=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, integer1321.tree);

            	        	        {
            	        	            bc_ext->value->basic_constraints->pathlen=integer1321.text
            	        	            ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_extensionsCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7350);
            	        	        extensionsCertSignSubAlt1322=extensionsCertSignSubAlt(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignSubAlt1322.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3101:4: ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignSubAlt
            	    {
            	        // Grammar/RFC5280.g:3101:4: ( falsevalue )?
            	        {
            	            int alt354=2;
            	            switch ( LA(1) )
            	            {
            	                case FalseTag:
            	                	{
            	                		alt354=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt354)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3101:4: falsevalue
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_basicConstraintsCANoSkiSubAlt7356);
            	        	        falsevalue1323=falsevalue(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1323.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_basicConstraintsCANoSkiSubAlt7359);
            	        constructedOctetString1324=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1324.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCANoSkiSubAlt7361);
            	        sequenceTag1325=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1325.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCANoSkiSubAlt7363);
            	        truevalue1326=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1326.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignSubAlt_in_basicConstraintsCANoSkiSubAlt7367);
            	        extensionsNotCertSignSubAlt1327=extensionsNotCertSignSubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCANoSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignSubAlt1327.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebasicConstraintsCANoSkiSubAltEx; /* Prevent compiler warnings */
    rulebasicConstraintsCANoSkiSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end basicConstraintsCANoSkiSubAlt */

/**
 * $ANTLR start basicConstraintsCASubAlt
 * Grammar/RFC5280.g:3104:1: basicConstraintsCASubAlt : sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSkiSubAlt ) ;
 */
static RFC5280Parser_basicConstraintsCASubAlt_return
basicConstraintsCASubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_basicConstraintsCASubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1328;
    #undef	RETURN_TYPE_sequenceTag1328
    #define	RETURN_TYPE_sequenceTag1328 RFC5280Parser_sequenceTag_return

    RFC5280Parser_bcoid_return bcoid1329;
    #undef	RETURN_TYPE_bcoid1329
    #define	RETURN_TYPE_bcoid1329 RFC5280Parser_bcoid_return

    RFC5280Parser_truevalue_return truevalue1330;
    #undef	RETURN_TYPE_truevalue1330
    #define	RETURN_TYPE_truevalue1330 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1331;
    #undef	RETURN_TYPE_constructedOctetString1331
    #define	RETURN_TYPE_constructedOctetString1331 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1332;
    #undef	RETURN_TYPE_sequenceTag1332
    #define	RETURN_TYPE_sequenceTag1332 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1333;
    #undef	RETURN_TYPE_truevalue1333
    #define	RETURN_TYPE_truevalue1333 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCSubAlt_return extensionsNotBCSubAlt1334;
    #undef	RETURN_TYPE_extensionsNotBCSubAlt1334
    #define	RETURN_TYPE_extensionsNotBCSubAlt1334 RFC5280Parser_extensionsNotBCSubAlt_return

    RFC5280Parser_integer_return integer1335;
    #undef	RETURN_TYPE_integer1335
    #define	RETURN_TYPE_integer1335 RFC5280Parser_integer_return

    RFC5280Parser_extensionsCertSignAndSkiSubAlt_return extensionsCertSignAndSkiSubAlt1336;
    #undef	RETURN_TYPE_extensionsCertSignAndSkiSubAlt1336
    #define	RETURN_TYPE_extensionsCertSignAndSkiSubAlt1336 RFC5280Parser_extensionsCertSignAndSkiSubAlt_return

    RFC5280Parser_falsevalue_return falsevalue1337;
    #undef	RETURN_TYPE_falsevalue1337
    #define	RETURN_TYPE_falsevalue1337 RFC5280Parser_falsevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1338;
    #undef	RETURN_TYPE_constructedOctetString1338
    #define	RETURN_TYPE_constructedOctetString1338 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1339;
    #undef	RETURN_TYPE_sequenceTag1339
    #define	RETURN_TYPE_sequenceTag1339 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1340;
    #undef	RETURN_TYPE_truevalue1340
    #define	RETURN_TYPE_truevalue1340 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return extensionsNotCertSignAndSkiSubAlt1341;
    #undef	RETURN_TYPE_extensionsNotCertSignAndSkiSubAlt1341
    #define	RETURN_TYPE_extensionsNotCertSignAndSkiSubAlt1341 RFC5280Parser_extensionsNotCertSignAndSkiSubAlt_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1328.tree = NULL;

    bcoid1329.tree = NULL;

    truevalue1330.tree = NULL;

    constructedOctetString1331.tree = NULL;

    sequenceTag1332.tree = NULL;

    truevalue1333.tree = NULL;

    extensionsNotBCSubAlt1334.tree = NULL;

    integer1335.tree = NULL;

    extensionsCertSignAndSkiSubAlt1336.tree = NULL;

    falsevalue1337.tree = NULL;

    constructedOctetString1338.tree = NULL;

    sequenceTag1339.tree = NULL;

    truevalue1340.tree = NULL;

    extensionsNotCertSignAndSkiSubAlt1341.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3108:2: ( sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSkiSubAlt ) )
        // Grammar/RFC5280.g:3108:3: sequenceTag bcoid ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSkiSubAlt )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                printf("BcCA parsed \n");
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7389);
            sequenceTag1328=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsCASubAltEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1328.tree);

            FOLLOWPUSH(FOLLOW_bcoid_in_basicConstraintsCASubAlt7391);
            bcoid1329=bcoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebasicConstraintsCASubAltEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bcoid1329.tree);

            {
                bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bcoid1329.obj
                ;bc_ext->critical=0;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                		bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            }


            // Grammar/RFC5280.g:3113:3: ( truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt ) | ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSkiSubAlt )
            {
                int alt358=2;
                switch ( LA(1) )
                {
                case TrueTag:
                	{
                		alt358=1;
                	}
                    break;
                case ConstructedOctetTag:
                case FalseTag:
                	{
                		alt358=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 358;
                    EXCEPTION->state        = 0;


                    goto rulebasicConstraintsCASubAltEx;

                }

                switch (alt358)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3113:4: truevalue constructedOctetString sequenceTag truevalue ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt )
            	    {
            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCASubAlt7398);
            	        truevalue1330=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1330.tree);

            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7400);
            	        constructedOctetString1331=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1331.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7402);
            	        sequenceTag1332=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1332.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCASubAlt7404);
            	        truevalue1333=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1333.tree);

            	        {
            	            bc_ext->critical=1;bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3113:125: ( extensionsNotBCSubAlt | integer extensionsCertSignAndSkiSubAlt )
            	        {
            	            int alt356=2;
            	            switch ( LA(1) )
            	            {
            	            case SequenceTag:
            	            	{
            	            		alt356=1;
            	            	}
            	                break;
            	            case Int0:
            	            case Int1:
            	            case Int2:
            	            case IntTag:
            	            	{
            	            		alt356=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 356;
            	                EXCEPTION->state        = 0;


            	                goto rulebasicConstraintsCASubAltEx;

            	            }

            	            switch (alt356)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3113:127: extensionsNotBCSubAlt
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCSubAlt_in_basicConstraintsCASubAlt7410);
            	        	        extensionsNotBCSubAlt1334=extensionsNotBCSubAlt(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCASubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCSubAlt1334.tree);

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3113:150: integer extensionsCertSignAndSkiSubAlt
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_integer_in_basicConstraintsCASubAlt7413);
            	        	        integer1335=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCASubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, integer1335.tree);

            	        	        {
            	        	            bc_ext->value->basic_constraints->pathlen=integer1335.text
            	        	            ;
            	        	        }


            	        	        FOLLOWPUSH(FOLLOW_extensionsCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7418);
            	        	        extensionsCertSignAndSkiSubAlt1336=extensionsCertSignAndSkiSubAlt(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCASubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsCertSignAndSkiSubAlt1336.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3114:4: ( falsevalue )? constructedOctetString sequenceTag truevalue extensionsNotCertSignAndSkiSubAlt
            	    {
            	        // Grammar/RFC5280.g:3114:4: ( falsevalue )?
            	        {
            	            int alt357=2;
            	            switch ( LA(1) )
            	            {
            	                case FalseTag:
            	                	{
            	                		alt357=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt357)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3114:4: falsevalue
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_falsevalue_in_basicConstraintsCASubAlt7424);
            	        	        falsevalue1337=falsevalue(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulebasicConstraintsCASubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1337.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_basicConstraintsCASubAlt7427);
            	        constructedOctetString1338=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1338.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_basicConstraintsCASubAlt7429);
            	        sequenceTag1339=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1339.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_basicConstraintsCASubAlt7431);
            	        truevalue1340=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1340.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        FOLLOWPUSH(FOLLOW_extensionsNotCertSignAndSkiSubAlt_in_basicConstraintsCASubAlt7435);
            	        extensionsNotCertSignAndSkiSubAlt1341=extensionsNotCertSignAndSkiSubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebasicConstraintsCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotCertSignAndSkiSubAlt1341.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebasicConstraintsCASubAltEx; /* Prevent compiler warnings */
    rulebasicConstraintsCASubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end basicConstraintsCASubAlt */

/**
 * $ANTLR start extensionsMustBeCAandSkiSubAlt
 * Grammar/RFC5280.g:3116:1: extensionsMustBeCAandSkiSubAlt : ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )? ( sequenceTag bcoid truevalue constructedOctetString sequenceTag truevalue ( integer )? extensionsNotBCNotKeyUsageSubAlt | subAltNameCritical extensionsMustBeCAandSki | subjectKeyId extensionsMustBeCASubAlt ) ;
 */
static RFC5280Parser_extensionsMustBeCAandSkiSubAlt_return
extensionsMustBeCAandSkiSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCAandSkiSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return extensionsNotBCNotKeyUsageNotSkiNoSubAlt1342;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1342
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1342 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return

    RFC5280Parser_sequenceTag_return sequenceTag1343;
    #undef	RETURN_TYPE_sequenceTag1343
    #define	RETURN_TYPE_sequenceTag1343 RFC5280Parser_sequenceTag_return

    RFC5280Parser_bcoid_return bcoid1344;
    #undef	RETURN_TYPE_bcoid1344
    #define	RETURN_TYPE_bcoid1344 RFC5280Parser_bcoid_return

    RFC5280Parser_truevalue_return truevalue1345;
    #undef	RETURN_TYPE_truevalue1345
    #define	RETURN_TYPE_truevalue1345 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1346;
    #undef	RETURN_TYPE_constructedOctetString1346
    #define	RETURN_TYPE_constructedOctetString1346 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1347;
    #undef	RETURN_TYPE_sequenceTag1347
    #define	RETURN_TYPE_sequenceTag1347 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1348;
    #undef	RETURN_TYPE_truevalue1348
    #define	RETURN_TYPE_truevalue1348 RFC5280Parser_truevalue_return

    RFC5280Parser_integer_return integer1349;
    #undef	RETURN_TYPE_integer1349
    #define	RETURN_TYPE_integer1349 RFC5280Parser_integer_return

    RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return extensionsNotBCNotKeyUsageSubAlt1350;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1350
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1350 RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1351;
    #undef	RETURN_TYPE_subAltNameCritical1351
    #define	RETURN_TYPE_subAltNameCritical1351 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsMustBeCAandSki_return extensionsMustBeCAandSki1352;
    #undef	RETURN_TYPE_extensionsMustBeCAandSki1352
    #define	RETURN_TYPE_extensionsMustBeCAandSki1352 RFC5280Parser_extensionsMustBeCAandSki_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1353;
    #undef	RETURN_TYPE_subjectKeyId1353
    #define	RETURN_TYPE_subjectKeyId1353 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsMustBeCASubAlt_return extensionsMustBeCASubAlt1354;
    #undef	RETURN_TYPE_extensionsMustBeCASubAlt1354
    #define	RETURN_TYPE_extensionsMustBeCASubAlt1354 RFC5280Parser_extensionsMustBeCASubAlt_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    extensionsNotBCNotKeyUsageNotSkiNoSubAlt1342.tree = NULL;

    sequenceTag1343.tree = NULL;

    bcoid1344.tree = NULL;

    truevalue1345.tree = NULL;

    constructedOctetString1346.tree = NULL;

    sequenceTag1347.tree = NULL;

    truevalue1348.tree = NULL;

    integer1349.tree = NULL;

    extensionsNotBCNotKeyUsageSubAlt1350.tree = NULL;

    subAltNameCritical1351.tree = NULL;

    extensionsMustBeCAandSki1352.tree = NULL;

    subjectKeyId1353.tree = NULL;

    extensionsMustBeCASubAlt1354.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3120:2: ( ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )? ( sequenceTag bcoid truevalue constructedOctetString sequenceTag truevalue ( integer )? extensionsNotBCNotKeyUsageSubAlt | subAltNameCritical extensionsMustBeCAandSki | subjectKeyId extensionsMustBeCASubAlt ) )
        // Grammar/RFC5280.g:3120:3: ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )? ( sequenceTag bcoid truevalue constructedOctetString sequenceTag truevalue ( integer )? extensionsNotBCNotKeyUsageSubAlt | subAltNameCritical extensionsMustBeCAandSki | subjectKeyId extensionsMustBeCASubAlt )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:3123:3: ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )?
            {
                int alt359=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case OIDTag:
                    		    	{
                    		    		switch ( LA(3) )
                    		    		{
                    		    		    case AIAOID:
                    		    		    case OIDAKI:
                    		    		    case OIDCERTPOL:
                    		    		    case OIDCRL:
                    		    		    case OIDEXTKEY:
                    		    		    case OIDFRESHCRL:
                    		    		    case OIDINHIBIT:
                    		    		    case OIDISSALT:
                    		    		    case OIDNAME:
                    		    		    case OIDPOLCONST:
                    		    		    case OIDPOLMAP:
                    		    		    case OIDSUBDIR:
                    		    		    case PRINTABLE:
                    		    		    case SIAOID:
                    		    		    case VALUE:
                    		    		    	{
                    		    		    		alt359=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt359)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3123:4: extensionsNotBCNotKeyUsageNotSkiNoSubAlt
            	    {
            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCAandSkiSubAlt7456);
            	        extensionsNotBCNotKeyUsageNotSkiNoSubAlt1342=extensionsNotBCNotKeyUsageNotSkiNoSubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiNoSubAlt1342.tree);

            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3123:47: ( sequenceTag bcoid truevalue constructedOctetString sequenceTag truevalue ( integer )? extensionsNotBCNotKeyUsageSubAlt | subAltNameCritical extensionsMustBeCAandSki | subjectKeyId extensionsMustBeCASubAlt )
            {
                int alt361=3;
                switch ( LA(1) )
                {
                case SequenceTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDTag:
                			{
                				switch ( LA(3) )
                				{
                				case OIDBC:
                					{
                						alt361=1;
                					}
                				    break;
                				case OIDSUBALT:
                					{
                						alt361=2;
                					}
                				    break;
                				case OIDSKI:
                					{
                						alt361=3;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 361;
                				    EXCEPTION->state        = 2;


                				    goto ruleextensionsMustBeCAandSkiSubAltEx;

                				}

                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 361;
                		    EXCEPTION->state        = 1;


                		    goto ruleextensionsMustBeCAandSkiSubAltEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 361;
                    EXCEPTION->state        = 0;


                    goto ruleextensionsMustBeCAandSkiSubAltEx;

                }

                switch (alt361)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3123:48: sequenceTag bcoid truevalue constructedOctetString sequenceTag truevalue ( integer )? extensionsNotBCNotKeyUsageSubAlt
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7461);
            	        sequenceTag1343=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1343.tree);

            	        FOLLOWPUSH(FOLLOW_bcoid_in_extensionsMustBeCAandSkiSubAlt7463);
            	        bcoid1344=bcoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, bcoid1344.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7465);
            	        truevalue1345=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1345.tree);

            	        {
            	            bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bcoid1344.obj
            	            ;bc_ext->critical=1;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
            	            		bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            	        }


            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsMustBeCAandSkiSubAlt7471);
            	        constructedOctetString1346=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1346.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCAandSkiSubAlt7473);
            	        sequenceTag1347=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1347.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCAandSkiSubAlt7475);
            	        truevalue1348=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1348.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3125:95: ( integer )?
            	        {
            	            int alt360=2;
            	            switch ( LA(1) )
            	            {
            	                case Int0:
            	                case Int1:
            	                case Int2:
            	                case IntTag:
            	                	{
            	                		alt360=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt360)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3125:96: integer
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_integer_in_extensionsMustBeCAandSkiSubAlt7480);
            	        	        integer1349=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, integer1349.tree);

            	        	        {
            	        	            bc_ext->value->basic_constraints->pathlen=integer1349.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCAandSkiSubAlt7485);
            	        extensionsNotBCNotKeyUsageSubAlt1350=extensionsNotBCNotKeyUsageSubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageSubAlt1350.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3126:4: subAltNameCritical extensionsMustBeCAandSki
            	    {
            	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsMustBeCAandSkiSubAlt7490);
            	        subAltNameCritical1351=subAltNameCritical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1351.tree);

            	        FOLLOWPUSH(FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCAandSkiSubAlt7492);
            	        extensionsMustBeCAandSki1352=extensionsMustBeCAandSki(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCAandSki1352.tree);

            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:3127:4: subjectKeyId extensionsMustBeCASubAlt
            	    {
            	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsMustBeCAandSkiSubAlt7497);
            	        subjectKeyId1353=subjectKeyId(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1353.tree);

            	        FOLLOWPUSH(FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCAandSkiSubAlt7499);
            	        extensionsMustBeCASubAlt1354=extensionsMustBeCASubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCASubAlt1354.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCAandSkiSubAltEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCAandSkiSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCAandSkiSubAlt */

/**
 * $ANTLR start extensionsMustBeCAandSki
 * Grammar/RFC5280.g:3130:1: extensionsMustBeCAandSki : ( extensionsNotBCNotKeyUsageNotSki )? ( sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )? ) ;
 */
static RFC5280Parser_extensionsMustBeCAandSki_return
extensionsMustBeCAandSki(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCAandSki_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_bcoid_return bc;
    #undef	RETURN_TYPE_bc
    #define	RETURN_TYPE_bc RFC5280Parser_bcoid_return

    RFC5280Parser_integer_return i;
    #undef	RETURN_TYPE_i
    #define	RETURN_TYPE_i RFC5280Parser_integer_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1355;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1355
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1355 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return

    RFC5280Parser_sequenceTag_return sequenceTag1356;
    #undef	RETURN_TYPE_sequenceTag1356
    #define	RETURN_TYPE_sequenceTag1356 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1357;
    #undef	RETURN_TYPE_truevalue1357
    #define	RETURN_TYPE_truevalue1357 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1358;
    #undef	RETURN_TYPE_constructedOctetString1358
    #define	RETURN_TYPE_constructedOctetString1358 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1359;
    #undef	RETURN_TYPE_sequenceTag1359
    #define	RETURN_TYPE_sequenceTag1359 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1360;
    #undef	RETURN_TYPE_truevalue1360
    #define	RETURN_TYPE_truevalue1360 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage1361;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage1361
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage1361 RFC5280Parser_extensionsNotBCNotKeyUsage_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1362;
    #undef	RETURN_TYPE_subjectKeyId1362
    #define	RETURN_TYPE_subjectKeyId1362 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1363;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1363
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1363 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return

    RFC5280Parser_sequenceTag_return sequenceTag1364;
    #undef	RETURN_TYPE_sequenceTag1364
    #define	RETURN_TYPE_sequenceTag1364 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1365;
    #undef	RETURN_TYPE_truevalue1365
    #define	RETURN_TYPE_truevalue1365 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1366;
    #undef	RETURN_TYPE_constructedOctetString1366
    #define	RETURN_TYPE_constructedOctetString1366 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1367;
    #undef	RETURN_TYPE_sequenceTag1367
    #define	RETURN_TYPE_sequenceTag1367 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1368;
    #undef	RETURN_TYPE_truevalue1368
    #define	RETURN_TYPE_truevalue1368 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1369;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1369
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1369 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    bc.tree = NULL;

    i.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1355.tree = NULL;

    sequenceTag1356.tree = NULL;

    truevalue1357.tree = NULL;

    constructedOctetString1358.tree = NULL;

    sequenceTag1359.tree = NULL;

    truevalue1360.tree = NULL;

    extensionsNotBCNotKeyUsage1361.tree = NULL;

    subjectKeyId1362.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1363.tree = NULL;

    sequenceTag1364.tree = NULL;

    truevalue1365.tree = NULL;

    constructedOctetString1366.tree = NULL;

    sequenceTag1367.tree = NULL;

    truevalue1368.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1369.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3134:2: ( ( extensionsNotBCNotKeyUsageNotSki )? ( sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )? ) )
        // Grammar/RFC5280.g:3134:3: ( extensionsNotBCNotKeyUsageNotSki )? ( sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )? )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:3137:3: ( extensionsNotBCNotKeyUsageNotSki )?
            {
                int alt362=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case OIDTag:
                    		    	{
                    		    		switch ( LA(3) )
                    		    		{
                    		    		    case AIAOID:
                    		    		    case OIDAKI:
                    		    		    case OIDCERTPOL:
                    		    		    case OIDCRL:
                    		    		    case OIDEXTKEY:
                    		    		    case OIDFRESHCRL:
                    		    		    case OIDINHIBIT:
                    		    		    case OIDISSALT:
                    		    		    case OIDNAME:
                    		    		    case OIDPOLCONST:
                    		    		    case OIDPOLMAP:
                    		    		    case OIDSUBALT:
                    		    		    case OIDSUBDIR:
                    		    		    case PRINTABLE:
                    		    		    case SIAOID:
                    		    		    case VALUE:
                    		    		    	{
                    		    		    		alt362=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt362)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3137:4: extensionsNotBCNotKeyUsageNotSki
            	    {
            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7523);
            	        extensionsNotBCNotKeyUsageNotSki1355=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1355.tree);

            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3137:39: ( sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )? )
            {
                int alt367=2;
                switch ( LA(1) )
                {
                case SequenceTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDTag:
                			{
                				switch ( LA(3) )
                				{
                				case OIDBC:
                					{
                						alt367=1;
                					}
                				    break;
                				case OIDSKI:
                					{
                						alt367=2;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 367;
                				    EXCEPTION->state        = 2;


                				    goto ruleextensionsMustBeCAandSkiEx;

                				}

                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 367;
                		    EXCEPTION->state        = 1;


                		    goto ruleextensionsMustBeCAandSkiEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 367;
                    EXCEPTION->state        = 0;


                    goto ruleextensionsMustBeCAandSkiEx;

                }

                switch (alt367)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3137:40: sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsage
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7528);
            	        sequenceTag1356=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1356.tree);

            	        FOLLOWPUSH(FOLLOW_bcoid_in_extensionsMustBeCAandSki7532);
            	        bc=bcoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, bc.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCAandSki7534);
            	        truevalue1357=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1357.tree);

            	        {
            	            bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bc.obj
            	            ;bc_ext->critical=1;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
            	            		bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            	        }


            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7540);
            	        constructedOctetString1358=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1358.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7542);
            	        sequenceTag1359=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1359.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCAandSki7544);
            	        truevalue1360=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1360.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3139:94: (i= integer )?
            	        {
            	            int alt363=2;
            	            switch ( LA(1) )
            	            {
            	                case Int0:
            	                case Int1:
            	                case Int2:
            	                case IntTag:
            	                	{
            	                		alt363=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt363)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3139:95: i= integer
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_integer_in_extensionsMustBeCAandSki7551);
            	        	        i=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCAandSkiEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, i.tree);

            	        	        {
            	        	            bc_ext->value->basic_constraints->pathlen=i.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCAandSki7556);
            	        extensionsNotBCNotKeyUsage1361=extensionsNotBCNotKeyUsage(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage1361.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3140:4: subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )?
            	    {
            	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsMustBeCAandSki7561);
            	        subjectKeyId1362=subjectKeyId(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1362.tree);

            	        // Grammar/RFC5280.g:3140:17: ( extensionsNotBCNotKeyUsageNotSki )?
            	        {
            	            int alt364=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case OIDTag:
            	                		    	{
            	                		    		switch ( LA(3) )
            	                		    		{
            	                		    		    case AIAOID:
            	                		    		    case OIDAKI:
            	                		    		    case OIDCERTPOL:
            	                		    		    case OIDCRL:
            	                		    		    case OIDEXTKEY:
            	                		    		    case OIDFRESHCRL:
            	                		    		    case OIDINHIBIT:
            	                		    		    case OIDISSALT:
            	                		    		    case OIDNAME:
            	                		    		    case OIDPOLCONST:
            	                		    		    case OIDPOLMAP:
            	                		    		    case OIDSUBALT:
            	                		    		    case OIDSUBDIR:
            	                		    		    case PRINTABLE:
            	                		    		    case SIAOID:
            	                		    		    case VALUE:
            	                		    		    	{
            	                		    		    		alt364=1;
            	                		    		    	}
            	                		    		        break;
            	                		    		}

            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt364)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3140:18: extensionsNotBCNotKeyUsageNotSki
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7564);
            	        	        extensionsNotBCNotKeyUsageNotSki1363=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCAandSkiEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1363.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7568);
            	        sequenceTag1364=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1364.tree);

            	        FOLLOWPUSH(FOLLOW_bcoid_in_extensionsMustBeCAandSki7572);
            	        bc=bcoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, bc.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCAandSki7574);
            	        truevalue1365=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1365.tree);

            	        {
            	            bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bc.obj
            	            ;bc_ext->critical=1;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
            	            	bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            	        }


            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsMustBeCAandSki7579);
            	        constructedOctetString1366=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1366.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCAandSki7581);
            	        sequenceTag1367=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1367.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCAandSki7583);
            	        truevalue1368=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAandSkiEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1368.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3142:94: (i= integer )?
            	        {
            	            int alt365=2;
            	            switch ( LA(1) )
            	            {
            	                case Int0:
            	                case Int1:
            	                case Int2:
            	                case IntTag:
            	                	{
            	                		alt365=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt365)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3142:95: i= integer
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_integer_in_extensionsMustBeCAandSki7590);
            	        	        i=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCAandSkiEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, i.tree);

            	        	        {
            	        	            bc_ext->value->basic_constraints->pathlen=i.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:3142:159: ( extensionsNotBCNotKeyUsageNotSki )?
            	        {
            	            int alt366=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case OIDTag:
            	                		    	{
            	                		    		switch ( LA(3) )
            	                		    		{
            	                		    		    case AIAOID:
            	                		    		    case OIDAKI:
            	                		    		    case OIDCERTPOL:
            	                		    		    case OIDCRL:
            	                		    		    case OIDEXTKEY:
            	                		    		    case OIDFRESHCRL:
            	                		    		    case OIDINHIBIT:
            	                		    		    case OIDISSALT:
            	                		    		    case OIDNAME:
            	                		    		    case OIDPOLCONST:
            	                		    		    case OIDPOLMAP:
            	                		    		    case OIDSUBALT:
            	                		    		    case OIDSUBDIR:
            	                		    		    case PRINTABLE:
            	                		    		    case SIAOID:
            	                		    		    case VALUE:
            	                		    		    	{
            	                		    		    		alt366=1;
            	                		    		    	}
            	                		    		        break;
            	                		    		}

            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt366)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3142:160: extensionsNotBCNotKeyUsageNotSki
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCAandSki7596);
            	        	        extensionsNotBCNotKeyUsageNotSki1369=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCAandSkiEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1369.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCAandSkiEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCAandSkiEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCAandSki */

/**
 * $ANTLR start extensionsMustBeCASubAlt
 * Grammar/RFC5280.g:3145:1: extensionsMustBeCASubAlt : ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )? ( sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )? ) ;
 */
static RFC5280Parser_extensionsMustBeCASubAlt_return
extensionsMustBeCASubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCASubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_bcoid_return bc;
    #undef	RETURN_TYPE_bc
    #define	RETURN_TYPE_bc RFC5280Parser_bcoid_return

    RFC5280Parser_integer_return i;
    #undef	RETURN_TYPE_i
    #define	RETURN_TYPE_i RFC5280Parser_integer_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return extensionsNotBCNotKeyUsageNotSkiNoSubAlt1370;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1370
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1370 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return

    RFC5280Parser_sequenceTag_return sequenceTag1371;
    #undef	RETURN_TYPE_sequenceTag1371
    #define	RETURN_TYPE_sequenceTag1371 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1372;
    #undef	RETURN_TYPE_truevalue1372
    #define	RETURN_TYPE_truevalue1372 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1373;
    #undef	RETURN_TYPE_constructedOctetString1373
    #define	RETURN_TYPE_constructedOctetString1373 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1374;
    #undef	RETURN_TYPE_sequenceTag1374
    #define	RETURN_TYPE_sequenceTag1374 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1375;
    #undef	RETURN_TYPE_truevalue1375
    #define	RETURN_TYPE_truevalue1375 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return extensionsNotBCNotKeyUsageNotSkiSubAlt1376;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1376
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1376 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1377;
    #undef	RETURN_TYPE_subAltNameCritical1377
    #define	RETURN_TYPE_subAltNameCritical1377 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1378;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1378
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1378 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return

    RFC5280Parser_sequenceTag_return sequenceTag1379;
    #undef	RETURN_TYPE_sequenceTag1379
    #define	RETURN_TYPE_sequenceTag1379 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1380;
    #undef	RETURN_TYPE_truevalue1380
    #define	RETURN_TYPE_truevalue1380 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1381;
    #undef	RETURN_TYPE_constructedOctetString1381
    #define	RETURN_TYPE_constructedOctetString1381 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1382;
    #undef	RETURN_TYPE_sequenceTag1382
    #define	RETURN_TYPE_sequenceTag1382 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1383;
    #undef	RETURN_TYPE_truevalue1383
    #define	RETURN_TYPE_truevalue1383 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1384;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1384
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1384 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    bc.tree = NULL;

    i.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiNoSubAlt1370.tree = NULL;

    sequenceTag1371.tree = NULL;

    truevalue1372.tree = NULL;

    constructedOctetString1373.tree = NULL;

    sequenceTag1374.tree = NULL;

    truevalue1375.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiSubAlt1376.tree = NULL;

    subAltNameCritical1377.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1378.tree = NULL;

    sequenceTag1379.tree = NULL;

    truevalue1380.tree = NULL;

    constructedOctetString1381.tree = NULL;

    sequenceTag1382.tree = NULL;

    truevalue1383.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1384.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3149:2: ( ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )? ( sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )? ) )
        // Grammar/RFC5280.g:3149:3: ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )? ( sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )? )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:3152:2: ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )?
            {
                int alt368=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case OIDTag:
                    		    	{
                    		    		switch ( LA(3) )
                    		    		{
                    		    		    case AIAOID:
                    		    		    case OIDAKI:
                    		    		    case OIDCERTPOL:
                    		    		    case OIDCRL:
                    		    		    case OIDEXTKEY:
                    		    		    case OIDFRESHCRL:
                    		    		    case OIDINHIBIT:
                    		    		    case OIDISSALT:
                    		    		    case OIDNAME:
                    		    		    case OIDPOLCONST:
                    		    		    case OIDPOLMAP:
                    		    		    case OIDSUBDIR:
                    		    		    case PRINTABLE:
                    		    		    case SIAOID:
                    		    		    case VALUE:
                    		    		    	{
                    		    		    		alt368=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt368)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3152:3: extensionsNotBCNotKeyUsageNotSkiNoSubAlt
            	    {
            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCASubAlt7619);
            	        extensionsNotBCNotKeyUsageNotSkiNoSubAlt1370=extensionsNotBCNotKeyUsageNotSkiNoSubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiNoSubAlt1370.tree);

            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3152:46: ( sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )? )
            {
                int alt373=2;
                switch ( LA(1) )
                {
                case SequenceTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDTag:
                			{
                				switch ( LA(3) )
                				{
                				case OIDBC:
                					{
                						alt373=1;
                					}
                				    break;
                				case OIDSUBALT:
                					{
                						alt373=2;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 373;
                				    EXCEPTION->state        = 2;


                				    goto ruleextensionsMustBeCASubAltEx;

                				}

                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 373;
                		    EXCEPTION->state        = 1;


                		    goto ruleextensionsMustBeCASubAltEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 373;
                    EXCEPTION->state        = 0;


                    goto ruleextensionsMustBeCASubAltEx;

                }

                switch (alt373)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3152:47: sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? extensionsNotBCNotKeyUsageNotSkiSubAlt
            	    {
            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7624);
            	        sequenceTag1371=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1371.tree);

            	        FOLLOWPUSH(FOLLOW_bcoid_in_extensionsMustBeCASubAlt7628);
            	        bc=bcoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, bc.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCASubAlt7630);
            	        truevalue1372=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1372.tree);

            	        {
            	            bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bc.obj
            	            ;bc_ext->critical=1;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
            	            	bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            	        }


            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7635);
            	        constructedOctetString1373=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1373.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7637);
            	        sequenceTag1374=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1374.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCASubAlt7639);
            	        truevalue1375=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1375.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3154:94: (i= integer )?
            	        {
            	            int alt369=2;
            	            switch ( LA(1) )
            	            {
            	                case Int0:
            	                case Int1:
            	                case Int2:
            	                case IntTag:
            	                	{
            	                		alt369=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt369)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3154:95: i= integer
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_integer_in_extensionsMustBeCASubAlt7646);
            	        	        i=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCASubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, i.tree);

            	        	        {
            	        	            bc_ext->value->basic_constraints->pathlen=i.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCASubAlt7651);
            	        extensionsNotBCNotKeyUsageNotSkiSubAlt1376=extensionsNotBCNotKeyUsageNotSkiSubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiSubAlt1376.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3155:4: subAltNameCritical ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bc= bcoid truevalue constructedOctetString sequenceTag truevalue (i= integer )? ( extensionsNotBCNotKeyUsageNotSki )?
            	    {
            	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsMustBeCASubAlt7656);
            	        subAltNameCritical1377=subAltNameCritical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1377.tree);

            	        // Grammar/RFC5280.g:3155:23: ( extensionsNotBCNotKeyUsageNotSki )?
            	        {
            	            int alt370=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case OIDTag:
            	                		    	{
            	                		    		switch ( LA(3) )
            	                		    		{
            	                		    		    case AIAOID:
            	                		    		    case OIDAKI:
            	                		    		    case OIDCERTPOL:
            	                		    		    case OIDCRL:
            	                		    		    case OIDEXTKEY:
            	                		    		    case OIDFRESHCRL:
            	                		    		    case OIDINHIBIT:
            	                		    		    case OIDISSALT:
            	                		    		    case OIDNAME:
            	                		    		    case OIDPOLCONST:
            	                		    		    case OIDPOLMAP:
            	                		    		    case OIDSUBALT:
            	                		    		    case OIDSUBDIR:
            	                		    		    case PRINTABLE:
            	                		    		    case SIAOID:
            	                		    		    case VALUE:
            	                		    		    	{
            	                		    		    		alt370=1;
            	                		    		    	}
            	                		    		        break;
            	                		    		}

            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt370)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3155:24: extensionsNotBCNotKeyUsageNotSki
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7659);
            	        	        extensionsNotBCNotKeyUsageNotSki1378=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCASubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1378.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7663);
            	        sequenceTag1379=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1379.tree);

            	        FOLLOWPUSH(FOLLOW_bcoid_in_extensionsMustBeCASubAlt7667);
            	        bc=bcoid(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, bc.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCASubAlt7669);
            	        truevalue1380=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1380.tree);

            	        {
            	            bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bc.obj
            	            ;bc_ext->critical=1;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
            	            	bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            	        }


            	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsMustBeCASubAlt7674);
            	        constructedOctetString1381=constructedOctetString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1381.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCASubAlt7676);
            	        sequenceTag1382=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1382.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCASubAlt7678);
            	        truevalue1383=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCASubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1383.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3157:94: (i= integer )?
            	        {
            	            int alt371=2;
            	            switch ( LA(1) )
            	            {
            	                case Int0:
            	                case Int1:
            	                case Int2:
            	                case IntTag:
            	                	{
            	                		alt371=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt371)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3157:95: i= integer
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_integer_in_extensionsMustBeCASubAlt7685);
            	        	        i=integer(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCASubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, i.tree);

            	        	        {
            	        	            bc_ext->value->basic_constraints->pathlen=i.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:3157:160: ( extensionsNotBCNotKeyUsageNotSki )?
            	        {
            	            int alt372=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case OIDTag:
            	                		    	{
            	                		    		switch ( LA(3) )
            	                		    		{
            	                		    		    case AIAOID:
            	                		    		    case OIDAKI:
            	                		    		    case OIDCERTPOL:
            	                		    		    case OIDCRL:
            	                		    		    case OIDEXTKEY:
            	                		    		    case OIDFRESHCRL:
            	                		    		    case OIDINHIBIT:
            	                		    		    case OIDISSALT:
            	                		    		    case OIDNAME:
            	                		    		    case OIDPOLCONST:
            	                		    		    case OIDPOLMAP:
            	                		    		    case OIDSUBALT:
            	                		    		    case OIDSUBDIR:
            	                		    		    case PRINTABLE:
            	                		    		    case SIAOID:
            	                		    		    case VALUE:
            	                		    		    	{
            	                		    		    		alt372=1;
            	                		    		    	}
            	                		    		        break;
            	                		    		}

            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt372)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3157:161: extensionsNotBCNotKeyUsageNotSki
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCASubAlt7692);
            	        	        extensionsNotBCNotKeyUsageNotSki1384=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCASubAltEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1384.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCASubAltEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCASubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCASubAlt */

/**
 * $ANTLR start extensionsMustBeCA
 * Grammar/RFC5280.g:3161:1: extensionsMustBeCA : ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bcoid truevalue constructedOctetString sequenceTag truevalue ( integer )? ( extensionsNotBCNotKeyUsageNotSki )? ;
 */
static RFC5280Parser_extensionsMustBeCA_return
extensionsMustBeCA(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCA_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1385;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1385
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1385 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return

    RFC5280Parser_sequenceTag_return sequenceTag1386;
    #undef	RETURN_TYPE_sequenceTag1386
    #define	RETURN_TYPE_sequenceTag1386 RFC5280Parser_sequenceTag_return

    RFC5280Parser_bcoid_return bcoid1387;
    #undef	RETURN_TYPE_bcoid1387
    #define	RETURN_TYPE_bcoid1387 RFC5280Parser_bcoid_return

    RFC5280Parser_truevalue_return truevalue1388;
    #undef	RETURN_TYPE_truevalue1388
    #define	RETURN_TYPE_truevalue1388 RFC5280Parser_truevalue_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1389;
    #undef	RETURN_TYPE_constructedOctetString1389
    #define	RETURN_TYPE_constructedOctetString1389 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_sequenceTag_return sequenceTag1390;
    #undef	RETURN_TYPE_sequenceTag1390
    #define	RETURN_TYPE_sequenceTag1390 RFC5280Parser_sequenceTag_return

    RFC5280Parser_truevalue_return truevalue1391;
    #undef	RETURN_TYPE_truevalue1391
    #define	RETURN_TYPE_truevalue1391 RFC5280Parser_truevalue_return

    RFC5280Parser_integer_return integer1392;
    #undef	RETURN_TYPE_integer1392
    #define	RETURN_TYPE_integer1392 RFC5280Parser_integer_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1393;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1393
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1393 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    extensionsNotBCNotKeyUsageNotSki1385.tree = NULL;

    sequenceTag1386.tree = NULL;

    bcoid1387.tree = NULL;

    truevalue1388.tree = NULL;

    constructedOctetString1389.tree = NULL;

    sequenceTag1390.tree = NULL;

    truevalue1391.tree = NULL;

    integer1392.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1393.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3165:2: ( ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bcoid truevalue constructedOctetString sequenceTag truevalue ( integer )? ( extensionsNotBCNotKeyUsageNotSki )? )
        // Grammar/RFC5280.g:3165:3: ( extensionsNotBCNotKeyUsageNotSki )? sequenceTag bcoid truevalue constructedOctetString sequenceTag truevalue ( integer )? ( extensionsNotBCNotKeyUsageNotSki )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:3167:10: ( extensionsNotBCNotKeyUsageNotSki )?
            {
                int alt374=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case OIDTag:
                    		    	{
                    		    		switch ( LA(3) )
                    		    		{
                    		    		    case AIAOID:
                    		    		    case OIDAKI:
                    		    		    case OIDCERTPOL:
                    		    		    case OIDCRL:
                    		    		    case OIDEXTKEY:
                    		    		    case OIDFRESHCRL:
                    		    		    case OIDINHIBIT:
                    		    		    case OIDISSALT:
                    		    		    case OIDNAME:
                    		    		    case OIDPOLCONST:
                    		    		    case OIDPOLMAP:
                    		    		    case OIDSUBALT:
                    		    		    case OIDSUBDIR:
                    		    		    case PRINTABLE:
                    		    		    case SIAOID:
                    		    		    case VALUE:
                    		    		    	{
                    		    		    		alt374=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt374)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3167:11: extensionsNotBCNotKeyUsageNotSki
            	    {
            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7714);
            	        extensionsNotBCNotKeyUsageNotSki1385=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1385.tree);

            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCA7718);
            sequenceTag1386=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionsMustBeCAEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1386.tree);

            FOLLOWPUSH(FOLLOW_bcoid_in_extensionsMustBeCA7720);
            bcoid1387=bcoid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionsMustBeCAEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bcoid1387.tree);

            FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCA7722);
            truevalue1388=truevalue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionsMustBeCAEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, truevalue1388.tree);

            {
                bc_ext = malloc(sizeof(x509_EXTENSION));bc_ext->oid=bcoid1387.obj
                ;bc_ext->critical=1;bc_ext->value=malloc(sizeof(X509_EXTENSION_VALUE));
                	bc_ext->value->basic_constraints=malloc(sizeof(BASIC_CONSTRAINT));bc_ext->value->basic_constraints->is_ca=0;bc_ext->value->basic_constraints->pathlen=NULL;
            }


            FOLLOWPUSH(FOLLOW_constructedOctetString_in_extensionsMustBeCA7727);
            constructedOctetString1389=constructedOctetString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionsMustBeCAEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1389.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionsMustBeCA7729);
            sequenceTag1390=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionsMustBeCAEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1390.tree);

            FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCA7731);
            truevalue1391=truevalue(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionsMustBeCAEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, truevalue1391.tree);

            {
                bc_ext->value->basic_constraints->is_ca = 1;
            }


            // Grammar/RFC5280.g:3169:94: ( integer )?
            {
                int alt375=2;
                switch ( LA(1) )
                {
                    case Int0:
                    case Int1:
                    case Int2:
                    case IntTag:
                    	{
                    		alt375=1;
                    	}
                        break;
                }

                switch (alt375)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3169:95: integer
            	    {
            	        FOLLOWPUSH(FOLLOW_integer_in_extensionsMustBeCA7736);
            	        integer1392=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, integer1392.tree);

            	        {
            	            bc_ext->value->basic_constraints->pathlen=integer1392.text
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3169:163: ( extensionsNotBCNotKeyUsageNotSki )?
            {
                int alt376=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case OIDTag:
                    		    	{
                    		    		switch ( LA(3) )
                    		    		{
                    		    		    case AIAOID:
                    		    		    case OIDAKI:
                    		    		    case OIDCERTPOL:
                    		    		    case OIDCRL:
                    		    		    case OIDEXTKEY:
                    		    		    case OIDFRESHCRL:
                    		    		    case OIDINHIBIT:
                    		    		    case OIDISSALT:
                    		    		    case OIDNAME:
                    		    		    case OIDPOLCONST:
                    		    		    case OIDPOLMAP:
                    		    		    case OIDSUBALT:
                    		    		    case OIDSUBDIR:
                    		    		    case PRINTABLE:
                    		    		    case SIAOID:
                    		    		    case VALUE:
                    		    		    	{
                    		    		    		alt376=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt376)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3169:164: extensionsNotBCNotKeyUsageNotSki
            	    {
            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCA7742);
            	        extensionsNotBCNotKeyUsageNotSki1393=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCAEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1393.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCAEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCAEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCA */

/**
 * $ANTLR start extensionsMustBeCaAndSkiNoPathLenSubAlt
 * Grammar/RFC5280.g:3174:1: extensionsMustBeCaAndSkiNoPathLenSubAlt : ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )? ( basicConstraints truevalue extensionsNotBCNotKeyUsageSubAlt | subAltNameCritical extensionsMustBeCaAndSkiNoPathLen | subjectKeyId extensionsMustBeCaNoPathLenSubAlt ) ;
 */
static RFC5280Parser_extensionsMustBeCaAndSkiNoPathLenSubAlt_return
extensionsMustBeCaAndSkiNoPathLenSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCaAndSkiNoPathLenSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return extensionsNotBCNotKeyUsageNotSkiNoSubAlt1394;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1394
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1394 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return

    RFC5280Parser_basicConstraints_return basicConstraints1395;
    #undef	RETURN_TYPE_basicConstraints1395
    #define	RETURN_TYPE_basicConstraints1395 RFC5280Parser_basicConstraints_return

    RFC5280Parser_truevalue_return truevalue1396;
    #undef	RETURN_TYPE_truevalue1396
    #define	RETURN_TYPE_truevalue1396 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return extensionsNotBCNotKeyUsageSubAlt1397;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1397
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1397 RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1398;
    #undef	RETURN_TYPE_subAltNameCritical1398
    #define	RETURN_TYPE_subAltNameCritical1398 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsMustBeCaAndSkiNoPathLen_return extensionsMustBeCaAndSkiNoPathLen1399;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLen1399
    #define	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLen1399 RFC5280Parser_extensionsMustBeCaAndSkiNoPathLen_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1400;
    #undef	RETURN_TYPE_subjectKeyId1400
    #define	RETURN_TYPE_subjectKeyId1400 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return extensionsMustBeCaNoPathLenSubAlt1401;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt1401
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt1401 RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionsNotBCNotKeyUsageNotSkiNoSubAlt1394.tree = NULL;

    basicConstraints1395.tree = NULL;

    truevalue1396.tree = NULL;

    extensionsNotBCNotKeyUsageSubAlt1397.tree = NULL;

    subAltNameCritical1398.tree = NULL;

    extensionsMustBeCaAndSkiNoPathLen1399.tree = NULL;

    subjectKeyId1400.tree = NULL;

    extensionsMustBeCaNoPathLenSubAlt1401.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3181:2: ( ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )? ( basicConstraints truevalue extensionsNotBCNotKeyUsageSubAlt | subAltNameCritical extensionsMustBeCaAndSkiNoPathLen | subjectKeyId extensionsMustBeCaNoPathLenSubAlt ) )
        // Grammar/RFC5280.g:3181:4: ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )? ( basicConstraints truevalue extensionsNotBCNotKeyUsageSubAlt | subAltNameCritical extensionsMustBeCaAndSkiNoPathLen | subjectKeyId extensionsMustBeCaNoPathLenSubAlt )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // Grammar/RFC5280.g:3181:4: ( extensionsNotBCNotKeyUsageNotSkiNoSubAlt )?
            {
                int alt377=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case OIDTag:
                    		    	{
                    		    		switch ( LA(3) )
                    		    		{
                    		    		    case AIAOID:
                    		    		    case OIDAKI:
                    		    		    case OIDCERTPOL:
                    		    		    case OIDCRL:
                    		    		    case OIDEXTKEY:
                    		    		    case OIDFRESHCRL:
                    		    		    case OIDINHIBIT:
                    		    		    case OIDISSALT:
                    		    		    case OIDNAME:
                    		    		    case OIDPOLCONST:
                    		    		    case OIDPOLMAP:
                    		    		    case OIDSUBDIR:
                    		    		    case PRINTABLE:
                    		    		    case SIAOID:
                    		    		    case VALUE:
                    		    		    	{
                    		    		    		alt377=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt377)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3181:5: extensionsNotBCNotKeyUsageNotSkiNoSubAlt
            	    {
            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7770);
            	        extensionsNotBCNotKeyUsageNotSkiNoSubAlt1394=extensionsNotBCNotKeyUsageNotSkiNoSubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiNoSubAlt1394.tree);

            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3181:48: ( basicConstraints truevalue extensionsNotBCNotKeyUsageSubAlt | subAltNameCritical extensionsMustBeCaAndSkiNoPathLen | subjectKeyId extensionsMustBeCaNoPathLenSubAlt )
            {
                int alt378=3;
                switch ( LA(1) )
                {
                case SequenceTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDTag:
                			{
                				switch ( LA(3) )
                				{
                				case OIDBC:
                					{
                						alt378=1;
                					}
                				    break;
                				case OIDSUBALT:
                					{
                						alt378=2;
                					}
                				    break;
                				case OIDSKI:
                					{
                						alt378=3;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 378;
                				    EXCEPTION->state        = 2;


                				    goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;

                				}

                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 378;
                		    EXCEPTION->state        = 1;


                		    goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 378;
                    EXCEPTION->state        = 0;


                    goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;

                }

                switch (alt378)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3181:49: basicConstraints truevalue extensionsNotBCNotKeyUsageSubAlt
            	    {
            	        FOLLOWPUSH(FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7775);
            	        basicConstraints1395=basicConstraints(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraints1395.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7777);
            	        truevalue1396=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1396.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7781);
            	        extensionsNotBCNotKeyUsageSubAlt1397=extensionsNotBCNotKeyUsageSubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageSubAlt1397.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3182:4: subAltNameCritical extensionsMustBeCaAndSkiNoPathLen
            	    {
            	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7786);
            	        subAltNameCritical1398=subAltNameCritical(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1398.tree);

            	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7788);
            	        extensionsMustBeCaAndSkiNoPathLen1399=extensionsMustBeCaAndSkiNoPathLen(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSkiNoPathLen1399.tree);

            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:3183:4: subjectKeyId extensionsMustBeCaNoPathLenSubAlt
            	    {
            	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7793);
            	        subjectKeyId1400=subjectKeyId(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1400.tree);

            	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaAndSkiNoPathLenSubAlt7795);
            	        extensionsMustBeCaNoPathLenSubAlt1401=extensionsMustBeCaNoPathLenSubAlt(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLenSubAlt1401.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCaAndSkiNoPathLenSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCaAndSkiNoPathLenSubAlt */

/**
 * $ANTLR start extensionsMustBeCaAndSkiNoPathLen
 * Grammar/RFC5280.g:3185:1: extensionsMustBeCaAndSkiNoPathLen : ( extensionsNotBCNotKeyUsageNotSki )? ( basicConstraints truevalue extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? basicConstraints truevalue ( extensionsNotBCNotKeyUsageNotSki )? ) ;
 */
static RFC5280Parser_extensionsMustBeCaAndSkiNoPathLen_return
extensionsMustBeCaAndSkiNoPathLen(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCaAndSkiNoPathLen_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1402;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1402
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1402 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return

    RFC5280Parser_basicConstraints_return basicConstraints1403;
    #undef	RETURN_TYPE_basicConstraints1403
    #define	RETURN_TYPE_basicConstraints1403 RFC5280Parser_basicConstraints_return

    RFC5280Parser_truevalue_return truevalue1404;
    #undef	RETURN_TYPE_truevalue1404
    #define	RETURN_TYPE_truevalue1404 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage1405;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage1405
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage1405 RFC5280Parser_extensionsNotBCNotKeyUsage_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1406;
    #undef	RETURN_TYPE_subjectKeyId1406
    #define	RETURN_TYPE_subjectKeyId1406 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1407;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1407
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1407 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return

    RFC5280Parser_basicConstraints_return basicConstraints1408;
    #undef	RETURN_TYPE_basicConstraints1408
    #define	RETURN_TYPE_basicConstraints1408 RFC5280Parser_basicConstraints_return

    RFC5280Parser_truevalue_return truevalue1409;
    #undef	RETURN_TYPE_truevalue1409
    #define	RETURN_TYPE_truevalue1409 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1410;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1410
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1410 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionsNotBCNotKeyUsageNotSki1402.tree = NULL;

    basicConstraints1403.tree = NULL;

    truevalue1404.tree = NULL;

    extensionsNotBCNotKeyUsage1405.tree = NULL;

    subjectKeyId1406.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1407.tree = NULL;

    basicConstraints1408.tree = NULL;

    truevalue1409.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1410.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3192:2: ( ( extensionsNotBCNotKeyUsageNotSki )? ( basicConstraints truevalue extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? basicConstraints truevalue ( extensionsNotBCNotKeyUsageNotSki )? ) )
        // Grammar/RFC5280.g:3192:4: ( extensionsNotBCNotKeyUsageNotSki )? ( basicConstraints truevalue extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? basicConstraints truevalue ( extensionsNotBCNotKeyUsageNotSki )? )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // Grammar/RFC5280.g:3192:4: ( extensionsNotBCNotKeyUsageNotSki )?
            {
                int alt379=2;
                switch ( LA(1) )
                {
                    case SequenceTag:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case OIDTag:
                    		    	{
                    		    		switch ( LA(3) )
                    		    		{
                    		    		    case AIAOID:
                    		    		    case OIDAKI:
                    		    		    case OIDCERTPOL:
                    		    		    case OIDCRL:
                    		    		    case OIDEXTKEY:
                    		    		    case OIDFRESHCRL:
                    		    		    case OIDINHIBIT:
                    		    		    case OIDISSALT:
                    		    		    case OIDNAME:
                    		    		    case OIDPOLCONST:
                    		    		    case OIDPOLMAP:
                    		    		    case OIDSUBALT:
                    		    		    case OIDSUBDIR:
                    		    		    case PRINTABLE:
                    		    		    case SIAOID:
                    		    		    case VALUE:
                    		    		    	{
                    		    		    		alt379=1;
                    		    		    	}
                    		    		        break;
                    		    		}

                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt379)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3192:5: extensionsNotBCNotKeyUsageNotSki
            	    {
            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7818);
            	        extensionsNotBCNotKeyUsageNotSki1402=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1402.tree);

            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3192:40: ( basicConstraints truevalue extensionsNotBCNotKeyUsage | subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? basicConstraints truevalue ( extensionsNotBCNotKeyUsageNotSki )? )
            {
                int alt382=2;
                switch ( LA(1) )
                {
                case SequenceTag:
                	{
                		switch ( LA(2) )
                		{
                		case OIDTag:
                			{
                				switch ( LA(3) )
                				{
                				case OIDBC:
                					{
                						alt382=1;
                					}
                				    break;
                				case OIDSKI:
                					{
                						alt382=2;
                					}
                				    break;

                				default:
                				    CONSTRUCTEX();
                				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				    EXCEPTION->message      = (void *)"";
                				    EXCEPTION->decisionNum  = 382;
                				    EXCEPTION->state        = 2;


                				    goto ruleextensionsMustBeCaAndSkiNoPathLenEx;

                				}

                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 382;
                		    EXCEPTION->state        = 1;


                		    goto ruleextensionsMustBeCaAndSkiNoPathLenEx;

                		}

                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 382;
                    EXCEPTION->state        = 0;


                    goto ruleextensionsMustBeCaAndSkiNoPathLenEx;

                }

                switch (alt382)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3192:41: basicConstraints truevalue extensionsNotBCNotKeyUsage
            	    {
            	        FOLLOWPUSH(FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7823);
            	        basicConstraints1403=basicConstraints(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraints1403.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7825);
            	        truevalue1404=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1404.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsMustBeCaAndSkiNoPathLen7829);
            	        extensionsNotBCNotKeyUsage1405=extensionsNotBCNotKeyUsage(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage1405.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3193:4: subjectKeyId ( extensionsNotBCNotKeyUsageNotSki )? basicConstraints truevalue ( extensionsNotBCNotKeyUsageNotSki )?
            	    {
            	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiNoPathLen7834);
            	        subjectKeyId1406=subjectKeyId(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1406.tree);

            	        // Grammar/RFC5280.g:3193:17: ( extensionsNotBCNotKeyUsageNotSki )?
            	        {
            	            int alt380=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case OIDTag:
            	                		    	{
            	                		    		switch ( LA(3) )
            	                		    		{
            	                		    		    case AIAOID:
            	                		    		    case OIDAKI:
            	                		    		    case OIDCERTPOL:
            	                		    		    case OIDCRL:
            	                		    		    case OIDEXTKEY:
            	                		    		    case OIDFRESHCRL:
            	                		    		    case OIDINHIBIT:
            	                		    		    case OIDISSALT:
            	                		    		    case OIDNAME:
            	                		    		    case OIDPOLCONST:
            	                		    		    case OIDPOLMAP:
            	                		    		    case OIDSUBALT:
            	                		    		    case OIDSUBDIR:
            	                		    		    case PRINTABLE:
            	                		    		    case SIAOID:
            	                		    		    case VALUE:
            	                		    		    	{
            	                		    		    		alt380=1;
            	                		    		    	}
            	                		    		        break;
            	                		    		}

            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt380)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3193:18: extensionsNotBCNotKeyUsageNotSki
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7837);
            	        	        extensionsNotBCNotKeyUsageNotSki1407=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCaAndSkiNoPathLenEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1407.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_basicConstraints_in_extensionsMustBeCaAndSkiNoPathLen7841);
            	        basicConstraints1408=basicConstraints(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraints1408.tree);

            	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCaAndSkiNoPathLen7843);
            	        truevalue1409=truevalue(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionsMustBeCaAndSkiNoPathLenEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1409.tree);

            	        {
            	            bc_ext->value->basic_constraints->is_ca = 1;
            	        }


            	        // Grammar/RFC5280.g:3193:127: ( extensionsNotBCNotKeyUsageNotSki )?
            	        {
            	            int alt381=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case OIDTag:
            	                		    	{
            	                		    		switch ( LA(3) )
            	                		    		{
            	                		    		    case AIAOID:
            	                		    		    case OIDAKI:
            	                		    		    case OIDCERTPOL:
            	                		    		    case OIDCRL:
            	                		    		    case OIDEXTKEY:
            	                		    		    case OIDFRESHCRL:
            	                		    		    case OIDINHIBIT:
            	                		    		    case OIDISSALT:
            	                		    		    case OIDNAME:
            	                		    		    case OIDPOLCONST:
            	                		    		    case OIDPOLMAP:
            	                		    		    case OIDSUBALT:
            	                		    		    case OIDSUBDIR:
            	                		    		    case PRINTABLE:
            	                		    		    case SIAOID:
            	                		    		    case VALUE:
            	                		    		    	{
            	                		    		    		alt381=1;
            	                		    		    	}
            	                		    		        break;
            	                		    		}

            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt381)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3193:128: extensionsNotBCNotKeyUsageNotSki
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaAndSkiNoPathLen7848);
            	        	        extensionsNotBCNotKeyUsageNotSki1410=extensionsNotBCNotKeyUsageNotSki(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionsMustBeCaAndSkiNoPathLenEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1410.tree);

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCaAndSkiNoPathLenEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCaAndSkiNoPathLenEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCaAndSkiNoPathLen */

/**
 * $ANTLR start extensionsMustBeCaSubAlt
 * Grammar/RFC5280.g:3196:1: extensionsMustBeCaSubAlt : ( extensionNoSubAlt extensionsMustBeCaSubAlt | dependentExtension extensionsMustBeCaSubAlt | keyUsageCommon ( bitstring extensionsMustBeCaNoPathLenSubAlt | bitstringCertSign extensionsMustBeCASubAlt ) | basicConstraintsCANoSkiSubAlt | subAltNameCritical extensionsMustBeCa );
 */
static RFC5280Parser_extensionsMustBeCaSubAlt_return
extensionsMustBeCaSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCaSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1411;
    #undef	RETURN_TYPE_extensionNoSubAlt1411
    #define	RETURN_TYPE_extensionNoSubAlt1411 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsMustBeCaSubAlt_return extensionsMustBeCaSubAlt1412;
    #undef	RETURN_TYPE_extensionsMustBeCaSubAlt1412
    #define	RETURN_TYPE_extensionsMustBeCaSubAlt1412 RFC5280Parser_extensionsMustBeCaSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1413;
    #undef	RETURN_TYPE_dependentExtension1413
    #define	RETURN_TYPE_dependentExtension1413 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaSubAlt_return extensionsMustBeCaSubAlt1414;
    #undef	RETURN_TYPE_extensionsMustBeCaSubAlt1414
    #define	RETURN_TYPE_extensionsMustBeCaSubAlt1414 RFC5280Parser_extensionsMustBeCaSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1415;
    #undef	RETURN_TYPE_keyUsageCommon1415
    #define	RETURN_TYPE_keyUsageCommon1415 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1416;
    #undef	RETURN_TYPE_bitstring1416
    #define	RETURN_TYPE_bitstring1416 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return extensionsMustBeCaNoPathLenSubAlt1417;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt1417
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt1417 RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1418;
    #undef	RETURN_TYPE_bitstringCertSign1418
    #define	RETURN_TYPE_bitstringCertSign1418 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsMustBeCASubAlt_return extensionsMustBeCASubAlt1419;
    #undef	RETURN_TYPE_extensionsMustBeCASubAlt1419
    #define	RETURN_TYPE_extensionsMustBeCASubAlt1419 RFC5280Parser_extensionsMustBeCASubAlt_return

    RFC5280Parser_basicConstraintsCANoSkiSubAlt_return basicConstraintsCANoSkiSubAlt1420;
    #undef	RETURN_TYPE_basicConstraintsCANoSkiSubAlt1420
    #define	RETURN_TYPE_basicConstraintsCANoSkiSubAlt1420 RFC5280Parser_basicConstraintsCANoSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1421;
    #undef	RETURN_TYPE_subAltNameCritical1421
    #define	RETURN_TYPE_subAltNameCritical1421 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsMustBeCa_return extensionsMustBeCa1422;
    #undef	RETURN_TYPE_extensionsMustBeCa1422
    #define	RETURN_TYPE_extensionsMustBeCa1422 RFC5280Parser_extensionsMustBeCa_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1411.tree = NULL;

    extensionsMustBeCaSubAlt1412.tree = NULL;

    dependentExtension1413.tree = NULL;

    extensionsMustBeCaSubAlt1414.tree = NULL;

    keyUsageCommon1415.tree = NULL;

    bitstring1416.tree = NULL;

    extensionsMustBeCaNoPathLenSubAlt1417.tree = NULL;

    bitstringCertSign1418.tree = NULL;

    extensionsMustBeCASubAlt1419.tree = NULL;

    basicConstraintsCANoSkiSubAlt1420.tree = NULL;

    subAltNameCritical1421.tree = NULL;

    extensionsMustBeCa1422.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3203:2: ( extensionNoSubAlt extensionsMustBeCaSubAlt | dependentExtension extensionsMustBeCaSubAlt | keyUsageCommon ( bitstring extensionsMustBeCaNoPathLenSubAlt | bitstringCertSign extensionsMustBeCASubAlt ) | basicConstraintsCANoSkiSubAlt | subAltNameCritical extensionsMustBeCa )

            ANTLR3_UINT32 alt384;

            alt384=5;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt384=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt384=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt384=3;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt384=4;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt384=5;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 384;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsMustBeCaSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 384;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsMustBeCaSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 384;
                EXCEPTION->state        = 0;


                goto ruleextensionsMustBeCaSubAltEx;

            }

            switch (alt384)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3203:4: extensionNoSubAlt extensionsMustBeCaSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaSubAlt7874);
        	        extensionNoSubAlt1411=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1411.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7876);
        	        extensionsMustBeCaSubAlt1412=extensionsMustBeCaSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaSubAlt1412.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3204:4: dependentExtension extensionsMustBeCaSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsMustBeCaSubAlt7881);
        	        dependentExtension1413=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1413.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaSubAlt7883);
        	        extensionsMustBeCaSubAlt1414=extensionsMustBeCaSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaSubAlt1414.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3205:4: keyUsageCommon ( bitstring extensionsMustBeCaNoPathLenSubAlt | bitstringCertSign extensionsMustBeCASubAlt )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsMustBeCaSubAlt7888);
        	        keyUsageCommon1415=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1415.tree);

        	        // Grammar/RFC5280.g:3205:19: ( bitstring extensionsMustBeCaNoPathLenSubAlt | bitstringCertSign extensionsMustBeCASubAlt )
        	        {
        	            int alt383=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt383=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt383=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt383=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 383;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsMustBeCaSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 383;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsMustBeCaSubAltEx;

        	            }

        	            switch (alt383)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3205:20: bitstring extensionsMustBeCaNoPathLenSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsMustBeCaSubAlt7891);
        	        	        bitstring1416=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1416.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring1416.text
        	        	            ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaSubAlt7895);
        	        	        extensionsMustBeCaNoPathLenSubAlt1417=extensionsMustBeCaNoPathLenSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLenSubAlt1417.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3205:118: bitstringCertSign extensionsMustBeCASubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsMustBeCaSubAlt7899);
        	        	        bitstringCertSign1418=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1418.tree);

        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCASubAlt_in_extensionsMustBeCaSubAlt7901);
        	        	        extensionsMustBeCASubAlt1419=extensionsMustBeCASubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCASubAlt1419.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3206:4: basicConstraintsCANoSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraintsCANoSkiSubAlt_in_extensionsMustBeCaSubAlt7907);
        	        basicConstraintsCANoSkiSubAlt1420=basicConstraintsCANoSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraintsCANoSkiSubAlt1420.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:3207:4: subAltNameCritical extensionsMustBeCa
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsMustBeCaSubAlt7912);
        	        subAltNameCritical1421=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1421.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaSubAlt7914);
        	        extensionsMustBeCa1422=extensionsMustBeCa(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCa1422.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCaSubAltEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCaSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCaSubAlt */

/**
 * $ANTLR start extensionsMustBeCa
 * Grammar/RFC5280.g:3210:1: extensionsMustBeCa : ( extension extensionsMustBeCa | dependentExtension extensionsMustBeCa | keyUsageCommon ( bitstring extensionsMustBeCaNoPathLen | bitstringCertSign extensionsMustBeCA ) | basicConstraintsCANoSki );
 */
static RFC5280Parser_extensionsMustBeCa_return
extensionsMustBeCa(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCa_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1423;
    #undef	RETURN_TYPE_extension1423
    #define	RETURN_TYPE_extension1423 RFC5280Parser_extension_return

    RFC5280Parser_extensionsMustBeCa_return extensionsMustBeCa1424;
    #undef	RETURN_TYPE_extensionsMustBeCa1424
    #define	RETURN_TYPE_extensionsMustBeCa1424 RFC5280Parser_extensionsMustBeCa_return

    RFC5280Parser_dependentExtension_return dependentExtension1425;
    #undef	RETURN_TYPE_dependentExtension1425
    #define	RETURN_TYPE_dependentExtension1425 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCa_return extensionsMustBeCa1426;
    #undef	RETURN_TYPE_extensionsMustBeCa1426
    #define	RETURN_TYPE_extensionsMustBeCa1426 RFC5280Parser_extensionsMustBeCa_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1427;
    #undef	RETURN_TYPE_keyUsageCommon1427
    #define	RETURN_TYPE_keyUsageCommon1427 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1428;
    #undef	RETURN_TYPE_bitstring1428
    #define	RETURN_TYPE_bitstring1428 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsMustBeCaNoPathLen_return extensionsMustBeCaNoPathLen1429;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLen1429
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLen1429 RFC5280Parser_extensionsMustBeCaNoPathLen_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1430;
    #undef	RETURN_TYPE_bitstringCertSign1430
    #define	RETURN_TYPE_bitstringCertSign1430 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsMustBeCA_return extensionsMustBeCA1431;
    #undef	RETURN_TYPE_extensionsMustBeCA1431
    #define	RETURN_TYPE_extensionsMustBeCA1431 RFC5280Parser_extensionsMustBeCA_return

    RFC5280Parser_basicConstraintsCANoSki_return basicConstraintsCANoSki1432;
    #undef	RETURN_TYPE_basicConstraintsCANoSki1432
    #define	RETURN_TYPE_basicConstraintsCANoSki1432 RFC5280Parser_basicConstraintsCANoSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1423.tree = NULL;

    extensionsMustBeCa1424.tree = NULL;

    dependentExtension1425.tree = NULL;

    extensionsMustBeCa1426.tree = NULL;

    keyUsageCommon1427.tree = NULL;

    bitstring1428.tree = NULL;

    extensionsMustBeCaNoPathLen1429.tree = NULL;

    bitstringCertSign1430.tree = NULL;

    extensionsMustBeCA1431.tree = NULL;

    basicConstraintsCANoSki1432.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3217:2: ( extension extensionsMustBeCa | dependentExtension extensionsMustBeCa | keyUsageCommon ( bitstring extensionsMustBeCaNoPathLen | bitstringCertSign extensionsMustBeCA ) | basicConstraintsCANoSki )

            ANTLR3_UINT32 alt386;

            alt386=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt386=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt386=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt386=3;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt386=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 386;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsMustBeCaEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 386;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsMustBeCaEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 386;
                EXCEPTION->state        = 0;


                goto ruleextensionsMustBeCaEx;

            }

            switch (alt386)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3217:4: extension extensionsMustBeCa
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsMustBeCa7937);
        	        extension1423=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1423.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7939);
        	        extensionsMustBeCa1424=extensionsMustBeCa(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCa1424.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3218:4: dependentExtension extensionsMustBeCa
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsMustBeCa7944);
        	        dependentExtension1425=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1425.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCa_in_extensionsMustBeCa7946);
        	        extensionsMustBeCa1426=extensionsMustBeCa(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCa1426.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3219:4: keyUsageCommon ( bitstring extensionsMustBeCaNoPathLen | bitstringCertSign extensionsMustBeCA )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsMustBeCa7951);
        	        keyUsageCommon1427=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1427.tree);

        	        // Grammar/RFC5280.g:3219:19: ( bitstring extensionsMustBeCaNoPathLen | bitstringCertSign extensionsMustBeCA )
        	        {
        	            int alt385=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt385=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt385=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt385=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 385;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsMustBeCaEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 385;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsMustBeCaEx;

        	            }

        	            switch (alt385)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3219:20: bitstring extensionsMustBeCaNoPathLen
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsMustBeCa7954);
        	        	        bitstring1428=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1428.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring1428.text
        	        	            ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCa7958);
        	        	        extensionsMustBeCaNoPathLen1429=extensionsMustBeCaNoPathLen(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLen1429.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3219:112: bitstringCertSign extensionsMustBeCA
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsMustBeCa7962);
        	        	        bitstringCertSign1430=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1430.tree);

        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCA_in_extensionsMustBeCa7964);
        	        	        extensionsMustBeCA1431=extensionsMustBeCA(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCA1431.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3220:4: basicConstraintsCANoSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraintsCANoSki_in_extensionsMustBeCa7970);
        	        basicConstraintsCANoSki1432=basicConstraintsCANoSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraintsCANoSki1432.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCaEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCaEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCa */

/**
 * $ANTLR start extensionsMustBeCaAndSkiSubAlt
 * Grammar/RFC5280.g:3222:1: extensionsMustBeCaAndSkiSubAlt : ( extensionNoSubAlt extensionsMustBeCaAndSkiSubAlt | dependentExtension extensionsMustBeCaAndSkiSubAlt | keyUsageCommon ( bitstring extensionsMustBeCaAndSkiNoPathLenSubAlt | bitstringCertSign extensionsMustBeCAandSkiSubAlt ) | basicConstraintsCASubAlt | subjectKeyId extensionsMustBeCaSubAlt | subAltNameCritical extensionsMustBeCaAndSki );
 */
static RFC5280Parser_extensionsMustBeCaAndSkiSubAlt_return
extensionsMustBeCaAndSkiSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCaAndSkiSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1433;
    #undef	RETURN_TYPE_extensionNoSubAlt1433
    #define	RETURN_TYPE_extensionNoSubAlt1433 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsMustBeCaAndSkiSubAlt_return extensionsMustBeCaAndSkiSubAlt1434;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSkiSubAlt1434
    #define	RETURN_TYPE_extensionsMustBeCaAndSkiSubAlt1434 RFC5280Parser_extensionsMustBeCaAndSkiSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1435;
    #undef	RETURN_TYPE_dependentExtension1435
    #define	RETURN_TYPE_dependentExtension1435 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaAndSkiSubAlt_return extensionsMustBeCaAndSkiSubAlt1436;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSkiSubAlt1436
    #define	RETURN_TYPE_extensionsMustBeCaAndSkiSubAlt1436 RFC5280Parser_extensionsMustBeCaAndSkiSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1437;
    #undef	RETURN_TYPE_keyUsageCommon1437
    #define	RETURN_TYPE_keyUsageCommon1437 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1438;
    #undef	RETURN_TYPE_bitstring1438
    #define	RETURN_TYPE_bitstring1438 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsMustBeCaAndSkiNoPathLenSubAlt_return extensionsMustBeCaAndSkiNoPathLenSubAlt1439;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLenSubAlt1439
    #define	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLenSubAlt1439 RFC5280Parser_extensionsMustBeCaAndSkiNoPathLenSubAlt_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1440;
    #undef	RETURN_TYPE_bitstringCertSign1440
    #define	RETURN_TYPE_bitstringCertSign1440 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsMustBeCAandSkiSubAlt_return extensionsMustBeCAandSkiSubAlt1441;
    #undef	RETURN_TYPE_extensionsMustBeCAandSkiSubAlt1441
    #define	RETURN_TYPE_extensionsMustBeCAandSkiSubAlt1441 RFC5280Parser_extensionsMustBeCAandSkiSubAlt_return

    RFC5280Parser_basicConstraintsCASubAlt_return basicConstraintsCASubAlt1442;
    #undef	RETURN_TYPE_basicConstraintsCASubAlt1442
    #define	RETURN_TYPE_basicConstraintsCASubAlt1442 RFC5280Parser_basicConstraintsCASubAlt_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1443;
    #undef	RETURN_TYPE_subjectKeyId1443
    #define	RETURN_TYPE_subjectKeyId1443 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsMustBeCaSubAlt_return extensionsMustBeCaSubAlt1444;
    #undef	RETURN_TYPE_extensionsMustBeCaSubAlt1444
    #define	RETURN_TYPE_extensionsMustBeCaSubAlt1444 RFC5280Parser_extensionsMustBeCaSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1445;
    #undef	RETURN_TYPE_subAltNameCritical1445
    #define	RETURN_TYPE_subAltNameCritical1445 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsMustBeCaAndSki_return extensionsMustBeCaAndSki1446;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSki1446
    #define	RETURN_TYPE_extensionsMustBeCaAndSki1446 RFC5280Parser_extensionsMustBeCaAndSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1433.tree = NULL;

    extensionsMustBeCaAndSkiSubAlt1434.tree = NULL;

    dependentExtension1435.tree = NULL;

    extensionsMustBeCaAndSkiSubAlt1436.tree = NULL;

    keyUsageCommon1437.tree = NULL;

    bitstring1438.tree = NULL;

    extensionsMustBeCaAndSkiNoPathLenSubAlt1439.tree = NULL;

    bitstringCertSign1440.tree = NULL;

    extensionsMustBeCAandSkiSubAlt1441.tree = NULL;

    basicConstraintsCASubAlt1442.tree = NULL;

    subjectKeyId1443.tree = NULL;

    extensionsMustBeCaSubAlt1444.tree = NULL;

    subAltNameCritical1445.tree = NULL;

    extensionsMustBeCaAndSki1446.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3229:2: ( extensionNoSubAlt extensionsMustBeCaAndSkiSubAlt | dependentExtension extensionsMustBeCaAndSkiSubAlt | keyUsageCommon ( bitstring extensionsMustBeCaAndSkiNoPathLenSubAlt | bitstringCertSign extensionsMustBeCAandSkiSubAlt ) | basicConstraintsCASubAlt | subjectKeyId extensionsMustBeCaSubAlt | subAltNameCritical extensionsMustBeCaAndSki )

            ANTLR3_UINT32 alt388;

            alt388=6;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt388=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt388=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt388=3;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt388=4;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt388=5;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt388=6;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 388;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsMustBeCaAndSkiSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 388;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsMustBeCaAndSkiSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 388;
                EXCEPTION->state        = 0;


                goto ruleextensionsMustBeCaAndSkiSubAltEx;

            }

            switch (alt388)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3229:4: extensionNoSubAlt extensionsMustBeCaAndSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaAndSkiSubAlt7991);
        	        extensionNoSubAlt1433=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1433.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt7993);
        	        extensionsMustBeCaAndSkiSubAlt1434=extensionsMustBeCaAndSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSkiSubAlt1434.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3230:4: dependentExtension extensionsMustBeCaAndSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsMustBeCaAndSkiSubAlt7998);
        	        dependentExtension1435=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1435.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8000);
        	        extensionsMustBeCaAndSkiSubAlt1436=extensionsMustBeCaAndSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSkiSubAlt1436.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3231:4: keyUsageCommon ( bitstring extensionsMustBeCaAndSkiNoPathLenSubAlt | bitstringCertSign extensionsMustBeCAandSkiSubAlt )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSkiSubAlt8005);
        	        keyUsageCommon1437=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1437.tree);

        	        // Grammar/RFC5280.g:3231:19: ( bitstring extensionsMustBeCaAndSkiNoPathLenSubAlt | bitstringCertSign extensionsMustBeCAandSkiSubAlt )
        	        {
        	            int alt387=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt387=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt387=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt387=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 387;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsMustBeCaAndSkiSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 387;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsMustBeCaAndSkiSubAltEx;

        	            }

        	            switch (alt387)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3231:20: bitstring extensionsMustBeCaAndSkiNoPathLenSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsMustBeCaAndSkiSubAlt8008);
        	        	        bitstring1438=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1438.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring1438.text
        	        	            ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSkiNoPathLenSubAlt_in_extensionsMustBeCaAndSkiSubAlt8012);
        	        	        extensionsMustBeCaAndSkiNoPathLenSubAlt1439=extensionsMustBeCaAndSkiNoPathLenSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSkiNoPathLenSubAlt1439.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3231:124: bitstringCertSign extensionsMustBeCAandSkiSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSkiSubAlt8016);
        	        	        bitstringCertSign1440=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1440.tree);

        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCAandSkiSubAlt_in_extensionsMustBeCaAndSkiSubAlt8018);
        	        	        extensionsMustBeCAandSkiSubAlt1441=extensionsMustBeCAandSkiSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCAandSkiSubAlt1441.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3232:4: basicConstraintsCASubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraintsCASubAlt_in_extensionsMustBeCaAndSkiSubAlt8024);
        	        basicConstraintsCASubAlt1442=basicConstraintsCASubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraintsCASubAlt1442.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:3233:4: subjectKeyId extensionsMustBeCaSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSkiSubAlt8029);
        	        subjectKeyId1443=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1443.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaSubAlt_in_extensionsMustBeCaAndSkiSubAlt8031);
        	        extensionsMustBeCaSubAlt1444=extensionsMustBeCaSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaSubAlt1444.tree);

        	    }
        	    break;
        	case 6:
        	    // Grammar/RFC5280.g:3234:4: subAltNameCritical extensionsMustBeCaAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsMustBeCaAndSkiSubAlt8036);
        	        subAltNameCritical1445=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1445.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSkiSubAlt8038);
        	        extensionsMustBeCaAndSki1446=extensionsMustBeCaAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSki1446.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCaAndSkiSubAltEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCaAndSkiSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCaAndSkiSubAlt */

/**
 * $ANTLR start extensionsMustBeCaAndSki
 * Grammar/RFC5280.g:3237:1: extensionsMustBeCaAndSki : ( extension extensionsMustBeCaAndSki | dependentExtension extensionsMustBeCaAndSki | keyUsageCommon ( bitstring extensionsMustBeCaAndSkiNoPathLen | bitstringCertSign extensionsMustBeCAandSki ) | basicConstraintsCA | subjectKeyId extensionsMustBeCa );
 */
static RFC5280Parser_extensionsMustBeCaAndSki_return
extensionsMustBeCaAndSki(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCaAndSki_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1447;
    #undef	RETURN_TYPE_extension1447
    #define	RETURN_TYPE_extension1447 RFC5280Parser_extension_return

    RFC5280Parser_extensionsMustBeCaAndSki_return extensionsMustBeCaAndSki1448;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSki1448
    #define	RETURN_TYPE_extensionsMustBeCaAndSki1448 RFC5280Parser_extensionsMustBeCaAndSki_return

    RFC5280Parser_dependentExtension_return dependentExtension1449;
    #undef	RETURN_TYPE_dependentExtension1449
    #define	RETURN_TYPE_dependentExtension1449 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaAndSki_return extensionsMustBeCaAndSki1450;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSki1450
    #define	RETURN_TYPE_extensionsMustBeCaAndSki1450 RFC5280Parser_extensionsMustBeCaAndSki_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1451;
    #undef	RETURN_TYPE_keyUsageCommon1451
    #define	RETURN_TYPE_keyUsageCommon1451 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1452;
    #undef	RETURN_TYPE_bitstring1452
    #define	RETURN_TYPE_bitstring1452 RFC5280Parser_bitstring_return

    RFC5280Parser_extensionsMustBeCaAndSkiNoPathLen_return extensionsMustBeCaAndSkiNoPathLen1453;
    #undef	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLen1453
    #define	RETURN_TYPE_extensionsMustBeCaAndSkiNoPathLen1453 RFC5280Parser_extensionsMustBeCaAndSkiNoPathLen_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1454;
    #undef	RETURN_TYPE_bitstringCertSign1454
    #define	RETURN_TYPE_bitstringCertSign1454 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsMustBeCAandSki_return extensionsMustBeCAandSki1455;
    #undef	RETURN_TYPE_extensionsMustBeCAandSki1455
    #define	RETURN_TYPE_extensionsMustBeCAandSki1455 RFC5280Parser_extensionsMustBeCAandSki_return

    RFC5280Parser_basicConstraintsCA_return basicConstraintsCA1456;
    #undef	RETURN_TYPE_basicConstraintsCA1456
    #define	RETURN_TYPE_basicConstraintsCA1456 RFC5280Parser_basicConstraintsCA_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1457;
    #undef	RETURN_TYPE_subjectKeyId1457
    #define	RETURN_TYPE_subjectKeyId1457 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsMustBeCa_return extensionsMustBeCa1458;
    #undef	RETURN_TYPE_extensionsMustBeCa1458
    #define	RETURN_TYPE_extensionsMustBeCa1458 RFC5280Parser_extensionsMustBeCa_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1447.tree = NULL;

    extensionsMustBeCaAndSki1448.tree = NULL;

    dependentExtension1449.tree = NULL;

    extensionsMustBeCaAndSki1450.tree = NULL;

    keyUsageCommon1451.tree = NULL;

    bitstring1452.tree = NULL;

    extensionsMustBeCaAndSkiNoPathLen1453.tree = NULL;

    bitstringCertSign1454.tree = NULL;

    extensionsMustBeCAandSki1455.tree = NULL;

    basicConstraintsCA1456.tree = NULL;

    subjectKeyId1457.tree = NULL;

    extensionsMustBeCa1458.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3244:2: ( extension extensionsMustBeCaAndSki | dependentExtension extensionsMustBeCaAndSki | keyUsageCommon ( bitstring extensionsMustBeCaAndSkiNoPathLen | bitstringCertSign extensionsMustBeCAandSki ) | basicConstraintsCA | subjectKeyId extensionsMustBeCa )

            ANTLR3_UINT32 alt390;

            alt390=5;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt390=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt390=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt390=3;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt390=4;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt390=5;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 390;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsMustBeCaAndSkiEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 390;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsMustBeCaAndSkiEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 390;
                EXCEPTION->state        = 0;


                goto ruleextensionsMustBeCaAndSkiEx;

            }

            switch (alt390)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3244:4: extension extensionsMustBeCaAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsMustBeCaAndSki8061);
        	        extension1447=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1447.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8063);
        	        extensionsMustBeCaAndSki1448=extensionsMustBeCaAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSki1448.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3245:4: dependentExtension extensionsMustBeCaAndSki
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsMustBeCaAndSki8068);
        	        dependentExtension1449=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1449.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSki_in_extensionsMustBeCaAndSki8070);
        	        extensionsMustBeCaAndSki1450=extensionsMustBeCaAndSki(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSki1450.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3246:4: keyUsageCommon ( bitstring extensionsMustBeCaAndSkiNoPathLen | bitstringCertSign extensionsMustBeCAandSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsMustBeCaAndSki8075);
        	        keyUsageCommon1451=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1451.tree);

        	        // Grammar/RFC5280.g:3246:19: ( bitstring extensionsMustBeCaAndSkiNoPathLen | bitstringCertSign extensionsMustBeCAandSki )
        	        {
        	            int alt389=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt389=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt389=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt389=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 389;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsMustBeCaAndSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 389;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsMustBeCaAndSkiEx;

        	            }

        	            switch (alt389)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3246:20: bitstring extensionsMustBeCaAndSkiNoPathLen
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsMustBeCaAndSki8078);
        	        	        bitstring1452=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1452.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring1452.text
        	        	            ;
        	        	        }


        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaAndSkiNoPathLen_in_extensionsMustBeCaAndSki8082);
        	        	        extensionsMustBeCaAndSkiNoPathLen1453=extensionsMustBeCaAndSkiNoPathLen(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaAndSkiNoPathLen1453.tree);

        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3246:118: bitstringCertSign extensionsMustBeCAandSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsMustBeCaAndSki8086);
        	        	        bitstringCertSign1454=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1454.tree);

        	        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCAandSki_in_extensionsMustBeCaAndSki8088);
        	        	        extensionsMustBeCAandSki1455=extensionsMustBeCAandSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCAandSki1455.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3247:4: basicConstraintsCA
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraintsCA_in_extensionsMustBeCaAndSki8094);
        	        basicConstraintsCA1456=basicConstraintsCA(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraintsCA1456.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:3248:4: subjectKeyId extensionsMustBeCa
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsMustBeCaAndSki8099);
        	        subjectKeyId1457=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1457.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCa_in_extensionsMustBeCaAndSki8101);
        	        extensionsMustBeCa1458=extensionsMustBeCa(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaAndSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCa1458.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCaAndSkiEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCaAndSkiEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCaAndSki */

/**
 * $ANTLR start extensionsMustBeCaNoPathLenSubAlt
 * Grammar/RFC5280.g:3250:1: extensionsMustBeCaNoPathLenSubAlt : ( extensionNoSubAlt extensionsMustBeCaNoPathLenSubAlt | dependentExtension extensionsMustBeCaNoPathLenSubAlt | basicConstraints truevalue extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical extensionsMustBeCaNoPathLen );
 */
static RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return
extensionsMustBeCaNoPathLenSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1459;
    #undef	RETURN_TYPE_extensionNoSubAlt1459
    #define	RETURN_TYPE_extensionNoSubAlt1459 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return extensionsMustBeCaNoPathLenSubAlt1460;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt1460
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt1460 RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1461;
    #undef	RETURN_TYPE_dependentExtension1461
    #define	RETURN_TYPE_dependentExtension1461 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return extensionsMustBeCaNoPathLenSubAlt1462;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt1462
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLenSubAlt1462 RFC5280Parser_extensionsMustBeCaNoPathLenSubAlt_return

    RFC5280Parser_basicConstraints_return basicConstraints1463;
    #undef	RETURN_TYPE_basicConstraints1463
    #define	RETURN_TYPE_basicConstraints1463 RFC5280Parser_basicConstraints_return

    RFC5280Parser_truevalue_return truevalue1464;
    #undef	RETURN_TYPE_truevalue1464
    #define	RETURN_TYPE_truevalue1464 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return extensionsNotBCNotKeyUsageNotSkiSubAlt1465;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1465
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1465 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1466;
    #undef	RETURN_TYPE_subAltNameCritical1466
    #define	RETURN_TYPE_subAltNameCritical1466 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsMustBeCaNoPathLen_return extensionsMustBeCaNoPathLen1467;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLen1467
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLen1467 RFC5280Parser_extensionsMustBeCaNoPathLen_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1459.tree = NULL;

    extensionsMustBeCaNoPathLenSubAlt1460.tree = NULL;

    dependentExtension1461.tree = NULL;

    extensionsMustBeCaNoPathLenSubAlt1462.tree = NULL;

    basicConstraints1463.tree = NULL;

    truevalue1464.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiSubAlt1465.tree = NULL;

    subAltNameCritical1466.tree = NULL;

    extensionsMustBeCaNoPathLen1467.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3257:2: ( extensionNoSubAlt extensionsMustBeCaNoPathLenSubAlt | dependentExtension extensionsMustBeCaNoPathLenSubAlt | basicConstraints truevalue extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical extensionsMustBeCaNoPathLen )

            ANTLR3_UINT32 alt391;

            alt391=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt391=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt391=2;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt391=3;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt391=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 391;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsMustBeCaNoPathLenSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 391;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsMustBeCaNoPathLenSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 391;
                EXCEPTION->state        = 0;


                goto ruleextensionsMustBeCaNoPathLenSubAltEx;

            }

            switch (alt391)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3257:4: extensionNoSubAlt extensionsMustBeCaNoPathLenSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8123);
        	        extensionNoSubAlt1459=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1459.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8125);
        	        extensionsMustBeCaNoPathLenSubAlt1460=extensionsMustBeCaNoPathLenSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLenSubAlt1460.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3258:4: dependentExtension extensionsMustBeCaNoPathLenSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLenSubAlt8130);
        	        dependentExtension1461=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1461.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLenSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8132);
        	        extensionsMustBeCaNoPathLenSubAlt1462=extensionsMustBeCaNoPathLenSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLenSubAlt1462.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3259:4: basicConstraints truevalue extensionsNotBCNotKeyUsageNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLenSubAlt8137);
        	        basicConstraints1463=basicConstraints(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraints1463.tree);

        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCaNoPathLenSubAlt8139);
        	        truevalue1464=truevalue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1464.tree);

        	        {
        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        }


        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsMustBeCaNoPathLenSubAlt8143);
        	        extensionsNotBCNotKeyUsageNotSkiSubAlt1465=extensionsNotBCNotKeyUsageNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiSubAlt1465.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3260:4: subAltNameCritical extensionsMustBeCaNoPathLen
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsMustBeCaNoPathLenSubAlt8148);
        	        subAltNameCritical1466=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1466.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLenSubAlt8150);
        	        extensionsMustBeCaNoPathLen1467=extensionsMustBeCaNoPathLen(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLen1467.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCaNoPathLenSubAltEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCaNoPathLenSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCaNoPathLenSubAlt */

/**
 * $ANTLR start extensionsMustBeCaNoPathLen
 * Grammar/RFC5280.g:3263:1: extensionsMustBeCaNoPathLen : ( extension extensionsMustBeCaNoPathLen | dependentExtension extensionsMustBeCaNoPathLen | basicConstraints truevalue ( extensionsNotBCNotKeyUsageNotSki )? );
 */
static RFC5280Parser_extensionsMustBeCaNoPathLen_return
extensionsMustBeCaNoPathLen(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsMustBeCaNoPathLen_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1468;
    #undef	RETURN_TYPE_extension1468
    #define	RETURN_TYPE_extension1468 RFC5280Parser_extension_return

    RFC5280Parser_extensionsMustBeCaNoPathLen_return extensionsMustBeCaNoPathLen1469;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLen1469
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLen1469 RFC5280Parser_extensionsMustBeCaNoPathLen_return

    RFC5280Parser_dependentExtension_return dependentExtension1470;
    #undef	RETURN_TYPE_dependentExtension1470
    #define	RETURN_TYPE_dependentExtension1470 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsMustBeCaNoPathLen_return extensionsMustBeCaNoPathLen1471;
    #undef	RETURN_TYPE_extensionsMustBeCaNoPathLen1471
    #define	RETURN_TYPE_extensionsMustBeCaNoPathLen1471 RFC5280Parser_extensionsMustBeCaNoPathLen_return

    RFC5280Parser_basicConstraints_return basicConstraints1472;
    #undef	RETURN_TYPE_basicConstraints1472
    #define	RETURN_TYPE_basicConstraints1472 RFC5280Parser_basicConstraints_return

    RFC5280Parser_truevalue_return truevalue1473;
    #undef	RETURN_TYPE_truevalue1473
    #define	RETURN_TYPE_truevalue1473 RFC5280Parser_truevalue_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1474;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1474
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1474 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1468.tree = NULL;

    extensionsMustBeCaNoPathLen1469.tree = NULL;

    dependentExtension1470.tree = NULL;

    extensionsMustBeCaNoPathLen1471.tree = NULL;

    basicConstraints1472.tree = NULL;

    truevalue1473.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1474.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3270:2: ( extension extensionsMustBeCaNoPathLen | dependentExtension extensionsMustBeCaNoPathLen | basicConstraints truevalue ( extensionsNotBCNotKeyUsageNotSki )? )

            ANTLR3_UINT32 alt393;

            alt393=3;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt393=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt393=2;
            					}
            				    break;
            				case OIDBC:
            					{
            						alt393=3;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 393;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsMustBeCaNoPathLenEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 393;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsMustBeCaNoPathLenEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 393;
                EXCEPTION->state        = 0;


                goto ruleextensionsMustBeCaNoPathLenEx;

            }

            switch (alt393)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3270:4: extension extensionsMustBeCaNoPathLen
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsMustBeCaNoPathLen8174);
        	        extension1468=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1468.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8176);
        	        extensionsMustBeCaNoPathLen1469=extensionsMustBeCaNoPathLen(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLen1469.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3271:4: dependentExtension extensionsMustBeCaNoPathLen
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsMustBeCaNoPathLen8181);
        	        dependentExtension1470=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1470.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsMustBeCaNoPathLen_in_extensionsMustBeCaNoPathLen8183);
        	        extensionsMustBeCaNoPathLen1471=extensionsMustBeCaNoPathLen(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsMustBeCaNoPathLen1471.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3272:4: basicConstraints truevalue ( extensionsNotBCNotKeyUsageNotSki )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_basicConstraints_in_extensionsMustBeCaNoPathLen8188);
        	        basicConstraints1472=basicConstraints(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, basicConstraints1472.tree);

        	        FOLLOWPUSH(FOLLOW_truevalue_in_extensionsMustBeCaNoPathLen8190);
        	        truevalue1473=truevalue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsMustBeCaNoPathLenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1473.tree);

        	        {
        	            bc_ext->value->basic_constraints->is_ca = 1;
        	        }


        	        // Grammar/RFC5280.g:3272:78: ( extensionsNotBCNotKeyUsageNotSki )?
        	        {
        	            int alt392=2;
        	            switch ( LA(1) )
        	            {
        	                case SequenceTag:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case OIDTag:
        	                		    	{
        	                		    		switch ( LA(3) )
        	                		    		{
        	                		    		    case AIAOID:
        	                		    		    case OIDAKI:
        	                		    		    case OIDCERTPOL:
        	                		    		    case OIDCRL:
        	                		    		    case OIDEXTKEY:
        	                		    		    case OIDFRESHCRL:
        	                		    		    case OIDINHIBIT:
        	                		    		    case OIDISSALT:
        	                		    		    case OIDNAME:
        	                		    		    case OIDPOLCONST:
        	                		    		    case OIDPOLMAP:
        	                		    		    case OIDSUBALT:
        	                		    		    case OIDSUBDIR:
        	                		    		    case PRINTABLE:
        	                		    		    case SIAOID:
        	                		    		    case VALUE:
        	                		    		    	{
        	                		    		    		alt392=1;
        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt392)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3272:79: extensionsNotBCNotKeyUsageNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsMustBeCaNoPathLen8195);
        	        	        extensionsNotBCNotKeyUsageNotSki1474=extensionsNotBCNotKeyUsageNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsMustBeCaNoPathLenEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1474.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsMustBeCaNoPathLenEx; /* Prevent compiler warnings */
    ruleextensionsMustBeCaNoPathLenEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsMustBeCaNoPathLen */

/**
 * $ANTLR start extensionsNotBCNotKeyUsageNotSkiSubAlt
 * Grammar/RFC5280.g:3276:1: extensionsNotBCNotKeyUsageNotSkiSubAlt : ( extensionNoSubAlt extensionsNotBCNotKeyUsageNotSkiSubAlt | dependentExtension extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical ( extensionsNotBCNotKeyUsageNotSki )? );
 */
static RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return
extensionsNotBCNotKeyUsageNotSkiSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1475;
    #undef	RETURN_TYPE_extensionNoSubAlt1475
    #define	RETURN_TYPE_extensionNoSubAlt1475 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return extensionsNotBCNotKeyUsageNotSkiSubAlt1476;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1476
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1476 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1477;
    #undef	RETURN_TYPE_dependentExtension1477
    #define	RETURN_TYPE_dependentExtension1477 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return extensionsNotBCNotKeyUsageNotSkiSubAlt1478;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1478
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1478 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1479;
    #undef	RETURN_TYPE_subAltNameCritical1479
    #define	RETURN_TYPE_subAltNameCritical1479 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1480;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1480
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1480 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1475.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiSubAlt1476.tree = NULL;

    dependentExtension1477.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiSubAlt1478.tree = NULL;

    subAltNameCritical1479.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1480.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3282:2: ( extensionNoSubAlt extensionsNotBCNotKeyUsageNotSkiSubAlt | dependentExtension extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical ( extensionsNotBCNotKeyUsageNotSki )? )

            ANTLR3_UINT32 alt395;

            alt395=3;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt395=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt395=2;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt395=3;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 395;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 395;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 395;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx;

            }

            switch (alt395)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3283:3: extensionNoSubAlt extensionsNotBCNotKeyUsageNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8222);
        	        extensionNoSubAlt1475=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1475.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8224);
        	        extensionsNotBCNotKeyUsageNotSkiSubAlt1476=extensionsNotBCNotKeyUsageNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiSubAlt1476.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3284:4: dependentExtension extensionsNotBCNotKeyUsageNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8229);
        	        dependentExtension1477=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1477.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8231);
        	        extensionsNotBCNotKeyUsageNotSkiSubAlt1478=extensionsNotBCNotKeyUsageNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiSubAlt1478.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3285:4: subAltNameCritical ( extensionsNotBCNotKeyUsageNotSki )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8237);
        	        subAltNameCritical1479=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1479.tree);

        	        // Grammar/RFC5280.g:3285:23: ( extensionsNotBCNotKeyUsageNotSki )?
        	        {
        	            int alt394=2;
        	            switch ( LA(1) )
        	            {
        	                case SequenceTag:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case OIDTag:
        	                		    	{
        	                		    		switch ( LA(3) )
        	                		    		{
        	                		    		    case AIAOID:
        	                		    		    case OIDAKI:
        	                		    		    case OIDCERTPOL:
        	                		    		    case OIDCRL:
        	                		    		    case OIDEXTKEY:
        	                		    		    case OIDFRESHCRL:
        	                		    		    case OIDINHIBIT:
        	                		    		    case OIDISSALT:
        	                		    		    case OIDNAME:
        	                		    		    case OIDPOLCONST:
        	                		    		    case OIDPOLMAP:
        	                		    		    case OIDSUBALT:
        	                		    		    case OIDSUBDIR:
        	                		    		    case PRINTABLE:
        	                		    		    case SIAOID:
        	                		    		    case VALUE:
        	                		    		    	{
        	                		    		    		alt394=1;
        	                		    		    	}
        	                		    		        break;
        	                		    		}

        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt394)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3285:23: extensionsNotBCNotKeyUsageNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSkiSubAlt8239);
        	        	        extensionsNotBCNotKeyUsageNotSki1480=extensionsNotBCNotKeyUsageNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1480.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNotBCNotKeyUsageNotSkiSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotBCNotKeyUsageNotSkiSubAlt */

/**
 * $ANTLR start extensionsNotBCNotKeyUsageNotSki
 * Grammar/RFC5280.g:3287:1: extensionsNotBCNotKeyUsageNotSki : ( extension (| extensionsNotBCNotKeyUsageNotSki ) | dependentExtension (| extensionsNotBCNotKeyUsageNotSki ) );
 */
static RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return
extensionsNotBCNotKeyUsageNotSki(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1481;
    #undef	RETURN_TYPE_extension1481
    #define	RETURN_TYPE_extension1481 RFC5280Parser_extension_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1482;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1482
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1482 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return

    RFC5280Parser_dependentExtension_return dependentExtension1483;
    #undef	RETURN_TYPE_dependentExtension1483
    #define	RETURN_TYPE_dependentExtension1483 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1484;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1484
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1484 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1481.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1482.tree = NULL;

    dependentExtension1483.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1484.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3293:2: ( extension (| extensionsNotBCNotKeyUsageNotSki ) | dependentExtension (| extensionsNotBCNotKeyUsageNotSki ) )

            ANTLR3_UINT32 alt398;

            alt398=2;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt398=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt398=2;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 398;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotBCNotKeyUsageNotSkiEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 398;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotBCNotKeyUsageNotSkiEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 398;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotBCNotKeyUsageNotSkiEx;

            }

            switch (alt398)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3294:3: extension (| extensionsNotBCNotKeyUsageNotSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsNotBCNotKeyUsageNotSki8262);
        	        extension1481=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageNotSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1481.tree);

        	        // Grammar/RFC5280.g:3294:13: (| extensionsNotBCNotKeyUsageNotSki )
        	        {
        	            int alt396=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case OIDBC:
        	            				case OIDSKI:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt396=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt396=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 396;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCNotKeyUsageNotSkiEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 396;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCNotKeyUsageNotSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 396;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotKeyUsageNotSkiEx;

        	            }

        	            switch (alt396)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3294:15: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3294:17: extensionsNotBCNotKeyUsageNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8268);
        	        	        extensionsNotBCNotKeyUsageNotSki1482=extensionsNotBCNotKeyUsageNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotKeyUsageNotSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1482.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3295:4: dependentExtension (| extensionsNotBCNotKeyUsageNotSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSki8274);
        	        dependentExtension1483=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageNotSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1483.tree);

        	        // Grammar/RFC5280.g:3295:23: (| extensionsNotBCNotKeyUsageNotSki )
        	        {
        	            int alt397=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case OIDBC:
        	            				case OIDSKI:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt397=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt397=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 397;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCNotKeyUsageNotSkiEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 397;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCNotKeyUsageNotSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 397;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotKeyUsageNotSkiEx;

        	            }

        	            switch (alt397)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3295:25: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3295:27: extensionsNotBCNotKeyUsageNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsageNotSki8280);
        	        	        extensionsNotBCNotKeyUsageNotSki1484=extensionsNotBCNotKeyUsageNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotKeyUsageNotSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1484.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotBCNotKeyUsageNotSkiEx; /* Prevent compiler warnings */
    ruleextensionsNotBCNotKeyUsageNotSkiEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotBCNotKeyUsageNotSki */

/**
 * $ANTLR start extensionsNotBCNotKeyUsageNotSkiNoSubAlt
 * Grammar/RFC5280.g:3297:1: extensionsNotBCNotKeyUsageNotSkiNoSubAlt : ( extensionNoSubAlt (| extensionsNotBCNotKeyUsageNotSkiNoSubAlt ) | dependentExtension (| extensionsNotBCNotKeyUsageNotSkiNoSubAlt ) );
 */
static RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return
extensionsNotBCNotKeyUsageNotSkiNoSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1485;
    #undef	RETURN_TYPE_extensionNoSubAlt1485
    #define	RETURN_TYPE_extensionNoSubAlt1485 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return extensionsNotBCNotKeyUsageNotSkiNoSubAlt1486;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1486
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1486 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1487;
    #undef	RETURN_TYPE_dependentExtension1487
    #define	RETURN_TYPE_dependentExtension1487 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return extensionsNotBCNotKeyUsageNotSkiNoSubAlt1488;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1488
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiNoSubAlt1488 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1485.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiNoSubAlt1486.tree = NULL;

    dependentExtension1487.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiNoSubAlt1488.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3303:2: ( extensionNoSubAlt (| extensionsNotBCNotKeyUsageNotSkiNoSubAlt ) | dependentExtension (| extensionsNotBCNotKeyUsageNotSkiNoSubAlt ) )

            ANTLR3_UINT32 alt401;

            alt401=2;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt401=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt401=2;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 401;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 401;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 401;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;

            }

            switch (alt401)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3304:3: extensionNoSubAlt (| extensionsNotBCNotKeyUsageNotSkiNoSubAlt )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8305);
        	        extensionNoSubAlt1485=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1485.tree);

        	        // Grammar/RFC5280.g:3304:21: (| extensionsNotBCNotKeyUsageNotSkiNoSubAlt )
        	        {
        	            int alt399=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case OIDBC:
        	            				case OIDSKI:
        	            				case OIDSUBALT:
        	            					{
        	            						alt399=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt399=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 399;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 399;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 399;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;

        	            }

        	            switch (alt399)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3304:23: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3304:25: extensionsNotBCNotKeyUsageNotSkiNoSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8311);
        	        	        extensionsNotBCNotKeyUsageNotSkiNoSubAlt1486=extensionsNotBCNotKeyUsageNotSkiNoSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiNoSubAlt1486.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3305:4: dependentExtension (| extensionsNotBCNotKeyUsageNotSkiNoSubAlt )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8317);
        	        dependentExtension1487=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1487.tree);

        	        // Grammar/RFC5280.g:3305:23: (| extensionsNotBCNotKeyUsageNotSkiNoSubAlt )
        	        {
        	            int alt400=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case OIDBC:
        	            				case OIDSKI:
        	            				case OIDSUBALT:
        	            					{
        	            						alt400=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt400=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 400;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 400;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 400;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;

        	            }

        	            switch (alt400)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3305:25: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3305:27: extensionsNotBCNotKeyUsageNotSkiNoSubAlt
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiNoSubAlt_in_extensionsNotBCNotKeyUsageNotSkiNoSubAlt8323);
        	        	        extensionsNotBCNotKeyUsageNotSkiNoSubAlt1488=extensionsNotBCNotKeyUsageNotSkiNoSubAlt(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiNoSubAlt1488.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNotBCNotKeyUsageNotSkiNoSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotBCNotKeyUsageNotSkiNoSubAlt */

/**
 * $ANTLR start extensionsNotBCNotKeyUsageSubAlt
 * Grammar/RFC5280.g:3307:1: extensionsNotBCNotKeyUsageSubAlt : ( extensionNoSubAlt extensionsNotBCNotKeyUsageSubAlt | dependentExtension extensionsNotBCNotKeyUsageSubAlt | subjectKeyId extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical extensionsNotBCNotKeyUsage );
 */
static RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return
extensionsNotBCNotKeyUsageSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1489;
    #undef	RETURN_TYPE_extensionNoSubAlt1489
    #define	RETURN_TYPE_extensionNoSubAlt1489 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return extensionsNotBCNotKeyUsageSubAlt1490;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1490
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1490 RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1491;
    #undef	RETURN_TYPE_dependentExtension1491
    #define	RETURN_TYPE_dependentExtension1491 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return extensionsNotBCNotKeyUsageSubAlt1492;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1492
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1492 RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1493;
    #undef	RETURN_TYPE_subjectKeyId1493
    #define	RETURN_TYPE_subjectKeyId1493 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return extensionsNotBCNotKeyUsageNotSkiSubAlt1494;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1494
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1494 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1495;
    #undef	RETURN_TYPE_subAltNameCritical1495
    #define	RETURN_TYPE_subAltNameCritical1495 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage1496;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage1496
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage1496 RFC5280Parser_extensionsNotBCNotKeyUsage_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1489.tree = NULL;

    extensionsNotBCNotKeyUsageSubAlt1490.tree = NULL;

    dependentExtension1491.tree = NULL;

    extensionsNotBCNotKeyUsageSubAlt1492.tree = NULL;

    subjectKeyId1493.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiSubAlt1494.tree = NULL;

    subAltNameCritical1495.tree = NULL;

    extensionsNotBCNotKeyUsage1496.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3313:2: ( extensionNoSubAlt extensionsNotBCNotKeyUsageSubAlt | dependentExtension extensionsNotBCNotKeyUsageSubAlt | subjectKeyId extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical extensionsNotBCNotKeyUsage )

            ANTLR3_UINT32 alt402;

            alt402=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt402=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt402=2;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt402=3;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt402=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 402;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotBCNotKeyUsageSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 402;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotBCNotKeyUsageSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 402;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotBCNotKeyUsageSubAltEx;

            }

            switch (alt402)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3314:3: extensionNoSubAlt extensionsNotBCNotKeyUsageSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8347);
        	        extensionNoSubAlt1489=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1489.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8349);
        	        extensionsNotBCNotKeyUsageSubAlt1490=extensionsNotBCNotKeyUsageSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageSubAlt1490.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3315:4: dependentExtension extensionsNotBCNotKeyUsageSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsageSubAlt8354);
        	        dependentExtension1491=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1491.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8356);
        	        extensionsNotBCNotKeyUsageSubAlt1492=extensionsNotBCNotKeyUsageSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageSubAlt1492.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3316:4: subjectKeyId extensionsNotBCNotKeyUsageNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsageSubAlt8362);
        	        subjectKeyId1493=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1493.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotKeyUsageSubAlt8364);
        	        extensionsNotBCNotKeyUsageNotSkiSubAlt1494=extensionsNotBCNotKeyUsageNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiSubAlt1494.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3317:4: subAltNameCritical extensionsNotBCNotKeyUsage
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsNotBCNotKeyUsageSubAlt8369);
        	        subAltNameCritical1495=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1495.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsageSubAlt8371);
        	        extensionsNotBCNotKeyUsage1496=extensionsNotBCNotKeyUsage(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage1496.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotBCNotKeyUsageSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNotBCNotKeyUsageSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotBCNotKeyUsageSubAlt */

/**
 * $ANTLR start extensionsNotBCNotKeyUsage
 * Grammar/RFC5280.g:3320:1: extensionsNotBCNotKeyUsage : ( extension extensionsNotBCNotKeyUsage | dependentExtension extensionsNotBCNotKeyUsage | subjectKeyId (| extensionsNotBCNotKeyUsageNotSki ) );
 */
static RFC5280Parser_extensionsNotBCNotKeyUsage_return
extensionsNotBCNotKeyUsage(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotBCNotKeyUsage_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1497;
    #undef	RETURN_TYPE_extension1497
    #define	RETURN_TYPE_extension1497 RFC5280Parser_extension_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage1498;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage1498
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage1498 RFC5280Parser_extensionsNotBCNotKeyUsage_return

    RFC5280Parser_dependentExtension_return dependentExtension1499;
    #undef	RETURN_TYPE_dependentExtension1499
    #define	RETURN_TYPE_dependentExtension1499 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage1500;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage1500
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage1500 RFC5280Parser_extensionsNotBCNotKeyUsage_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1501;
    #undef	RETURN_TYPE_subjectKeyId1501
    #define	RETURN_TYPE_subjectKeyId1501 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1502;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1502
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1502 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1497.tree = NULL;

    extensionsNotBCNotKeyUsage1498.tree = NULL;

    dependentExtension1499.tree = NULL;

    extensionsNotBCNotKeyUsage1500.tree = NULL;

    subjectKeyId1501.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1502.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3326:2: ( extension extensionsNotBCNotKeyUsage | dependentExtension extensionsNotBCNotKeyUsage | subjectKeyId (| extensionsNotBCNotKeyUsageNotSki ) )

            ANTLR3_UINT32 alt404;

            alt404=3;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt404=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt404=2;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt404=3;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 404;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotBCNotKeyUsageEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 404;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotBCNotKeyUsageEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 404;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotBCNotKeyUsageEx;

            }

            switch (alt404)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3327:3: extension extensionsNotBCNotKeyUsage
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsNotBCNotKeyUsage8394);
        	        extension1497=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1497.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8396);
        	        extensionsNotBCNotKeyUsage1498=extensionsNotBCNotKeyUsage(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage1498.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3328:4: dependentExtension extensionsNotBCNotKeyUsage
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotBCNotKeyUsage8401);
        	        dependentExtension1499=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1499.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBCNotKeyUsage8403);
        	        extensionsNotBCNotKeyUsage1500=extensionsNotBCNotKeyUsage(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage1500.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3329:4: subjectKeyId (| extensionsNotBCNotKeyUsageNotSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsNotBCNotKeyUsage8409);
        	        subjectKeyId1501=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotKeyUsageEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1501.tree);

        	        // Grammar/RFC5280.g:3329:17: (| extensionsNotBCNotKeyUsageNotSki )
        	        {
        	            int alt403=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt403=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt403=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 403;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCNotKeyUsageEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 403;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCNotKeyUsageEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 403;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotKeyUsageEx;

        	            }

        	            switch (alt403)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3329:19: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3329:20: extensionsNotBCNotKeyUsageNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotKeyUsage8414);
        	        	        extensionsNotBCNotKeyUsageNotSki1502=extensionsNotBCNotKeyUsageNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotKeyUsageEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1502.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotBCNotKeyUsageEx; /* Prevent compiler warnings */
    ruleextensionsNotBCNotKeyUsageEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotBCNotKeyUsage */

/**
 * $ANTLR start extensionsNotBCSubAlt
 * Grammar/RFC5280.g:3331:1: extensionsNotBCSubAlt : ( extensionNoSubAlt extensionsNotBCSubAlt | dependentExtension extensionsNotBCSubAlt | keyUsageCommon ( bitstring | bitstringCertSign ) extensionsNotBCNotKeyUsageSubAlt | subjectKeyId extensionsNotBCNotSkiSubAlt | subAltNameCritical extensionsNotBC );
 */
static RFC5280Parser_extensionsNotBCSubAlt_return
extensionsNotBCSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotBCSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1503;
    #undef	RETURN_TYPE_extensionNoSubAlt1503
    #define	RETURN_TYPE_extensionNoSubAlt1503 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNotBCSubAlt_return extensionsNotBCSubAlt1504;
    #undef	RETURN_TYPE_extensionsNotBCSubAlt1504
    #define	RETURN_TYPE_extensionsNotBCSubAlt1504 RFC5280Parser_extensionsNotBCSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1505;
    #undef	RETURN_TYPE_dependentExtension1505
    #define	RETURN_TYPE_dependentExtension1505 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotBCSubAlt_return extensionsNotBCSubAlt1506;
    #undef	RETURN_TYPE_extensionsNotBCSubAlt1506
    #define	RETURN_TYPE_extensionsNotBCSubAlt1506 RFC5280Parser_extensionsNotBCSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1507;
    #undef	RETURN_TYPE_keyUsageCommon1507
    #define	RETURN_TYPE_keyUsageCommon1507 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1508;
    #undef	RETURN_TYPE_bitstring1508
    #define	RETURN_TYPE_bitstring1508 RFC5280Parser_bitstring_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1509;
    #undef	RETURN_TYPE_bitstringCertSign1509
    #define	RETURN_TYPE_bitstringCertSign1509 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return extensionsNotBCNotKeyUsageSubAlt1510;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1510
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageSubAlt1510 RFC5280Parser_extensionsNotBCNotKeyUsageSubAlt_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1511;
    #undef	RETURN_TYPE_subjectKeyId1511
    #define	RETURN_TYPE_subjectKeyId1511 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNotBCNotSkiSubAlt_return extensionsNotBCNotSkiSubAlt1512;
    #undef	RETURN_TYPE_extensionsNotBCNotSkiSubAlt1512
    #define	RETURN_TYPE_extensionsNotBCNotSkiSubAlt1512 RFC5280Parser_extensionsNotBCNotSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1513;
    #undef	RETURN_TYPE_subAltNameCritical1513
    #define	RETURN_TYPE_subAltNameCritical1513 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNotBC_return extensionsNotBC1514;
    #undef	RETURN_TYPE_extensionsNotBC1514
    #define	RETURN_TYPE_extensionsNotBC1514 RFC5280Parser_extensionsNotBC_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1503.tree = NULL;

    extensionsNotBCSubAlt1504.tree = NULL;

    dependentExtension1505.tree = NULL;

    extensionsNotBCSubAlt1506.tree = NULL;

    keyUsageCommon1507.tree = NULL;

    bitstring1508.tree = NULL;

    bitstringCertSign1509.tree = NULL;

    extensionsNotBCNotKeyUsageSubAlt1510.tree = NULL;

    subjectKeyId1511.tree = NULL;

    extensionsNotBCNotSkiSubAlt1512.tree = NULL;

    subAltNameCritical1513.tree = NULL;

    extensionsNotBC1514.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3338:2: ( extensionNoSubAlt extensionsNotBCSubAlt | dependentExtension extensionsNotBCSubAlt | keyUsageCommon ( bitstring | bitstringCertSign ) extensionsNotBCNotKeyUsageSubAlt | subjectKeyId extensionsNotBCNotSkiSubAlt | subAltNameCritical extensionsNotBC )

            ANTLR3_UINT32 alt406;

            alt406=5;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt406=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt406=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt406=3;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt406=4;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt406=5;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 406;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotBCSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 406;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotBCSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 406;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotBCSubAltEx;

            }

            switch (alt406)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3339:3: extensionNoSubAlt extensionsNotBCSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNotBCSubAlt8438);
        	        extensionNoSubAlt1503=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1503.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8440);
        	        extensionsNotBCSubAlt1504=extensionsNotBCSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCSubAlt1504.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3340:4: dependentExtension extensionsNotBCSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotBCSubAlt8445);
        	        dependentExtension1505=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1505.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCSubAlt_in_extensionsNotBCSubAlt8447);
        	        extensionsNotBCSubAlt1506=extensionsNotBCSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCSubAlt1506.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3341:4: keyUsageCommon ( bitstring | bitstringCertSign ) extensionsNotBCNotKeyUsageSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNotBCSubAlt8452);
        	        keyUsageCommon1507=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1507.tree);

        	        // Grammar/RFC5280.g:3341:19: ( bitstring | bitstringCertSign )
        	        {
        	            int alt405=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt405=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt405=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt405=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 405;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsNotBCSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 405;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCSubAltEx;

        	            }

        	            switch (alt405)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3341:20: bitstring
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNotBCSubAlt8455);
        	        	        bitstring1508=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1508.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring1508.text
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3341:83: bitstringCertSign
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsNotBCSubAlt8460);
        	        	        bitstringCertSign1509=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1509.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageSubAlt_in_extensionsNotBCSubAlt8463);
        	        extensionsNotBCNotKeyUsageSubAlt1510=extensionsNotBCNotKeyUsageSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageSubAlt1510.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3342:4: subjectKeyId extensionsNotBCNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsNotBCSubAlt8468);
        	        subjectKeyId1511=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1511.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCSubAlt8470);
        	        extensionsNotBCNotSkiSubAlt1512=extensionsNotBCNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSkiSubAlt1512.tree);

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:3343:4: subAltNameCritical extensionsNotBC
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsNotBCSubAlt8475);
        	        subAltNameCritical1513=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1513.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBC_in_extensionsNotBCSubAlt8477);
        	        extensionsNotBC1514=extensionsNotBC(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBC1514.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotBCSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNotBCSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotBCSubAlt */

/**
 * $ANTLR start extensionsNotBC
 * Grammar/RFC5280.g:3346:1: extensionsNotBC : ( extension extensionsNotBC | dependentExtension extensionsNotBC | keyUsageCommon ( bitstring | bitstringCertSign ) extensionsNotBCNotKeyUsage | subjectKeyId (| extensionsNotBCNotSki ) );
 */
static RFC5280Parser_extensionsNotBC_return
extensionsNotBC(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotBC_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1515;
    #undef	RETURN_TYPE_extension1515
    #define	RETURN_TYPE_extension1515 RFC5280Parser_extension_return

    RFC5280Parser_extensionsNotBC_return extensionsNotBC1516;
    #undef	RETURN_TYPE_extensionsNotBC1516
    #define	RETURN_TYPE_extensionsNotBC1516 RFC5280Parser_extensionsNotBC_return

    RFC5280Parser_dependentExtension_return dependentExtension1517;
    #undef	RETURN_TYPE_dependentExtension1517
    #define	RETURN_TYPE_dependentExtension1517 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotBC_return extensionsNotBC1518;
    #undef	RETURN_TYPE_extensionsNotBC1518
    #define	RETURN_TYPE_extensionsNotBC1518 RFC5280Parser_extensionsNotBC_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1519;
    #undef	RETURN_TYPE_keyUsageCommon1519
    #define	RETURN_TYPE_keyUsageCommon1519 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1520;
    #undef	RETURN_TYPE_bitstring1520
    #define	RETURN_TYPE_bitstring1520 RFC5280Parser_bitstring_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1521;
    #undef	RETURN_TYPE_bitstringCertSign1521
    #define	RETURN_TYPE_bitstringCertSign1521 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsNotBCNotKeyUsage_return extensionsNotBCNotKeyUsage1522;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsage1522
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsage1522 RFC5280Parser_extensionsNotBCNotKeyUsage_return

    RFC5280Parser_subjectKeyId_return subjectKeyId1523;
    #undef	RETURN_TYPE_subjectKeyId1523
    #define	RETURN_TYPE_subjectKeyId1523 RFC5280Parser_subjectKeyId_return

    RFC5280Parser_extensionsNotBCNotSki_return extensionsNotBCNotSki1524;
    #undef	RETURN_TYPE_extensionsNotBCNotSki1524
    #define	RETURN_TYPE_extensionsNotBCNotSki1524 RFC5280Parser_extensionsNotBCNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1515.tree = NULL;

    extensionsNotBC1516.tree = NULL;

    dependentExtension1517.tree = NULL;

    extensionsNotBC1518.tree = NULL;

    keyUsageCommon1519.tree = NULL;

    bitstring1520.tree = NULL;

    bitstringCertSign1521.tree = NULL;

    extensionsNotBCNotKeyUsage1522.tree = NULL;

    subjectKeyId1523.tree = NULL;

    extensionsNotBCNotSki1524.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3353:2: ( extension extensionsNotBC | dependentExtension extensionsNotBC | keyUsageCommon ( bitstring | bitstringCertSign ) extensionsNotBCNotKeyUsage | subjectKeyId (| extensionsNotBCNotSki ) )

            ANTLR3_UINT32 alt409;

            alt409=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt409=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt409=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt409=3;
            					}
            				    break;
            				case OIDSKI:
            					{
            						alt409=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 409;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotBCEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 409;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotBCEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 409;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotBCEx;

            }

            switch (alt409)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3353:4: extension extensionsNotBC
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsNotBC8500);
        	        extension1515=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1515.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBC_in_extensionsNotBC8502);
        	        extensionsNotBC1516=extensionsNotBC(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBC1516.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3354:4: dependentExtension extensionsNotBC
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotBC8507);
        	        dependentExtension1517=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1517.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBC_in_extensionsNotBC8509);
        	        extensionsNotBC1518=extensionsNotBC(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBC1518.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3355:4: keyUsageCommon ( bitstring | bitstringCertSign ) extensionsNotBCNotKeyUsage
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNotBC8514);
        	        keyUsageCommon1519=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1519.tree);

        	        // Grammar/RFC5280.g:3355:19: ( bitstring | bitstringCertSign )
        	        {
        	            int alt407=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt407=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt407=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt407=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 407;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsNotBCEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 407;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCEx;

        	            }

        	            switch (alt407)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3355:20: bitstring
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNotBC8517);
        	        	        bitstring1520=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1520.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring1520.text
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3355:83: bitstringCertSign
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsNotBC8522);
        	        	        bitstringCertSign1521=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1521.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsage_in_extensionsNotBC8525);
        	        extensionsNotBCNotKeyUsage1522=extensionsNotBCNotKeyUsage(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsage1522.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3356:4: subjectKeyId (| extensionsNotBCNotSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subjectKeyId_in_extensionsNotBC8530);
        	        subjectKeyId1523=subjectKeyId(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subjectKeyId1523.tree);

        	        // Grammar/RFC5280.g:3356:17: (| extensionsNotBCNotSki )
        	        {
        	            int alt408=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt408=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt408=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 408;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 408;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 408;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCEx;

        	            }

        	            switch (alt408)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3356:19: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3356:20: extensionsNotBCNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSki_in_extensionsNotBC8535);
        	        	        extensionsNotBCNotSki1524=extensionsNotBCNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSki1524.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotBCEx; /* Prevent compiler warnings */
    ruleextensionsNotBCEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotBC */

/**
 * $ANTLR start extensionsNotBCNotSkiSubAlt
 * Grammar/RFC5280.g:3359:1: extensionsNotBCNotSkiSubAlt : ( extensionNoSubAlt extensionsNotBCNotSkiSubAlt | dependentExtension extensionsNotBCNotSkiSubAlt | keyUsageCommon ( bitstring | bitstringCertSign ) extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical (| extensionsNotBCNotSki ) );
 */
static RFC5280Parser_extensionsNotBCNotSkiSubAlt_return
extensionsNotBCNotSkiSubAlt(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotBCNotSkiSubAlt_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extensionNoSubAlt_return extensionNoSubAlt1525;
    #undef	RETURN_TYPE_extensionNoSubAlt1525
    #define	RETURN_TYPE_extensionNoSubAlt1525 RFC5280Parser_extensionNoSubAlt_return

    RFC5280Parser_extensionsNotBCNotSkiSubAlt_return extensionsNotBCNotSkiSubAlt1526;
    #undef	RETURN_TYPE_extensionsNotBCNotSkiSubAlt1526
    #define	RETURN_TYPE_extensionsNotBCNotSkiSubAlt1526 RFC5280Parser_extensionsNotBCNotSkiSubAlt_return

    RFC5280Parser_dependentExtension_return dependentExtension1527;
    #undef	RETURN_TYPE_dependentExtension1527
    #define	RETURN_TYPE_dependentExtension1527 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotBCNotSkiSubAlt_return extensionsNotBCNotSkiSubAlt1528;
    #undef	RETURN_TYPE_extensionsNotBCNotSkiSubAlt1528
    #define	RETURN_TYPE_extensionsNotBCNotSkiSubAlt1528 RFC5280Parser_extensionsNotBCNotSkiSubAlt_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1529;
    #undef	RETURN_TYPE_keyUsageCommon1529
    #define	RETURN_TYPE_keyUsageCommon1529 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1530;
    #undef	RETURN_TYPE_bitstring1530
    #define	RETURN_TYPE_bitstring1530 RFC5280Parser_bitstring_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1531;
    #undef	RETURN_TYPE_bitstringCertSign1531
    #define	RETURN_TYPE_bitstringCertSign1531 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return extensionsNotBCNotKeyUsageNotSkiSubAlt1532;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1532
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSkiSubAlt1532 RFC5280Parser_extensionsNotBCNotKeyUsageNotSkiSubAlt_return

    RFC5280Parser_subAltNameCritical_return subAltNameCritical1533;
    #undef	RETURN_TYPE_subAltNameCritical1533
    #define	RETURN_TYPE_subAltNameCritical1533 RFC5280Parser_subAltNameCritical_return

    RFC5280Parser_extensionsNotBCNotSki_return extensionsNotBCNotSki1534;
    #undef	RETURN_TYPE_extensionsNotBCNotSki1534
    #define	RETURN_TYPE_extensionsNotBCNotSki1534 RFC5280Parser_extensionsNotBCNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extensionNoSubAlt1525.tree = NULL;

    extensionsNotBCNotSkiSubAlt1526.tree = NULL;

    dependentExtension1527.tree = NULL;

    extensionsNotBCNotSkiSubAlt1528.tree = NULL;

    keyUsageCommon1529.tree = NULL;

    bitstring1530.tree = NULL;

    bitstringCertSign1531.tree = NULL;

    extensionsNotBCNotKeyUsageNotSkiSubAlt1532.tree = NULL;

    subAltNameCritical1533.tree = NULL;

    extensionsNotBCNotSki1534.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3366:2: ( extensionNoSubAlt extensionsNotBCNotSkiSubAlt | dependentExtension extensionsNotBCNotSkiSubAlt | keyUsageCommon ( bitstring | bitstringCertSign ) extensionsNotBCNotKeyUsageNotSkiSubAlt | subAltNameCritical (| extensionsNotBCNotSki ) )

            ANTLR3_UINT32 alt412;

            alt412=4;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt412=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt412=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt412=3;
            					}
            				    break;
            				case OIDSUBALT:
            					{
            						alt412=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 412;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotBCNotSkiSubAltEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 412;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotBCNotSkiSubAltEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 412;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotBCNotSkiSubAltEx;

            }

            switch (alt412)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3366:4: extensionNoSubAlt extensionsNotBCNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extensionNoSubAlt_in_extensionsNotBCNotSkiSubAlt8558);
        	        extensionNoSubAlt1525=extensionNoSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionNoSubAlt1525.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8560);
        	        extensionsNotBCNotSkiSubAlt1526=extensionsNotBCNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSkiSubAlt1526.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3367:4: dependentExtension extensionsNotBCNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotBCNotSkiSubAlt8565);
        	        dependentExtension1527=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1527.tree);

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8567);
        	        extensionsNotBCNotSkiSubAlt1528=extensionsNotBCNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSkiSubAlt1528.tree);

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3368:4: keyUsageCommon ( bitstring | bitstringCertSign ) extensionsNotBCNotKeyUsageNotSkiSubAlt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNotBCNotSkiSubAlt8572);
        	        keyUsageCommon1529=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1529.tree);

        	        // Grammar/RFC5280.g:3368:19: ( bitstring | bitstringCertSign )
        	        {
        	            int alt410=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt410=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt410=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt410=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 410;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsNotBCNotSkiSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 410;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotSkiSubAltEx;

        	            }

        	            switch (alt410)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3368:20: bitstring
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNotBCNotSkiSubAlt8575);
        	        	        bitstring1530=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1530.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring1530.text
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3368:83: bitstringCertSign
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsNotBCNotSkiSubAlt8580);
        	        	        bitstringCertSign1531=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1531.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSkiSubAlt_in_extensionsNotBCNotSkiSubAlt8583);
        	        extensionsNotBCNotKeyUsageNotSkiSubAlt1532=extensionsNotBCNotKeyUsageNotSkiSubAlt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSkiSubAlt1532.tree);

        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3369:4: subAltNameCritical (| extensionsNotBCNotSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_subAltNameCritical_in_extensionsNotBCNotSkiSubAlt8588);
        	        subAltNameCritical1533=subAltNameCritical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, subAltNameCritical1533.tree);

        	        // Grammar/RFC5280.g:3369:23: (| extensionsNotBCNotSki )
        	        {
        	            int alt411=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt411=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt411=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 411;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCNotSkiSubAltEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 411;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCNotSkiSubAltEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 411;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotSkiSubAltEx;

        	            }

        	            switch (alt411)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3369:25: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3369:26: extensionsNotBCNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSkiSubAlt8593);
        	        	        extensionsNotBCNotSki1534=extensionsNotBCNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotSkiSubAltEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSki1534.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotBCNotSkiSubAltEx; /* Prevent compiler warnings */
    ruleextensionsNotBCNotSkiSubAltEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotBCNotSkiSubAlt */

/**
 * $ANTLR start extensionsNotBCNotSki
 * Grammar/RFC5280.g:3371:1: extensionsNotBCNotSki : ( extension (| extensionsNotBCNotSki ) | dependentExtension (| extensionsNotBCNotSki ) | keyUsageCommon ( bitstring | bitstringCertSign ) (| extensionsNotBCNotKeyUsageNotSki ) );
 */
static RFC5280Parser_extensionsNotBCNotSki_return
extensionsNotBCNotSki(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionsNotBCNotSki_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_extension_return extension1535;
    #undef	RETURN_TYPE_extension1535
    #define	RETURN_TYPE_extension1535 RFC5280Parser_extension_return

    RFC5280Parser_extensionsNotBCNotSki_return extensionsNotBCNotSki1536;
    #undef	RETURN_TYPE_extensionsNotBCNotSki1536
    #define	RETURN_TYPE_extensionsNotBCNotSki1536 RFC5280Parser_extensionsNotBCNotSki_return

    RFC5280Parser_dependentExtension_return dependentExtension1537;
    #undef	RETURN_TYPE_dependentExtension1537
    #define	RETURN_TYPE_dependentExtension1537 RFC5280Parser_dependentExtension_return

    RFC5280Parser_extensionsNotBCNotSki_return extensionsNotBCNotSki1538;
    #undef	RETURN_TYPE_extensionsNotBCNotSki1538
    #define	RETURN_TYPE_extensionsNotBCNotSki1538 RFC5280Parser_extensionsNotBCNotSki_return

    RFC5280Parser_keyUsageCommon_return keyUsageCommon1539;
    #undef	RETURN_TYPE_keyUsageCommon1539
    #define	RETURN_TYPE_keyUsageCommon1539 RFC5280Parser_keyUsageCommon_return

    RFC5280Parser_bitstring_return bitstring1540;
    #undef	RETURN_TYPE_bitstring1540
    #define	RETURN_TYPE_bitstring1540 RFC5280Parser_bitstring_return

    RFC5280Parser_bitstringCertSign_return bitstringCertSign1541;
    #undef	RETURN_TYPE_bitstringCertSign1541
    #define	RETURN_TYPE_bitstringCertSign1541 RFC5280Parser_bitstringCertSign_return

    RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return extensionsNotBCNotKeyUsageNotSki1542;
    #undef	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1542
    #define	RETURN_TYPE_extensionsNotBCNotKeyUsageNotSki1542 RFC5280Parser_extensionsNotBCNotKeyUsageNotSki_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    extension1535.tree = NULL;

    extensionsNotBCNotSki1536.tree = NULL;

    dependentExtension1537.tree = NULL;

    extensionsNotBCNotSki1538.tree = NULL;

    keyUsageCommon1539.tree = NULL;

    bitstring1540.tree = NULL;

    bitstringCertSign1541.tree = NULL;

    extensionsNotBCNotKeyUsageNotSki1542.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3378:2: ( extension (| extensionsNotBCNotSki ) | dependentExtension (| extensionsNotBCNotSki ) | keyUsageCommon ( bitstring | bitstringCertSign ) (| extensionsNotBCNotKeyUsageNotSki ) )

            ANTLR3_UINT32 alt417;

            alt417=3;

            switch ( LA(1) )
            {
            case SequenceTag:
            	{
            		switch ( LA(2) )
            		{
            		case OIDTag:
            			{
            				switch ( LA(3) )
            				{
            				case AIAOID:
            				case OIDAKI:
            				case OIDCERTPOL:
            				case OIDCRL:
            				case OIDEXTKEY:
            				case OIDFRESHCRL:
            				case OIDISSALT:
            				case OIDSUBALT:
            				case OIDSUBDIR:
            				case PRINTABLE:
            				case SIAOID:
            				case VALUE:
            					{
            						alt417=1;
            					}
            				    break;
            				case OIDINHIBIT:
            				case OIDNAME:
            				case OIDPOLCONST:
            				case OIDPOLMAP:
            					{
            						alt417=2;
            					}
            				    break;
            				case OIDKEYUS:
            					{
            						alt417=3;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 417;
            				    EXCEPTION->state        = 2;


            				    goto ruleextensionsNotBCNotSkiEx;

            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 417;
            		    EXCEPTION->state        = 1;


            		    goto ruleextensionsNotBCNotSkiEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 417;
                EXCEPTION->state        = 0;


                goto ruleextensionsNotBCNotSkiEx;

            }

            switch (alt417)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3378:4: extension (| extensionsNotBCNotSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_extension_in_extensionsNotBCNotSki8615);
        	        extension1535=extension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, extension1535.tree);

        	        // Grammar/RFC5280.g:3378:14: (| extensionsNotBCNotSki )
        	        {
        	            int alt413=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt413=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt413=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 413;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCNotSkiEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 413;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCNotSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 413;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotSkiEx;

        	            }

        	            switch (alt413)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3378:16: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3378:18: extensionsNotBCNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8621);
        	        	        extensionsNotBCNotSki1536=extensionsNotBCNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSki1536.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3379:4: dependentExtension (| extensionsNotBCNotSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_dependentExtension_in_extensionsNotBCNotSki8627);
        	        dependentExtension1537=dependentExtension(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dependentExtension1537.tree);

        	        // Grammar/RFC5280.g:3379:23: (| extensionsNotBCNotSki )
        	        {
        	            int alt414=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt414=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDKEYUS:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt414=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 414;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCNotSkiEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 414;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCNotSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 414;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotSkiEx;

        	            }

        	            switch (alt414)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3379:25: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3379:27: extensionsNotBCNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotSki_in_extensionsNotBCNotSki8633);
        	        	        extensionsNotBCNotSki1538=extensionsNotBCNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotSki1538.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3380:4: keyUsageCommon ( bitstring | bitstringCertSign ) (| extensionsNotBCNotKeyUsageNotSki )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_keyUsageCommon_in_extensionsNotBCNotSki8639);
        	        keyUsageCommon1539=keyUsageCommon(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleextensionsNotBCNotSkiEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, keyUsageCommon1539.tree);

        	        // Grammar/RFC5280.g:3380:19: ( bitstring | bitstringCertSign )
        	        {
        	            int alt415=2;
        	            switch ( LA(1) )
        	            {
        	            case BitStringTag:
        	            	{
        	            		alt415=1;
        	            	}
        	                break;
        	            case BitStringKeyCert:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case PRINTABLE:
        	            		case VALUE:
        	            			{
        	            				alt415=1;
        	            			}
        	            		    break;
        	            		case SequenceTag:
        	            			{
        	            				alt415=2;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 415;
        	            		    EXCEPTION->state        = 2;


        	            		    goto ruleextensionsNotBCNotSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 415;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotSkiEx;

        	            }

        	            switch (alt415)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3380:20: bitstring
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstring_in_extensionsNotBCNotSki8642);
        	        	        bitstring1540=bitstring(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1540.tree);

        	        	        {
        	        	            key_usage_ext->value->keyusage = bitstring1540.text
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3380:83: bitstringCertSign
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_bitstringCertSign_in_extensionsNotBCNotSki8647);
        	        	        bitstringCertSign1541=bitstringCertSign(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstringCertSign1541.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // Grammar/RFC5280.g:3380:102: (| extensionsNotBCNotKeyUsageNotSki )
        	        {
        	            int alt416=2;
        	            switch ( LA(1) )
        	            {
        	            case SequenceTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case OIDTag:
        	            			{
        	            				switch ( LA(3) )
        	            				{
        	            				case GOST01SIGN:
        	            				case GOST94SIGN:
        	            				case MD2RSAOID:
        	            				case MD5RSAOID:
        	            				case RSAPSSOID:
        	            				case SHA1DSAOID:
        	            				case SHA1ECOID:
        	            				case SHA1RSAOID:
        	            				case SHA224DSAOID:
        	            				case SHA224ECOID:
        	            				case SHA224RSAOID:
        	            				case SHA256DSAOID:
        	            				case SHA256ECOID:
        	            				case SHA256RSAOID:
        	            				case SHA384ECOID:
        	            				case SHA384RSAOID:
        	            				case SHA512ECOID:
        	            				case SHA512RSAOID:
        	            					{
        	            						alt416=1;
        	            					}
        	            				    break;
        	            				case AIAOID:
        	            				case OIDAKI:
        	            				case OIDCERTPOL:
        	            				case OIDCRL:
        	            				case OIDEXTKEY:
        	            				case OIDFRESHCRL:
        	            				case OIDINHIBIT:
        	            				case OIDISSALT:
        	            				case OIDNAME:
        	            				case OIDPOLCONST:
        	            				case OIDPOLMAP:
        	            				case OIDSUBALT:
        	            				case OIDSUBDIR:
        	            				case PRINTABLE:
        	            				case SIAOID:
        	            				case VALUE:
        	            					{
        	            						alt416=2;
        	            					}
        	            				    break;

        	            				default:
        	            				    CONSTRUCTEX();
        	            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            				    EXCEPTION->message      = (void *)"";
        	            				    EXCEPTION->decisionNum  = 416;
        	            				    EXCEPTION->state        = 2;


        	            				    goto ruleextensionsNotBCNotSkiEx;

        	            				}

        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 416;
        	            		    EXCEPTION->state        = 1;


        	            		    goto ruleextensionsNotBCNotSkiEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 416;
        	                EXCEPTION->state        = 0;


        	                goto ruleextensionsNotBCNotSkiEx;

        	            }

        	            switch (alt416)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3380:104: 
        	        	    {
        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3380:105: extensionsNotBCNotKeyUsageNotSki
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionsNotBCNotKeyUsageNotSki_in_extensionsNotBCNotSki8653);
        	        	        extensionsNotBCNotKeyUsageNotSki1542=extensionsNotBCNotKeyUsageNotSki(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleextensionsNotBCNotSkiEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionsNotBCNotKeyUsageNotSki1542.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleextensionsNotBCNotSkiEx; /* Prevent compiler warnings */
    ruleextensionsNotBCNotSkiEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionsNotBCNotSki */

/**
 * $ANTLR start generalNames
 * Grammar/RFC5280.g:3381:1: generalNames returns [STACK_OF(GENERAL_NAME_POINTER) *text] : ({...}? => generalName )+ ;
 */
static RFC5280Parser_generalNames_return
generalNames(pRFC5280Parser ctx)
{
    RFC5280Parser_generalNames_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_generalName_return generalName1543;
    #undef	RETURN_TYPE_generalName1543
    #define	RETURN_TYPE_generalName1543 RFC5280Parser_generalName_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    generalName1543.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3385:2: ( ({...}? => generalName )+ )
        // Grammar/RFC5280.g:3385:3: ({...}? => generalName )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            {
                general_name_pointer=counter_list;retval.text=sk_GENERAL_NAME_POINTER_new_null();

            }


            // Grammar/RFC5280.g:3387:87: ({...}? => generalName )+
            {
                int cnt418=0;

                for (;;)
                {
                    int alt418=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA418_0 = LA(1);
            	    if ( (LA418_0 == Tag2))
            	    {
            	        switch ( LA(2) )
            	        {
            	        case VALUE:
            	        	{
            	        		{
            	        		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        		    */
            	        		    int LA418_5 = LA(3);
            	        		    if ( ((general_name_pointer != NULL)))
            	        		    {
            	        		        alt418=1;
            	        		    }

            	        		}
            	        	}
            	            break;
            	        case PRINTABLE:
            	        	{
            	        		{
            	        		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        		    */
            	        		    int LA418_6 = LA(3);
            	        		    if ( ((general_name_pointer != NULL)))
            	        		    {
            	        		        alt418=1;
            	        		    }

            	        		}
            	        	}
            	            break;

            	        }

            	    }
            	    else if ( (LA418_0 == Tag1))
            	    {
            	        switch ( LA(2) )
            	        {
            	        case VALUE:
            	        	{
            	        		{
            	        		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        		    */
            	        		    int LA418_7 = LA(3);
            	        		    if ( ((general_name_pointer != NULL)))
            	        		    {
            	        		        alt418=1;
            	        		    }

            	        		}
            	        	}
            	            break;
            	        case PRINTABLE:
            	        	{
            	        		{
            	        		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	        		    */
            	        		    int LA418_8 = LA(3);
            	        		    if ( ((general_name_pointer != NULL)))
            	        		    {
            	        		        alt418=1;
            	        		    }

            	        		}
            	        	}
            	            break;

            	        }

            	    }
            	    else if ( ((general_name_pointer != NULL)) && (LA418_0 == ConstructedTag0 || ((LA418_0 >= ConstructedTag3) && (LA418_0 <= ConstructedTag5)) || ((LA418_0 >= Tag6) && (LA418_0 <= Tag8))))
            	    {
            	        alt418=1;
            	    }

            	}
            	switch (alt418)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:3387:89: {...}? => generalName
            	        {
            	            if ( !((general_name_pointer != NULL)) )
            	            {
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	                    EXCEPTION->message      = (void *)"general_name_pointer != NULL";
            	                    EXCEPTION->ruleName	 = (void *)"generalNames";


            	            }

            	            FOLLOWPUSH(FOLLOW_generalName_in_generalNames8678);
            	            generalName1543=generalName(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulegeneralNamesEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, generalName1543.tree);

            	            {
            	                sk_GENERAL_NAME_POINTER_push(retval.text
            	                ,gen_name);
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt418 >= 1 )
            		{
            		    goto loop418;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulegeneralNamesEx;
            	}
            	cnt418++;
                }
                loop418: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulegeneralNamesEx; /* Prevent compiler warnings */
    rulegeneralNamesEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end generalNames */

/**
 * $ANTLR start generalName
 * Grammar/RFC5280.g:3389:1: generalName : ( constructedTag0 othername | tag1 | tag2 | constructedTag3 standardAttrs ( definedAttrs )? ( extensionAttrs )? | constructedTag4 notEmptyName | constructedTag5 edipartyname | tag6 | tag7 | tag8 );
 */
static RFC5280Parser_generalName_return
generalName(pRFC5280Parser ctx)
{
    RFC5280Parser_generalName_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_constructedTag0_return constructedTag01544;
    #undef	RETURN_TYPE_constructedTag01544
    #define	RETURN_TYPE_constructedTag01544 RFC5280Parser_constructedTag0_return

    RFC5280Parser_othername_return othername1545;
    #undef	RETURN_TYPE_othername1545
    #define	RETURN_TYPE_othername1545 RFC5280Parser_othername_return

    RFC5280Parser_tag1_return tag11546;
    #undef	RETURN_TYPE_tag11546
    #define	RETURN_TYPE_tag11546 RFC5280Parser_tag1_return

    RFC5280Parser_tag2_return tag21547;
    #undef	RETURN_TYPE_tag21547
    #define	RETURN_TYPE_tag21547 RFC5280Parser_tag2_return

    RFC5280Parser_constructedTag3_return constructedTag31548;
    #undef	RETURN_TYPE_constructedTag31548
    #define	RETURN_TYPE_constructedTag31548 RFC5280Parser_constructedTag3_return

    RFC5280Parser_standardAttrs_return standardAttrs1549;
    #undef	RETURN_TYPE_standardAttrs1549
    #define	RETURN_TYPE_standardAttrs1549 RFC5280Parser_standardAttrs_return

    RFC5280Parser_definedAttrs_return definedAttrs1550;
    #undef	RETURN_TYPE_definedAttrs1550
    #define	RETURN_TYPE_definedAttrs1550 RFC5280Parser_definedAttrs_return

    RFC5280Parser_extensionAttrs_return extensionAttrs1551;
    #undef	RETURN_TYPE_extensionAttrs1551
    #define	RETURN_TYPE_extensionAttrs1551 RFC5280Parser_extensionAttrs_return

    RFC5280Parser_constructedTag4_return constructedTag41552;
    #undef	RETURN_TYPE_constructedTag41552
    #define	RETURN_TYPE_constructedTag41552 RFC5280Parser_constructedTag4_return

    RFC5280Parser_notEmptyName_return notEmptyName1553;
    #undef	RETURN_TYPE_notEmptyName1553
    #define	RETURN_TYPE_notEmptyName1553 RFC5280Parser_notEmptyName_return

    RFC5280Parser_constructedTag5_return constructedTag51554;
    #undef	RETURN_TYPE_constructedTag51554
    #define	RETURN_TYPE_constructedTag51554 RFC5280Parser_constructedTag5_return

    RFC5280Parser_edipartyname_return edipartyname1555;
    #undef	RETURN_TYPE_edipartyname1555
    #define	RETURN_TYPE_edipartyname1555 RFC5280Parser_edipartyname_return

    RFC5280Parser_tag6_return tag61556;
    #undef	RETURN_TYPE_tag61556
    #define	RETURN_TYPE_tag61556 RFC5280Parser_tag6_return

    RFC5280Parser_tag7_return tag71557;
    #undef	RETURN_TYPE_tag71557
    #define	RETURN_TYPE_tag71557 RFC5280Parser_tag7_return

    RFC5280Parser_tag8_return tag81558;
    #undef	RETURN_TYPE_tag81558
    #define	RETURN_TYPE_tag81558 RFC5280Parser_tag8_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    gen_name = malloc(sizeof(GEN_NAME));gen_name->name = malloc(sizeof(field_gen_name));
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    constructedTag01544.tree = NULL;

    othername1545.tree = NULL;

    tag11546.tree = NULL;

    tag21547.tree = NULL;

    constructedTag31548.tree = NULL;

    standardAttrs1549.tree = NULL;

    definedAttrs1550.tree = NULL;

    extensionAttrs1551.tree = NULL;

    constructedTag41552.tree = NULL;

    notEmptyName1553.tree = NULL;

    constructedTag51554.tree = NULL;

    edipartyname1555.tree = NULL;

    tag61556.tree = NULL;

    tag71557.tree = NULL;

    tag81558.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3396:2: ( constructedTag0 othername | tag1 | tag2 | constructedTag3 standardAttrs ( definedAttrs )? ( extensionAttrs )? | constructedTag4 notEmptyName | constructedTag5 edipartyname | tag6 | tag7 | tag8 )

            ANTLR3_UINT32 alt421;

            alt421=9;

            switch ( LA(1) )
            {
            case ConstructedTag0:
            	{
            		alt421=1;
            	}
                break;
            case Tag1:
            	{
            		alt421=2;
            	}
                break;
            case Tag2:
            	{
            		alt421=3;
            	}
                break;
            case ConstructedTag3:
            	{
            		alt421=4;
            	}
                break;
            case ConstructedTag4:
            	{
            		alt421=5;
            	}
                break;
            case ConstructedTag5:
            	{
            		alt421=6;
            	}
                break;
            case Tag6:
            	{
            		alt421=7;
            	}
                break;
            case Tag7:
            	{
            		alt421=8;
            	}
                break;
            case Tag8:
            	{
            		alt421=9;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 421;
                EXCEPTION->state        = 0;


                goto rulegeneralNameEx;

            }

            switch (alt421)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3396:4: constructedTag0 othername
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag0_in_generalName8700);
        	        constructedTag01544=constructedTag0(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag01544.tree);

        	        FOLLOWPUSH(FOLLOW_othername_in_generalName8702);
        	        othername1545=othername(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, othername1545.tree);

        	        {
        	            gen_name->tag=0;gen_name->name->other_name=othername1545.text
        	            ;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3397:4: tag1
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag1_in_generalName8709);
        	        tag11546=tag1(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag11546.tree);

        	        {
        	            gen_name->tag=1;gen_name->name->rfc822name = new_asn1_string(22,tag11546.text
        	            ->length,tag11546.text
        	            ->value);
        	            	if(check_string("^((([[:alpha:]]|[[:digit:]]|!|#|\\$|%|&|'|\\*|\\+|\\-|/|=|\\?|\\^|_|`|{|}|\\||~|)+(\\.([[:alpha:]]|[[:digit:]]|!|#|\\$|%|&|'|\\*|\\+|\\-|/|=|\\?|\\^|_|`|{|}|\\||~|)+)*)|(\"([\\x00-\\x1F]|[\\x21-\\x27]|[\\x2A-\\x5B]|[\\x5D-\\x7E]|\\\\.?)*\"))@((([[:alpha:]]|[[:digit:]])(([[:alpha:]]|[[:digit:]]|\\-)*([[:alpha:]]|[[:digit:]]))?)(\\.(([[:alpha:]]|[[:digit:]])(([[:alpha:]]|[[:digit:]]|\\-)*([[:alpha:]]|[[:digit:]]))?))+|\\[([\\x01-\\x1F]|[\\x21-\\x5A]|\\\\|[\\x5E-\\x7F])+\\])$",tag11546.text
        	            ->value,tag11546.text
        	            ->length))
        	            		warning |= BAD_EMAIL_FORMAT_WARNING;
        	            	
        	        }


        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3401:4: tag2
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag2_in_generalName8716);
        	        tag21547=tag2(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag21547.tree);

        	        {
        	            gen_name->tag=2;gen_name->name->DNSname = new_asn1_string(22,tag21547.text
        	            ->length,tag21547.text
        	            ->value);
        	            	if(check_string("^([[:alpha:]]|[[:digit:]])(([[:alpha:]]|[[:digit:]]|\\-)*([[:alpha:]]|[[:digit:]]))?(\\.([[:alpha:]]|[[:digit:]])(([[:alpha:]]|[[:digit:]]|\\-)*([[:alpha:]]|[[:digit:]]))?)*$",tag21547.text
        	            ->value,tag21547.text
        	            ->length))
        	            		warning|=BAD_DNS_FORMAT_WARNING;
        	            	
        	        }


        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3405:4: constructedTag3 standardAttrs ( definedAttrs )? ( extensionAttrs )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_generalName8723);
        	        constructedTag31548=constructedTag3(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag31548.tree);

        	        {
        	            sequence_pointer =counter_list; gen_name->tag=3; gen_name->name->x400_addr = malloc(sizeof(x400_address));gen_name->name->x400_addr->standard_attributes=malloc(sizeof(standard_attrs));
        	        }


        	        FOLLOWPUSH(FOLLOW_standardAttrs_in_generalName8730);
        	        standardAttrs1549=standardAttrs(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, standardAttrs1549.tree);

        	        // Grammar/RFC5280.g:3406:17: ( definedAttrs )?
        	        {
        	            int alt419=2;
        	            switch ( LA(1) )
        	            {
        	                case SequenceTag:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		    case SequenceTag:
        	                		    	{
        	                		    		alt419=1;
        	                		    	}
        	                		        break;
        	                		}

        	                	}
        	                    break;
        	            }

        	            switch (alt419)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3406:17: definedAttrs
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_definedAttrs_in_generalName8732);
        	        	        definedAttrs1550=definedAttrs(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulegeneralNameEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, definedAttrs1550.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	        // Grammar/RFC5280.g:3406:31: ( extensionAttrs )?
        	        {
        	            int alt420=2;
        	            switch ( LA(1) )
        	            {
        	                case SetTag:
        	                	{
        	                		alt420=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt420)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3406:31: extensionAttrs
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_extensionAttrs_in_generalName8735);
        	        	        extensionAttrs1551=extensionAttrs(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulegeneralNameEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, extensionAttrs1551.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:3407:4: constructedTag4 notEmptyName
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag4_in_generalName8741);
        	        constructedTag41552=constructedTag4(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag41552.tree);

        	        FOLLOWPUSH(FOLLOW_notEmptyName_in_generalName8743);
        	        notEmptyName1553=notEmptyName(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, notEmptyName1553.tree);

        	        {
        	            gen_name->tag=4;gen_name->name->dn = dname;
        	        }


        	    }
        	    break;
        	case 6:
        	    // Grammar/RFC5280.g:3408:4: constructedTag5 edipartyname
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag5_in_generalName8750);
        	        constructedTag51554=constructedTag5(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag51554.tree);

        	        FOLLOWPUSH(FOLLOW_edipartyname_in_generalName8752);
        	        edipartyname1555=edipartyname(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, edipartyname1555.tree);

        	        {
        	            gen_name->tag=5;gen_name->name->edi=edipartyname1555.text
        	            ;
        	        }


        	    }
        	    break;
        	case 7:
        	    // Grammar/RFC5280.g:3409:4: tag6
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag6_in_generalName8759);
        	        tag61556=tag6(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag61556.tree);

        	        {
        	            gen_name->tag=6;gen_name->name->uri = new_asn1_string(22,tag61556.text
        	            ->length,tag61556.text
        	            ->value);
        	            	if(check_string("^[[:alpha:]]([[:alpha:]]|[[:digit:]]|\\+|\\-|\\.)*:([[:alpha:]]|[[:digit:]]|\\-|\\.|_|~|:|\\?|/|\\[|\\]|@|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|%)*(\\?([[:alpha:]]|[[:digit:]]|\\-|\\.|_|~|:|\\?|/|@|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|%)*)?\\z",tag61556.text
        	            ->value,tag61556.text
        	            ->length))
        	            		warning |= BAD_URI_FORMAT_WARNING;
        	            	
        	        }


        	    }
        	    break;
        	case 8:
        	    // Grammar/RFC5280.g:3413:4: tag7
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag7_in_generalName8766);
        	        tag71557=tag7(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag71557.tree);

        	        {
        	            gen_name->tag=7;gen_name->name->IP_addr = new_asn1_string(4,tag71557.text
        	            ->length,tag71557.text
        	            ->value);
        	        }


        	    }
        	    break;
        	case 9:
        	    // Grammar/RFC5280.g:3414:4: tag8
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag8_in_generalName8773);
        	        tag81558=tag8(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulegeneralNameEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag81558.tree);

        	        {
        	            gen_name->tag=8;
        	            		oid_array *test = malloc(sizeof(oid_array));
        	            		test->oid = malloc(sizeof(mpz_t)*(tag81558.text
        	            ->length+2));
        	            		printf("It's ok til here \n");
        	            		int oid_len = compute_oid_value(tag81558.text
        	            ->value,tag81558.text
        	            ->length,test->oid);
        	            		printf("Value computed \n");
        	            		int i;
        	            		char **oid_numbers;
        	            		oid_numbers = malloc(sizeof(char *)*oid_len);
        	            		int oid_obj_len = 0;
        	            		for(i=0;i<oid_len;i++)
        	            		{
        	            			oid_numbers[i] = mpz_get_str(NULL,10,test->oid[i]);
        	            			oid_obj_len += strlen(oid_numbers[i]);
        	            		}
        	            		char *oid_value = malloc(oid_obj_len+oid_len);
        	            		strcpy(oid_value,oid_numbers[0]);
        	            		for(i=1;i<oid_len;i++)
        	            		{
        	            			strcat(oid_value,".");
        	            			strcat(oid_value,oid_numbers[i]);
        	            		}
        	            		printf("OID Value is %s \n",oid_value);
        	            		test->len = oid_len;	
        	            		int new_nid = OBJ_txt2nid(oid_value);
        	            		if(new_nid == NID_undef)
        	            			new_nid = OBJ_create(oid_value,oid_value,oid_value);
        	            		gen_name->name->registered_id = OBJ_nid2obj(new_nid);
        	            		free(test);
        	            	
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulegeneralNameEx; /* Prevent compiler warnings */
    rulegeneralNameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end generalName */

/**
 * $ANTLR start othername
 * Grammar/RFC5280.g:3446:1: othername returns [other_name *text] : oid constructedTag0 any ;
 */
static RFC5280Parser_othername_return
othername(pRFC5280Parser ctx)
{
    RFC5280Parser_othername_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_oid_return oid1559;
    #undef	RETURN_TYPE_oid1559
    #define	RETURN_TYPE_oid1559 RFC5280Parser_oid_return

    RFC5280Parser_constructedTag0_return constructedTag01560;
    #undef	RETURN_TYPE_constructedTag01560
    #define	RETURN_TYPE_constructedTag01560 RFC5280Parser_constructedTag0_return

    RFC5280Parser_any_return any1561;
    #undef	RETURN_TYPE_any1561
    #define	RETURN_TYPE_any1561 RFC5280Parser_any_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    oid1559.tree = NULL;

    constructedTag01560.tree = NULL;

    any1561.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3450:2: ( oid constructedTag0 any )
        // Grammar/RFC5280.g:3450:3: oid constructedTag0 any
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_oid_in_othername8796);
            oid1559=oid(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleothernameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, oid1559.tree);

            FOLLOWPUSH(FOLLOW_constructedTag0_in_othername8798);
            constructedTag01560=constructedTag0(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleothernameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedTag01560.tree);

            FOLLOWPUSH(FOLLOW_any_in_othername8800);
            any1561=any(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleothernameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, any1561.tree);

            {
                retval.text=malloc(sizeof(other_name));

                		retval.text
                ->oid=oid1559.text
                ->obj;
                		retval.text
                ->value=any1561.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleothernameEx; /* Prevent compiler warnings */
    ruleothernameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end othername */

/**
 * $ANTLR start edipartyname
 * Grammar/RFC5280.g:3457:1: edipartyname returns [EDIPARTYNAME *text] : ( tag0 )? tag1 ;
 */
static RFC5280Parser_edipartyname_return
edipartyname(pRFC5280Parser ctx)
{
    RFC5280Parser_edipartyname_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_tag0_return tag01562;
    #undef	RETURN_TYPE_tag01562
    #define	RETURN_TYPE_tag01562 RFC5280Parser_tag0_return

    RFC5280Parser_tag1_return tag11563;
    #undef	RETURN_TYPE_tag11563
    #define	RETURN_TYPE_tag11563 RFC5280Parser_tag1_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.text= malloc(sizeof(EDIPARTYNAME));
    retval.text
    ->nameAssigner = NULL;
    tag01562.tree = NULL;

    tag11563.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3461:2: ( ( tag0 )? tag1 )
        // Grammar/RFC5280.g:3461:3: ( tag0 )? tag1
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:3463:10: ( tag0 )?
            {
                int alt422=2;
                switch ( LA(1) )
                {
                    case Tag0:
                    case TagInt1:
                    case TagInt10:
                    case TagInt11:
                    case TagInt12:
                    case TagInt13:
                    case TagInt14:
                    case TagInt15:
                    case TagInt16:
                    case TagInt17:
                    case TagInt18:
                    case TagInt19:
                    case TagInt2:
                    case TagInt20:
                    case TagInt21:
                    case TagInt22:
                    case TagInt23:
                    case TagInt3:
                    case TagInt4:
                    case TagInt5:
                    case TagInt6:
                    case TagInt7:
                    case TagInt8:
                    case TagInt9:
                    	{
                    		alt422=1;
                    	}
                        break;
                }

                switch (alt422)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3463:11: tag0
            	    {
            	        FOLLOWPUSH(FOLLOW_tag0_in_edipartyname8828);
            	        tag01562=tag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleedipartynameEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag01562.tree);

            	        {
            	            retval.text
            	            ->nameAssigner=new_asn1_string(12,tag01562.text
            	            ->length,tag01562.text
            	            ->value);
            	        }


            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_tag1_in_edipartyname8833);
            tag11563=tag1(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleedipartynameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, tag11563.tree);

            {

                		retval.text
                ->partyName = new_asn1_string(12,tag11563.text
                ->length,tag11563.text
                ->value);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleedipartynameEx; /* Prevent compiler warnings */
    ruleedipartynameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end edipartyname */

/**
 * $ANTLR start standardAttrs
 * Grammar/RFC5280.g:3467:1: standardAttrs : sequenceTag ( countryName )? ( adName )? ({...}? =>tag_zero= tag0 |) ({...}? =>tag_one= tag1 |) ( constructedTag2 ( numericString |print= printString ) )? (tag_three= tag3 )? ( tag4 )? ({...}? => constructedTag5 (t0= tag0 ) ({...}? =>t1= tag1 |) ({...}? =>t2= tag2 |) (t3= tag3 )? |) ( constructedTag6 (print= printString )+ )? ;
 */
static RFC5280Parser_standardAttrs_return
standardAttrs(pRFC5280Parser ctx)
{
    RFC5280Parser_standardAttrs_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_tag0_return tag_zero;
    #undef	RETURN_TYPE_tag_zero
    #define	RETURN_TYPE_tag_zero RFC5280Parser_tag0_return

    RFC5280Parser_tag1_return tag_one;
    #undef	RETURN_TYPE_tag_one
    #define	RETURN_TYPE_tag_one RFC5280Parser_tag1_return

    RFC5280Parser_printString_return print;
    #undef	RETURN_TYPE_print
    #define	RETURN_TYPE_print RFC5280Parser_printString_return

    RFC5280Parser_tag3_return tag_three;
    #undef	RETURN_TYPE_tag_three
    #define	RETURN_TYPE_tag_three RFC5280Parser_tag3_return

    RFC5280Parser_tag0_return t0;
    #undef	RETURN_TYPE_t0
    #define	RETURN_TYPE_t0 RFC5280Parser_tag0_return

    RFC5280Parser_tag1_return t1;
    #undef	RETURN_TYPE_t1
    #define	RETURN_TYPE_t1 RFC5280Parser_tag1_return

    RFC5280Parser_tag2_return t2;
    #undef	RETURN_TYPE_t2
    #define	RETURN_TYPE_t2 RFC5280Parser_tag2_return

    RFC5280Parser_tag3_return t3;
    #undef	RETURN_TYPE_t3
    #define	RETURN_TYPE_t3 RFC5280Parser_tag3_return

    RFC5280Parser_sequenceTag_return sequenceTag1564;
    #undef	RETURN_TYPE_sequenceTag1564
    #define	RETURN_TYPE_sequenceTag1564 RFC5280Parser_sequenceTag_return

    RFC5280Parser_countryName_return countryName1565;
    #undef	RETURN_TYPE_countryName1565
    #define	RETURN_TYPE_countryName1565 RFC5280Parser_countryName_return

    RFC5280Parser_adName_return adName1566;
    #undef	RETURN_TYPE_adName1566
    #define	RETURN_TYPE_adName1566 RFC5280Parser_adName_return

    RFC5280Parser_constructedTag2_return constructedTag21567;
    #undef	RETURN_TYPE_constructedTag21567
    #define	RETURN_TYPE_constructedTag21567 RFC5280Parser_constructedTag2_return

    RFC5280Parser_numericString_return numericString1568;
    #undef	RETURN_TYPE_numericString1568
    #define	RETURN_TYPE_numericString1568 RFC5280Parser_numericString_return

    RFC5280Parser_tag4_return tag41569;
    #undef	RETURN_TYPE_tag41569
    #define	RETURN_TYPE_tag41569 RFC5280Parser_tag4_return

    RFC5280Parser_constructedTag5_return constructedTag51570;
    #undef	RETURN_TYPE_constructedTag51570
    #define	RETURN_TYPE_constructedTag51570 RFC5280Parser_constructedTag5_return

    RFC5280Parser_constructedTag6_return constructedTag61571;
    #undef	RETURN_TYPE_constructedTag61571
    #define	RETURN_TYPE_constructedTag61571 RFC5280Parser_constructedTag6_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    ASN1_STRING *str;
    tag_zero.tree = NULL;

    tag_one.tree = NULL;

    print.tree = NULL;

    tag_three.tree = NULL;

    t0.tree = NULL;

    t1.tree = NULL;

    t2.tree = NULL;

    t3.tree = NULL;

    sequenceTag1564.tree = NULL;

    countryName1565.tree = NULL;

    adName1566.tree = NULL;

    constructedTag21567.tree = NULL;

    numericString1568.tree = NULL;

    tag41569.tree = NULL;

    constructedTag51570.tree = NULL;

    constructedTag61571.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3471:2: ( sequenceTag ( countryName )? ( adName )? ({...}? =>tag_zero= tag0 |) ({...}? =>tag_one= tag1 |) ( constructedTag2 ( numericString |print= printString ) )? (tag_three= tag3 )? ( tag4 )? ({...}? => constructedTag5 (t0= tag0 ) ({...}? =>t1= tag1 |) ({...}? =>t2= tag2 |) (t3= tag3 )? |) ( constructedTag6 (print= printString )+ )? )
        // Grammar/RFC5280.g:3471:3: sequenceTag ( countryName )? ( adName )? ({...}? =>tag_zero= tag0 |) ({...}? =>tag_one= tag1 |) ( constructedTag2 ( numericString |print= printString ) )? (tag_three= tag3 )? ( tag4 )? ({...}? => constructedTag5 (t0= tag0 ) ({...}? =>t1= tag1 |) ({...}? =>t2= tag2 |) (t3= tag3 )? |) ( constructedTag6 (print= printString )+ )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_standardAttrs8854);
            sequenceTag1564=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestandardAttrsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1564.tree);

            // Grammar/RFC5280.g:3473:22: ( countryName )?
            {
                int alt423=2;
                switch ( LA(1) )
                {
                    case AppTag1:
                    	{
                    		alt423=1;
                    	}
                        break;
                }

                switch (alt423)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3473:23: countryName
            	    {
            	        FOLLOWPUSH(FOLLOW_countryName_in_standardAttrs8857);
            	        countryName1565=countryName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestandardAttrsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, countryName1565.tree);

            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3473:37: ( adName )?
            {
                int alt424=2;
                switch ( LA(1) )
                {
                    case AppTag2:
                    	{
                    		alt424=1;
                    	}
                        break;
                }

                switch (alt424)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3473:38: adName
            	    {
            	        FOLLOWPUSH(FOLLOW_adName_in_standardAttrs8862);
            	        adName1566=adName(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestandardAttrsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, adName1566.tree);

            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3473:47: ({...}? =>tag_zero= tag0 |)
            {
                int alt425=2;
                switch ( LA(1) )
                {
                case Tag0:
                	{
                		switch ( LA(2) )
                		{
                		case VALUE:
                			{
                				{
                				    int LA425_26 = LA(3);
                				    if ( ((sequence_pointer != NULL)))
                				    {
                				        alt425=1;
                				    }
                				    else if ( (ANTLR3_TRUE))
                				    {
                				        alt425=2;
                				    }
                				    else
                				    {

                				        CONSTRUCTEX();
                				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				        EXCEPTION->message      = (void *)"";
                				        EXCEPTION->decisionNum  = 425;
                				        EXCEPTION->state        = 26;


                				        goto rulestandardAttrsEx;

                				    }
                				}
                			}
                		    break;
                		case PRINTABLE:
                			{
                				{
                				    int LA425_27 = LA(3);
                				    if ( ((sequence_pointer != NULL)))
                				    {
                				        alt425=1;
                				    }
                				    else if ( (ANTLR3_TRUE))
                				    {
                				        alt425=2;
                				    }
                				    else
                				    {

                				        CONSTRUCTEX();
                				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				        EXCEPTION->message      = (void *)"";
                				        EXCEPTION->decisionNum  = 425;
                				        EXCEPTION->state        = 27;


                				        goto rulestandardAttrsEx;

                				    }
                				}
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 425;
                		    EXCEPTION->state        = 1;


                		    goto rulestandardAttrsEx;

                		}

                	}
                    break;
                case TagInt1:
                	{
                		{
                		    int LA425_2 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 2;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt2:
                	{
                		{
                		    int LA425_3 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 3;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt3:
                	{
                		{
                		    int LA425_4 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 4;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt4:
                	{
                		{
                		    int LA425_5 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 5;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt5:
                	{
                		{
                		    int LA425_6 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 6;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt6:
                	{
                		{
                		    int LA425_7 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 7;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt7:
                	{
                		{
                		    int LA425_8 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 8;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt8:
                	{
                		{
                		    int LA425_9 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 9;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt9:
                	{
                		{
                		    int LA425_10 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 10;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt10:
                	{
                		{
                		    int LA425_11 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 11;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt11:
                	{
                		{
                		    int LA425_12 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 12;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt12:
                	{
                		{
                		    int LA425_13 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 13;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt13:
                	{
                		{
                		    int LA425_14 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 14;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt14:
                	{
                		{
                		    int LA425_15 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 15;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt15:
                	{
                		{
                		    int LA425_16 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 16;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt16:
                	{
                		{
                		    int LA425_17 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 17;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt17:
                	{
                		{
                		    int LA425_18 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 18;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt18:
                	{
                		{
                		    int LA425_19 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 19;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt19:
                	{
                		{
                		    int LA425_20 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 20;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt20:
                	{
                		{
                		    int LA425_21 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 21;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt21:
                	{
                		{
                		    int LA425_22 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 22;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt22:
                	{
                		{
                		    int LA425_23 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 23;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case TagInt23:
                	{
                		{
                		    int LA425_24 = LA(2);
                		    if ( ((sequence_pointer != NULL)))
                		    {
                		        alt425=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt425=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 425;
                		        EXCEPTION->state        = 24;


                		        goto rulestandardAttrsEx;

                		    }
                		}
                	}
                    break;
                case ConstructedTag0:
                case ConstructedTag1:
                case ConstructedTag2:
                case ConstructedTag3:
                case ConstructedTag4:
                case ConstructedTag5:
                case ConstructedTag6:
                case SequenceTag:
                case SetTag:
                case Tag1:
                case Tag2:
                case Tag3:
                case Tag4:
                case Tag6:
                case Tag7:
                case Tag8:
                	{
                		alt425=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 425;
                    EXCEPTION->state        = 0;


                    goto rulestandardAttrsEx;

                }

                switch (alt425)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3473:49: {...}? =>tag_zero= tag0
            	    {
            	        if ( !((sequence_pointer != NULL)) )
            	        {
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	                EXCEPTION->message      = (void *)"sequence_pointer != NULL";
            	                EXCEPTION->ruleName	 = (void *)"standardAttrs";


            	        }

            	        FOLLOWPUSH(FOLLOW_tag0_in_standardAttrs8873);
            	        tag_zero=tag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestandardAttrsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag_zero.tree);

            	        {
            	            if(!(1 <= tag_zero.text
            	            ->length && tag_zero.text
            	            ->length <= ub_x121_address_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	gen_name->name->x400_addr->standard_attributes->net_addr = new_asn1_string(18,tag_zero.text
            	            ->length,tag_zero.text
            	            ->value);
            	            	
            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3480:4: 
            	    {
            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3480:6: ({...}? =>tag_one= tag1 |)
            {
                int alt426=2;
                switch ( LA(1) )
                {
                case Tag1:
                	{
                		switch ( LA(2) )
                		{
                		case VALUE:
                			{
                				{
                				    int LA426_3 = LA(3);
                				    if ( ((sequence_pointer != NULL)))
                				    {
                				        alt426=1;
                				    }
                				    else if ( (ANTLR3_TRUE))
                				    {
                				        alt426=2;
                				    }
                				    else
                				    {

                				        CONSTRUCTEX();
                				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				        EXCEPTION->message      = (void *)"";
                				        EXCEPTION->decisionNum  = 426;
                				        EXCEPTION->state        = 3;


                				        goto rulestandardAttrsEx;

                				    }
                				}
                			}
                		    break;
                		case PRINTABLE:
                			{
                				{
                				    int LA426_4 = LA(3);
                				    if ( ((sequence_pointer != NULL)))
                				    {
                				        alt426=1;
                				    }
                				    else if ( (ANTLR3_TRUE))
                				    {
                				        alt426=2;
                				    }
                				    else
                				    {

                				        CONSTRUCTEX();
                				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                				        EXCEPTION->message      = (void *)"";
                				        EXCEPTION->decisionNum  = 426;
                				        EXCEPTION->state        = 4;


                				        goto rulestandardAttrsEx;

                				    }
                				}
                			}
                		    break;

                		default:
                		    CONSTRUCTEX();
                		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		    EXCEPTION->message      = (void *)"";
                		    EXCEPTION->decisionNum  = 426;
                		    EXCEPTION->state        = 1;


                		    goto rulestandardAttrsEx;

                		}

                	}
                    break;
                case ConstructedTag0:
                case ConstructedTag1:
                case ConstructedTag2:
                case ConstructedTag3:
                case ConstructedTag4:
                case ConstructedTag5:
                case ConstructedTag6:
                case SequenceTag:
                case SetTag:
                case Tag0:
                case Tag2:
                case Tag3:
                case Tag4:
                case Tag6:
                case Tag7:
                case Tag8:
                case TagInt1:
                case TagInt10:
                case TagInt11:
                case TagInt12:
                case TagInt13:
                case TagInt14:
                case TagInt15:
                case TagInt16:
                case TagInt17:
                case TagInt18:
                case TagInt19:
                case TagInt2:
                case TagInt20:
                case TagInt21:
                case TagInt22:
                case TagInt23:
                case TagInt3:
                case TagInt4:
                case TagInt5:
                case TagInt6:
                case TagInt7:
                case TagInt8:
                case TagInt9:
                	{
                		alt426=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 426;
                    EXCEPTION->state        = 0;


                    goto rulestandardAttrsEx;

                }

                switch (alt426)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3480:7: {...}? =>tag_one= tag1
            	    {
            	        if ( !((sequence_pointer != NULL)) )
            	        {
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	                EXCEPTION->message      = (void *)"sequence_pointer != NULL";
            	                EXCEPTION->ruleName	 = (void *)"standardAttrs";


            	        }

            	        FOLLOWPUSH(FOLLOW_tag1_in_standardAttrs8888);
            	        tag_one=tag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestandardAttrsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag_one.tree);

            	        {
            	            if(!(1 <= tag_one.text
            	            ->length && tag_one.text
            	            ->length <= ub_terminal_id_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	gen_name->name->x400_addr->standard_attributes->terminal_id = new_asn1_string(18,tag_one.text
            	            ->length,tag_one.text
            	            ->value);
            	            	
            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3488:3: 
            	    {
            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3488:5: ( constructedTag2 ( numericString |print= printString ) )?
            {
                int alt428=2;
                switch ( LA(1) )
                {
                    case ConstructedTag2:
                    	{
                    		switch ( LA(2) )
                    		{
                    		    case NumericStringTag:
                    		    case PrintStringTag:
                    		    	{
                    		    		alt428=1;
                    		    	}
                    		        break;
                    		}

                    	}
                        break;
                }

                switch (alt428)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3488:6: constructedTag2 ( numericString |print= printString )
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag2_in_standardAttrs8898);
            	        constructedTag21567=constructedTag2(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestandardAttrsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag21567.tree);

            	        // Grammar/RFC5280.g:3488:22: ( numericString |print= printString )
            	        {
            	            int alt427=2;
            	            switch ( LA(1) )
            	            {
            	            case NumericStringTag:
            	            	{
            	            		alt427=1;
            	            	}
            	                break;
            	            case PrintStringTag:
            	            	{
            	            		alt427=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 427;
            	                EXCEPTION->state        = 0;


            	                goto rulestandardAttrsEx;

            	            }

            	            switch (alt427)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3488:23: numericString
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_numericString_in_standardAttrs8901);
            	        	        numericString1568=numericString(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestandardAttrsEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, numericString1568.tree);

            	        	        {
            	        	            str=numericString1568.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3488:66: print= printString
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_printString_in_standardAttrs8909);
            	        	        print=printString(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestandardAttrsEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, print.tree);

            	        	        {
            	        	            str=print.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	            if(!(1 <= str->length && str->length <= ub_domain_name_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	gen_name->name->x400_addr->standard_attributes->private_domain_name = str;
            	            	
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3496:5: (tag_three= tag3 )?
            {
                int alt429=2;
                switch ( LA(1) )
                {
                    case Tag3:
                    	{
                    		alt429=1;
                    	}
                        break;
                }

                switch (alt429)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3496:6: tag_three= tag3
            	    {
            	        FOLLOWPUSH(FOLLOW_tag3_in_standardAttrs8924);
            	        tag_three=tag3(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestandardAttrsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag_three.tree);

            	        {
            	            if(!(1 <= tag_three.text
            	            ->length && tag_three.text
            	            ->length <= ub_organization_name_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	gen_name->name->x400_addr->standard_attributes->organization_name = new_asn1_string(19,tag_three.text
            	            ->length,tag_three.text
            	            ->value);
            	            	
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3504:5: ( tag4 )?
            {
                int alt430=2;
                switch ( LA(1) )
                {
                    case Tag4:
                    	{
                    		alt430=1;
                    	}
                        break;
                }

                switch (alt430)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3504:6: tag4
            	    {
            	        FOLLOWPUSH(FOLLOW_tag4_in_standardAttrs8934);
            	        tag41569=tag4(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestandardAttrsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tag41569.tree);

            	        {
            	            if(!(1 <= tag41569.text
            	            ->length && tag41569.text
            	            ->length <= ub_numeric_user_id_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	gen_name->name->x400_addr->standard_attributes->numeric_user_identifier = new_asn1_string(18,tag41569.text
            	            ->length,tag41569.text
            	            ->value);
            	            	
            	        }


            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3513:2: ({...}? => constructedTag5 (t0= tag0 ) ({...}? =>t1= tag1 |) ({...}? =>t2= tag2 |) (t3= tag3 )? |)
            {
                int alt434=2;
                alt434 = cdfa434.predict(ctx, RECOGNIZER, ISTREAM, &cdfa434);
                if  (HASEXCEPTION())
                {
                    goto rulestandardAttrsEx;
                }

                switch (alt434)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3513:3: {...}? => constructedTag5 (t0= tag0 ) ({...}? =>t1= tag1 |) ({...}? =>t2= tag2 |) (t3= tag3 )?
            	    {
            	        if ( !((sequence_pointer != NULL)) )
            	        {
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	                EXCEPTION->message      = (void *)"sequence_pointer != NULL";
            	                EXCEPTION->ruleName	 = (void *)"standardAttrs";


            	        }

            	        FOLLOWPUSH(FOLLOW_constructedTag5_in_standardAttrs8949);
            	        constructedTag51570=constructedTag5(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestandardAttrsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag51570.tree);

            	        // Grammar/RFC5280.g:3513:49: (t0= tag0 )
            	        // Grammar/RFC5280.g:3513:50: t0= tag0
            	        {
            	            FOLLOWPUSH(FOLLOW_tag0_in_standardAttrs8954);
            	            t0=tag0(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestandardAttrsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, t0.tree);

            	            {
            	                if(!(1 <= t0.text
            	                ->length && t0.text
            	                ->length <= ub_surname_length))
            	                	{
            	                		printf("Attribute String length constraint not satisfied \n");
            	                		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	                	}
            	                	gen_name->name->x400_addr->standard_attributes->surname = new_asn1_string(19,t0.text
            	                ->length,t0.text
            	                ->value);
            	                	
            	            }


            	        }


            	        // Grammar/RFC5280.g:3521:3: ({...}? =>t1= tag1 |)
            	        {
            	            int alt431=2;
            	            switch ( LA(1) )
            	            {
            	            case Tag1:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case VALUE:
            	            			{
            	            				{
            	            				    int LA431_3 = LA(3);
            	            				    if ( ((sequence_pointer != NULL)))
            	            				    {
            	            				        alt431=1;
            	            				    }
            	            				    else if ( (ANTLR3_TRUE))
            	            				    {
            	            				        alt431=2;
            	            				    }
            	            				    else
            	            				    {

            	            				        CONSTRUCTEX();
            	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				        EXCEPTION->message      = (void *)"";
            	            				        EXCEPTION->decisionNum  = 431;
            	            				        EXCEPTION->state        = 3;


            	            				        goto rulestandardAttrsEx;

            	            				    }
            	            				}
            	            			}
            	            		    break;
            	            		case PRINTABLE:
            	            			{
            	            				{
            	            				    int LA431_4 = LA(3);
            	            				    if ( ((sequence_pointer != NULL)))
            	            				    {
            	            				        alt431=1;
            	            				    }
            	            				    else if ( (ANTLR3_TRUE))
            	            				    {
            	            				        alt431=2;
            	            				    }
            	            				    else
            	            				    {

            	            				        CONSTRUCTEX();
            	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				        EXCEPTION->message      = (void *)"";
            	            				        EXCEPTION->decisionNum  = 431;
            	            				        EXCEPTION->state        = 4;


            	            				        goto rulestandardAttrsEx;

            	            				    }
            	            				}
            	            			}
            	            		    break;

            	            		default:
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 431;
            	            		    EXCEPTION->state        = 1;


            	            		    goto rulestandardAttrsEx;

            	            		}

            	            	}
            	                break;
            	            case ConstructedTag0:
            	            case ConstructedTag1:
            	            case ConstructedTag2:
            	            case ConstructedTag3:
            	            case ConstructedTag4:
            	            case ConstructedTag5:
            	            case ConstructedTag6:
            	            case SequenceTag:
            	            case SetTag:
            	            case Tag0:
            	            case Tag2:
            	            case Tag3:
            	            case Tag6:
            	            case Tag7:
            	            case Tag8:
            	            case TagInt1:
            	            case TagInt10:
            	            case TagInt11:
            	            case TagInt12:
            	            case TagInt13:
            	            case TagInt14:
            	            case TagInt15:
            	            case TagInt16:
            	            case TagInt17:
            	            case TagInt18:
            	            case TagInt19:
            	            case TagInt2:
            	            case TagInt20:
            	            case TagInt21:
            	            case TagInt22:
            	            case TagInt23:
            	            case TagInt3:
            	            case TagInt4:
            	            case TagInt5:
            	            case TagInt6:
            	            case TagInt7:
            	            case TagInt8:
            	            case TagInt9:
            	            	{
            	            		alt431=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 431;
            	                EXCEPTION->state        = 0;


            	                goto rulestandardAttrsEx;

            	            }

            	            switch (alt431)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3521:4: {...}? =>t1= tag1
            	        	    {
            	        	        if ( !((sequence_pointer != NULL)) )
            	        	        {
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"sequence_pointer != NULL";
            	        	                EXCEPTION->ruleName	 = (void *)"standardAttrs";


            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_tag1_in_standardAttrs8969);
            	        	        t1=tag1(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestandardAttrsEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, t1.tree);

            	        	        {
            	        	            if(!(1 <= t1.text
            	        	            ->length && t1.text
            	        	            ->length <= ub_given_name_length))
            	        	            		printf("Error on string length constraint \n");
            	        	            	gen_name->name->x400_addr->standard_attributes->given_name = new_asn1_string(19,t1.text
            	        	            ->length,t1.text
            	        	            ->value);
            	        	            	
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3526:3: 
            	        	    {
            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:3526:5: ({...}? =>t2= tag2 |)
            	        {
            	            int alt432=2;
            	            switch ( LA(1) )
            	            {
            	            case Tag2:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case VALUE:
            	            			{
            	            				{
            	            				    int LA432_3 = LA(3);
            	            				    if ( ((sequence_pointer != NULL)))
            	            				    {
            	            				        alt432=1;
            	            				    }
            	            				    else if ( (ANTLR3_TRUE))
            	            				    {
            	            				        alt432=2;
            	            				    }
            	            				    else
            	            				    {

            	            				        CONSTRUCTEX();
            	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				        EXCEPTION->message      = (void *)"";
            	            				        EXCEPTION->decisionNum  = 432;
            	            				        EXCEPTION->state        = 3;


            	            				        goto rulestandardAttrsEx;

            	            				    }
            	            				}
            	            			}
            	            		    break;
            	            		case PRINTABLE:
            	            			{
            	            				{
            	            				    int LA432_4 = LA(3);
            	            				    if ( ((sequence_pointer != NULL)))
            	            				    {
            	            				        alt432=1;
            	            				    }
            	            				    else if ( (ANTLR3_TRUE))
            	            				    {
            	            				        alt432=2;
            	            				    }
            	            				    else
            	            				    {

            	            				        CONSTRUCTEX();
            	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				        EXCEPTION->message      = (void *)"";
            	            				        EXCEPTION->decisionNum  = 432;
            	            				        EXCEPTION->state        = 4;


            	            				        goto rulestandardAttrsEx;

            	            				    }
            	            				}
            	            			}
            	            		    break;

            	            		default:
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 432;
            	            		    EXCEPTION->state        = 1;


            	            		    goto rulestandardAttrsEx;

            	            		}

            	            	}
            	                break;
            	            case ConstructedTag0:
            	            case ConstructedTag1:
            	            case ConstructedTag2:
            	            case ConstructedTag3:
            	            case ConstructedTag4:
            	            case ConstructedTag5:
            	            case ConstructedTag6:
            	            case SequenceTag:
            	            case SetTag:
            	            case Tag0:
            	            case Tag1:
            	            case Tag3:
            	            case Tag6:
            	            case Tag7:
            	            case Tag8:
            	            case TagInt1:
            	            case TagInt10:
            	            case TagInt11:
            	            case TagInt12:
            	            case TagInt13:
            	            case TagInt14:
            	            case TagInt15:
            	            case TagInt16:
            	            case TagInt17:
            	            case TagInt18:
            	            case TagInt19:
            	            case TagInt2:
            	            case TagInt20:
            	            case TagInt21:
            	            case TagInt22:
            	            case TagInt23:
            	            case TagInt3:
            	            case TagInt4:
            	            case TagInt5:
            	            case TagInt6:
            	            case TagInt7:
            	            case TagInt8:
            	            case TagInt9:
            	            	{
            	            		alt432=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 432;
            	                EXCEPTION->state        = 0;


            	                goto rulestandardAttrsEx;

            	            }

            	            switch (alt432)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3526:6: {...}? =>t2= tag2
            	        	    {
            	        	        if ( !((sequence_pointer != NULL)) )
            	        	        {
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"sequence_pointer != NULL";
            	        	                EXCEPTION->ruleName	 = (void *)"standardAttrs";


            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_tag2_in_standardAttrs8984);
            	        	        t2=tag2(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestandardAttrsEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, t2.tree);

            	        	        {
            	        	            if(!(1 <= t2.text
            	        	            ->length && t2.text
            	        	            ->length <= ub_initials_length))
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	gen_name->name->x400_addr->standard_attributes->initials = new_asn1_string(19,t2.text
            	        	            ->length,t2.text
            	        	            ->value);
            	        	            	
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3534:3: 
            	        	    {
            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:3534:5: (t3= tag3 )?
            	        {
            	            int alt433=2;
            	            switch ( LA(1) )
            	            {
            	                case Tag3:
            	                	{
            	                		alt433=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt433)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3534:6: t3= tag3
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tag3_in_standardAttrs8996);
            	        	        t3=tag3(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestandardAttrsEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, t3.tree);

            	        	        {
            	        	            if(!(1 <= t3.text
            	        	            ->length && t3.text
            	        	            ->length <= ub_generation_qualifier_length))
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	gen_name->name->x400_addr->standard_attributes->generation_qualifier = new_asn1_string(19,t3.text
            	        	            ->length,t3.text
            	        	            ->value);
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3542:5: 
            	    {
            	    }
            	    break;

                }
            }

            // Grammar/RFC5280.g:3542:7: ( constructedTag6 (print= printString )+ )?
            {
                int alt436=2;
                switch ( LA(1) )
                {
                    case ConstructedTag6:
                    	{
                    		alt436=1;
                    	}
                        break;
                }

                switch (alt436)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3542:8: constructedTag6 (print= printString )+
            	    {
            	        FOLLOWPUSH(FOLLOW_constructedTag6_in_standardAttrs9008);
            	        constructedTag61571=constructedTag6(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestandardAttrsEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag61571.tree);

            	        {
            	            gen_name->name->x400_addr->standard_attributes->organizational_unit_names = sk_STRING_POINTER_new_null();
            	        }


            	        // Grammar/RFC5280.g:3542:132: (print= printString )+
            	        {
            	            int cnt435=0;

            	            for (;;)
            	            {
            	                int alt435=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case PrintStringTag:
            	        		{
            	        			alt435=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt435)
            	        	{
            	        	    case 1:
            	        	        // Grammar/RFC5280.g:3542:133: print= printString
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_printString_in_standardAttrs9015);
            	        	            print=printString(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto rulestandardAttrsEx;
            	        	            }

            	        	            ADAPTOR->addChild(ADAPTOR, root_0, print.tree);

            	        	            {
            	        	                if(!(1 <= print.text
            	        	                ->length && print.text
            	        	                ->length <= ub_organizational_unit_name_length))
            	        	                	{
            	        	                		printf("Attribute String length constraint not satisfied \n");
            	        	                		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	                	}	
            	        	                	sk_STRING_POINTER_push(gen_name->name->x400_addr->standard_attributes->organizational_unit_names,print.text
            	        	                );
            	        	                	
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt435 >= 1 )
            	        		{
            	        		    goto loop435;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto rulestandardAttrsEx;
            	        	}
            	        	cnt435++;
            	            }
            	            loop435: ;	/* Jump to here if this rule does not match */
            	        }

            	        {
            	            int len = sk_STRING_POINTER_num(gen_name->name->x400_addr->standard_attributes->organizational_unit_names); 
            	            	if(!(1<len &&len<= ub_organizational_units))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestandardAttrsEx; /* Prevent compiler warnings */
    rulestandardAttrsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end standardAttrs */

/**
 * $ANTLR start countryName
 * Grammar/RFC5280.g:3558:1: countryName : appTag1 ( numericString | printString ) ;
 */
static RFC5280Parser_countryName_return
countryName(pRFC5280Parser ctx)
{
    RFC5280Parser_countryName_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_appTag1_return appTag11572;
    #undef	RETURN_TYPE_appTag11572
    #define	RETURN_TYPE_appTag11572 RFC5280Parser_appTag1_return

    RFC5280Parser_numericString_return numericString1573;
    #undef	RETURN_TYPE_numericString1573
    #define	RETURN_TYPE_numericString1573 RFC5280Parser_numericString_return

    RFC5280Parser_printString_return printString1574;
    #undef	RETURN_TYPE_printString1574
    #define	RETURN_TYPE_printString1574 RFC5280Parser_printString_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    ASN1_STRING *str;
    appTag11572.tree = NULL;

    numericString1573.tree = NULL;

    printString1574.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3562:2: ( appTag1 ( numericString | printString ) )
        // Grammar/RFC5280.g:3562:3: appTag1 ( numericString | printString )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_appTag1_in_countryName9047);
            appTag11572=appTag1(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulecountryNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, appTag11572.tree);

            // Grammar/RFC5280.g:3564:18: ( numericString | printString )
            {
                int alt437=2;
                switch ( LA(1) )
                {
                case NumericStringTag:
                	{
                		alt437=1;
                	}
                    break;
                case PrintStringTag:
                	{
                		alt437=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 437;
                    EXCEPTION->state        = 0;


                    goto rulecountryNameEx;

                }

                switch (alt437)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3564:19: numericString
            	    {
            	        FOLLOWPUSH(FOLLOW_numericString_in_countryName9050);
            	        numericString1573=numericString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecountryNameEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, numericString1573.tree);

            	        {
            	            str=numericString1573.text
            	            ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3564:62: printString
            	    {
            	        FOLLOWPUSH(FOLLOW_printString_in_countryName9056);
            	        printString1574=printString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulecountryNameEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, printString1574.tree);

            	        {
            	            str=printString1574.text
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            {
                if(str->length != ub_country_name_numeric_length)
                	{
                		printf("Attribute String length constraint not satisfied \n");
                		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
                	}
                	gen_name->name->x400_addr->standard_attributes->country_name = str;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecountryNameEx; /* Prevent compiler warnings */
    rulecountryNameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end countryName */

/**
 * $ANTLR start adName
 * Grammar/RFC5280.g:3573:1: adName : appTag2 ( numericString | printString ) ;
 */
static RFC5280Parser_adName_return
adName(pRFC5280Parser ctx)
{
    RFC5280Parser_adName_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_appTag2_return appTag21575;
    #undef	RETURN_TYPE_appTag21575
    #define	RETURN_TYPE_appTag21575 RFC5280Parser_appTag2_return

    RFC5280Parser_numericString_return numericString1576;
    #undef	RETURN_TYPE_numericString1576
    #define	RETURN_TYPE_numericString1576 RFC5280Parser_numericString_return

    RFC5280Parser_printString_return printString1577;
    #undef	RETURN_TYPE_printString1577
    #define	RETURN_TYPE_printString1577 RFC5280Parser_printString_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    ASN1_STRING *str;
    appTag21575.tree = NULL;

    numericString1576.tree = NULL;

    printString1577.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3577:2: ( appTag2 ( numericString | printString ) )
        // Grammar/RFC5280.g:3577:3: appTag2 ( numericString | printString )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_appTag2_in_adName9083);
            appTag21575=appTag2(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleadNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, appTag21575.tree);

            // Grammar/RFC5280.g:3579:18: ( numericString | printString )
            {
                int alt438=2;
                switch ( LA(1) )
                {
                case NumericStringTag:
                	{
                		alt438=1;
                	}
                    break;
                case PrintStringTag:
                	{
                		alt438=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 438;
                    EXCEPTION->state        = 0;


                    goto ruleadNameEx;

                }

                switch (alt438)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3579:19: numericString
            	    {
            	        FOLLOWPUSH(FOLLOW_numericString_in_adName9086);
            	        numericString1576=numericString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadNameEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, numericString1576.tree);

            	        {
            	            str=numericString1576.text
            	            ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3579:62: printString
            	    {
            	        FOLLOWPUSH(FOLLOW_printString_in_adName9092);
            	        printString1577=printString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleadNameEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, printString1577.tree);

            	        {
            	            str=printString1577.text
            	            ;
            	        }


            	    }
            	    break;

                }
            }

            {
                if(str->length > ub_domain_name_length)
                	{
                		printf("Attribute String length constraint not satisfied \n");
                		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
                	}
                	gen_name->name->x400_addr->standard_attributes->ad_name = str;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleadNameEx; /* Prevent compiler warnings */
    ruleadNameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end adName */

/**
 * $ANTLR start definedAttrs
 * Grammar/RFC5280.g:3589:1: definedAttrs : sequenceTag ( definedAttr )+ ;
 */
static RFC5280Parser_definedAttrs_return
definedAttrs(pRFC5280Parser ctx)
{
    RFC5280Parser_definedAttrs_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1578;
    #undef	RETURN_TYPE_sequenceTag1578
    #define	RETURN_TYPE_sequenceTag1578 RFC5280Parser_sequenceTag_return

    RFC5280Parser_definedAttr_return definedAttr1579;
    #undef	RETURN_TYPE_definedAttr1579
    #define	RETURN_TYPE_definedAttr1579 RFC5280Parser_definedAttr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1578.tree = NULL;

    definedAttr1579.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3593:2: ( sequenceTag ( definedAttr )+ )
        // Grammar/RFC5280.g:3593:3: sequenceTag ( definedAttr )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_definedAttrs9117);
            sequenceTag1578=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledefinedAttrsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1578.tree);

            {
                gen_name->name->x400_addr->defined_attributes = sk_DEFINED_ATTRS_POINTER_new_null();
            }


            // Grammar/RFC5280.g:3595:109: ( definedAttr )+
            {
                int cnt439=0;

                for (;;)
                {
                    int alt439=2;
            	switch ( LA(1) )
            	{
            	case SequenceTag:
            		{
            			switch ( LA(2) )
            			{
            			case PrintStringTag:
            				{
            					alt439=1;
            				}
            			    break;

            			}

            		}
            	    break;

            	}

            	switch (alt439)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:3595:110: definedAttr
            	        {
            	            FOLLOWPUSH(FOLLOW_definedAttr_in_definedAttrs9122);
            	            definedAttr1579=definedAttr(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruledefinedAttrsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, definedAttr1579.tree);

            	            {

            	                	sk_DEFINED_ATTRS_POINTER_push(gen_name->name->x400_addr->defined_attributes,definedAttr1579.text
            	                );
            	                	
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt439 >= 1 )
            		{
            		    goto loop439;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruledefinedAttrsEx;
            	}
            	cnt439++;
                }
                loop439: ;	/* Jump to here if this rule does not match */
            }

            {

                		int len = sk_DEFINED_ATTRS_POINTER_num(gen_name->name->x400_addr->defined_attributes);
                		if(len > ub_domain_defined_attributes)
                		{
                			printf("Error on defined attributes stack size \n");
                			exit(DEFINED_ATTRS_STACK_SIZE_ERROR);
                		}	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledefinedAttrsEx; /* Prevent compiler warnings */
    ruledefinedAttrsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end definedAttrs */

/**
 * $ANTLR start definedAttr
 * Grammar/RFC5280.g:3609:1: definedAttr returns [DEFINED_ATTRS_POINTER text] : sequenceTag type= printString value= printString ;
 */
static RFC5280Parser_definedAttr_return
definedAttr(pRFC5280Parser ctx)
{
    RFC5280Parser_definedAttr_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_printString_return type;
    #undef	RETURN_TYPE_type
    #define	RETURN_TYPE_type RFC5280Parser_printString_return

    RFC5280Parser_printString_return value;
    #undef	RETURN_TYPE_value
    #define	RETURN_TYPE_value RFC5280Parser_printString_return

    RFC5280Parser_sequenceTag_return sequenceTag1580;
    #undef	RETURN_TYPE_sequenceTag1580
    #define	RETURN_TYPE_sequenceTag1580 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    type.tree = NULL;

    value.tree = NULL;

    sequenceTag1580.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3613:2: ( sequenceTag type= printString value= printString )
        // Grammar/RFC5280.g:3613:3: sequenceTag type= printString value= printString
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_definedAttr9152);
            sequenceTag1580=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledefinedAttrEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1580.tree);

            FOLLOWPUSH(FOLLOW_printString_in_definedAttr9156);
            type=printString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledefinedAttrEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, type.tree);

            FOLLOWPUSH(FOLLOW_printString_in_definedAttr9160);
            value=printString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledefinedAttrEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, value.tree);

            {

                		retval.text= malloc(sizeof(defined_attrs));

                		if(!(1<= type.text
                ->length && type.text
                ->length <= ub_domain_defined_attribute_type_length))
                		{
                			printf("Attribute String length constraint not satisfied \n");
                			warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
                		}
                		retval.text
                ->type = type.text
                ;
                		if(!(1<= value.text
                ->length && value.text
                ->length <= ub_domain_defined_attribute_value_length))
                		{
                			printf("Attribute String length constraint not satisfied \n");
                			warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
                		}
                		retval.text
                ->value = value.text
                ;
                		
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledefinedAttrEx; /* Prevent compiler warnings */
    ruledefinedAttrEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end definedAttr */

/**
 * $ANTLR start extensionAttrs
 * Grammar/RFC5280.g:3632:1: extensionAttrs : set ( extensionAttr )+ ;
 */
static RFC5280Parser_extensionAttrs_return
extensionAttrs(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionAttrs_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_set_return set1581;
    #undef	RETURN_TYPE_set1581
    #define	RETURN_TYPE_set1581 RFC5280Parser_set_return

    RFC5280Parser_extensionAttr_return extensionAttr1582;
    #undef	RETURN_TYPE_extensionAttr1582
    #define	RETURN_TYPE_extensionAttr1582 RFC5280Parser_extensionAttr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    set1581.tree = NULL;

    extensionAttr1582.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3636:2: ( set ( extensionAttr )+ )
        // Grammar/RFC5280.g:3636:3: set ( extensionAttr )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_set_in_extensionAttrs9179);
            set1581=set(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionAttrsEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, set1581.tree);

            {
                gen_name->name->x400_addr->extensions_attributes = sk_EXTENSIONS_ATTRS_POINTER_new_null();
            }


            // Grammar/RFC5280.g:3638:106: ( extensionAttr )+
            {
                int cnt440=0;

                for (;;)
                {
                    int alt440=2;
            	switch ( LA(1) )
            	{
            	case SequenceTag:
            		{
            			switch ( LA(2) )
            			{
            			case Tag0:
            			case TagInt1:
            			case TagInt10:
            			case TagInt11:
            			case TagInt12:
            			case TagInt13:
            			case TagInt14:
            			case TagInt15:
            			case TagInt16:
            			case TagInt17:
            			case TagInt18:
            			case TagInt19:
            			case TagInt2:
            			case TagInt20:
            			case TagInt21:
            			case TagInt22:
            			case TagInt23:
            			case TagInt3:
            			case TagInt4:
            			case TagInt5:
            			case TagInt6:
            			case TagInt7:
            			case TagInt8:
            			case TagInt9:
            				{
            					alt440=1;
            				}
            			    break;

            			}

            		}
            	    break;

            	}

            	switch (alt440)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:3638:107: extensionAttr
            	        {
            	            FOLLOWPUSH(FOLLOW_extensionAttr_in_extensionAttrs9183);
            	            extensionAttr1582=extensionAttr(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleextensionAttrsEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, extensionAttr1582.tree);

            	            {
            	                sk_EXTENSIONS_ATTRS_POINTER_push(gen_name->name->x400_addr->extensions_attributes,extensionAttr1582.text
            	                );
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt440 >= 1 )
            		{
            		    goto loop440;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleextensionAttrsEx;
            	}
            	cnt440++;
                }
                loop440: ;	/* Jump to here if this rule does not match */
            }

            {

                		int len = sk_EXTENSIONS_ATTRS_POINTER_num(gen_name->name->x400_addr->extensions_attributes);
                		if(len > ub_extensions_attributes)
                		{
                			printf("Error on extension attributes stack size \n");
                			exit(EXTENSIONS_ATTRS_STACK_SIZE_ERROR);
                		}
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionAttrsEx; /* Prevent compiler warnings */
    ruleextensionAttrsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionAttrs */

/**
 * $ANTLR start extensionAttr
 * Grammar/RFC5280.g:3649:1: extensionAttr returns [EXTENSIONS_ATTRS_POINTER text] : sequenceTag ( tagInt1 constructedTag1 str= printString | tagInt2 constructedTag1 strtel= teletexString | tagInt3 constructedTag1 strtel= teletexString | tagInt4 constructedTag1 set (t0= tag0 ) (|{...}? =>t1= tag1 ) (|{...}? => tag2 ) ( tag3 )? | tagInt5 constructedTag1 sequenceTag (strtel= teletexString )+ | tagInt7 constructedTag1 str= printString | tagInt8 constructedTag1 (strnum= numericString |str= printString ) | tagInt9 constructedTag1 (strnum= numericString |str= printString ) | ( tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 ) constructedTag1 set (str= printString )? (t61= teletexString )? | tagInt16 constructedTag1 set ( sequenceTag (str= printString )+ )? (t61= teletexString )? | tagInt22 constructedTag1 (t0= tag0 ({...}? =>t1= tag1 |) | constructedTag0 ( constructedTag0 p= octetstring )? ( constructedTag1 s= octetstring )? ( constructedTag2 t= octetstring )? ( constructedTag3 set (n= octetstring )+ )? ) | tagInt23 constructedTag1 i23= integer | tagInt6 constructedTag1 sequenceTag ( sequenceTag type= teletexString value= teletexString )+ |i= onlyTag0 any ) ;
 */
static RFC5280Parser_extensionAttr_return
extensionAttr(pRFC5280Parser ctx)
{
    RFC5280Parser_extensionAttr_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_printString_return str;
    #undef	RETURN_TYPE_str
    #define	RETURN_TYPE_str RFC5280Parser_printString_return

    RFC5280Parser_teletexString_return strtel;
    #undef	RETURN_TYPE_strtel
    #define	RETURN_TYPE_strtel RFC5280Parser_teletexString_return

    RFC5280Parser_tag0_return t0;
    #undef	RETURN_TYPE_t0
    #define	RETURN_TYPE_t0 RFC5280Parser_tag0_return

    RFC5280Parser_tag1_return t1;
    #undef	RETURN_TYPE_t1
    #define	RETURN_TYPE_t1 RFC5280Parser_tag1_return

    RFC5280Parser_numericString_return strnum;
    #undef	RETURN_TYPE_strnum
    #define	RETURN_TYPE_strnum RFC5280Parser_numericString_return

    RFC5280Parser_teletexString_return t61;
    #undef	RETURN_TYPE_t61
    #define	RETURN_TYPE_t61 RFC5280Parser_teletexString_return

    RFC5280Parser_octetstring_return p;
    #undef	RETURN_TYPE_p
    #define	RETURN_TYPE_p RFC5280Parser_octetstring_return

    RFC5280Parser_octetstring_return s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s RFC5280Parser_octetstring_return

    RFC5280Parser_octetstring_return t;
    #undef	RETURN_TYPE_t
    #define	RETURN_TYPE_t RFC5280Parser_octetstring_return

    RFC5280Parser_octetstring_return n;
    #undef	RETURN_TYPE_n
    #define	RETURN_TYPE_n RFC5280Parser_octetstring_return

    RFC5280Parser_integer_return i23;
    #undef	RETURN_TYPE_i23
    #define	RETURN_TYPE_i23 RFC5280Parser_integer_return

    RFC5280Parser_teletexString_return type;
    #undef	RETURN_TYPE_type
    #define	RETURN_TYPE_type RFC5280Parser_teletexString_return

    RFC5280Parser_teletexString_return value;
    #undef	RETURN_TYPE_value
    #define	RETURN_TYPE_value RFC5280Parser_teletexString_return

    RFC5280Parser_onlyTag0_return i;
    #undef	RETURN_TYPE_i
    #define	RETURN_TYPE_i RFC5280Parser_onlyTag0_return

    RFC5280Parser_sequenceTag_return sequenceTag1583;
    #undef	RETURN_TYPE_sequenceTag1583
    #define	RETURN_TYPE_sequenceTag1583 RFC5280Parser_sequenceTag_return

    RFC5280Parser_tagInt1_return tagInt11584;
    #undef	RETURN_TYPE_tagInt11584
    #define	RETURN_TYPE_tagInt11584 RFC5280Parser_tagInt1_return

    RFC5280Parser_constructedTag1_return constructedTag11585;
    #undef	RETURN_TYPE_constructedTag11585
    #define	RETURN_TYPE_constructedTag11585 RFC5280Parser_constructedTag1_return

    RFC5280Parser_tagInt2_return tagInt21586;
    #undef	RETURN_TYPE_tagInt21586
    #define	RETURN_TYPE_tagInt21586 RFC5280Parser_tagInt2_return

    RFC5280Parser_constructedTag1_return constructedTag11587;
    #undef	RETURN_TYPE_constructedTag11587
    #define	RETURN_TYPE_constructedTag11587 RFC5280Parser_constructedTag1_return

    RFC5280Parser_tagInt3_return tagInt31588;
    #undef	RETURN_TYPE_tagInt31588
    #define	RETURN_TYPE_tagInt31588 RFC5280Parser_tagInt3_return

    RFC5280Parser_constructedTag1_return constructedTag11589;
    #undef	RETURN_TYPE_constructedTag11589
    #define	RETURN_TYPE_constructedTag11589 RFC5280Parser_constructedTag1_return

    RFC5280Parser_tagInt4_return tagInt41590;
    #undef	RETURN_TYPE_tagInt41590
    #define	RETURN_TYPE_tagInt41590 RFC5280Parser_tagInt4_return

    RFC5280Parser_constructedTag1_return constructedTag11591;
    #undef	RETURN_TYPE_constructedTag11591
    #define	RETURN_TYPE_constructedTag11591 RFC5280Parser_constructedTag1_return

    RFC5280Parser_set_return set1592;
    #undef	RETURN_TYPE_set1592
    #define	RETURN_TYPE_set1592 RFC5280Parser_set_return

    RFC5280Parser_tag2_return tag21593;
    #undef	RETURN_TYPE_tag21593
    #define	RETURN_TYPE_tag21593 RFC5280Parser_tag2_return

    RFC5280Parser_tag3_return tag31594;
    #undef	RETURN_TYPE_tag31594
    #define	RETURN_TYPE_tag31594 RFC5280Parser_tag3_return

    RFC5280Parser_tagInt5_return tagInt51595;
    #undef	RETURN_TYPE_tagInt51595
    #define	RETURN_TYPE_tagInt51595 RFC5280Parser_tagInt5_return

    RFC5280Parser_constructedTag1_return constructedTag11596;
    #undef	RETURN_TYPE_constructedTag11596
    #define	RETURN_TYPE_constructedTag11596 RFC5280Parser_constructedTag1_return

    RFC5280Parser_sequenceTag_return sequenceTag1597;
    #undef	RETURN_TYPE_sequenceTag1597
    #define	RETURN_TYPE_sequenceTag1597 RFC5280Parser_sequenceTag_return

    RFC5280Parser_tagInt7_return tagInt71598;
    #undef	RETURN_TYPE_tagInt71598
    #define	RETURN_TYPE_tagInt71598 RFC5280Parser_tagInt7_return

    RFC5280Parser_constructedTag1_return constructedTag11599;
    #undef	RETURN_TYPE_constructedTag11599
    #define	RETURN_TYPE_constructedTag11599 RFC5280Parser_constructedTag1_return

    RFC5280Parser_tagInt8_return tagInt81600;
    #undef	RETURN_TYPE_tagInt81600
    #define	RETURN_TYPE_tagInt81600 RFC5280Parser_tagInt8_return

    RFC5280Parser_constructedTag1_return constructedTag11601;
    #undef	RETURN_TYPE_constructedTag11601
    #define	RETURN_TYPE_constructedTag11601 RFC5280Parser_constructedTag1_return

    RFC5280Parser_tagInt9_return tagInt91602;
    #undef	RETURN_TYPE_tagInt91602
    #define	RETURN_TYPE_tagInt91602 RFC5280Parser_tagInt9_return

    RFC5280Parser_constructedTag1_return constructedTag11603;
    #undef	RETURN_TYPE_constructedTag11603
    #define	RETURN_TYPE_constructedTag11603 RFC5280Parser_constructedTag1_return

    RFC5280Parser_tagInt10_return tagInt101604;
    #undef	RETURN_TYPE_tagInt101604
    #define	RETURN_TYPE_tagInt101604 RFC5280Parser_tagInt10_return

    RFC5280Parser_tagInt11_return tagInt111605;
    #undef	RETURN_TYPE_tagInt111605
    #define	RETURN_TYPE_tagInt111605 RFC5280Parser_tagInt11_return

    RFC5280Parser_tagInt12_return tagInt121606;
    #undef	RETURN_TYPE_tagInt121606
    #define	RETURN_TYPE_tagInt121606 RFC5280Parser_tagInt12_return

    RFC5280Parser_tagInt13_return tagInt131607;
    #undef	RETURN_TYPE_tagInt131607
    #define	RETURN_TYPE_tagInt131607 RFC5280Parser_tagInt13_return

    RFC5280Parser_tagInt14_return tagInt141608;
    #undef	RETURN_TYPE_tagInt141608
    #define	RETURN_TYPE_tagInt141608 RFC5280Parser_tagInt14_return

    RFC5280Parser_tagInt15_return tagInt151609;
    #undef	RETURN_TYPE_tagInt151609
    #define	RETURN_TYPE_tagInt151609 RFC5280Parser_tagInt15_return

    RFC5280Parser_tagInt17_return tagInt171610;
    #undef	RETURN_TYPE_tagInt171610
    #define	RETURN_TYPE_tagInt171610 RFC5280Parser_tagInt17_return

    RFC5280Parser_tagInt18_return tagInt181611;
    #undef	RETURN_TYPE_tagInt181611
    #define	RETURN_TYPE_tagInt181611 RFC5280Parser_tagInt18_return

    RFC5280Parser_tagInt19_return tagInt191612;
    #undef	RETURN_TYPE_tagInt191612
    #define	RETURN_TYPE_tagInt191612 RFC5280Parser_tagInt19_return

    RFC5280Parser_tagInt20_return tagInt201613;
    #undef	RETURN_TYPE_tagInt201613
    #define	RETURN_TYPE_tagInt201613 RFC5280Parser_tagInt20_return

    RFC5280Parser_tagInt21_return tagInt211614;
    #undef	RETURN_TYPE_tagInt211614
    #define	RETURN_TYPE_tagInt211614 RFC5280Parser_tagInt21_return

    RFC5280Parser_constructedTag1_return constructedTag11615;
    #undef	RETURN_TYPE_constructedTag11615
    #define	RETURN_TYPE_constructedTag11615 RFC5280Parser_constructedTag1_return

    RFC5280Parser_set_return set1616;
    #undef	RETURN_TYPE_set1616
    #define	RETURN_TYPE_set1616 RFC5280Parser_set_return

    RFC5280Parser_tagInt16_return tagInt161617;
    #undef	RETURN_TYPE_tagInt161617
    #define	RETURN_TYPE_tagInt161617 RFC5280Parser_tagInt16_return

    RFC5280Parser_constructedTag1_return constructedTag11618;
    #undef	RETURN_TYPE_constructedTag11618
    #define	RETURN_TYPE_constructedTag11618 RFC5280Parser_constructedTag1_return

    RFC5280Parser_set_return set1619;
    #undef	RETURN_TYPE_set1619
    #define	RETURN_TYPE_set1619 RFC5280Parser_set_return

    RFC5280Parser_sequenceTag_return sequenceTag1620;
    #undef	RETURN_TYPE_sequenceTag1620
    #define	RETURN_TYPE_sequenceTag1620 RFC5280Parser_sequenceTag_return

    RFC5280Parser_tagInt22_return tagInt221621;
    #undef	RETURN_TYPE_tagInt221621
    #define	RETURN_TYPE_tagInt221621 RFC5280Parser_tagInt22_return

    RFC5280Parser_constructedTag1_return constructedTag11622;
    #undef	RETURN_TYPE_constructedTag11622
    #define	RETURN_TYPE_constructedTag11622 RFC5280Parser_constructedTag1_return

    RFC5280Parser_constructedTag0_return constructedTag01623;
    #undef	RETURN_TYPE_constructedTag01623
    #define	RETURN_TYPE_constructedTag01623 RFC5280Parser_constructedTag0_return

    RFC5280Parser_constructedTag0_return constructedTag01624;
    #undef	RETURN_TYPE_constructedTag01624
    #define	RETURN_TYPE_constructedTag01624 RFC5280Parser_constructedTag0_return

    RFC5280Parser_constructedTag1_return constructedTag11625;
    #undef	RETURN_TYPE_constructedTag11625
    #define	RETURN_TYPE_constructedTag11625 RFC5280Parser_constructedTag1_return

    RFC5280Parser_constructedTag2_return constructedTag21626;
    #undef	RETURN_TYPE_constructedTag21626
    #define	RETURN_TYPE_constructedTag21626 RFC5280Parser_constructedTag2_return

    RFC5280Parser_constructedTag3_return constructedTag31627;
    #undef	RETURN_TYPE_constructedTag31627
    #define	RETURN_TYPE_constructedTag31627 RFC5280Parser_constructedTag3_return

    RFC5280Parser_set_return set1628;
    #undef	RETURN_TYPE_set1628
    #define	RETURN_TYPE_set1628 RFC5280Parser_set_return

    RFC5280Parser_tagInt23_return tagInt231629;
    #undef	RETURN_TYPE_tagInt231629
    #define	RETURN_TYPE_tagInt231629 RFC5280Parser_tagInt23_return

    RFC5280Parser_constructedTag1_return constructedTag11630;
    #undef	RETURN_TYPE_constructedTag11630
    #define	RETURN_TYPE_constructedTag11630 RFC5280Parser_constructedTag1_return

    RFC5280Parser_tagInt6_return tagInt61631;
    #undef	RETURN_TYPE_tagInt61631
    #define	RETURN_TYPE_tagInt61631 RFC5280Parser_tagInt6_return

    RFC5280Parser_constructedTag1_return constructedTag11632;
    #undef	RETURN_TYPE_constructedTag11632
    #define	RETURN_TYPE_constructedTag11632 RFC5280Parser_constructedTag1_return

    RFC5280Parser_sequenceTag_return sequenceTag1633;
    #undef	RETURN_TYPE_sequenceTag1633
    #define	RETURN_TYPE_sequenceTag1633 RFC5280Parser_sequenceTag_return

    RFC5280Parser_sequenceTag_return sequenceTag1634;
    #undef	RETURN_TYPE_sequenceTag1634
    #define	RETURN_TYPE_sequenceTag1634 RFC5280Parser_sequenceTag_return

    RFC5280Parser_any_return any1635;
    #undef	RETURN_TYPE_any1635
    #define	RETURN_TYPE_any1635 RFC5280Parser_any_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    ASN1_STRING *str_num_or_print;
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    str.tree = NULL;

    strtel.tree = NULL;

    t0.tree = NULL;

    t1.tree = NULL;

    strnum.tree = NULL;

    t61.tree = NULL;

    p.tree = NULL;

    s.tree = NULL;

    t.tree = NULL;

    n.tree = NULL;

    i23.tree = NULL;

    type.tree = NULL;

    value.tree = NULL;

    i.tree = NULL;

    sequenceTag1583.tree = NULL;

    tagInt11584.tree = NULL;

    constructedTag11585.tree = NULL;

    tagInt21586.tree = NULL;

    constructedTag11587.tree = NULL;

    tagInt31588.tree = NULL;

    constructedTag11589.tree = NULL;

    tagInt41590.tree = NULL;

    constructedTag11591.tree = NULL;

    set1592.tree = NULL;

    tag21593.tree = NULL;

    tag31594.tree = NULL;

    tagInt51595.tree = NULL;

    constructedTag11596.tree = NULL;

    sequenceTag1597.tree = NULL;

    tagInt71598.tree = NULL;

    constructedTag11599.tree = NULL;

    tagInt81600.tree = NULL;

    constructedTag11601.tree = NULL;

    tagInt91602.tree = NULL;

    constructedTag11603.tree = NULL;

    tagInt101604.tree = NULL;

    tagInt111605.tree = NULL;

    tagInt121606.tree = NULL;

    tagInt131607.tree = NULL;

    tagInt141608.tree = NULL;

    tagInt151609.tree = NULL;

    tagInt171610.tree = NULL;

    tagInt181611.tree = NULL;

    tagInt191612.tree = NULL;

    tagInt201613.tree = NULL;

    tagInt211614.tree = NULL;

    constructedTag11615.tree = NULL;

    set1616.tree = NULL;

    tagInt161617.tree = NULL;

    constructedTag11618.tree = NULL;

    set1619.tree = NULL;

    sequenceTag1620.tree = NULL;

    tagInt221621.tree = NULL;

    constructedTag11622.tree = NULL;

    constructedTag01623.tree = NULL;

    constructedTag01624.tree = NULL;

    constructedTag11625.tree = NULL;

    constructedTag21626.tree = NULL;

    constructedTag31627.tree = NULL;

    set1628.tree = NULL;

    tagInt231629.tree = NULL;

    constructedTag11630.tree = NULL;

    tagInt61631.tree = NULL;

    constructedTag11632.tree = NULL;

    sequenceTag1633.tree = NULL;

    sequenceTag1634.tree = NULL;

    any1635.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3656:2: ( sequenceTag ( tagInt1 constructedTag1 str= printString | tagInt2 constructedTag1 strtel= teletexString | tagInt3 constructedTag1 strtel= teletexString | tagInt4 constructedTag1 set (t0= tag0 ) (|{...}? =>t1= tag1 ) (|{...}? => tag2 ) ( tag3 )? | tagInt5 constructedTag1 sequenceTag (strtel= teletexString )+ | tagInt7 constructedTag1 str= printString | tagInt8 constructedTag1 (strnum= numericString |str= printString ) | tagInt9 constructedTag1 (strnum= numericString |str= printString ) | ( tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 ) constructedTag1 set (str= printString )? (t61= teletexString )? | tagInt16 constructedTag1 set ( sequenceTag (str= printString )+ )? (t61= teletexString )? | tagInt22 constructedTag1 (t0= tag0 ({...}? =>t1= tag1 |) | constructedTag0 ( constructedTag0 p= octetstring )? ( constructedTag1 s= octetstring )? ( constructedTag2 t= octetstring )? ( constructedTag3 set (n= octetstring )+ )? ) | tagInt23 constructedTag1 i23= integer | tagInt6 constructedTag1 sequenceTag ( sequenceTag type= teletexString value= teletexString )+ |i= onlyTag0 any ) )
        // Grammar/RFC5280.g:3656:4: sequenceTag ( tagInt1 constructedTag1 str= printString | tagInt2 constructedTag1 strtel= teletexString | tagInt3 constructedTag1 strtel= teletexString | tagInt4 constructedTag1 set (t0= tag0 ) (|{...}? =>t1= tag1 ) (|{...}? => tag2 ) ( tag3 )? | tagInt5 constructedTag1 sequenceTag (strtel= teletexString )+ | tagInt7 constructedTag1 str= printString | tagInt8 constructedTag1 (strnum= numericString |str= printString ) | tagInt9 constructedTag1 (strnum= numericString |str= printString ) | ( tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 ) constructedTag1 set (str= printString )? (t61= teletexString )? | tagInt16 constructedTag1 set ( sequenceTag (str= printString )+ )? (t61= teletexString )? | tagInt22 constructedTag1 (t0= tag0 ({...}? =>t1= tag1 |) | constructedTag0 ( constructedTag0 p= octetstring )? ( constructedTag1 s= octetstring )? ( constructedTag2 t= octetstring )? ( constructedTag3 set (n= octetstring )+ )? ) | tagInt23 constructedTag1 i23= integer | tagInt6 constructedTag1 sequenceTag ( sequenceTag type= teletexString value= teletexString )+ |i= onlyTag0 any )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionAttr9215);
            sequenceTag1583=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleextensionAttrEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1583.tree);

            {
                retval.text=malloc(sizeof(extensions_attrs));

            }


            // Grammar/RFC5280.g:3657:3: ( tagInt1 constructedTag1 str= printString | tagInt2 constructedTag1 strtel= teletexString | tagInt3 constructedTag1 strtel= teletexString | tagInt4 constructedTag1 set (t0= tag0 ) (|{...}? =>t1= tag1 ) (|{...}? => tag2 ) ( tag3 )? | tagInt5 constructedTag1 sequenceTag (strtel= teletexString )+ | tagInt7 constructedTag1 str= printString | tagInt8 constructedTag1 (strnum= numericString |str= printString ) | tagInt9 constructedTag1 (strnum= numericString |str= printString ) | ( tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 ) constructedTag1 set (str= printString )? (t61= teletexString )? | tagInt16 constructedTag1 set ( sequenceTag (str= printString )+ )? (t61= teletexString )? | tagInt22 constructedTag1 (t0= tag0 ({...}? =>t1= tag1 |) | constructedTag0 ( constructedTag0 p= octetstring )? ( constructedTag1 s= octetstring )? ( constructedTag2 t= octetstring )? ( constructedTag3 set (n= octetstring )+ )? ) | tagInt23 constructedTag1 i23= integer | tagInt6 constructedTag1 sequenceTag ( sequenceTag type= teletexString value= teletexString )+ |i= onlyTag0 any )
            {
                int alt461=14;
                switch ( LA(1) )
                {
                case TagInt1:
                	{
                		alt461=1;
                	}
                    break;
                case TagInt2:
                	{
                		alt461=2;
                	}
                    break;
                case TagInt3:
                	{
                		alt461=3;
                	}
                    break;
                case TagInt4:
                	{
                		alt461=4;
                	}
                    break;
                case TagInt5:
                	{
                		alt461=5;
                	}
                    break;
                case TagInt7:
                	{
                		alt461=6;
                	}
                    break;
                case TagInt8:
                	{
                		alt461=7;
                	}
                    break;
                case TagInt9:
                	{
                		alt461=8;
                	}
                    break;
                case TagInt10:
                case TagInt11:
                case TagInt12:
                case TagInt13:
                case TagInt14:
                case TagInt15:
                case TagInt17:
                case TagInt18:
                case TagInt19:
                case TagInt20:
                case TagInt21:
                	{
                		alt461=9;
                	}
                    break;
                case TagInt16:
                	{
                		alt461=10;
                	}
                    break;
                case TagInt22:
                	{
                		alt461=11;
                	}
                    break;
                case TagInt23:
                	{
                		alt461=12;
                	}
                    break;
                case TagInt6:
                	{
                		alt461=13;
                	}
                    break;
                case Tag0:
                	{
                		alt461=14;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 461;
                    EXCEPTION->state        = 0;


                    goto ruleextensionAttrEx;

                }

                switch (alt461)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3657:4: tagInt1 constructedTag1 str= printString
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt1_in_extensionAttr9222);
            	        tagInt11584=tagInt1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt11584.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9224);
            	        constructedTag11585=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11585.tree);

            	        FOLLOWPUSH(FOLLOW_printString_in_extensionAttr9228);
            	        str=printString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, str.tree);

            	        {
            	            retval.text
            	            ->type=1;retval.text
            	            ->value = malloc(sizeof(EXTS_ATTRS_VALUE)); 
            	            	 if(!(1<= str.text
            	            ->length && str.text
            	            ->length <= ub_common_name_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	retval.text
            	            ->value->str_value=str.text
            	            ;
            	        }


            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3663:40: tagInt2 constructedTag1 strtel= teletexString
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt2_in_extensionAttr9234);
            	        tagInt21586=tagInt2(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt21586.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9236);
            	        constructedTag11587=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11587.tree);

            	        FOLLOWPUSH(FOLLOW_teletexString_in_extensionAttr9240);
            	        strtel=teletexString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, strtel.tree);

            	        {
            	             retval.text
            	            ->type=2;retval.text
            	            ->value = malloc(sizeof(EXTS_ATTRS_VALUE));
            	            	if(!(1<= strtel.text
            	            ->length && strtel.text
            	            ->length <= ub_common_name_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	 retval.text
            	            ->value->str_value=strtel.text
            	            ;
            	            	 
            	        }


            	    }
            	    break;
            	case 3:
            	    // Grammar/RFC5280.g:3670:6: tagInt3 constructedTag1 strtel= teletexString
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt3_in_extensionAttr9245);
            	        tagInt31588=tagInt3(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt31588.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9247);
            	        constructedTag11589=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11589.tree);

            	        FOLLOWPUSH(FOLLOW_teletexString_in_extensionAttr9251);
            	        strtel=teletexString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, strtel.tree);

            	        {
            	             retval.text
            	            ->type=3;retval.text
            	            ->value = malloc(sizeof(EXTS_ATTRS_VALUE));
            	            	 if(!(1<= strtel.text
            	            ->length && strtel.text
            	            ->length <= ub_organization_name_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	 retval.text
            	            ->value->str_value=strtel.text
            	            ;
            	            	 
            	        }


            	    }
            	    break;
            	case 4:
            	    // Grammar/RFC5280.g:3678:4: tagInt4 constructedTag1 set (t0= tag0 ) (|{...}? =>t1= tag1 ) (|{...}? => tag2 ) ( tag3 )?
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt4_in_extensionAttr9258);
            	        tagInt41590=tagInt4(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt41590.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9260);
            	        constructedTag11591=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11591.tree);

            	        FOLLOWPUSH(FOLLOW_set_in_extensionAttr9262);
            	        set1592=set(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, set1592.tree);

            	        // Grammar/RFC5280.g:3678:32: (t0= tag0 )
            	        // Grammar/RFC5280.g:3678:33: t0= tag0
            	        {
            	            FOLLOWPUSH(FOLLOW_tag0_in_extensionAttr9267);
            	            t0=tag0(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleextensionAttrEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, t0.tree);

            	            {
            	                retval.text
            	                ->type=4;
            	                	retval.text
            	                ->value = malloc(sizeof(EXTS_ATTRS_VALUE));
            	                	 retval.text
            	                ->value->personal_name = malloc(sizeof(PERSONAL_NAME));
            	                	 if(!(1<= t0.text
            	                ->length && t0.text
            	                ->length <= ub_surname_length))
            	                	{
            	                		printf("Attribute String length constraint not satisfied \n");
            	                		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	                	}
            	                	 retval.text
            	                ->value->personal_name->surname = new_asn1_string(20,t0.text
            	                ->length,t0.text
            	                ->value);
            	                	 retval.text
            	                ->value->personal_name->given_name = NULL;
            	                	 retval.text
            	                ->value->personal_name->initials = NULL;
            	                	 retval.text
            	                ->value->personal_name->gen_qualifier = NULL;
            	                	
            	            }


            	        }


            	        // Grammar/RFC5280.g:3690:5: (|{...}? =>t1= tag1 )
            	        {
            	            int alt441=2;
            	            switch ( LA(1) )
            	            {
            	            case ConstructedTag0:
            	            case ConstructedTag1:
            	            case ConstructedTag2:
            	            case ConstructedTag3:
            	            case ConstructedTag4:
            	            case ConstructedTag5:
            	            case SequenceTag:
            	            case Tag0:
            	            case Tag2:
            	            case Tag3:
            	            case Tag6:
            	            case Tag7:
            	            case Tag8:
            	            case TagInt1:
            	            case TagInt10:
            	            case TagInt11:
            	            case TagInt12:
            	            case TagInt13:
            	            case TagInt14:
            	            case TagInt15:
            	            case TagInt16:
            	            case TagInt17:
            	            case TagInt18:
            	            case TagInt19:
            	            case TagInt2:
            	            case TagInt20:
            	            case TagInt21:
            	            case TagInt22:
            	            case TagInt23:
            	            case TagInt3:
            	            case TagInt4:
            	            case TagInt5:
            	            case TagInt6:
            	            case TagInt7:
            	            case TagInt8:
            	            case TagInt9:
            	            	{
            	            		alt441=1;
            	            	}
            	                break;
            	            case Tag1:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case VALUE:
            	            			{
            	            				{
            	            				    int LA441_3 = LA(3);
            	            				    if ( (!( ((sequence_pointer != NULL)) )))
            	            				    {
            	            				        alt441=1;
            	            				    }
            	            				    else if ( ((sequence_pointer != NULL)))
            	            				    {
            	            				        alt441=2;
            	            				    }
            	            				    else
            	            				    {

            	            				        CONSTRUCTEX();
            	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				        EXCEPTION->message      = (void *)"";
            	            				        EXCEPTION->decisionNum  = 441;
            	            				        EXCEPTION->state        = 3;


            	            				        goto ruleextensionAttrEx;

            	            				    }
            	            				}
            	            			}
            	            		    break;
            	            		case PRINTABLE:
            	            			{
            	            				{
            	            				    int LA441_4 = LA(3);
            	            				    if ( (!( ((sequence_pointer != NULL)) )))
            	            				    {
            	            				        alt441=1;
            	            				    }
            	            				    else if ( ((sequence_pointer != NULL)))
            	            				    {
            	            				        alt441=2;
            	            				    }
            	            				    else
            	            				    {

            	            				        CONSTRUCTEX();
            	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				        EXCEPTION->message      = (void *)"";
            	            				        EXCEPTION->decisionNum  = 441;
            	            				        EXCEPTION->state        = 4;


            	            				        goto ruleextensionAttrEx;

            	            				    }
            	            				}
            	            			}
            	            		    break;

            	            		default:
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 441;
            	            		    EXCEPTION->state        = 2;


            	            		    goto ruleextensionAttrEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 441;
            	                EXCEPTION->state        = 0;


            	                goto ruleextensionAttrEx;

            	            }

            	            switch (alt441)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3690:7: 
            	        	    {
            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3690:8: {...}? =>t1= tag1
            	        	    {
            	        	        if ( !((sequence_pointer != NULL)) )
            	        	        {
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"sequence_pointer != NULL";
            	        	                EXCEPTION->ruleName	 = (void *)"extensionAttr";


            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_tag1_in_extensionAttr9280);
            	        	        t1=tag1(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, t1.tree);

            	        	        {

            	        	            	 if(!(1<= t1.text
            	        	            ->length && t1.text
            	        	            ->length <= ub_given_name_length))
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	 retval.text
            	        	            ->value->personal_name->given_name = new_asn1_string(20,t1.text
            	        	            ->length,t1.text
            	        	            ->value);	
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:3697:5: (|{...}? => tag2 )
            	        {
            	            int alt442=2;
            	            switch ( LA(1) )
            	            {
            	            case ConstructedTag0:
            	            case ConstructedTag1:
            	            case ConstructedTag2:
            	            case ConstructedTag3:
            	            case ConstructedTag4:
            	            case ConstructedTag5:
            	            case SequenceTag:
            	            case Tag0:
            	            case Tag1:
            	            case Tag3:
            	            case Tag6:
            	            case Tag7:
            	            case Tag8:
            	            case TagInt1:
            	            case TagInt10:
            	            case TagInt11:
            	            case TagInt12:
            	            case TagInt13:
            	            case TagInt14:
            	            case TagInt15:
            	            case TagInt16:
            	            case TagInt17:
            	            case TagInt18:
            	            case TagInt19:
            	            case TagInt2:
            	            case TagInt20:
            	            case TagInt21:
            	            case TagInt22:
            	            case TagInt23:
            	            case TagInt3:
            	            case TagInt4:
            	            case TagInt5:
            	            case TagInt6:
            	            case TagInt7:
            	            case TagInt8:
            	            case TagInt9:
            	            	{
            	            		alt442=1;
            	            	}
            	                break;
            	            case Tag2:
            	            	{
            	            		switch ( LA(2) )
            	            		{
            	            		case VALUE:
            	            			{
            	            				{
            	            				    int LA442_3 = LA(3);
            	            				    if ( (!( ((sequence_pointer != NULL)) )))
            	            				    {
            	            				        alt442=1;
            	            				    }
            	            				    else if ( ((sequence_pointer != NULL)))
            	            				    {
            	            				        alt442=2;
            	            				    }
            	            				    else
            	            				    {

            	            				        CONSTRUCTEX();
            	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				        EXCEPTION->message      = (void *)"";
            	            				        EXCEPTION->decisionNum  = 442;
            	            				        EXCEPTION->state        = 3;


            	            				        goto ruleextensionAttrEx;

            	            				    }
            	            				}
            	            			}
            	            		    break;
            	            		case PRINTABLE:
            	            			{
            	            				{
            	            				    int LA442_4 = LA(3);
            	            				    if ( (!( ((sequence_pointer != NULL)) )))
            	            				    {
            	            				        alt442=1;
            	            				    }
            	            				    else if ( ((sequence_pointer != NULL)))
            	            				    {
            	            				        alt442=2;
            	            				    }
            	            				    else
            	            				    {

            	            				        CONSTRUCTEX();
            	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            				        EXCEPTION->message      = (void *)"";
            	            				        EXCEPTION->decisionNum  = 442;
            	            				        EXCEPTION->state        = 4;


            	            				        goto ruleextensionAttrEx;

            	            				    }
            	            				}
            	            			}
            	            		    break;

            	            		default:
            	            		    CONSTRUCTEX();
            	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	            		    EXCEPTION->message      = (void *)"";
            	            		    EXCEPTION->decisionNum  = 442;
            	            		    EXCEPTION->state        = 2;


            	            		    goto ruleextensionAttrEx;

            	            		}

            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 442;
            	                EXCEPTION->state        = 0;


            	                goto ruleextensionAttrEx;

            	            }

            	            switch (alt442)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3697:7: 
            	        	    {
            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3697:8: {...}? => tag2
            	        	    {
            	        	        if ( !((sequence_pointer != NULL)) )
            	        	        {
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"sequence_pointer != NULL";
            	        	                EXCEPTION->ruleName	 = (void *)"extensionAttr";


            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_tag2_in_extensionAttr9290);
            	        	        tag21593=tag2(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tag21593.tree);

            	        	        {

            	        	            	 if(!(1<= tag21593.text
            	        	            ->length && tag21593.text
            	        	            ->length <= ub_initials_length))
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	 retval.text
            	        	            ->value->personal_name->initials = new_asn1_string(20,tag21593.text
            	        	            ->length,tag21593.text
            	        	            ->value);	
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:3704:5: ( tag3 )?
            	        {
            	            int alt443=2;
            	            switch ( LA(1) )
            	            {
            	                case Tag3:
            	                	{
            	                		alt443=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt443)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3704:6: tag3
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tag3_in_extensionAttr9295);
            	        	        tag31594=tag3(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tag31594.tree);

            	        	        {

            	        	            	 if(!(1<= tag31594.text
            	        	            ->length && tag31594.text
            	        	            ->length <= ub_generation_qualifier_length))
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	 retval.text
            	        	            ->value->personal_name->gen_qualifier = new_asn1_string(20,tag31594.text
            	        	            ->length,tag31594.text
            	        	            ->value);
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 5:
            	    // Grammar/RFC5280.g:3711:8: tagInt5 constructedTag1 sequenceTag (strtel= teletexString )+
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt5_in_extensionAttr9302);
            	        tagInt51595=tagInt5(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt51595.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9304);
            	        constructedTag11596=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11596.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionAttr9306);
            	        sequenceTag1597=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1597.tree);

            	        {
            	            retval.text
            	            ->type=5;retval.text
            	            ->value = malloc(sizeof(EXTS_ATTRS_VALUE));
            	            	retval.text
            	            ->value->organizational_unit_names = sk_STRING_POINTER_new_null();
            	            	
            	        }


            	        // Grammar/RFC5280.g:3714:2: (strtel= teletexString )+
            	        {
            	            int cnt444=0;

            	            for (;;)
            	            {
            	                int alt444=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case TeletexTag:
            	        		{
            	        			alt444=1;
            	        		}
            	        	    break;

            	        	}

            	        	switch (alt444)
            	        	{
            	        	    case 1:
            	        	        // Grammar/RFC5280.g:3714:3: strtel= teletexString
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_teletexString_in_extensionAttr9314);
            	        	            strtel=teletexString(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruleextensionAttrEx;
            	        	            }

            	        	            ADAPTOR->addChild(ADAPTOR, root_0, strtel.tree);

            	        	            {

            	        	                	if(!(1 <= strtel.text
            	        	                ->length && strtel.text
            	        	                ->length <= ub_organizational_unit_name_length))
            	        	                	{
            	        	                		printf("Attribute String length constraint not satisfied \n");
            	        	                		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	                	}
            	        	                	sk_STRING_POINTER_push(retval.text
            	        	                ->value->organizational_unit_names,strtel.text
            	        	                );
            	        	                	
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt444 >= 1 )
            	        		{
            	        		    goto loop444;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto ruleextensionAttrEx;
            	        	}
            	        	cnt444++;
            	            }
            	            loop444: ;	/* Jump to here if this rule does not match */
            	        }

            	        {
            	            int len = sk_STRING_POINTER_num(retval.text
            	            ->value->organizational_unit_names); 
            	            	if(!(1<len &&len<= ub_organizational_units))
            	            	{
            	            		printf("Error on organizational units stack size \n");
            	            		exit(OU_STACK_SIZE_ERROR);
            	            	}
            	            	
            	        }


            	    }
            	    break;
            	case 6:
            	    // Grammar/RFC5280.g:3729:6: tagInt7 constructedTag1 str= printString
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt7_in_extensionAttr9327);
            	        tagInt71598=tagInt7(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt71598.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9329);
            	        constructedTag11599=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11599.tree);

            	        FOLLOWPUSH(FOLLOW_printString_in_extensionAttr9333);
            	        str=printString(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, str.tree);

            	        {
            	            retval.text
            	            ->type=7;retval.text
            	            ->value=malloc(sizeof(EXTS_ATTRS_VALUE));
            	            	 if(!(1<= str.text
            	            ->length && str.text
            	            ->length <= ub_pds_name_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	 retval.text
            	            ->value->str_value=str.text
            	            ;	
            	            	
            	        }


            	    }
            	    break;
            	case 7:
            	    // Grammar/RFC5280.g:3737:4: tagInt8 constructedTag1 (strnum= numericString |str= printString )
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt8_in_extensionAttr9340);
            	        tagInt81600=tagInt8(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt81600.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9342);
            	        constructedTag11601=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11601.tree);

            	        // Grammar/RFC5280.g:3737:28: (strnum= numericString |str= printString )
            	        {
            	            int alt445=2;
            	            switch ( LA(1) )
            	            {
            	            case NumericStringTag:
            	            	{
            	            		alt445=1;
            	            	}
            	                break;
            	            case PrintStringTag:
            	            	{
            	            		alt445=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 445;
            	                EXCEPTION->state        = 0;


            	                goto ruleextensionAttrEx;

            	            }

            	            switch (alt445)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3737:29: strnum= numericString
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_numericString_in_extensionAttr9347);
            	        	        strnum=numericString(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, strnum.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=8;retval.text
            	        	            ->value=malloc(sizeof(EXTS_ATTRS_VALUE));
            	        	            	 if(strnum.text
            	        	            ->length != ub_country_name_numeric_length)
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	 retval.text
            	        	            ->value->str_value=strnum.text
            	        	            ;	
            	        	            	
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3745:4: str= printString
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_printString_in_extensionAttr9356);
            	        	        str=printString(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, str.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=8;retval.text
            	        	            ->value=malloc(sizeof(EXTS_ATTRS_VALUE));
            	        	            	 if(str.text
            	        	            ->length != ub_country_name_alpha_length)
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	 retval.text
            	        	            ->value->str_value=str.text
            	        	            ;	
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 8:
            	    // Grammar/RFC5280.g:3754:4: tagInt9 constructedTag1 (strnum= numericString |str= printString )
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt9_in_extensionAttr9366);
            	        tagInt91602=tagInt9(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt91602.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9368);
            	        constructedTag11603=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11603.tree);

            	        // Grammar/RFC5280.g:3754:28: (strnum= numericString |str= printString )
            	        {
            	            int alt446=2;
            	            switch ( LA(1) )
            	            {
            	            case NumericStringTag:
            	            	{
            	            		alt446=1;
            	            	}
            	                break;
            	            case PrintStringTag:
            	            	{
            	            		alt446=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 446;
            	                EXCEPTION->state        = 0;


            	                goto ruleextensionAttrEx;

            	            }

            	            switch (alt446)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3754:29: strnum= numericString
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_numericString_in_extensionAttr9373);
            	        	        strnum=numericString(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, strnum.tree);

            	        	        {
            	        	            str_num_or_print = strnum.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3754:86: str= printString
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_printString_in_extensionAttr9380);
            	        	        str=printString(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, str.tree);

            	        	        {
            	        	            str_num_or_print=str.text
            	        	            ;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        {
            	            retval.text
            	            ->type=9;retval.text
            	            ->value=malloc(sizeof(EXTS_ATTRS_VALUE));
            	            	 if(!(1<= str_num_or_print->length && str_num_or_print->length <= ub_postal_code_length))
            	            	{
            	            		printf("Attribute String length constraint not satisfied \n");
            	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	            	}
            	            	 retval.text
            	            ->value->str_value=str_num_or_print;	
            	            	
            	        }


            	    }
            	    break;
            	case 9:
            	    // Grammar/RFC5280.g:3762:4: ( tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 ) constructedTag1 set (str= printString )? (t61= teletexString )?
            	    {
            	        // Grammar/RFC5280.g:3762:4: ( tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 )
            	        {
            	            int alt447=11;
            	            switch ( LA(1) )
            	            {
            	            case TagInt10:
            	            	{
            	            		alt447=1;
            	            	}
            	                break;
            	            case TagInt11:
            	            	{
            	            		alt447=2;
            	            	}
            	                break;
            	            case TagInt12:
            	            	{
            	            		alt447=3;
            	            	}
            	                break;
            	            case TagInt13:
            	            	{
            	            		alt447=4;
            	            	}
            	                break;
            	            case TagInt14:
            	            	{
            	            		alt447=5;
            	            	}
            	                break;
            	            case TagInt15:
            	            	{
            	            		alt447=6;
            	            	}
            	                break;
            	            case TagInt17:
            	            	{
            	            		alt447=7;
            	            	}
            	                break;
            	            case TagInt18:
            	            	{
            	            		alt447=8;
            	            	}
            	                break;
            	            case TagInt19:
            	            	{
            	            		alt447=9;
            	            	}
            	                break;
            	            case TagInt20:
            	            	{
            	            		alt447=10;
            	            	}
            	                break;
            	            case TagInt21:
            	            	{
            	            		alt447=11;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 447;
            	                EXCEPTION->state        = 0;


            	                goto ruleextensionAttrEx;

            	            }

            	            switch (alt447)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3762:5: tagInt10
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt10_in_extensionAttr9391);
            	        	        tagInt101604=tagInt10(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt101604.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=10;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3762:33: tagInt11
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt11_in_extensionAttr9396);
            	        	        tagInt111605=tagInt11(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt111605.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=11;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 3:
            	        	    // Grammar/RFC5280.g:3762:61: tagInt12
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt12_in_extensionAttr9401);
            	        	        tagInt121606=tagInt12(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt121606.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=12;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 4:
            	        	    // Grammar/RFC5280.g:3762:89: tagInt13
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt13_in_extensionAttr9406);
            	        	        tagInt131607=tagInt13(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt131607.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=13;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 5:
            	        	    // Grammar/RFC5280.g:3762:117: tagInt14
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt14_in_extensionAttr9411);
            	        	        tagInt141608=tagInt14(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt141608.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=14;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 6:
            	        	    // Grammar/RFC5280.g:3762:145: tagInt15
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt15_in_extensionAttr9416);
            	        	        tagInt151609=tagInt15(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt151609.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=15;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 7:
            	        	    // Grammar/RFC5280.g:3763:4: tagInt17
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt17_in_extensionAttr9423);
            	        	        tagInt171610=tagInt17(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt171610.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=17;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 8:
            	        	    // Grammar/RFC5280.g:3763:32: tagInt18
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt18_in_extensionAttr9428);
            	        	        tagInt181611=tagInt18(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt181611.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=18;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 9:
            	        	    // Grammar/RFC5280.g:3763:60: tagInt19
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt19_in_extensionAttr9433);
            	        	        tagInt191612=tagInt19(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt191612.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=19;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 10:
            	        	    // Grammar/RFC5280.g:3763:88: tagInt20
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt20_in_extensionAttr9438);
            	        	        tagInt201613=tagInt20(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt201613.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=20;
            	        	        }


            	        	    }
            	        	    break;
            	        	case 11:
            	        	    // Grammar/RFC5280.g:3763:116: tagInt21
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tagInt21_in_extensionAttr9443);
            	        	        tagInt211614=tagInt21(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt211614.tree);

            	        	        {
            	        	            retval.text
            	        	            ->type=21;
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9449);
            	        constructedTag11615=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11615.tree);

            	        FOLLOWPUSH(FOLLOW_set_in_extensionAttr9451);
            	        set1616=set(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, set1616.tree);

            	        {
            	            retval.text
            	            ->value=malloc(sizeof(EXTS_ATTRS_VALUE));retval.text
            	            ->value->pds_parameter=malloc(sizeof(PDS_PARAMETER));
            	            	retval.text
            	            ->value->pds_parameter->printable = NULL;retval.text
            	            ->value->pds_parameter->teletex=NULL;
            	            	
            	        }


            	        // Grammar/RFC5280.g:3767:2: (str= printString )?
            	        {
            	            int alt448=2;
            	            switch ( LA(1) )
            	            {
            	                case PrintStringTag:
            	                	{
            	                		alt448=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt448)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3767:3: str= printString
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_printString_in_extensionAttr9459);
            	        	        str=printString(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, str.tree);

            	        	        {

            	        	            	 if(!(1<= str.text
            	        	            ->length && str.text
            	        	            ->length <= ub_pds_parameter_length))
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	retval.text
            	        	            ->value->pds_parameter->printable=str.text
            	        	            ;
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:3774:6: (t61= teletexString )?
            	        {
            	            int alt449=2;
            	            switch ( LA(1) )
            	            {
            	                case TeletexTag:
            	                	{
            	                		alt449=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt449)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3774:7: t61= teletexString
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_teletexString_in_extensionAttr9467);
            	        	        t61=teletexString(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, t61.tree);

            	        	        {

            	        	            	 if(!(1<= t61.text
            	        	            ->length && t61.text
            	        	            ->length <= ub_pds_parameter_length))
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	 retval.text
            	        	            ->value->pds_parameter->teletex=t61.text
            	        	            ;	
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 10:
            	    // Grammar/RFC5280.g:3782:4: tagInt16 constructedTag1 set ( sequenceTag (str= printString )+ )? (t61= teletexString )?
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt16_in_extensionAttr9476);
            	        tagInt161617=tagInt16(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt161617.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9478);
            	        constructedTag11618=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11618.tree);

            	        FOLLOWPUSH(FOLLOW_set_in_extensionAttr9480);
            	        set1619=set(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, set1619.tree);

            	        {
            	            retval.text
            	            ->type = 16;retval.text
            	            ->value=malloc(sizeof(EXTS_ATTRS_VALUE));retval.text
            	            ->value->upa=malloc(sizeof(UNFORMATTED_POSTAL_ADDRESS));
            	            	retval.text
            	            ->value->upa->printable_addr = NULL;retval.text
            	            ->value->upa->t_string=NULL;
            	            	
            	        }


            	        // Grammar/RFC5280.g:3784:4: ( sequenceTag (str= printString )+ )?
            	        {
            	            int alt451=2;
            	            switch ( LA(1) )
            	            {
            	                case SequenceTag:
            	                	{
            	                		switch ( LA(2) )
            	                		{
            	                		    case PrintStringTag:
            	                		    	{
            	                		    		alt451=1;
            	                		    	}
            	                		        break;
            	                		}

            	                	}
            	                    break;
            	            }

            	            switch (alt451)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3784:5: sequenceTag (str= printString )+
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionAttr9485);
            	        	        sequenceTag1620=sequenceTag(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1620.tree);

            	        	        {
            	        	            retval.text
            	        	            ->value->upa->printable_addr = sk_STRING_POINTER_new_null();
            	        	        }


            	        	        // Grammar/RFC5280.g:3784:85: (str= printString )+
            	        	        {
            	        	            int cnt450=0;

            	        	            for (;;)
            	        	            {
            	        	                int alt450=2;
            	        	        	switch ( LA(1) )
            	        	        	{
            	        	        	case PrintStringTag:
            	        	        		{
            	        	        			alt450=1;
            	        	        		}
            	        	        	    break;

            	        	        	}

            	        	        	switch (alt450)
            	        	        	{
            	        	        	    case 1:
            	        	        	        // Grammar/RFC5280.g:3784:86: str= printString
            	        	        	        {
            	        	        	            FOLLOWPUSH(FOLLOW_printString_in_extensionAttr9492);
            	        	        	            str=printString(ctx);

            	        	        	            FOLLOWPOP();
            	        	        	            if  (HASEXCEPTION())
            	        	        	            {
            	        	        	                goto ruleextensionAttrEx;
            	        	        	            }

            	        	        	            ADAPTOR->addChild(ADAPTOR, root_0, str.tree);

            	        	        	            {
            	        	        	                if(!(1 <= str.text
            	        	        	                ->length && str.text
            	        	        	                ->length <= ub_pds_parameter_length))
            	        	        	                	{
            	        	        	                		printf("Attribute String length constraint not satisfied \n");
            	        	        	                		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	        	                	}
            	        	        	                	sk_STRING_POINTER_push(retval.text
            	        	        	                ->value->upa->printable_addr,str.text
            	        	        	                );
            	        	        	                	
            	        	        	            }


            	        	        	        }
            	        	        	        break;

            	        	        	    default:

            	        	        		if ( cnt450 >= 1 )
            	        	        		{
            	        	        		    goto loop450;
            	        	        		}
            	        	        		/* mismatchedSetEx()
            	        	        		 */
            	        	        		CONSTRUCTEX();
            	        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        	        		goto ruleextensionAttrEx;
            	        	        	}
            	        	        	cnt450++;
            	        	            }
            	        	            loop450: ;	/* Jump to here if this rule does not match */
            	        	        }

            	        	        {
            	        	            int len = sk_STRING_POINTER_num(retval.text
            	        	            ->value->upa->printable_addr); 
            	        	            	if(!(1<len && len<= ub_pds_physical_address_lines))
            	        	            	{
            	        	            		printf("Error on organizational units stack size \n");
            	        	            		exit(OU_STACK_SIZE_ERROR);
            	        	            	}
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	        // Grammar/RFC5280.g:3798:7: (t61= teletexString )?
            	        {
            	            int alt452=2;
            	            switch ( LA(1) )
            	            {
            	                case TeletexTag:
            	                	{
            	                		alt452=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt452)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3798:8: t61= teletexString
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_teletexString_in_extensionAttr9508);
            	        	        t61=teletexString(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, t61.tree);

            	        	        {

            	        	            	 if(!(1<= t61.text
            	        	            ->length && t61.text
            	        	            ->length <= ub_unformatted_address_length))
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	 retval.text
            	        	            ->value->upa->t_string=t61.text
            	        	            ;	
            	        	            	
            	        	        }


            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 11:
            	    // Grammar/RFC5280.g:3806:4: tagInt22 constructedTag1 (t0= tag0 ({...}? =>t1= tag1 |) | constructedTag0 ( constructedTag0 p= octetstring )? ( constructedTag1 s= octetstring )? ( constructedTag2 t= octetstring )? ( constructedTag3 set (n= octetstring )+ )? )
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt22_in_extensionAttr9518);
            	        tagInt221621=tagInt22(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt221621.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9520);
            	        constructedTag11622=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11622.tree);

            	        {
            	            retval.text
            	            ->type=22;retval.text
            	            ->value=malloc(sizeof(EXTS_ATTRS_VALUE));
            	        }


            	        // Grammar/RFC5280.g:3806:93: (t0= tag0 ({...}? =>t1= tag1 |) | constructedTag0 ( constructedTag0 p= octetstring )? ( constructedTag1 s= octetstring )? ( constructedTag2 t= octetstring )? ( constructedTag3 set (n= octetstring )+ )? )
            	        {
            	            int alt459=2;
            	            switch ( LA(1) )
            	            {
            	            case Tag0:
            	            case TagInt1:
            	            case TagInt10:
            	            case TagInt11:
            	            case TagInt12:
            	            case TagInt13:
            	            case TagInt14:
            	            case TagInt15:
            	            case TagInt16:
            	            case TagInt17:
            	            case TagInt18:
            	            case TagInt19:
            	            case TagInt2:
            	            case TagInt20:
            	            case TagInt21:
            	            case TagInt22:
            	            case TagInt23:
            	            case TagInt3:
            	            case TagInt4:
            	            case TagInt5:
            	            case TagInt6:
            	            case TagInt7:
            	            case TagInt8:
            	            case TagInt9:
            	            	{
            	            		alt459=1;
            	            	}
            	                break;
            	            case ConstructedTag0:
            	            	{
            	            		alt459=2;
            	            	}
            	                break;

            	            default:
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	                EXCEPTION->message      = (void *)"";
            	                EXCEPTION->decisionNum  = 459;
            	                EXCEPTION->state        = 0;


            	                goto ruleextensionAttrEx;

            	            }

            	            switch (alt459)
            	            {
            	        	case 1:
            	        	    // Grammar/RFC5280.g:3806:94: t0= tag0 ({...}? =>t1= tag1 |)
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_tag0_in_extensionAttr9527);
            	        	        t0=tag0(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, t0.tree);

            	        	        {
            	        	            retval.text
            	        	            ->value->e163_4 = malloc(sizeof(E163_4_ADDR));
            	        	            	if(!(1<= t0.text
            	        	            ->length && t0.text
            	        	            ->length <= ub_e163_4_number_length))
            	        	            	{
            	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	            	}
            	        	            	 retval.text
            	        	            ->value->e163_4->number=new_asn1_string(18,t0.text
            	        	            ->length,t0.text
            	        	            ->value);
            	        	            	 retval.text
            	        	            ->value->e163_4->sub_address=NULL;	
            	        	            	
            	        	        }


            	        	        // Grammar/RFC5280.g:3814:4: ({...}? =>t1= tag1 |)
            	        	        {
            	        	            int alt453=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	            case Tag1:
            	        	            	{
            	        	            		switch ( LA(2) )
            	        	            		{
            	        	            		case VALUE:
            	        	            			{
            	        	            				{
            	        	            				    int LA453_3 = LA(3);
            	        	            				    if ( ((sequence_pointer != NULL)))
            	        	            				    {
            	        	            				        alt453=1;
            	        	            				    }
            	        	            				    else if ( (ANTLR3_TRUE))
            	        	            				    {
            	        	            				        alt453=2;
            	        	            				    }
            	        	            				    else
            	        	            				    {

            	        	            				        CONSTRUCTEX();
            	        	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            				        EXCEPTION->message      = (void *)"";
            	        	            				        EXCEPTION->decisionNum  = 453;
            	        	            				        EXCEPTION->state        = 3;


            	        	            				        goto ruleextensionAttrEx;

            	        	            				    }
            	        	            				}
            	        	            			}
            	        	            		    break;
            	        	            		case PRINTABLE:
            	        	            			{
            	        	            				{
            	        	            				    int LA453_4 = LA(3);
            	        	            				    if ( ((sequence_pointer != NULL)))
            	        	            				    {
            	        	            				        alt453=1;
            	        	            				    }
            	        	            				    else if ( (ANTLR3_TRUE))
            	        	            				    {
            	        	            				        alt453=2;
            	        	            				    }
            	        	            				    else
            	        	            				    {

            	        	            				        CONSTRUCTEX();
            	        	            				        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            				        EXCEPTION->message      = (void *)"";
            	        	            				        EXCEPTION->decisionNum  = 453;
            	        	            				        EXCEPTION->state        = 4;


            	        	            				        goto ruleextensionAttrEx;

            	        	            				    }
            	        	            				}
            	        	            			}
            	        	            		    break;

            	        	            		default:
            	        	            		    CONSTRUCTEX();
            	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	            		    EXCEPTION->message      = (void *)"";
            	        	            		    EXCEPTION->decisionNum  = 453;
            	        	            		    EXCEPTION->state        = 1;


            	        	            		    goto ruleextensionAttrEx;

            	        	            		}

            	        	            	}
            	        	                break;
            	        	            case ConstructedTag0:
            	        	            case ConstructedTag1:
            	        	            case ConstructedTag2:
            	        	            case ConstructedTag3:
            	        	            case ConstructedTag4:
            	        	            case ConstructedTag5:
            	        	            case SequenceTag:
            	        	            case Tag0:
            	        	            case Tag2:
            	        	            case Tag6:
            	        	            case Tag7:
            	        	            case Tag8:
            	        	            case TagInt1:
            	        	            case TagInt10:
            	        	            case TagInt11:
            	        	            case TagInt12:
            	        	            case TagInt13:
            	        	            case TagInt14:
            	        	            case TagInt15:
            	        	            case TagInt16:
            	        	            case TagInt17:
            	        	            case TagInt18:
            	        	            case TagInt19:
            	        	            case TagInt2:
            	        	            case TagInt20:
            	        	            case TagInt21:
            	        	            case TagInt22:
            	        	            case TagInt23:
            	        	            case TagInt3:
            	        	            case TagInt4:
            	        	            case TagInt5:
            	        	            case TagInt6:
            	        	            case TagInt7:
            	        	            case TagInt8:
            	        	            case TagInt9:
            	        	            	{
            	        	            		alt453=2;
            	        	            	}
            	        	                break;

            	        	            default:
            	        	                CONSTRUCTEX();
            	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            	        	                EXCEPTION->message      = (void *)"";
            	        	                EXCEPTION->decisionNum  = 453;
            	        	                EXCEPTION->state        = 0;


            	        	                goto ruleextensionAttrEx;

            	        	            }

            	        	            switch (alt453)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:3814:5: {...}? =>t1= tag1
            	        	        	    {
            	        	        	        if ( !((sequence_pointer != NULL)) )
            	        	        	        {
            	        	        	                CONSTRUCTEX();
            	        	        	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	        	        	                EXCEPTION->message      = (void *)"sequence_pointer != NULL";
            	        	        	                EXCEPTION->ruleName	 = (void *)"extensionAttr";


            	        	        	        }

            	        	        	        FOLLOWPUSH(FOLLOW_tag1_in_extensionAttr9537);
            	        	        	        t1=tag1(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleextensionAttrEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, t1.tree);

            	        	        	        {

            	        	        	            	 if(!(1<= t1.text
            	        	        	            ->length && t1.text
            	        	        	            ->length <= ub_e163_4_sub_address_length))
            	        	        	            	{
            	        	        	            		printf("Attribute String length constraint not satisfied \n");
            	        	        	            		warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	        	            	}
            	        	        	            	 retval.text
            	        	        	            ->value->e163_4->sub_address=new_asn1_string(18,t1.text
            	        	        	            ->length,t1.text
            	        	        	            ->value);		
            	        	        	            	
            	        	        	        }


            	        	        	    }
            	        	        	    break;
            	        	        	case 2:
            	        	        	    // Grammar/RFC5280.g:3821:5: 
            	        	        	    {
            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;
            	        	case 2:
            	        	    // Grammar/RFC5280.g:3821:9: constructedTag0 ( constructedTag0 p= octetstring )? ( constructedTag1 s= octetstring )? ( constructedTag2 t= octetstring )? ( constructedTag3 set (n= octetstring )+ )?
            	        	    {
            	        	        FOLLOWPUSH(FOLLOW_constructedTag0_in_extensionAttr9545);
            	        	        constructedTag01623=constructedTag0(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto ruleextensionAttrEx;
            	        	        }

            	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag01623.tree);

            	        	        {
            	        	            retval.text
            	        	            ->value->psap=malloc(sizeof(PSAP_ADDR));retval.text
            	        	            ->value->psap->p_selector=NULL;
            	        	            	retval.text
            	        	            ->value->psap->s_selector=NULL;retval.text
            	        	            ->value->psap->t_selector=NULL;retval.text
            	        	            ->value->psap->n_addresses=NULL;
            	        	            	
            	        	        }


            	        	        // Grammar/RFC5280.g:3823:3: ( constructedTag0 p= octetstring )?
            	        	        {
            	        	            int alt454=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case ConstructedTag0:
            	        	                	{
            	        	                		switch ( LA(2) )
            	        	                		{
            	        	                		    case OctetTag:
            	        	                		    	{
            	        	                		    		alt454=1;
            	        	                		    	}
            	        	                		        break;
            	        	                		}

            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt454)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:3823:4: constructedTag0 p= octetstring
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag0_in_extensionAttr9549);
            	        	        	        constructedTag01624=constructedTag0(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleextensionAttrEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag01624.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_octetstring_in_extensionAttr9553);
            	        	        	        p=octetstring(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleextensionAttrEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, p.tree);

            	        	        	        {
            	        	        	            retval.text
            	        	        	            ->value->psap->p_selector=p.text
            	        	        	            ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:3823:78: ( constructedTag1 s= octetstring )?
            	        	        {
            	        	            int alt455=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case ConstructedTag1:
            	        	                	{
            	        	                		switch ( LA(2) )
            	        	                		{
            	        	                		    case OctetTag:
            	        	                		    	{
            	        	                		    		alt455=1;
            	        	                		    	}
            	        	                		        break;
            	        	                		}

            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt455)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:3823:79: constructedTag1 s= octetstring
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9560);
            	        	        	        constructedTag11625=constructedTag1(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleextensionAttrEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11625.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_octetstring_in_extensionAttr9564);
            	        	        	        s=octetstring(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleextensionAttrEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, s.tree);

            	        	        	        {
            	        	        	            retval.text
            	        	        	            ->value->psap->s_selector=s.text
            	        	        	            ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:3824:2: ( constructedTag2 t= octetstring )?
            	        	        {
            	        	            int alt456=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case ConstructedTag2:
            	        	                	{
            	        	                		switch ( LA(2) )
            	        	                		{
            	        	                		    case OctetTag:
            	        	                		    	{
            	        	                		    		alt456=1;
            	        	                		    	}
            	        	                		        break;
            	        	                		}

            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt456)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:3824:3: constructedTag2 t= octetstring
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag2_in_extensionAttr9573);
            	        	        	        constructedTag21626=constructedTag2(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleextensionAttrEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag21626.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_octetstring_in_extensionAttr9577);
            	        	        	        t=octetstring(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleextensionAttrEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, t.tree);

            	        	        	        {
            	        	        	            retval.text
            	        	        	            ->value->psap->p_selector=t.text
            	        	        	            ;
            	        	        	        }


            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	        // Grammar/RFC5280.g:3824:77: ( constructedTag3 set (n= octetstring )+ )?
            	        	        {
            	        	            int alt458=2;
            	        	            switch ( LA(1) )
            	        	            {
            	        	                case ConstructedTag3:
            	        	                	{
            	        	                		switch ( LA(2) )
            	        	                		{
            	        	                		    case SetTag:
            	        	                		    	{
            	        	                		    		alt458=1;
            	        	                		    	}
            	        	                		        break;
            	        	                		}

            	        	                	}
            	        	                    break;
            	        	            }

            	        	            switch (alt458)
            	        	            {
            	        	        	case 1:
            	        	        	    // Grammar/RFC5280.g:3824:78: constructedTag3 set (n= octetstring )+
            	        	        	    {
            	        	        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_extensionAttr9584);
            	        	        	        constructedTag31627=constructedTag3(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleextensionAttrEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag31627.tree);

            	        	        	        FOLLOWPUSH(FOLLOW_set_in_extensionAttr9586);
            	        	        	        set1628=set(ctx);

            	        	        	        FOLLOWPOP();
            	        	        	        if  (HASEXCEPTION())
            	        	        	        {
            	        	        	            goto ruleextensionAttrEx;
            	        	        	        }

            	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, set1628.tree);

            	        	        	        {
            	        	        	            retval.text
            	        	        	            ->value->psap->n_addresses=sk_STRING_POINTER_new_null();
            	        	        	        }


            	        	        	        // Grammar/RFC5280.g:3825:2: (n= octetstring )+
            	        	        	        {
            	        	        	            int cnt457=0;

            	        	        	            for (;;)
            	        	        	            {
            	        	        	                int alt457=2;
            	        	        	        	switch ( LA(1) )
            	        	        	        	{
            	        	        	        	case OctetTag:
            	        	        	        		{
            	        	        	        			alt457=1;
            	        	        	        		}
            	        	        	        	    break;

            	        	        	        	}

            	        	        	        	switch (alt457)
            	        	        	        	{
            	        	        	        	    case 1:
            	        	        	        	        // Grammar/RFC5280.g:3825:3: n= octetstring
            	        	        	        	        {
            	        	        	        	            FOLLOWPUSH(FOLLOW_octetstring_in_extensionAttr9595);
            	        	        	        	            n=octetstring(ctx);

            	        	        	        	            FOLLOWPOP();
            	        	        	        	            if  (HASEXCEPTION())
            	        	        	        	            {
            	        	        	        	                goto ruleextensionAttrEx;
            	        	        	        	            }

            	        	        	        	            ADAPTOR->addChild(ADAPTOR, root_0, n.tree);

            	        	        	        	            {

            	        	        	        	                	sk_STRING_POINTER_push(retval.text
            	        	        	        	                ->value->psap->n_addresses,n.text
            	        	        	        	                );
            	        	        	        	                	
            	        	        	        	            }


            	        	        	        	        }
            	        	        	        	        break;

            	        	        	        	    default:

            	        	        	        		if ( cnt457 >= 1 )
            	        	        	        		{
            	        	        	        		    goto loop457;
            	        	        	        		}
            	        	        	        		/* mismatchedSetEx()
            	        	        	        		 */
            	        	        	        		CONSTRUCTEX();
            	        	        	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        	        	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        	        	        		goto ruleextensionAttrEx;
            	        	        	        	}
            	        	        	        	cnt457++;
            	        	        	            }
            	        	        	            loop457: ;	/* Jump to here if this rule does not match */
            	        	        	        }

            	        	        	    }
            	        	        	    break;

            	        	            }
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	    }
            	    break;
            	case 12:
            	    // Grammar/RFC5280.g:3828:4: tagInt23 constructedTag1 i23= integer
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt23_in_extensionAttr9606);
            	        tagInt231629=tagInt23(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt231629.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9608);
            	        constructedTag11630=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11630.tree);

            	        FOLLOWPUSH(FOLLOW_integer_in_extensionAttr9612);
            	        i23=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i23.tree);

            	        {
            	             retval.text
            	            ->type=23;retval.text
            	            ->value = malloc(sizeof(EXTS_ATTRS_VALUE));
            	            	 if(!(i23.text
            	            ->length==1 || (i23.text
            	            ->length==2 && i23.text
            	            ->data[0] & 254 == 0)))
            	            	 {
            	            	 	printf("Error on integer bounds \n");
            	            	 	warning|=INTEGER_BOUNDS_WARNING;
            	            	 }	
            	            	 retval.text
            	            ->value->str_value=i23.text
            	            ;
            	            	 
            	        }


            	    }
            	    break;
            	case 13:
            	    // Grammar/RFC5280.g:3835:6: tagInt6 constructedTag1 sequenceTag ( sequenceTag type= teletexString value= teletexString )+
            	    {
            	        FOLLOWPUSH(FOLLOW_tagInt6_in_extensionAttr9617);
            	        tagInt61631=tagInt6(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt61631.tree);

            	        FOLLOWPUSH(FOLLOW_constructedTag1_in_extensionAttr9619);
            	        constructedTag11632=constructedTag1(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11632.tree);

            	        FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionAttr9621);
            	        sequenceTag1633=sequenceTag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1633.tree);

            	        {
            	            retval.text
            	            ->type=6;retval.text
            	            ->value=malloc(sizeof(EXTS_ATTRS_VALUE));retval.text
            	            ->value->domain_defined=sk_DEFINED_ATTRS_POINTER_new_null();
            	            	 
            	        }


            	        // Grammar/RFC5280.g:3836:4: ( sequenceTag type= teletexString value= teletexString )+
            	        {
            	            int cnt460=0;

            	            for (;;)
            	            {
            	                int alt460=2;
            	        	switch ( LA(1) )
            	        	{
            	        	case SequenceTag:
            	        		{
            	        			switch ( LA(2) )
            	        			{
            	        			case TeletexTag:
            	        				{
            	        					alt460=1;
            	        				}
            	        			    break;

            	        			}

            	        		}
            	        	    break;

            	        	}

            	        	switch (alt460)
            	        	{
            	        	    case 1:
            	        	        // Grammar/RFC5280.g:3836:5: sequenceTag type= teletexString value= teletexString
            	        	        {
            	        	            FOLLOWPUSH(FOLLOW_sequenceTag_in_extensionAttr9625);
            	        	            sequenceTag1634=sequenceTag(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruleextensionAttrEx;
            	        	            }

            	        	            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1634.tree);

            	        	            FOLLOWPUSH(FOLLOW_teletexString_in_extensionAttr9629);
            	        	            type=teletexString(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruleextensionAttrEx;
            	        	            }

            	        	            ADAPTOR->addChild(ADAPTOR, root_0, type.tree);

            	        	            FOLLOWPUSH(FOLLOW_teletexString_in_extensionAttr9633);
            	        	            value=teletexString(ctx);

            	        	            FOLLOWPOP();
            	        	            if  (HASEXCEPTION())
            	        	            {
            	        	                goto ruleextensionAttrEx;
            	        	            }

            	        	            ADAPTOR->addChild(ADAPTOR, root_0, value.tree);

            	        	            {

            	        	                		defined_attrs* def = malloc(sizeof(defined_attrs));
            	        	                		if(!(1<= type.text
            	        	                ->length && type.text
            	        	                ->length <= ub_domain_defined_attribute_type_length))
            	        	                		{
            	        	                			printf("Attribute String length constraint not satisfied \n");
            	        	                			warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	                		}
            	        	                		def->type = type.text
            	        	                ;
            	        	                		if(!(1<= value.text
            	        	                ->length && value.text
            	        	                ->length <= ub_domain_defined_attribute_value_length))
            	        	                		{
            	        	                			printf("Attribute String length constraint not satisfied \n");
            	        	                			warning|=ATTRIBUTE_STRING_LENGTH_WARNING;
            	        	                		}
            	        	                		def->value = value.text
            	        	                ;	 
            	        	                	 	sk_DEFINED_ATTRS_POINTER_push(retval.text
            	        	                ->value->domain_defined,def);
            	        	                	 
            	        	            }


            	        	        }
            	        	        break;

            	        	    default:

            	        		if ( cnt460 >= 1 )
            	        		{
            	        		    goto loop460;
            	        		}
            	        		/* mismatchedSetEx()
            	        		 */
            	        		CONSTRUCTEX();
            	        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	        		goto ruleextensionAttrEx;
            	        	}
            	        	cnt460++;
            	            }
            	            loop460: ;	/* Jump to here if this rule does not match */
            	        }

            	        {

            	            		int len = sk_DEFINED_ATTRS_POINTER_num(retval.text
            	            ->value->domain_defined);
            	            		if(len > ub_domain_defined_attributes)
            	            		{
            	            			printf("Error on defined attributes stack size \n");
            	            			exit(DEFINED_ATTRS_STACK_SIZE_ERROR);
            	            		}	
            	            	
            	        }


            	    }
            	    break;
            	case 14:
            	    // Grammar/RFC5280.g:3860:4: i= onlyTag0 any
            	    {
            	        FOLLOWPUSH(FOLLOW_onlyTag0_in_extensionAttr9647);
            	        i=onlyTag0(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, i.tree);

            	        FOLLOWPUSH(FOLLOW_any_in_extensionAttr9649);
            	        any1635=any(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleextensionAttrEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, any1635.tree);

            	        {
            	            mpz_t length,value;mpz_init_set_ui(length,i.text
            	            ->length);mpz_init_set_ui(value,0);compute_integer(i.text
            	            ->value,length,value);
            	            	if(!(0<=mpz_get_ui(value) && mpz_get_ui(value) <= ub_extensions_attributes))
            	            	 {
            	            	 	printf("Error on integer bounds \n");
            	            	 	warning|=INTEGER_BOUNDS_WARNING;
            	            	 }
            	            	retval.text
            	            ->type=mpz_get_ui(value);retval.text
            	            ->value=malloc(sizeof(EXTS_ATTRS_VALUE));retval.text
            	            ->value->any=any1635.text
            	            ;
            	            	
            	        }


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleextensionAttrEx; /* Prevent compiler warnings */
    ruleextensionAttrEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end extensionAttr */

/**
 * $ANTLR start name
 * Grammar/RFC5280.g:3869:1: name : sequenceTag rdns ;
 */
static RFC5280Parser_name_return
name(pRFC5280Parser ctx)
{
    RFC5280Parser_name_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1636;
    #undef	RETURN_TYPE_sequenceTag1636
    #define	RETURN_TYPE_sequenceTag1636 RFC5280Parser_sequenceTag_return

    RFC5280Parser_rdns_return rdns1637;
    #undef	RETURN_TYPE_rdns1637
    #define	RETURN_TYPE_rdns1637 RFC5280Parser_rdns_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    dname = sk_X509_DNAME_ENTRY_new_null();
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    sequenceTag1636.tree = NULL;

    rdns1637.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3875:2: ( sequenceTag rdns )
        // Grammar/RFC5280.g:3875:4: sequenceTag rdns
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_sequenceTag_in_name9669);
            sequenceTag1636=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1636.tree);

            FOLLOWPUSH(FOLLOW_rdns_in_name9671);
            rdns1637=rdns(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, rdns1637.tree);

            {
                cert->issuer = dname;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenameEx; /* Prevent compiler warnings */
    rulenameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end name */

/**
 * $ANTLR start rdns
 * Grammar/RFC5280.g:3877:1: rdns : ( set rdn rdns |);
 */
static RFC5280Parser_rdns_return
rdns(pRFC5280Parser ctx)
{
    RFC5280Parser_rdns_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_set_return set1638;
    #undef	RETURN_TYPE_set1638
    #define	RETURN_TYPE_set1638 RFC5280Parser_set_return

    RFC5280Parser_rdn_return rdn1639;
    #undef	RETURN_TYPE_rdn1639
    #define	RETURN_TYPE_rdn1639 RFC5280Parser_rdn_return

    RFC5280Parser_rdns_return rdns1640;
    #undef	RETURN_TYPE_rdns1640
    #define	RETURN_TYPE_rdns1640 RFC5280Parser_rdns_return


    /* Initialize rule variables
     */

    root_0 = NULL;


    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    set1638.tree = NULL;

    rdn1639.tree = NULL;

    rdns1640.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3884:2: ( set rdn rdns |)

            ANTLR3_UINT32 alt462;

            alt462=2;

            switch ( LA(1) )
            {
            case SetTag:
            	{
            		alt462=1;
            	}
                break;
            case EOF:
            	{
            		alt462=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 462;
                EXCEPTION->state        = 0;


                goto rulerdnsEx;

            }

            switch (alt462)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3884:4: set rdn rdns
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_set_in_rdns9692);
        	        set1638=set(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerdnsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, set1638.tree);

        	        {
        	            set_pointer = counter_list;
        	        }


        	        FOLLOWPUSH(FOLLOW_rdn_in_rdns9695);
        	        rdn1639=rdn(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerdnsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, rdn1639.tree);

        	        FOLLOWPUSH(FOLLOW_rdns_in_rdns9697);
        	        rdns1640=rdns(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulerdnsEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, rdns1640.tree);

        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3884:48: 
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulerdnsEx; /* Prevent compiler warnings */
    rulerdnsEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rdns */

/**
 * $ANTLR start notEmptyName
 * Grammar/RFC5280.g:3886:1: notEmptyName : sequenceTag rdnsNotEmpty ;
 */
static RFC5280Parser_notEmptyName_return
notEmptyName(pRFC5280Parser ctx)
{
    RFC5280Parser_notEmptyName_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1641;
    #undef	RETURN_TYPE_sequenceTag1641
    #define	RETURN_TYPE_sequenceTag1641 RFC5280Parser_sequenceTag_return

    RFC5280Parser_rdnsNotEmpty_return rdnsNotEmpty1642;
    #undef	RETURN_TYPE_rdnsNotEmpty1642
    #define	RETURN_TYPE_rdnsNotEmpty1642 RFC5280Parser_rdnsNotEmpty_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    dname = sk_X509_DNAME_ENTRY_new_null();
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif	
    sequenceTag1641.tree = NULL;

    rdnsNotEmpty1642.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3893:2: ( sequenceTag rdnsNotEmpty )
        // Grammar/RFC5280.g:3893:4: sequenceTag rdnsNotEmpty
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_sequenceTag_in_notEmptyName9719);
            sequenceTag1641=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenotEmptyNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1641.tree);

            FOLLOWPUSH(FOLLOW_rdnsNotEmpty_in_notEmptyName9721);
            rdnsNotEmpty1642=rdnsNotEmpty(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenotEmptyNameEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, rdnsNotEmpty1642.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulenotEmptyNameEx; /* Prevent compiler warnings */
    rulenotEmptyNameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end notEmptyName */

/**
 * $ANTLR start rdnsNotEmpty
 * Grammar/RFC5280.g:3895:1: rdnsNotEmpty : set rdn ( rdnsNotEmpty |) ;
 */
static RFC5280Parser_rdnsNotEmpty_return
rdnsNotEmpty(pRFC5280Parser ctx)
{
    RFC5280Parser_rdnsNotEmpty_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_set_return set1643;
    #undef	RETURN_TYPE_set1643
    #define	RETURN_TYPE_set1643 RFC5280Parser_set_return

    RFC5280Parser_rdn_return rdn1644;
    #undef	RETURN_TYPE_rdn1644
    #define	RETURN_TYPE_rdn1644 RFC5280Parser_rdn_return

    RFC5280Parser_rdnsNotEmpty_return rdnsNotEmpty1645;
    #undef	RETURN_TYPE_rdnsNotEmpty1645
    #define	RETURN_TYPE_rdnsNotEmpty1645 RFC5280Parser_rdnsNotEmpty_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    set1643.tree = NULL;

    rdn1644.tree = NULL;

    rdnsNotEmpty1645.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3899:2: ( set rdn ( rdnsNotEmpty |) )
        // Grammar/RFC5280.g:3899:3: set rdn ( rdnsNotEmpty |)
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_set_in_rdnsNotEmpty9738);
            set1643=set(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerdnsNotEmptyEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, set1643.tree);

            {
                set_pointer = counter_list;
            }


            FOLLOWPUSH(FOLLOW_rdn_in_rdnsNotEmpty9741);
            rdn1644=rdn(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerdnsNotEmptyEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, rdn1644.tree);

            // Grammar/RFC5280.g:3901:47: ( rdnsNotEmpty |)
            {
                int alt463=2;
                switch ( LA(1) )
                {
                case SetTag:
                	{
                		alt463=1;
                	}
                    break;
                case ConstructedTag0:
                case ConstructedTag1:
                case ConstructedTag2:
                case ConstructedTag3:
                case ConstructedTag4:
                case ConstructedTag5:
                case SequenceTag:
                case Tag0:
                case Tag1:
                case Tag2:
                case Tag6:
                case Tag7:
                case Tag8:
                case TagInt1:
                case TagInt10:
                case TagInt11:
                case TagInt12:
                case TagInt13:
                case TagInt14:
                case TagInt15:
                case TagInt16:
                case TagInt17:
                case TagInt18:
                case TagInt19:
                case TagInt2:
                case TagInt20:
                case TagInt21:
                case TagInt22:
                case TagInt23:
                case TagInt3:
                case TagInt4:
                case TagInt5:
                case TagInt6:
                case TagInt7:
                case TagInt8:
                case TagInt9:
                	{
                		alt463=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 463;
                    EXCEPTION->state        = 0;


                    goto rulerdnsNotEmptyEx;

                }

                switch (alt463)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3901:48: rdnsNotEmpty
            	    {
            	        FOLLOWPUSH(FOLLOW_rdnsNotEmpty_in_rdnsNotEmpty9744);
            	        rdnsNotEmpty1645=rdnsNotEmpty(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerdnsNotEmptyEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, rdnsNotEmpty1645.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3901:63: 
            	    {
            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulerdnsNotEmptyEx; /* Prevent compiler warnings */
    rulerdnsNotEmptyEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rdnsNotEmpty */

/**
 * $ANTLR start rdn
 * Grammar/RFC5280.g:3903:1: rdn : sequenceTag dn ({...}? => rdn |) ;
 */
static RFC5280Parser_rdn_return
rdn(pRFC5280Parser ctx)
{
    RFC5280Parser_rdn_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_sequenceTag_return sequenceTag1646;
    #undef	RETURN_TYPE_sequenceTag1646
    #define	RETURN_TYPE_sequenceTag1646 RFC5280Parser_sequenceTag_return

    RFC5280Parser_dn_return dn1647;
    #undef	RETURN_TYPE_dn1647
    #define	RETURN_TYPE_dn1647 RFC5280Parser_dn_return

    RFC5280Parser_rdn_return rdn1648;
    #undef	RETURN_TYPE_rdn1648
    #define	RETURN_TYPE_rdn1648 RFC5280Parser_rdn_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    sequenceTag1646.tree = NULL;

    dn1647.tree = NULL;

    rdn1648.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3906:2: ( sequenceTag dn ({...}? => rdn |) )
        // Grammar/RFC5280.g:3906:3: sequenceTag dn ({...}? => rdn |)
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_sequenceTag_in_rdn9762);
            sequenceTag1646=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerdnEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1646.tree);

            FOLLOWPUSH(FOLLOW_dn_in_rdn9764);
            dn1647=dn(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerdnEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, dn1647.tree);

            // Grammar/RFC5280.g:3908:25: ({...}? => rdn |)
            {
                int alt464=2;
                switch ( LA(1) )
                {
                case SequenceTag:
                	{
                		{
                		    int LA464_1 = LA(2);
                		    if ( ((set_pointer != NULL)))
                		    {
                		        alt464=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt464=2;
                		    }
                		    else
                		    {

                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 464;
                		        EXCEPTION->state        = 1;


                		        goto rulerdnEx;

                		    }
                		}
                	}
                    break;
                case EOF:
                case ConstructedTag0:
                case ConstructedTag1:
                case ConstructedTag2:
                case ConstructedTag3:
                case ConstructedTag4:
                case ConstructedTag5:
                case SetTag:
                case Tag0:
                case Tag1:
                case Tag2:
                case Tag6:
                case Tag7:
                case Tag8:
                case TagInt1:
                case TagInt10:
                case TagInt11:
                case TagInt12:
                case TagInt13:
                case TagInt14:
                case TagInt15:
                case TagInt16:
                case TagInt17:
                case TagInt18:
                case TagInt19:
                case TagInt2:
                case TagInt20:
                case TagInt21:
                case TagInt22:
                case TagInt23:
                case TagInt3:
                case TagInt4:
                case TagInt5:
                case TagInt6:
                case TagInt7:
                case TagInt8:
                case TagInt9:
                	{
                		alt464=2;
                	}
                    break;

                default:
                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 464;
                    EXCEPTION->state        = 0;


                    goto rulerdnEx;

                }

                switch (alt464)
                {
            	case 1:
            	    // Grammar/RFC5280.g:3908:26: {...}? => rdn
            	    {
            	        if ( !((set_pointer != NULL)) )
            	        {
            	                CONSTRUCTEX();
            	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	                EXCEPTION->message      = (void *)"set_pointer != NULL";
            	                EXCEPTION->ruleName	 = (void *)"rdn";


            	        }

            	        FOLLOWPUSH(FOLLOW_rdn_in_rdn9769);
            	        rdn1648=rdn(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulerdnEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, rdn1648.tree);

            	    }
            	    break;
            	case 2:
            	    // Grammar/RFC5280.g:3908:56: 
            	    {
            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulerdnEx; /* Prevent compiler warnings */
    rulerdnEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rdn */

/**
 * $ANTLR start dn
 * Grammar/RFC5280.g:3910:1: dn : ( ( ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) directoryString | ( dnoid | countryoid | serialoid ) ( printString |stria5= ia5String ) | legacyemailoid stria5= ia5String ) | oid any );
 */
static RFC5280Parser_dn_return
dn(pRFC5280Parser ctx)
{
    RFC5280Parser_dn_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_ia5String_return stria5;
    #undef	RETURN_TYPE_stria5
    #define	RETURN_TYPE_stria5 RFC5280Parser_ia5String_return

    RFC5280Parser_cnoid_return cnoid1649;
    #undef	RETURN_TYPE_cnoid1649
    #define	RETURN_TYPE_cnoid1649 RFC5280Parser_cnoid_return

    RFC5280Parser_oidon_return oidon1650;
    #undef	RETURN_TYPE_oidon1650
    #define	RETURN_TYPE_oidon1650 RFC5280Parser_oidon_return

    RFC5280Parser_oidname_return oidname1651;
    #undef	RETURN_TYPE_oidname1651
    #define	RETURN_TYPE_oidname1651 RFC5280Parser_oidname_return

    RFC5280Parser_surnameoid_return surnameoid1652;
    #undef	RETURN_TYPE_surnameoid1652
    #define	RETURN_TYPE_surnameoid1652 RFC5280Parser_surnameoid_return

    RFC5280Parser_givenoid_return givenoid1653;
    #undef	RETURN_TYPE_givenoid1653
    #define	RETURN_TYPE_givenoid1653 RFC5280Parser_givenoid_return

    RFC5280Parser_initoid_return initoid1654;
    #undef	RETURN_TYPE_initoid1654
    #define	RETURN_TYPE_initoid1654 RFC5280Parser_initoid_return

    RFC5280Parser_genqualifieroid_return genqualifieroid1655;
    #undef	RETURN_TYPE_genqualifieroid1655
    #define	RETURN_TYPE_genqualifieroid1655 RFC5280Parser_genqualifieroid_return

    RFC5280Parser_localoid_return localoid1656;
    #undef	RETURN_TYPE_localoid1656
    #define	RETURN_TYPE_localoid1656 RFC5280Parser_localoid_return

    RFC5280Parser_ouoid_return ouoid1657;
    #undef	RETURN_TYPE_ouoid1657
    #define	RETURN_TYPE_ouoid1657 RFC5280Parser_ouoid_return

    RFC5280Parser_sorpoid_return sorpoid1658;
    #undef	RETURN_TYPE_sorpoid1658
    #define	RETURN_TYPE_sorpoid1658 RFC5280Parser_sorpoid_return

    RFC5280Parser_titleoid_return titleoid1659;
    #undef	RETURN_TYPE_titleoid1659
    #define	RETURN_TYPE_titleoid1659 RFC5280Parser_titleoid_return

    RFC5280Parser_pseudooid_return pseudooid1660;
    #undef	RETURN_TYPE_pseudooid1660
    #define	RETURN_TYPE_pseudooid1660 RFC5280Parser_pseudooid_return

    RFC5280Parser_directoryString_return directoryString1661;
    #undef	RETURN_TYPE_directoryString1661
    #define	RETURN_TYPE_directoryString1661 RFC5280Parser_directoryString_return

    RFC5280Parser_dnoid_return dnoid1662;
    #undef	RETURN_TYPE_dnoid1662
    #define	RETURN_TYPE_dnoid1662 RFC5280Parser_dnoid_return

    RFC5280Parser_countryoid_return countryoid1663;
    #undef	RETURN_TYPE_countryoid1663
    #define	RETURN_TYPE_countryoid1663 RFC5280Parser_countryoid_return

    RFC5280Parser_serialoid_return serialoid1664;
    #undef	RETURN_TYPE_serialoid1664
    #define	RETURN_TYPE_serialoid1664 RFC5280Parser_serialoid_return

    RFC5280Parser_printString_return printString1665;
    #undef	RETURN_TYPE_printString1665
    #define	RETURN_TYPE_printString1665 RFC5280Parser_printString_return

    RFC5280Parser_legacyemailoid_return legacyemailoid1666;
    #undef	RETURN_TYPE_legacyemailoid1666
    #define	RETURN_TYPE_legacyemailoid1666 RFC5280Parser_legacyemailoid_return

    RFC5280Parser_oid_return oid1667;
    #undef	RETURN_TYPE_oid1667
    #define	RETURN_TYPE_oid1667 RFC5280Parser_oid_return

    RFC5280Parser_any_return any1668;
    #undef	RETURN_TYPE_any1668
    #define	RETURN_TYPE_any1668 RFC5280Parser_any_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    ASN1_OBJECT *obj;ASN1_STRING *str;
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    stria5.tree = NULL;

    cnoid1649.tree = NULL;

    oidon1650.tree = NULL;

    oidname1651.tree = NULL;

    surnameoid1652.tree = NULL;

    givenoid1653.tree = NULL;

    initoid1654.tree = NULL;

    genqualifieroid1655.tree = NULL;

    localoid1656.tree = NULL;

    ouoid1657.tree = NULL;

    sorpoid1658.tree = NULL;

    titleoid1659.tree = NULL;

    pseudooid1660.tree = NULL;

    directoryString1661.tree = NULL;

    dnoid1662.tree = NULL;

    countryoid1663.tree = NULL;

    serialoid1664.tree = NULL;

    printString1665.tree = NULL;

    legacyemailoid1666.tree = NULL;

    oid1667.tree = NULL;

    any1668.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3917:2: ( ( ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) directoryString | ( dnoid | countryoid | serialoid ) ( printString |stria5= ia5String ) | legacyemailoid stria5= ia5String ) | oid any )

            ANTLR3_UINT32 alt469;

            alt469=2;

            switch ( LA(1) )
            {
            case OIDTag:
            	{
            		switch ( LA(2) )
            		{
            		case LEGACYEMAILOID:
            		case NAMEOID:
            		case OIDCN:
            		case OIDCOUNTRY:
            		case OIDDNQUALIFIER:
            		case OIDGENQUALIFIER:
            		case OIDGIVENAME:
            		case OIDINIT:
            		case OIDLOCAL:
            		case OIDON:
            		case OIDOU:
            		case OIDPSEUDO:
            		case OIDSERIAL:
            		case OIDSORP:
            		case OIDTITLE:
            		case SURNAMEOID:
            			{
            				alt469=1;
            			}
            		    break;
            		case PRINTABLE:
            		case VALUE:
            			{
            				alt469=2;
            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 469;
            		    EXCEPTION->state        = 1;


            		    goto rulednEx;

            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 469;
                EXCEPTION->state        = 0;


                goto rulednEx;

            }

            switch (alt469)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3917:3: ( ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) directoryString | ( dnoid | countryoid | serialoid ) ( printString |stria5= ia5String ) | legacyemailoid stria5= ia5String )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        // Grammar/RFC5280.g:3917:3: ( ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) directoryString | ( dnoid | countryoid | serialoid ) ( printString |stria5= ia5String ) | legacyemailoid stria5= ia5String )
        	        {
        	            int alt468=3;
        	            switch ( LA(1) )
        	            {
        	            case OIDTag:
        	            	{
        	            		switch ( LA(2) )
        	            		{
        	            		case NAMEOID:
        	            		case OIDCN:
        	            		case OIDGENQUALIFIER:
        	            		case OIDGIVENAME:
        	            		case OIDINIT:
        	            		case OIDLOCAL:
        	            		case OIDON:
        	            		case OIDOU:
        	            		case OIDPSEUDO:
        	            		case OIDSORP:
        	            		case OIDTITLE:
        	            		case SURNAMEOID:
        	            			{
        	            				alt468=1;
        	            			}
        	            		    break;
        	            		case OIDCOUNTRY:
        	            		case OIDDNQUALIFIER:
        	            		case OIDSERIAL:
        	            			{
        	            				alt468=2;
        	            			}
        	            		    break;
        	            		case LEGACYEMAILOID:
        	            			{
        	            				alt468=3;
        	            			}
        	            		    break;

        	            		default:
        	            		    CONSTRUCTEX();
        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	            		    EXCEPTION->message      = (void *)"";
        	            		    EXCEPTION->decisionNum  = 468;
        	            		    EXCEPTION->state        = 1;


        	            		    goto rulednEx;

        	            		}

        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 468;
        	                EXCEPTION->state        = 0;


        	                goto rulednEx;

        	            }

        	            switch (alt468)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:3917:4: ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid ) directoryString
        	        	    {
        	        	        // Grammar/RFC5280.g:3917:4: ( cnoid | oidon | oidname | surnameoid | givenoid | initoid | genqualifieroid | localoid | ouoid | sorpoid | titleoid | pseudooid )
        	        	        {
        	        	            int alt465=12;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case OIDTag:
        	        	            	{
        	        	            		switch ( LA(2) )
        	        	            		{
        	        	            		case OIDCN:
        	        	            			{
        	        	            				alt465=1;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDON:
        	        	            			{
        	        	            				alt465=2;
        	        	            			}
        	        	            		    break;
        	        	            		case NAMEOID:
        	        	            			{
        	        	            				alt465=3;
        	        	            			}
        	        	            		    break;
        	        	            		case SURNAMEOID:
        	        	            			{
        	        	            				alt465=4;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDGIVENAME:
        	        	            			{
        	        	            				alt465=5;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDINIT:
        	        	            			{
        	        	            				alt465=6;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDGENQUALIFIER:
        	        	            			{
        	        	            				alt465=7;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDLOCAL:
        	        	            			{
        	        	            				alt465=8;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDOU:
        	        	            			{
        	        	            				alt465=9;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDSORP:
        	        	            			{
        	        	            				alt465=10;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDTITLE:
        	        	            			{
        	        	            				alt465=11;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDPSEUDO:
        	        	            			{
        	        	            				alt465=12;
        	        	            			}
        	        	            		    break;

        	        	            		default:
        	        	            		    CONSTRUCTEX();
        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            		    EXCEPTION->message      = (void *)"";
        	        	            		    EXCEPTION->decisionNum  = 465;
        	        	            		    EXCEPTION->state        = 1;


        	        	            		    goto rulednEx;

        	        	            		}

        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 465;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulednEx;

        	        	            }

        	        	            switch (alt465)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:3917:5: cnoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_cnoid_in_dn9795);
        	        	        	        cnoid1649=cnoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, cnoid1649.tree);

        	        	        	        {
        	        	        	            obj = cnoid1649.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:3917:32: oidon
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_oidon_in_dn9800);
        	        	        	        oidon1650=oidon(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, oidon1650.tree);

        	        	        	        {
        	        	        	            obj = oidon1650.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // Grammar/RFC5280.g:3917:59: oidname
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_oidname_in_dn9805);
        	        	        	        oidname1651=oidname(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, oidname1651.tree);

        	        	        	        {
        	        	        	            obj = oidname1651.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 4:
        	        	        	    // Grammar/RFC5280.g:3917:90: surnameoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_surnameoid_in_dn9810);
        	        	        	        surnameoid1652=surnameoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, surnameoid1652.tree);

        	        	        	        {
        	        	        	            obj = surnameoid1652.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 5:
        	        	        	    // Grammar/RFC5280.g:3918:3: givenoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_givenoid_in_dn9818);
        	        	        	        givenoid1653=givenoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, givenoid1653.tree);

        	        	        	        {
        	        	        	            obj = givenoid1653.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 6:
        	        	        	    // Grammar/RFC5280.g:3918:36: initoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_initoid_in_dn9823);
        	        	        	        initoid1654=initoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, initoid1654.tree);

        	        	        	        {
        	        	        	            obj = initoid1654.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 7:
        	        	        	    // Grammar/RFC5280.g:3918:67: genqualifieroid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_genqualifieroid_in_dn9828);
        	        	        	        genqualifieroid1655=genqualifieroid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, genqualifieroid1655.tree);

        	        	        	        {
        	        	        	            obj = genqualifieroid1655.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 8:
        	        	        	    // Grammar/RFC5280.g:3918:114: localoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_localoid_in_dn9833);
        	        	        	        localoid1656=localoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, localoid1656.tree);

        	        	        	        {
        	        	        	            obj = localoid1656.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 9:
        	        	        	    // Grammar/RFC5280.g:3918:147: ouoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_ouoid_in_dn9838);
        	        	        	        ouoid1657=ouoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, ouoid1657.tree);

        	        	        	        {
        	        	        	            obj = ouoid1657.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 10:
        	        	        	    // Grammar/RFC5280.g:3919:4: sorpoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_sorpoid_in_dn9846);
        	        	        	        sorpoid1658=sorpoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, sorpoid1658.tree);

        	        	        	        {
        	        	        	            obj = sorpoid1658.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 11:
        	        	        	    // Grammar/RFC5280.g:3919:34: titleoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_titleoid_in_dn9850);
        	        	        	        titleoid1659=titleoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, titleoid1659.tree);

        	        	        	        {
        	        	        	            obj = titleoid1659.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 12:
        	        	        	    // Grammar/RFC5280.g:3919:67: pseudooid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_pseudooid_in_dn9855);
        	        	        	        pseudooid1660=pseudooid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, pseudooid1660.tree);

        	        	        	        {
        	        	        	            obj = pseudooid1660.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        FOLLOWPUSH(FOLLOW_directoryString_in_dn9860);
        	        	        directoryString1661=directoryString(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulednEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, directoryString1661.tree);

        	        	        {
        	        	            str=directoryString1661.text
        	        	            ;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:3936:4: ( dnoid | countryoid | serialoid ) ( printString |stria5= ia5String )
        	        	    {
        	        	        // Grammar/RFC5280.g:3936:4: ( dnoid | countryoid | serialoid )
        	        	        {
        	        	            int alt466=3;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case OIDTag:
        	        	            	{
        	        	            		switch ( LA(2) )
        	        	            		{
        	        	            		case OIDDNQUALIFIER:
        	        	            			{
        	        	            				alt466=1;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDCOUNTRY:
        	        	            			{
        	        	            				alt466=2;
        	        	            			}
        	        	            		    break;
        	        	            		case OIDSERIAL:
        	        	            			{
        	        	            				alt466=3;
        	        	            			}
        	        	            		    break;

        	        	            		default:
        	        	            		    CONSTRUCTEX();
        	        	            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	            		    EXCEPTION->message      = (void *)"";
        	        	            		    EXCEPTION->decisionNum  = 466;
        	        	            		    EXCEPTION->state        = 1;


        	        	            		    goto rulednEx;

        	        	            		}

        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 466;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulednEx;

        	        	            }

        	        	            switch (alt466)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:3936:5: dnoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_dnoid_in_dn9876);
        	        	        	        dnoid1662=dnoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, dnoid1662.tree);

        	        	        	        {
        	        	        	            obj = dnoid1662.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:3936:33: countryoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_countryoid_in_dn9882);
        	        	        	        countryoid1663=countryoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, countryoid1663.tree);

        	        	        	        {
        	        	        	            obj = countryoid1663.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 3:
        	        	        	    // Grammar/RFC5280.g:3936:70: serialoid
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_serialoid_in_dn9887);
        	        	        	        serialoid1664=serialoid(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, serialoid1664.tree);

        	        	        	        {
        	        	        	            obj = serialoid1664.obj
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        // Grammar/RFC5280.g:3936:105: ( printString |stria5= ia5String )
        	        	        {
        	        	            int alt467=2;
        	        	            switch ( LA(1) )
        	        	            {
        	        	            case PrintStringTag:
        	        	            	{
        	        	            		alt467=1;
        	        	            	}
        	        	                break;
        	        	            case IA5StringTag:
        	        	            	{
        	        	            		alt467=2;
        	        	            	}
        	        	                break;

        	        	            default:
        	        	                CONSTRUCTEX();
        	        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	        	                EXCEPTION->message      = (void *)"";
        	        	                EXCEPTION->decisionNum  = 467;
        	        	                EXCEPTION->state        = 0;


        	        	                goto rulednEx;

        	        	            }

        	        	            switch (alt467)
        	        	            {
        	        	        	case 1:
        	        	        	    // Grammar/RFC5280.g:3936:106: printString
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_printString_in_dn9893);
        	        	        	        printString1665=printString(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, printString1665.tree);

        	        	        	        {
        	        	        	            str=printString1665.text
        	        	        	            ;
        	        	        	        }


        	        	        	    }
        	        	        	    break;
        	        	        	case 2:
        	        	        	    // Grammar/RFC5280.g:3936:145: stria5= ia5String
        	        	        	    {
        	        	        	        FOLLOWPUSH(FOLLOW_ia5String_in_dn9901);
        	        	        	        stria5=ia5String(ctx);

        	        	        	        FOLLOWPOP();
        	        	        	        if  (HASEXCEPTION())
        	        	        	        {
        	        	        	            goto rulednEx;
        	        	        	        }

        	        	        	        ADAPTOR->addChild(ADAPTOR, root_0, stria5.tree);

        	        	        	        {
        	        	        	            str=stria5.text
        	        	        	            ;printf("Warning: ia5 not allowed \n");
        	        	        	        }


        	        	        	    }
        	        	        	    break;

        	        	            }
        	        	        }

        	        	        {
        	        	            str->type=MBSTRING_ASC;printf("setting to ASCII \n");
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // Grammar/RFC5280.g:3939:4: legacyemailoid stria5= ia5String
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_legacyemailoid_in_dn9916);
        	        	        legacyemailoid1666=legacyemailoid(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulednEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, legacyemailoid1666.tree);

        	        	        FOLLOWPUSH(FOLLOW_ia5String_in_dn9920);
        	        	        stria5=ia5String(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulednEx;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, stria5.tree);

        	        	        {
        	        	            obj = legacyemailoid1666.obj
        	        	            ;str=stria5.text
        	        	            ;str->type=MBSTRING_ASC;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	            			ASN1_STRING *out = malloc(sizeof(ASN1_STRING));
        	            			out->data = NULL;
        	            			ASN1_STRING_TABLE *tbl = ASN1_STRING_TABLE_get(OBJ_obj2nid(obj));
        	            			if(ASN1_mbstring_ncopy(&out,str->data,str->length,str->type,tbl->mask,tbl->minsize,tbl->maxsize) == -1)
        	            			{
        	            				printf("DN String length constraint not satisfied \n");
        	            				exit(X509_DNAME_ERROR);
        	            			}
        	            			X509_DNAME_ENTRY *entry = malloc(sizeof(X509_DNAME_ENTRY));
        	            			entry->string_name = malloc(sizeof(X509_STRING_NAME));
        	            			entry->string_name->oid = obj;
        	            			entry->string_name->value = out; 
        	            			sk_X509_DNAME_ENTRY_push(dname,entry);
        	            		
        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3955:4: oid any
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_oid_in_dn9932);
        	        oid1667=oid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulednEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, oid1667.tree);

        	        FOLLOWPUSH(FOLLOW_any_in_dn9934);
        	        any1668=any(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulednEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, any1668.tree);

        	        {

        	            		X509_DNAME_ENTRY *entry = malloc(sizeof(X509_DNAME_ENTRY));
        	            		entry->other_name = malloc(sizeof(other_name));	
        	            		entry->other_name->oid = oid1667.text
        	            ->obj;
        	            		entry->other_name->value = any1668.text
        	            ;
        	            		sk_X509_DNAME_ENTRY_push(dname,entry);
        	            		
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulednEx; /* Prevent compiler warnings */
    rulednEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dn */

/**
 * $ANTLR start directoryString
 * Grammar/RFC5280.g:3965:1: directoryString returns [ASN1_STRING *text] : ( teletexString | printString | utf8String | univerString | bmpString | ia5String );
 */
static RFC5280Parser_directoryString_return
directoryString(pRFC5280Parser ctx)
{
    RFC5280Parser_directoryString_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_teletexString_return teletexString1669;
    #undef	RETURN_TYPE_teletexString1669
    #define	RETURN_TYPE_teletexString1669 RFC5280Parser_teletexString_return

    RFC5280Parser_printString_return printString1670;
    #undef	RETURN_TYPE_printString1670
    #define	RETURN_TYPE_printString1670 RFC5280Parser_printString_return

    RFC5280Parser_utf8String_return utf8String1671;
    #undef	RETURN_TYPE_utf8String1671
    #define	RETURN_TYPE_utf8String1671 RFC5280Parser_utf8String_return

    RFC5280Parser_univerString_return univerString1672;
    #undef	RETURN_TYPE_univerString1672
    #define	RETURN_TYPE_univerString1672 RFC5280Parser_univerString_return

    RFC5280Parser_bmpString_return bmpString1673;
    #undef	RETURN_TYPE_bmpString1673
    #define	RETURN_TYPE_bmpString1673 RFC5280Parser_bmpString_return

    RFC5280Parser_ia5String_return ia5String1674;
    #undef	RETURN_TYPE_ia5String1674
    #define	RETURN_TYPE_ia5String1674 RFC5280Parser_ia5String_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    teletexString1669.tree = NULL;

    printString1670.tree = NULL;

    utf8String1671.tree = NULL;

    univerString1672.tree = NULL;

    bmpString1673.tree = NULL;

    ia5String1674.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:3972:2: ( teletexString | printString | utf8String | univerString | bmpString | ia5String )

            ANTLR3_UINT32 alt470;

            alt470=6;

            switch ( LA(1) )
            {
            case TeletexTag:
            	{
            		alt470=1;
            	}
                break;
            case PrintStringTag:
            	{
            		alt470=2;
            	}
                break;
            case UTF8Tag:
            	{
            		alt470=3;
            	}
                break;
            case UniverStringTag:
            	{
            		alt470=4;
            	}
                break;
            case BMPTag:
            	{
            		alt470=5;
            	}
                break;
            case IA5StringTag:
            	{
            		alt470=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 470;
                EXCEPTION->state        = 0;


                goto ruledirectoryStringEx;

            }

            switch (alt470)
            {
        	case 1:
        	    // Grammar/RFC5280.g:3972:4: teletexString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_teletexString_in_directoryString9966);
        	        teletexString1669=teletexString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledirectoryStringEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, teletexString1669.tree);

        	        {
        	            retval.text= 
        	            teletexString1669.text
        	            ;
        	            retval.text
        	            ->type = MBSTRING_ASC;
        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:3973:4: printString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_printString_in_directoryString9973);
        	        printString1670=printString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledirectoryStringEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, printString1670.tree);

        	        {
        	            retval.text= 
        	            printString1670.text
        	            ;
        	            retval.text
        	            ->type = MBSTRING_ASC;
        	        }


        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:3974:4: utf8String
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_utf8String_in_directoryString9980);
        	        utf8String1671=utf8String(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledirectoryStringEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, utf8String1671.tree);

        	        {
        	            retval.text= 
        	            utf8String1671.text
        	            ;
        	            retval.text
        	            ->type = MBSTRING_UTF8;
        	        }


        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:3975:4: univerString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_univerString_in_directoryString9987);
        	        univerString1672=univerString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledirectoryStringEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, univerString1672.tree);

        	        {
        	            retval.text= 
        	            univerString1672.text
        	            ;
        	            retval.text
        	            ->type = MBSTRING_UNIV;
        	        }


        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:3976:4: bmpString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_bmpString_in_directoryString9994);
        	        bmpString1673=bmpString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledirectoryStringEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bmpString1673.tree);

        	        {
        	            retval.text= 
        	            bmpString1673.text
        	            ;
        	            retval.text
        	            ->type = MBSTRING_BMP;
        	        }


        	    }
        	    break;
        	case 6:
        	    // Grammar/RFC5280.g:3977:4: ia5String
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_ia5String_in_directoryString10001);
        	        ia5String1674=ia5String(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledirectoryStringEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, ia5String1674.tree);

        	        {
        	            retval.text= 
        	            ia5String1674.text
        	            ;
        	            retval.text
        	            ->type = MBSTRING_ASC;warning |= IA5STRING_MISUSE_WARNING;
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledirectoryStringEx; /* Prevent compiler warnings */
    ruledirectoryStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end directoryString */

/**
 * $ANTLR start signature
 * Grammar/RFC5280.g:3980:1: signature : bitstring ;
 */
static RFC5280Parser_signature_return
signature(pRFC5280Parser ctx)
{
    RFC5280Parser_signature_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_bitstring_return bitstring1675;
    #undef	RETURN_TYPE_bitstring1675
    #define	RETURN_TYPE_bitstring1675 RFC5280Parser_bitstring_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    bitstring1675.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3984:2: ( bitstring )
        // Grammar/RFC5280.g:3984:3: bitstring
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_bitstring_in_signature10020);
            bitstring1675=bitstring(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesignatureEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, bitstring1675.tree);

            {

                	cert->signature = malloc(sizeof(X509_SIGNATURE));
                	cert->signature->sign = bitstring1675.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesignatureEx; /* Prevent compiler warnings */
    rulesignatureEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end signature */

/**
 * $ANTLR start dsa_signature
 * Grammar/RFC5280.g:3993:1: dsa_signature : constructedBitString sequenceTag r= integer s= integer ;
 */
static RFC5280Parser_dsa_signature_return
dsa_signature(pRFC5280Parser ctx)
{
    RFC5280Parser_dsa_signature_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integer_return r;
    #undef	RETURN_TYPE_r
    #define	RETURN_TYPE_r RFC5280Parser_integer_return

    RFC5280Parser_integer_return s;
    #undef	RETURN_TYPE_s
    #define	RETURN_TYPE_s RFC5280Parser_integer_return

    RFC5280Parser_constructedBitString_return constructedBitString1676;
    #undef	RETURN_TYPE_constructedBitString1676
    #define	RETURN_TYPE_constructedBitString1676 RFC5280Parser_constructedBitString_return

    RFC5280Parser_sequenceTag_return sequenceTag1677;
    #undef	RETURN_TYPE_sequenceTag1677
    #define	RETURN_TYPE_sequenceTag1677 RFC5280Parser_sequenceTag_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    r.tree = NULL;

    s.tree = NULL;

    constructedBitString1676.tree = NULL;

    sequenceTag1677.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:3997:2: ( constructedBitString sequenceTag r= integer s= integer )
        // Grammar/RFC5280.g:3997:3: constructedBitString sequenceTag r= integer s= integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FOLLOWPUSH(FOLLOW_constructedBitString_in_dsa_signature10042);
            constructedBitString1676=constructedBitString(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_signatureEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, constructedBitString1676.tree);

            FOLLOWPUSH(FOLLOW_sequenceTag_in_dsa_signature10044);
            sequenceTag1677=sequenceTag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_signatureEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1677.tree);

            FOLLOWPUSH(FOLLOW_integer_in_dsa_signature10048);
            r=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_signatureEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, r.tree);

            FOLLOWPUSH(FOLLOW_integer_in_dsa_signature10052);
            s=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledsa_signatureEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, s.tree);

            {

                	cert->signature=malloc(sizeof(X509_SIGNATURE));
                	cert->signature->dsa_sign = malloc(sizeof(DSA_signature));
                	cert->signature->dsa_sign->r = r.text
                ;
                	cert->signature->dsa_sign->s = s.text
                ;
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledsa_signatureEx; /* Prevent compiler warnings */
    ruledsa_signatureEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dsa_signature */

/**
 * $ANTLR start critical
 * Grammar/RFC5280.g:4010:1: critical returns [int bool] : ( truevalue | falsevalue );
 */
static RFC5280Parser_critical_return
critical(pRFC5280Parser ctx)
{
    RFC5280Parser_critical_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_truevalue_return truevalue1678;
    #undef	RETURN_TYPE_truevalue1678
    #define	RETURN_TYPE_truevalue1678 RFC5280Parser_truevalue_return

    RFC5280Parser_falsevalue_return falsevalue1679;
    #undef	RETURN_TYPE_falsevalue1679
    #define	RETURN_TYPE_falsevalue1679 RFC5280Parser_falsevalue_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    truevalue1678.tree = NULL;

    falsevalue1679.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:4016:9: ( truevalue | falsevalue )

            ANTLR3_UINT32 alt471;

            alt471=2;

            switch ( LA(1) )
            {
            case TrueTag:
            	{
            		alt471=1;
            	}
                break;
            case FalseTag:
            	{
            		alt471=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 471;
                EXCEPTION->state        = 0;


                goto rulecriticalEx;

            }

            switch (alt471)
            {
        	case 1:
        	    // Grammar/RFC5280.g:4017:3: truevalue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_truevalue_in_critical10084);
        	        truevalue1678=truevalue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecriticalEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, truevalue1678.tree);

        	        {
        	            retval.bool=1;

        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:4017:26: falsevalue
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_falsevalue_in_critical10090);
        	        falsevalue1679=falsevalue(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecriticalEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, falsevalue1679.tree);

        	        {
        	            retval.bool=0;

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulecriticalEx; /* Prevent compiler warnings */
    rulecriticalEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end critical */

/**
 * $ANTLR start time_span
 * Grammar/RFC5280.g:4020:1: time_span returns [ASN1_TIME *text] : ( utc | genTime );
 */
static RFC5280Parser_time_span_return
time_span(pRFC5280Parser ctx)
{
    RFC5280Parser_time_span_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_utc_return utc1680;
    #undef	RETURN_TYPE_utc1680
    #define	RETURN_TYPE_utc1680 RFC5280Parser_utc_return

    RFC5280Parser_genTime_return genTime1681;
    #undef	RETURN_TYPE_genTime1681
    #define	RETURN_TYPE_genTime1681 RFC5280Parser_genTime_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    utc1680.tree = NULL;

    genTime1681.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:4026:9: ( utc | genTime )

            ANTLR3_UINT32 alt472;

            alt472=2;

            switch ( LA(1) )
            {
            case UTCTag:
            	{
            		alt472=1;
            	}
                break;
            case GeneralTimeTag:
            	{
            		alt472=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 472;
                EXCEPTION->state        = 0;


                goto ruletime_spanEx;

            }

            switch (alt472)
            {
        	case 1:
        	    // Grammar/RFC5280.g:4027:4: utc
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_utc_in_time_span10118);
        	        utc1680=utc(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletime_spanEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, utc1680.tree);

        	        {
        	            retval.text=
        	            utc1680.text
        	            ;

        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:4027:29: genTime
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_genTime_in_time_span10124);
        	        genTime1681=genTime(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletime_spanEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, genTime1681.tree);

        	        {
        	            retval.text=
        	            genTime1681.text
        	            ;

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletime_spanEx; /* Prevent compiler warnings */
    ruletime_spanEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end time_span */

/**
 * $ANTLR start any
 * Grammar/RFC5280.g:4028:1: any returns [ANY* text] : ({...}? => anyToken )+ ;
 */
static RFC5280Parser_any_return
any(pRFC5280Parser ctx)
{
    RFC5280Parser_any_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_anyToken_return anyToken1682;
    #undef	RETURN_TYPE_anyToken1682
    #define	RETURN_TYPE_anyToken1682 RFC5280Parser_anyToken_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    any_pointer = counter_list;printf("any_pointer is %x \n",any_pointer);ANY* result = NULL;
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    anyToken1682.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4034:9: ( ({...}? => anyToken )+ )
        // Grammar/RFC5280.g:4036:2: ({...}? => anyToken )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // Grammar/RFC5280.g:4036:2: ({...}? => anyToken )+
            {
                int cnt473=0;

                for (;;)
                {
                    int alt473=2;
            	{
            	   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	    */
            	    int LA473_0 = LA(1);
            	    if ( (LA473_0 == OctetTag))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_2 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == SequenceTag))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_3 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == Tag0))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_4 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt1))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_5 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt2))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_6 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt3))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_7 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt4))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_8 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt5))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_9 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt6))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_10 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt7))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_11 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt8))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_12 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt9))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_13 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt10))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_14 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt11))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_15 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt12))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_16 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt13))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_17 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt14))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_18 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt15))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_19 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt16))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_20 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt17))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_21 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt18))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_22 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt19))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_23 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt20))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_24 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt21))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_25 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt22))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_26 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == TagInt23))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_27 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == Tag1))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_28 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == ConstructedTag1))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_29 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == Tag2))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_30 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == ConstructedTag2))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_31 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == ConstructedTag0))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_32 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == ConstructedTag3))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_33 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == ConstructedTag4))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_34 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == ConstructedTag5))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_35 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == Tag6))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_36 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == Tag7))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_37 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == Tag8))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_38 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( (LA473_0 == SetTag))
            	    {
            	        {
            	           /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
            	            */
            	            int LA473_39 = LA(2);
            	            if ( ((any_pointer != NULL)))
            	            {
            	                alt473=1;
            	            }

            	        }
            	    }
            	    else if ( ((any_pointer != NULL)) && (((LA473_0 >= BMPTag) && (LA473_0 <= BitStringTag)) || LA473_0 == ConstructedOctetTag || ((LA473_0 >= ConstructedTag6) && (LA473_0 <= ConstructedTag8)) || LA473_0 == FalseTag || ((LA473_0 >= GeneralStringTag) && (LA473_0 <= GraphicalStringTag)) || ((LA473_0 >= IA5StringTag) && (LA473_0 <= IntTag)) || LA473_0 == Null || LA473_0 == OIDTag || LA473_0 == PrintStringTag || ((LA473_0 >= Tag3) && (LA473_0 <= Tag5)) || ((LA473_0 >= TeletexTag) && (LA473_0 <= TrueTag)) || ((LA473_0 >= UTCTag) && (LA473_0 <= UniverStringTag)) || ((LA473_0 >= VideoStringTag) && (LA473_0 <= VisibleStringTag))))
            	    {
            	        alt473=1;
            	    }

            	}
            	switch (alt473)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:4036:3: {...}? => anyToken
            	        {
            	            if ( !((any_pointer != NULL)) )
            	            {
            	                    CONSTRUCTEX();
            	                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
            	                    EXCEPTION->message      = (void *)"any_pointer != NULL";
            	                    EXCEPTION->ruleName	 = (void *)"any";


            	            }

            	            {
            	                printf("any token is parsed \n");
            	            }


            	            FOLLOWPUSH(FOLLOW_anyToken_in_any10152);
            	            anyToken1682=anyToken(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleanyEx;
            	            }

            	            ADAPTOR->addChild(ADAPTOR, root_0, anyToken1682.tree);

            	            {

            	                	if(!result)
            	                	{
            	                		result = malloc(sizeof(ANY));
            	                		retval.text= result;

            	                	}
            	                	else
            	                	{
            	                		result->next=malloc(sizeof(ANY));
            	                		result=result->next;
            	                	}
            	                	result->el=anyToken1682.text
            	                ;
            	                	result->next=NULL;
            	                	
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt473 >= 1 )
            		{
            		    goto loop473;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleanyEx;
            	}
            	cnt473++;
                }
                loop473: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleanyEx; /* Prevent compiler warnings */
    ruleanyEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end any */

/**
 * $ANTLR start anyToken
 * Grammar/RFC5280.g:4051:1: anyToken returns [void *text] : ( teletexString | ia5String | bmpString | utf8String | printString | univerString | visibleString | generalString | graphicString | videoString | integer | bitstring | constructedOctetString | time_span | critical | set | null | octetstring | sequenceTag | oid | constructedTag0 | tag0 | constructedTag1 | tag1 | constructedTag2 | tag2 | constructedTag3 | tag3 | constructedTag4 | tag4 | constructedTag5 | tag5 | constructedTag6 | tag6 | constructedTag7 | tag7 | constructedTag8 | tag8 );
 */
static RFC5280Parser_anyToken_return
anyToken(pRFC5280Parser ctx)
{
    RFC5280Parser_anyToken_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_teletexString_return teletexString1683;
    #undef	RETURN_TYPE_teletexString1683
    #define	RETURN_TYPE_teletexString1683 RFC5280Parser_teletexString_return

    RFC5280Parser_ia5String_return ia5String1684;
    #undef	RETURN_TYPE_ia5String1684
    #define	RETURN_TYPE_ia5String1684 RFC5280Parser_ia5String_return

    RFC5280Parser_bmpString_return bmpString1685;
    #undef	RETURN_TYPE_bmpString1685
    #define	RETURN_TYPE_bmpString1685 RFC5280Parser_bmpString_return

    RFC5280Parser_utf8String_return utf8String1686;
    #undef	RETURN_TYPE_utf8String1686
    #define	RETURN_TYPE_utf8String1686 RFC5280Parser_utf8String_return

    RFC5280Parser_printString_return printString1687;
    #undef	RETURN_TYPE_printString1687
    #define	RETURN_TYPE_printString1687 RFC5280Parser_printString_return

    RFC5280Parser_univerString_return univerString1688;
    #undef	RETURN_TYPE_univerString1688
    #define	RETURN_TYPE_univerString1688 RFC5280Parser_univerString_return

    RFC5280Parser_visibleString_return visibleString1689;
    #undef	RETURN_TYPE_visibleString1689
    #define	RETURN_TYPE_visibleString1689 RFC5280Parser_visibleString_return

    RFC5280Parser_generalString_return generalString1690;
    #undef	RETURN_TYPE_generalString1690
    #define	RETURN_TYPE_generalString1690 RFC5280Parser_generalString_return

    RFC5280Parser_graphicString_return graphicString1691;
    #undef	RETURN_TYPE_graphicString1691
    #define	RETURN_TYPE_graphicString1691 RFC5280Parser_graphicString_return

    RFC5280Parser_videoString_return videoString1692;
    #undef	RETURN_TYPE_videoString1692
    #define	RETURN_TYPE_videoString1692 RFC5280Parser_videoString_return

    RFC5280Parser_integer_return integer1693;
    #undef	RETURN_TYPE_integer1693
    #define	RETURN_TYPE_integer1693 RFC5280Parser_integer_return

    RFC5280Parser_bitstring_return bitstring1694;
    #undef	RETURN_TYPE_bitstring1694
    #define	RETURN_TYPE_bitstring1694 RFC5280Parser_bitstring_return

    RFC5280Parser_constructedOctetString_return constructedOctetString1695;
    #undef	RETURN_TYPE_constructedOctetString1695
    #define	RETURN_TYPE_constructedOctetString1695 RFC5280Parser_constructedOctetString_return

    RFC5280Parser_time_span_return time_span1696;
    #undef	RETURN_TYPE_time_span1696
    #define	RETURN_TYPE_time_span1696 RFC5280Parser_time_span_return

    RFC5280Parser_critical_return critical1697;
    #undef	RETURN_TYPE_critical1697
    #define	RETURN_TYPE_critical1697 RFC5280Parser_critical_return

    RFC5280Parser_set_return set1698;
    #undef	RETURN_TYPE_set1698
    #define	RETURN_TYPE_set1698 RFC5280Parser_set_return

    RFC5280Parser_null_return null1699;
    #undef	RETURN_TYPE_null1699
    #define	RETURN_TYPE_null1699 RFC5280Parser_null_return

    RFC5280Parser_octetstring_return octetstring1700;
    #undef	RETURN_TYPE_octetstring1700
    #define	RETURN_TYPE_octetstring1700 RFC5280Parser_octetstring_return

    RFC5280Parser_sequenceTag_return sequenceTag1701;
    #undef	RETURN_TYPE_sequenceTag1701
    #define	RETURN_TYPE_sequenceTag1701 RFC5280Parser_sequenceTag_return

    RFC5280Parser_oid_return oid1702;
    #undef	RETURN_TYPE_oid1702
    #define	RETURN_TYPE_oid1702 RFC5280Parser_oid_return

    RFC5280Parser_constructedTag0_return constructedTag01703;
    #undef	RETURN_TYPE_constructedTag01703
    #define	RETURN_TYPE_constructedTag01703 RFC5280Parser_constructedTag0_return

    RFC5280Parser_tag0_return tag01704;
    #undef	RETURN_TYPE_tag01704
    #define	RETURN_TYPE_tag01704 RFC5280Parser_tag0_return

    RFC5280Parser_constructedTag1_return constructedTag11705;
    #undef	RETURN_TYPE_constructedTag11705
    #define	RETURN_TYPE_constructedTag11705 RFC5280Parser_constructedTag1_return

    RFC5280Parser_tag1_return tag11706;
    #undef	RETURN_TYPE_tag11706
    #define	RETURN_TYPE_tag11706 RFC5280Parser_tag1_return

    RFC5280Parser_constructedTag2_return constructedTag21707;
    #undef	RETURN_TYPE_constructedTag21707
    #define	RETURN_TYPE_constructedTag21707 RFC5280Parser_constructedTag2_return

    RFC5280Parser_tag2_return tag21708;
    #undef	RETURN_TYPE_tag21708
    #define	RETURN_TYPE_tag21708 RFC5280Parser_tag2_return

    RFC5280Parser_constructedTag3_return constructedTag31709;
    #undef	RETURN_TYPE_constructedTag31709
    #define	RETURN_TYPE_constructedTag31709 RFC5280Parser_constructedTag3_return

    RFC5280Parser_tag3_return tag31710;
    #undef	RETURN_TYPE_tag31710
    #define	RETURN_TYPE_tag31710 RFC5280Parser_tag3_return

    RFC5280Parser_constructedTag4_return constructedTag41711;
    #undef	RETURN_TYPE_constructedTag41711
    #define	RETURN_TYPE_constructedTag41711 RFC5280Parser_constructedTag4_return

    RFC5280Parser_tag4_return tag41712;
    #undef	RETURN_TYPE_tag41712
    #define	RETURN_TYPE_tag41712 RFC5280Parser_tag4_return

    RFC5280Parser_constructedTag5_return constructedTag51713;
    #undef	RETURN_TYPE_constructedTag51713
    #define	RETURN_TYPE_constructedTag51713 RFC5280Parser_constructedTag5_return

    RFC5280Parser_tag5_return tag51714;
    #undef	RETURN_TYPE_tag51714
    #define	RETURN_TYPE_tag51714 RFC5280Parser_tag5_return

    RFC5280Parser_constructedTag6_return constructedTag61715;
    #undef	RETURN_TYPE_constructedTag61715
    #define	RETURN_TYPE_constructedTag61715 RFC5280Parser_constructedTag6_return

    RFC5280Parser_tag6_return tag61716;
    #undef	RETURN_TYPE_tag61716
    #define	RETURN_TYPE_tag61716 RFC5280Parser_tag6_return

    RFC5280Parser_constructedTag7_return constructedTag71717;
    #undef	RETURN_TYPE_constructedTag71717
    #define	RETURN_TYPE_constructedTag71717 RFC5280Parser_constructedTag7_return

    RFC5280Parser_tag7_return tag71718;
    #undef	RETURN_TYPE_tag71718
    #define	RETURN_TYPE_tag71718 RFC5280Parser_tag7_return

    RFC5280Parser_constructedTag8_return constructedTag81719;
    #undef	RETURN_TYPE_constructedTag81719
    #define	RETURN_TYPE_constructedTag81719 RFC5280Parser_constructedTag8_return

    RFC5280Parser_tag8_return tag81720;
    #undef	RETURN_TYPE_tag81720
    #define	RETURN_TYPE_tag81720 RFC5280Parser_tag8_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    teletexString1683.tree = NULL;

    ia5String1684.tree = NULL;

    bmpString1685.tree = NULL;

    utf8String1686.tree = NULL;

    printString1687.tree = NULL;

    univerString1688.tree = NULL;

    visibleString1689.tree = NULL;

    generalString1690.tree = NULL;

    graphicString1691.tree = NULL;

    videoString1692.tree = NULL;

    integer1693.tree = NULL;

    bitstring1694.tree = NULL;

    constructedOctetString1695.tree = NULL;

    time_span1696.tree = NULL;

    critical1697.tree = NULL;

    set1698.tree = NULL;

    null1699.tree = NULL;

    octetstring1700.tree = NULL;

    sequenceTag1701.tree = NULL;

    oid1702.tree = NULL;

    constructedTag01703.tree = NULL;

    tag01704.tree = NULL;

    constructedTag11705.tree = NULL;

    tag11706.tree = NULL;

    constructedTag21707.tree = NULL;

    tag21708.tree = NULL;

    constructedTag31709.tree = NULL;

    tag31710.tree = NULL;

    constructedTag41711.tree = NULL;

    tag41712.tree = NULL;

    constructedTag51713.tree = NULL;

    tag51714.tree = NULL;

    constructedTag61715.tree = NULL;

    tag61716.tree = NULL;

    constructedTag71717.tree = NULL;

    tag71718.tree = NULL;

    constructedTag81719.tree = NULL;

    tag81720.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:4057:9: ( teletexString | ia5String | bmpString | utf8String | printString | univerString | visibleString | generalString | graphicString | videoString | integer | bitstring | constructedOctetString | time_span | critical | set | null | octetstring | sequenceTag | oid | constructedTag0 | tag0 | constructedTag1 | tag1 | constructedTag2 | tag2 | constructedTag3 | tag3 | constructedTag4 | tag4 | constructedTag5 | tag5 | constructedTag6 | tag6 | constructedTag7 | tag7 | constructedTag8 | tag8 )

            ANTLR3_UINT32 alt474;

            alt474=38;

            switch ( LA(1) )
            {
            case TeletexTag:
            	{
            		alt474=1;
            	}
                break;
            case IA5StringTag:
            	{
            		alt474=2;
            	}
                break;
            case BMPTag:
            	{
            		alt474=3;
            	}
                break;
            case UTF8Tag:
            	{
            		alt474=4;
            	}
                break;
            case PrintStringTag:
            	{
            		alt474=5;
            	}
                break;
            case UniverStringTag:
            	{
            		alt474=6;
            	}
                break;
            case VisibleStringTag:
            	{
            		alt474=7;
            	}
                break;
            case GeneralStringTag:
            	{
            		alt474=8;
            	}
                break;
            case GraphicalStringTag:
            	{
            		alt474=9;
            	}
                break;
            case VideoStringTag:
            	{
            		alt474=10;
            	}
                break;
            case Int0:
            case Int1:
            case Int2:
            case IntTag:
            	{
            		alt474=11;
            	}
                break;
            case BitStringKeyCert:
            case BitStringTag:
            	{
            		alt474=12;
            	}
                break;
            case ConstructedOctetTag:
            	{
            		alt474=13;
            	}
                break;
            case GeneralTimeTag:
            case UTCTag:
            	{
            		alt474=14;
            	}
                break;
            case FalseTag:
            case TrueTag:
            	{
            		alt474=15;
            	}
                break;
            case SetTag:
            	{
            		alt474=16;
            	}
                break;
            case Null:
            	{
            		alt474=17;
            	}
                break;
            case OctetTag:
            	{
            		alt474=18;
            	}
                break;
            case SequenceTag:
            	{
            		alt474=19;
            	}
                break;
            case OIDTag:
            	{
            		alt474=20;
            	}
                break;
            case ConstructedTag0:
            	{
            		alt474=21;
            	}
                break;
            case Tag0:
            case TagInt1:
            case TagInt10:
            case TagInt11:
            case TagInt12:
            case TagInt13:
            case TagInt14:
            case TagInt15:
            case TagInt16:
            case TagInt17:
            case TagInt18:
            case TagInt19:
            case TagInt2:
            case TagInt20:
            case TagInt21:
            case TagInt22:
            case TagInt23:
            case TagInt3:
            case TagInt4:
            case TagInt5:
            case TagInt6:
            case TagInt7:
            case TagInt8:
            case TagInt9:
            	{
            		alt474=22;
            	}
                break;
            case ConstructedTag1:
            	{
            		alt474=23;
            	}
                break;
            case Tag1:
            	{
            		alt474=24;
            	}
                break;
            case ConstructedTag2:
            	{
            		alt474=25;
            	}
                break;
            case Tag2:
            	{
            		alt474=26;
            	}
                break;
            case ConstructedTag3:
            	{
            		alt474=27;
            	}
                break;
            case Tag3:
            	{
            		alt474=28;
            	}
                break;
            case ConstructedTag4:
            	{
            		alt474=29;
            	}
                break;
            case Tag4:
            	{
            		alt474=30;
            	}
                break;
            case ConstructedTag5:
            	{
            		alt474=31;
            	}
                break;
            case Tag5:
            	{
            		alt474=32;
            	}
                break;
            case ConstructedTag6:
            	{
            		alt474=33;
            	}
                break;
            case Tag6:
            	{
            		alt474=34;
            	}
                break;
            case ConstructedTag7:
            	{
            		alt474=35;
            	}
                break;
            case Tag7:
            	{
            		alt474=36;
            	}
                break;
            case ConstructedTag8:
            	{
            		alt474=37;
            	}
                break;
            case Tag8:
            	{
            		alt474=38;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 474;
                EXCEPTION->state        = 0;


                goto ruleanyTokenEx;

            }

            switch (alt474)
            {
        	case 1:
        	    // Grammar/RFC5280.g:4058:3: teletexString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_teletexString_in_anyToken10181);
        	        teletexString1683=teletexString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, teletexString1683.tree);

        	        {
        	            retval.text=
        	            teletexString1683.text
        	            ;

        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:4059:4: ia5String
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_ia5String_in_anyToken10188);
        	        ia5String1684=ia5String(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, ia5String1684.tree);

        	        {
        	            retval.text=
        	            ia5String1684.text
        	            ;

        	        }


        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:4060:4: bmpString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_bmpString_in_anyToken10195);
        	        bmpString1685=bmpString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bmpString1685.tree);

        	        {
        	            retval.text=
        	            bmpString1685.text
        	            ;

        	        }


        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:4061:4: utf8String
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_utf8String_in_anyToken10202);
        	        utf8String1686=utf8String(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, utf8String1686.tree);

        	        {
        	            retval.text=
        	            utf8String1686.text
        	            ;

        	        }


        	    }
        	    break;
        	case 5:
        	    // Grammar/RFC5280.g:4062:4: printString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_printString_in_anyToken10209);
        	        printString1687=printString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, printString1687.tree);

        	        {
        	            retval.text=
        	            printString1687.text
        	            ;

        	        }


        	    }
        	    break;
        	case 6:
        	    // Grammar/RFC5280.g:4063:4: univerString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_univerString_in_anyToken10216);
        	        univerString1688=univerString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, univerString1688.tree);

        	        {
        	            retval.text=
        	            univerString1688.text
        	            ;

        	        }


        	    }
        	    break;
        	case 7:
        	    // Grammar/RFC5280.g:4064:4: visibleString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_visibleString_in_anyToken10223);
        	        visibleString1689=visibleString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, visibleString1689.tree);

        	        {
        	            retval.text=
        	            visibleString1689.text
        	            ;

        	        }


        	    }
        	    break;
        	case 8:
        	    // Grammar/RFC5280.g:4065:4: generalString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_generalString_in_anyToken10230);
        	        generalString1690=generalString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, generalString1690.tree);

        	        {
        	            retval.text=
        	            generalString1690.text
        	            ;

        	        }


        	    }
        	    break;
        	case 9:
        	    // Grammar/RFC5280.g:4066:4: graphicString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_graphicString_in_anyToken10237);
        	        graphicString1691=graphicString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, graphicString1691.tree);

        	        {
        	            retval.text=
        	            graphicString1691.text
        	            ;

        	        }


        	    }
        	    break;
        	case 10:
        	    // Grammar/RFC5280.g:4067:4: videoString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_videoString_in_anyToken10244);
        	        videoString1692=videoString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, videoString1692.tree);

        	        {
        	            retval.text=
        	            videoString1692.text
        	            ;

        	        }


        	    }
        	    break;
        	case 11:
        	    // Grammar/RFC5280.g:4068:4: integer
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_integer_in_anyToken10251);
        	        integer1693=integer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, integer1693.tree);

        	        {
        	            retval.text=
        	            integer1693.text
        	            ;

        	        }


        	    }
        	    break;
        	case 12:
        	    // Grammar/RFC5280.g:4069:4: bitstring
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_bitstring_in_anyToken10258);
        	        bitstring1694=bitstring(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, bitstring1694.tree);

        	        {
        	            retval.text=
        	            bitstring1694.text
        	            ;

        	        }


        	    }
        	    break;
        	case 13:
        	    // Grammar/RFC5280.g:4070:4: constructedOctetString
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedOctetString_in_anyToken10265);
        	        constructedOctetString1695=constructedOctetString(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedOctetString1695.tree);

        	        {
        	            retval.text= new_asn1_string (36,0,NULL);

        	        }


        	    }
        	    break;
        	case 14:
        	    // Grammar/RFC5280.g:4071:4: time_span
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_time_span_in_anyToken10272);
        	        time_span1696=time_span(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, time_span1696.tree);

        	        {
        	            retval.text=
        	            time_span1696.text
        	            ;

        	        }


        	    }
        	    break;
        	case 15:
        	    // Grammar/RFC5280.g:4072:4: critical
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_critical_in_anyToken10279);
        	        critical1697=critical(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, critical1697.tree);

        	        {
        	            retval.text=
        	            (STRSTREAM->toStringTT(STRSTREAM, critical1697.start, critical1697.stop))
        	            ;

        	        }


        	    }
        	    break;
        	case 16:
        	    // Grammar/RFC5280.g:4073:4: set
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_set_in_anyToken10286);
        	        set1698=set(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, set1698.tree);

        	        {
        	            retval.text=new_asn1_string(49,0,NULL);

        	        }


        	    }
        	    break;
        	case 17:
        	    // Grammar/RFC5280.g:4074:4: null
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_null_in_anyToken10293);
        	        null1699=null(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, null1699.tree);

        	        {
        	            retval.text=new_asn1_string(5,0,NULL);

        	        }


        	    }
        	    break;
        	case 18:
        	    // Grammar/RFC5280.g:4075:4: octetstring
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_octetstring_in_anyToken10300);
        	        octetstring1700=octetstring(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, octetstring1700.tree);

        	        {
        	            retval.text=
        	            octetstring1700.text
        	            ;

        	        }


        	    }
        	    break;
        	case 19:
        	    // Grammar/RFC5280.g:4076:4: sequenceTag
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_sequenceTag_in_anyToken10307);
        	        sequenceTag1701=sequenceTag(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, sequenceTag1701.tree);

        	        {
        	            retval.text=new_asn1_string(48,0,NULL);

        	        }


        	    }
        	    break;
        	case 20:
        	    // Grammar/RFC5280.g:4077:4: oid
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_oid_in_anyToken10314);
        	        oid1702=oid(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, oid1702.tree);

        	        {
        	            retval.text=
        	            oid1702.text
        	            ->obj;

        	        }


        	    }
        	    break;
        	case 21:
        	    // Grammar/RFC5280.g:4078:4: constructedTag0
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag0_in_anyToken10321);
        	        constructedTag01703=constructedTag0(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag01703.tree);

        	        {
        	            retval.text=new_asn1_string(160,0,NULL);

        	        }


        	    }
        	    break;
        	case 22:
        	    // Grammar/RFC5280.g:4079:4: tag0
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag0_in_anyToken10328);
        	        tag01704=tag0(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag01704.tree);

        	        {
        	            retval.text=new_asn1_string(80,
        	            tag01704.text
        	            ->length,tag01704.text
        	            ->value);

        	        }


        	    }
        	    break;
        	case 23:
        	    // Grammar/RFC5280.g:4080:4: constructedTag1
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag1_in_anyToken10335);
        	        constructedTag11705=constructedTag1(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag11705.tree);

        	        {
        	            retval.text=new_asn1_string(161,0,NULL);

        	        }


        	    }
        	    break;
        	case 24:
        	    // Grammar/RFC5280.g:4081:4: tag1
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag1_in_anyToken10342);
        	        tag11706=tag1(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag11706.tree);

        	        {
        	            retval.text=new_asn1_string(81,
        	            tag11706.text
        	            ->length,tag11706.text
        	            ->value);

        	        }


        	    }
        	    break;
        	case 25:
        	    // Grammar/RFC5280.g:4082:4: constructedTag2
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag2_in_anyToken10349);
        	        constructedTag21707=constructedTag2(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag21707.tree);

        	        {
        	            retval.text=new_asn1_string(162,0,NULL);

        	        }


        	    }
        	    break;
        	case 26:
        	    // Grammar/RFC5280.g:4083:4: tag2
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag2_in_anyToken10356);
        	        tag21708=tag2(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag21708.tree);

        	        {
        	            retval.text=new_asn1_string(82,
        	            tag21708.text
        	            ->length,tag21708.text
        	            ->value);

        	        }


        	    }
        	    break;
        	case 27:
        	    // Grammar/RFC5280.g:4084:4: constructedTag3
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag3_in_anyToken10363);
        	        constructedTag31709=constructedTag3(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag31709.tree);

        	        {
        	            retval.text=new_asn1_string(163,0,NULL);

        	        }


        	    }
        	    break;
        	case 28:
        	    // Grammar/RFC5280.g:4085:4: tag3
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag3_in_anyToken10370);
        	        tag31710=tag3(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag31710.tree);

        	        {
        	            retval.text=new_asn1_string(83,
        	            tag31710.text
        	            ->length,tag31710.text
        	            ->value);

        	        }


        	    }
        	    break;
        	case 29:
        	    // Grammar/RFC5280.g:4086:4: constructedTag4
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag4_in_anyToken10377);
        	        constructedTag41711=constructedTag4(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag41711.tree);

        	        {
        	            retval.text=new_asn1_string(164,0,NULL);

        	        }


        	    }
        	    break;
        	case 30:
        	    // Grammar/RFC5280.g:4087:4: tag4
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag4_in_anyToken10384);
        	        tag41712=tag4(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag41712.tree);

        	        {
        	            retval.text=new_asn1_string(84,
        	            tag41712.text
        	            ->length,tag41712.text
        	            ->value);

        	        }


        	    }
        	    break;
        	case 31:
        	    // Grammar/RFC5280.g:4088:4: constructedTag5
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag5_in_anyToken10391);
        	        constructedTag51713=constructedTag5(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag51713.tree);

        	        {
        	            retval.text=new_asn1_string(165,0,NULL);

        	        }


        	    }
        	    break;
        	case 32:
        	    // Grammar/RFC5280.g:4089:4: tag5
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag5_in_anyToken10398);
        	        tag51714=tag5(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag51714.tree);

        	        {
        	            retval.text=new_asn1_string(85,
        	            tag51714.text
        	            ->length,tag51714.text
        	            ->value);

        	        }


        	    }
        	    break;
        	case 33:
        	    // Grammar/RFC5280.g:4090:4: constructedTag6
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag6_in_anyToken10405);
        	        constructedTag61715=constructedTag6(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag61715.tree);

        	        {
        	            retval.text=new_asn1_string(166,0,NULL);

        	        }


        	    }
        	    break;
        	case 34:
        	    // Grammar/RFC5280.g:4091:4: tag6
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag6_in_anyToken10412);
        	        tag61716=tag6(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag61716.tree);

        	        {
        	            retval.text=new_asn1_string(86,
        	            tag61716.text
        	            ->length,tag61716.text
        	            ->value);

        	        }


        	    }
        	    break;
        	case 35:
        	    // Grammar/RFC5280.g:4092:4: constructedTag7
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag7_in_anyToken10419);
        	        constructedTag71717=constructedTag7(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag71717.tree);

        	        {
        	            retval.text=new_asn1_string(167,0,NULL);

        	        }


        	    }
        	    break;
        	case 36:
        	    // Grammar/RFC5280.g:4093:4: tag7
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag7_in_anyToken10426);
        	        tag71718=tag7(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag71718.tree);

        	        {
        	            retval.text=new_asn1_string(87,
        	            tag71718.text
        	            ->length,tag71718.text
        	            ->value);

        	        }


        	    }
        	    break;
        	case 37:
        	    // Grammar/RFC5280.g:4094:4: constructedTag8
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_constructedTag8_in_anyToken10433);
        	        constructedTag81719=constructedTag8(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, constructedTag81719.tree);

        	        {
        	            retval.text=new_asn1_string(168,0,NULL);

        	        }


        	    }
        	    break;
        	case 38:
        	    // Grammar/RFC5280.g:4095:4: tag8
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_tag8_in_anyToken10440);
        	        tag81720=tag8(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleanyTokenEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, tag81720.tree);

        	        {
        	            retval.text=new_asn1_string(88,
        	            tag81720.text
        	            ->length,tag81720.text
        	            ->value);

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleanyTokenEx; /* Prevent compiler warnings */
    ruleanyTokenEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end anyToken */

/**
 * $ANTLR start octetstring
 * Grammar/RFC5280.g:4100:1: octetstring returns [ASN1_OCTET_STRING* text] : OctetTag val ;
 */
static RFC5280Parser_octetstring_return
octetstring(pRFC5280Parser ctx)
{
    RFC5280Parser_octetstring_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OctetTag1721;
    RFC5280Parser_val_return val1722;
    #undef	RETURN_TYPE_val1722
    #define	RETURN_TYPE_val1722 RFC5280Parser_val_return

    pANTLR3_BASE_TREE OctetTag1721_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OctetTag1721       = NULL;
    val1722.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OctetTag1721_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4103:2: ( OctetTag val )
        // Grammar/RFC5280.g:4103:3: OctetTag val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OctetTag1721 = (pANTLR3_COMMON_TOKEN) MATCHT(OctetTag, &FOLLOW_OctetTag_in_octetstring10467);
            if  (HASEXCEPTION())
            {
                goto ruleoctetstringEx;
            }

            OctetTag1721_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OctetTag1721));
            ADAPTOR->addChild(ADAPTOR, root_0, OctetTag1721_tree);


            FOLLOWPUSH(FOLLOW_val_in_octetstring10469);
            val1722=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoctetstringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1722.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((OctetTag1721->getText(OctetTag1721))->chars,length);
                		
                retval.text= (ASN1_OCTET_STRING *) new_asn1_string (4,mpz_get_ui(length),
                val1722.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoctetstringEx; /* Prevent compiler warnings */
    ruleoctetstringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end octetstring */

/**
 * $ANTLR start integer
 * Grammar/RFC5280.g:4113:1: integer returns [ASN1_INTEGER *text] : ( integerAbove3 | int0 | int1 | int2 );
 */
static RFC5280Parser_integer_return
integer(pRFC5280Parser ctx)
{
    RFC5280Parser_integer_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_integerAbove3_return integerAbove31723;
    #undef	RETURN_TYPE_integerAbove31723
    #define	RETURN_TYPE_integerAbove31723 RFC5280Parser_integerAbove3_return

    RFC5280Parser_int0_return int01724;
    #undef	RETURN_TYPE_int01724
    #define	RETURN_TYPE_int01724 RFC5280Parser_int0_return

    RFC5280Parser_int1_return int11725;
    #undef	RETURN_TYPE_int11725
    #define	RETURN_TYPE_int11725 RFC5280Parser_int1_return

    RFC5280Parser_int2_return int21726;
    #undef	RETURN_TYPE_int21726
    #define	RETURN_TYPE_int21726 RFC5280Parser_int2_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    integerAbove31723.tree = NULL;

    int01724.tree = NULL;

    int11725.tree = NULL;

    int21726.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:4119:9: ( integerAbove3 | int0 | int1 | int2 )

            ANTLR3_UINT32 alt475;

            alt475=4;

            switch ( LA(1) )
            {
            case IntTag:
            	{
            		alt475=1;
            	}
                break;
            case Int0:
            	{
            		alt475=2;
            	}
                break;
            case Int1:
            	{
            		alt475=3;
            	}
                break;
            case Int2:
            	{
            		alt475=4;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 475;
                EXCEPTION->state        = 0;


                goto ruleintegerEx;

            }

            switch (alt475)
            {
        	case 1:
        	    // Grammar/RFC5280.g:4120:4: integerAbove3
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_integerAbove3_in_integer10499);
        	        integerAbove31723=integerAbove3(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleintegerEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, integerAbove31723.tree);

        	        {
        	            retval.text=
        	            integerAbove31723.text
        	            ;

        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:4121:4: int0
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_int0_in_integer10506);
        	        int01724=int0(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleintegerEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, int01724.tree);

        	        {
        	            unsigned char *value = malloc(1);value[0]=0;retval.text= (ASN1_INTEGER *) new_asn1_string(2,1,value);

        	        }


        	    }
        	    break;
        	case 3:
        	    // Grammar/RFC5280.g:4122:4: int1
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_int1_in_integer10513);
        	        int11725=int1(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleintegerEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, int11725.tree);

        	        {
        	            unsigned char *value = malloc(1);value[0]=1;retval.text= (ASN1_INTEGER *) new_asn1_string(2,1,value);

        	        }


        	    }
        	    break;
        	case 4:
        	    // Grammar/RFC5280.g:4123:4: int2
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_int2_in_integer10520);
        	        int21726=int2(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleintegerEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, int21726.tree);

        	        {
        	            unsigned char *value = malloc(1);value[0]=2;retval.text= (ASN1_INTEGER *) new_asn1_string(2,1,value);

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruleintegerEx; /* Prevent compiler warnings */
    ruleintegerEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end integer */

/**
 * $ANTLR start integerAbove3
 * Grammar/RFC5280.g:4126:1: integerAbove3 returns [ASN1_INTEGER *text] : IntTag val ;
 */
static RFC5280Parser_integerAbove3_return
integerAbove3(pRFC5280Parser ctx)
{
    RFC5280Parser_integerAbove3_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IntTag1727;
    RFC5280Parser_val_return val1728;
    #undef	RETURN_TYPE_val1728
    #define	RETURN_TYPE_val1728 RFC5280Parser_val_return

    pANTLR3_BASE_TREE IntTag1727_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IntTag1727       = NULL;
    val1728.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IntTag1727_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4129:2: ( IntTag val )
        // Grammar/RFC5280.g:4129:3: IntTag val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            IntTag1727 = (pANTLR3_COMMON_TOKEN) MATCHT(IntTag, &FOLLOW_IntTag_in_integerAbove310543);
            if  (HASEXCEPTION())
            {
                goto ruleintegerAbove3Ex;
            }

            IntTag1727_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IntTag1727));
            ADAPTOR->addChild(ADAPTOR, root_0, IntTag1727_tree);


            FOLLOWPUSH(FOLLOW_val_in_integerAbove310545);
            val1728=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleintegerAbove3Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1728.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((IntTag1727->getText(IntTag1727))->chars,length);
                		
                retval.text= (ASN1_INTEGER *) new_asn1_string(2,mpz_get_ui(length),
                val1728.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleintegerAbove3Ex; /* Prevent compiler warnings */
    ruleintegerAbove3Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end integerAbove3 */

/**
 * $ANTLR start int0
 * Grammar/RFC5280.g:4139:1: int0 : Int0 ;
 */
static RFC5280Parser_int0_return
int0(pRFC5280Parser ctx)
{
    RFC5280Parser_int0_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Int01729;

    pANTLR3_BASE_TREE Int01729_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Int01729       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Int01729_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4142:2: ( Int0 )
        // Grammar/RFC5280.g:4142:3: Int0
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Int01729 = (pANTLR3_COMMON_TOKEN) MATCHT(Int0, &FOLLOW_Int0_in_int010565);
            if  (HASEXCEPTION())
            {
                goto ruleint0Ex;
            }

            Int01729_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Int01729));
            ADAPTOR->addChild(ADAPTOR, root_0, Int01729_tree);


            {
                entire_encoding(1);printf("Int0 \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleint0Ex; /* Prevent compiler warnings */
    ruleint0Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end int0 */

/**
 * $ANTLR start int1
 * Grammar/RFC5280.g:4146:1: int1 : Int1 ;
 */
static RFC5280Parser_int1_return
int1(pRFC5280Parser ctx)
{
    RFC5280Parser_int1_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Int11730;

    pANTLR3_BASE_TREE Int11730_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Int11730       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Int11730_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4149:2: ( Int1 )
        // Grammar/RFC5280.g:4149:3: Int1
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Int11730 = (pANTLR3_COMMON_TOKEN) MATCHT(Int1, &FOLLOW_Int1_in_int110580);
            if  (HASEXCEPTION())
            {
                goto ruleint1Ex;
            }

            Int11730_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Int11730));
            ADAPTOR->addChild(ADAPTOR, root_0, Int11730_tree);


            {
                entire_encoding(1);printf("Int1 \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleint1Ex; /* Prevent compiler warnings */
    ruleint1Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end int1 */

/**
 * $ANTLR start int2
 * Grammar/RFC5280.g:4153:1: int2 : Int2 ;
 */
static RFC5280Parser_int2_return
int2(pRFC5280Parser ctx)
{
    RFC5280Parser_int2_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Int21731;

    pANTLR3_BASE_TREE Int21731_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Int21731       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Int21731_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4156:2: ( Int2 )
        // Grammar/RFC5280.g:4156:3: Int2
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Int21731 = (pANTLR3_COMMON_TOKEN) MATCHT(Int2, &FOLLOW_Int2_in_int210595);
            if  (HASEXCEPTION())
            {
                goto ruleint2Ex;
            }

            Int21731_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Int21731));
            ADAPTOR->addChild(ADAPTOR, root_0, Int21731_tree);


            {
                entire_encoding(1);printf("Int2 \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleint2Ex; /* Prevent compiler warnings */
    ruleint2Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end int2 */

/**
 * $ANTLR start bitstring
 * Grammar/RFC5280.g:4160:1: bitstring returns [ASN1_STRING* text] : ( BitStringTag val | BitStringKeyCert val );
 */
static RFC5280Parser_bitstring_return
bitstring(pRFC5280Parser ctx)
{
    RFC5280Parser_bitstring_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    BitStringTag1732;
    pANTLR3_COMMON_TOKEN    BitStringKeyCert1734;
    RFC5280Parser_val_return val1733;
    #undef	RETURN_TYPE_val1733
    #define	RETURN_TYPE_val1733 RFC5280Parser_val_return

    RFC5280Parser_val_return val1735;
    #undef	RETURN_TYPE_val1735
    #define	RETURN_TYPE_val1735 RFC5280Parser_val_return

    pANTLR3_BASE_TREE BitStringTag1732_tree;
    pANTLR3_BASE_TREE BitStringKeyCert1734_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    BitStringTag1732       = NULL;
    BitStringKeyCert1734       = NULL;
    val1733.tree = NULL;

    val1735.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    BitStringTag1732_tree   = NULL;
    BitStringKeyCert1734_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:4166:9: ( BitStringTag val | BitStringKeyCert val )

            ANTLR3_UINT32 alt476;

            alt476=2;

            switch ( LA(1) )
            {
            case BitStringTag:
            	{
            		alt476=1;
            	}
                break;
            case BitStringKeyCert:
            	{
            		alt476=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 476;
                EXCEPTION->state        = 0;


                goto rulebitstringEx;

            }

            switch (alt476)
            {
        	case 1:
        	    // Grammar/RFC5280.g:4167:3: BitStringTag val
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        BitStringTag1732 = (pANTLR3_COMMON_TOKEN) MATCHT(BitStringTag, &FOLLOW_BitStringTag_in_bitstring10621);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitstringEx;
        	        }

        	        BitStringTag1732_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BitStringTag1732));
        	        ADAPTOR->addChild(ADAPTOR, root_0, BitStringTag1732_tree);


        	        FOLLOWPUSH(FOLLOW_val_in_bitstring10623);
        	        val1733=val(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitstringEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, val1733.tree);

        	        {

        	            		mpz_t length;
        	            		mpz_init_set_ui(length,0);
        	            		primitive_type((BitStringTag1732->getText(BitStringTag1732))->chars,length);
        	            		ASN1_STRING *bs;
        	            		bs = malloc(sizeof(ASN1_STRING));
        	            		compute_bitstring (
        	            val1733.text
        	            ,mpz_get_ui(length),bs);
        	            		retval.text= bs;

        	            	
        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:4176:4: BitStringKeyCert val
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        BitStringKeyCert1734 = (pANTLR3_COMMON_TOKEN) MATCHT(BitStringKeyCert, &FOLLOW_BitStringKeyCert_in_bitstring10630);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitstringEx;
        	        }

        	        BitStringKeyCert1734_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BitStringKeyCert1734));
        	        ADAPTOR->addChild(ADAPTOR, root_0, BitStringKeyCert1734_tree);


        	        FOLLOWPUSH(FOLLOW_val_in_bitstring10632);
        	        val1735=val(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulebitstringEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, val1735.tree);

        	        {

        	            		mpz_t length;
        	            		mpz_init_set_ui(length,0);
        	            		primitive_type((BitStringKeyCert1734->getText(BitStringKeyCert1734))->chars,length);
        	            		ASN1_STRING *bs;
        	            		bs = malloc(sizeof(ASN1_STRING));
        	            		if((unsigned char) (BitStringKeyCert1734->getText(BitStringKeyCert1734))->chars[2] > 8)
        	            			exit(BAD_BITSTRING_ENCODING_ERROR);
        	            		unsigned char mask = 255 << (unsigned char) (BitStringKeyCert1734->getText(BitStringKeyCert1734))->chars[2];
        	            		bs->type =3;
        	            		bs->length = mpz_get_ui(length)-1;
        	            		bs->data=malloc(bs->length);
        	            		
        	            val1735.text
        	            [bs->length-1] &= mask;
        	            		unsigned long i;
        	            		for(i=0;i<bs->length;i++)
        	            			bs->data[i]=val1735.text
        	            [i];
        	            		retval.text= bs;

        	            		printf("It's bit string \n");
        	            	
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulebitstringEx; /* Prevent compiler warnings */
    rulebitstringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end bitstring */

/**
 * $ANTLR start bitstringCertSign
 * Grammar/RFC5280.g:4197:1: bitstringCertSign : BitStringKeyCert ;
 */
static RFC5280Parser_bitstringCertSign_return
bitstringCertSign(pRFC5280Parser ctx)
{
    RFC5280Parser_bitstringCertSign_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    BitStringKeyCert1736;

    pANTLR3_BASE_TREE BitStringKeyCert1736_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    BitStringKeyCert1736       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    BitStringKeyCert1736_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4201:2: ( BitStringKeyCert )
        // Grammar/RFC5280.g:4201:3: BitStringKeyCert
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            BitStringKeyCert1736 = (pANTLR3_COMMON_TOKEN) MATCHT(BitStringKeyCert, &FOLLOW_BitStringKeyCert_in_bitstringCertSign10652);
            if  (HASEXCEPTION())
            {
                goto rulebitstringCertSignEx;
            }

            BitStringKeyCert1736_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BitStringKeyCert1736));
            ADAPTOR->addChild(ADAPTOR, root_0, BitStringKeyCert1736_tree);


            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((BitStringKeyCert1736->getText(BitStringKeyCert1736))->chars,length);
                		ASN1_STRING *bs;
                		bs = malloc(sizeof(ASN1_STRING));
                		unsigned char mask = 255 << (unsigned char) (BitStringKeyCert1736->getText(BitStringKeyCert1736))->chars[2];
                		bs->type=3;
                		bs->length = mpz_get_ui(length)-1;
                		bs->data=malloc(bs->length);
                		(BitStringKeyCert1736->getText(BitStringKeyCert1736))->chars[bs->length+2] &= mask;
                		unsigned long i;
                		for(i=0;i<bs->length;i++)
                			bs->data[i]=(BitStringKeyCert1736->getText(BitStringKeyCert1736))->chars[i+3];
                		key_usage_ext->value->keyusage=bs;
                		printf("It's bit string cert sign \n");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebitstringCertSignEx; /* Prevent compiler warnings */
    rulebitstringCertSignEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end bitstringCertSign */

/**
 * $ANTLR start oid
 * Grammar/RFC5280.g:4307:1: oid returns [oid_array* text] : OIDTag val ;
 */
static RFC5280Parser_oid_return
oid(pRFC5280Parser ctx)
{
    RFC5280Parser_oid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1737;
    RFC5280Parser_val_return val1738;
    #undef	RETURN_TYPE_val1738
    #define	RETURN_TYPE_val1738 RFC5280Parser_val_return

    pANTLR3_BASE_TREE OIDTag1737_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1737       = NULL;
    val1738.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1737_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4310:2: ( OIDTag val )
        // Grammar/RFC5280.g:4310:3: OIDTag val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1737 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_oid10677);
            if  (HASEXCEPTION())
            {
                goto ruleoidEx;
            }

            OIDTag1737_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1737));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1737_tree);


            FOLLOWPUSH(FOLLOW_val_in_oid10679);
            val1738=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoidEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1738.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((OIDTag1737->getText(OIDTag1737))->chars,length);
                		oid_array* test;
                		int len = mpz_get_ui(length);
                		test = malloc(sizeof(oid_array));
                		test->oid = malloc(sizeof(mpz_t)*(len+2));
                		printf("It's ok til here \n");
                		int oid_len = compute_oid_value(
                val1738.text
                ,len,test->oid);
                		printf("Value computed \n");
                		int i;
                		char **oid_numbers;
                		oid_numbers = malloc(sizeof(char *)*oid_len);
                		int oid_obj_len = 0;
                		for(i=0;i<oid_len;i++)
                		{
                			oid_numbers[i] = mpz_get_str(NULL,10,test->oid[i]);
                			oid_obj_len += strlen(oid_numbers[i]);
                		}
                		char *oid_value = malloc(oid_obj_len+oid_len);
                		strcpy(oid_value,oid_numbers[0]);
                		for(i=1;i<oid_len;i++)
                		{
                			strcat(oid_value,".");
                			strcat(oid_value,oid_numbers[i]);
                		}
                		printf("OID Value is %s \n",oid_value);
                		test->len = oid_len;
                		int new_nid = OBJ_txt2nid(oid_value);
                		if(new_nid == NID_undef)
                			new_nid = OBJ_create(oid_value,oid_value,oid_value);
                		test->obj = OBJ_nid2obj(new_nid);
                		retval.text= test;

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoidEx; /* Prevent compiler warnings */
    ruleoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end oid */

/**
 * $ANTLR start cnoid
 * Grammar/RFC5280.g:4349:1: cnoid returns [ASN1_OBJECT * obj] : OIDTag OIDCN ;
 */
static RFC5280Parser_cnoid_return
cnoid(pRFC5280Parser ctx)
{
    RFC5280Parser_cnoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1739;
    pANTLR3_COMMON_TOKEN    OIDCN1740;

    pANTLR3_BASE_TREE OIDTag1739_tree;
    pANTLR3_BASE_TREE OIDCN1740_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1739       = NULL;
    OIDCN1740       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1739_tree   = NULL;
    OIDCN1740_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4352:2: ( OIDTag OIDCN )
        // Grammar/RFC5280.g:4352:3: OIDTag OIDCN
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1739 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_cnoid10702);
            if  (HASEXCEPTION())
            {
                goto rulecnoidEx;
            }

            OIDTag1739_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1739));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1739_tree);


            OIDCN1740 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDCN, &FOLLOW_OIDCN_in_cnoid10704);
            if  (HASEXCEPTION())
            {
                goto rulecnoidEx;
            }

            OIDCN1740_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDCN1740));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDCN1740_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_commonName);

                		printf("it's CN \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecnoidEx; /* Prevent compiler warnings */
    rulecnoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end cnoid */

/**
 * $ANTLR start oidon
 * Grammar/RFC5280.g:4360:1: oidon returns [ASN1_OBJECT * obj] : OIDTag OIDON ;
 */
static RFC5280Parser_oidon_return
oidon(pRFC5280Parser ctx)
{
    RFC5280Parser_oidon_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1741;
    pANTLR3_COMMON_TOKEN    OIDON1742;

    pANTLR3_BASE_TREE OIDTag1741_tree;
    pANTLR3_BASE_TREE OIDON1742_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1741       = NULL;
    OIDON1742       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1741_tree   = NULL;
    OIDON1742_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4363:2: ( OIDTag OIDON )
        // Grammar/RFC5280.g:4363:3: OIDTag OIDON
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1741 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_oidon10726);
            if  (HASEXCEPTION())
            {
                goto ruleoidonEx;
            }

            OIDTag1741_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1741));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1741_tree);


            OIDON1742 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDON, &FOLLOW_OIDON_in_oidon10728);
            if  (HASEXCEPTION())
            {
                goto ruleoidonEx;
            }

            OIDON1742_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDON1742));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDON1742_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_organizationName);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoidonEx; /* Prevent compiler warnings */
    ruleoidonEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end oidon */

/**
 * $ANTLR start aiaoid
 * Grammar/RFC5280.g:4370:1: aiaoid returns [ASN1_OBJECT * obj] : OIDTag AIAOID ;
 */
static RFC5280Parser_aiaoid_return
aiaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_aiaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1743;
    pANTLR3_COMMON_TOKEN    AIAOID1744;

    pANTLR3_BASE_TREE OIDTag1743_tree;
    pANTLR3_BASE_TREE AIAOID1744_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1743       = NULL;
    AIAOID1744       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1743_tree   = NULL;
    AIAOID1744_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4373:2: ( OIDTag AIAOID )
        // Grammar/RFC5280.g:4373:3: OIDTag AIAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1743 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_aiaoid10747);
            if  (HASEXCEPTION())
            {
                goto ruleaiaoidEx;
            }

            OIDTag1743_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1743));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1743_tree);


            AIAOID1744 = (pANTLR3_COMMON_TOKEN) MATCHT(AIAOID, &FOLLOW_AIAOID_in_aiaoid10749);
            if  (HASEXCEPTION())
            {
                goto ruleaiaoidEx;
            }

            AIAOID1744_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AIAOID1744));
            ADAPTOR->addChild(ADAPTOR, root_0, AIAOID1744_tree);


            {
                	
                		entire_encoding(8);
                		mpz_t oid[9];
                		mpz_init_set_ui(oid[0],1);
                		mpz_init_set_ui(oid[1],3);
                		mpz_init_set_ui(oid[2],6);
                		mpz_init_set_ui(oid[3],1);
                		mpz_init_set_ui(oid[4],5);
                		mpz_init_set_ui(oid[5],5);
                		mpz_init_set_ui(oid[6],7);
                		mpz_init_set_ui(oid[7],1);
                		mpz_init_set_ui(oid[8],1);
                		mpz_t index;
                		mpz_init(index);
                		compute_index(oid,9,index);
                		gmp_printf("AIA index is %Zd \n",index);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_info_access);

                		printf("it's AIA \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaiaoidEx; /* Prevent compiler warnings */
    ruleaiaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end aiaoid */

/**
 * $ANTLR start siaoid
 * Grammar/RFC5280.g:4395:1: siaoid returns [ASN1_OBJECT * obj] : OIDTag SIAOID ;
 */
static RFC5280Parser_siaoid_return
siaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_siaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1745;
    pANTLR3_COMMON_TOKEN    SIAOID1746;

    pANTLR3_BASE_TREE OIDTag1745_tree;
    pANTLR3_BASE_TREE SIAOID1746_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1745       = NULL;
    SIAOID1746       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1745_tree   = NULL;
    SIAOID1746_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4398:2: ( OIDTag SIAOID )
        // Grammar/RFC5280.g:4398:3: OIDTag SIAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1745 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_siaoid10769);
            if  (HASEXCEPTION())
            {
                goto rulesiaoidEx;
            }

            OIDTag1745_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1745));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1745_tree);


            SIAOID1746 = (pANTLR3_COMMON_TOKEN) MATCHT(SIAOID, &FOLLOW_SIAOID_in_siaoid10771);
            if  (HASEXCEPTION())
            {
                goto rulesiaoidEx;
            }

            SIAOID1746_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SIAOID1746));
            ADAPTOR->addChild(ADAPTOR, root_0, SIAOID1746_tree);


            {

                		entire_encoding(8);
                		mpz_t oid[9];
                		mpz_init_set_ui(oid[0],1);
                		mpz_init_set_ui(oid[1],3);
                		mpz_init_set_ui(oid[2],6);
                		mpz_init_set_ui(oid[3],1);
                		mpz_init_set_ui(oid[4],5);
                		mpz_init_set_ui(oid[5],5);
                		mpz_init_set_ui(oid[6],7);
                		mpz_init_set_ui(oid[7],1);
                		mpz_init_set_ui(oid[8],11);
                		mpz_t index;
                		mpz_init(index);
                		compute_index(oid,9,index);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_sinfo_access);

                		printf("it's SIA \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesiaoidEx; /* Prevent compiler warnings */
    rulesiaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end siaoid */

/**
 * $ANTLR start akioid
 * Grammar/RFC5280.g:4419:1: akioid returns [ASN1_OBJECT * obj] : OIDTag OIDAKI ;
 */
static RFC5280Parser_akioid_return
akioid(pRFC5280Parser ctx)
{
    RFC5280Parser_akioid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1747;
    pANTLR3_COMMON_TOKEN    OIDAKI1748;

    pANTLR3_BASE_TREE OIDTag1747_tree;
    pANTLR3_BASE_TREE OIDAKI1748_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1747       = NULL;
    OIDAKI1748       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1747_tree   = NULL;
    OIDAKI1748_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4422:2: ( OIDTag OIDAKI )
        // Grammar/RFC5280.g:4422:3: OIDTag OIDAKI
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1747 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_akioid10791);
            if  (HASEXCEPTION())
            {
                goto ruleakioidEx;
            }

            OIDTag1747_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1747));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1747_tree);


            OIDAKI1748 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDAKI, &FOLLOW_OIDAKI_in_akioid10793);
            if  (HASEXCEPTION())
            {
                goto ruleakioidEx;
            }

            OIDAKI1748_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDAKI1748));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDAKI1748_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2035188);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_authority_key_identifier);

                		printf("It's AKI \n");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleakioidEx; /* Prevent compiler warnings */
    ruleakioidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end akioid */

/**
 * $ANTLR start skioid
 * Grammar/RFC5280.g:4433:1: skioid returns [ASN1_OBJECT * obj] : OIDTag OIDSKI ;
 */
static RFC5280Parser_skioid_return
skioid(pRFC5280Parser ctx)
{
    RFC5280Parser_skioid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1749;
    pANTLR3_COMMON_TOKEN    OIDSKI1750;

    pANTLR3_BASE_TREE OIDTag1749_tree;
    pANTLR3_BASE_TREE OIDSKI1750_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1749       = NULL;
    OIDSKI1750       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1749_tree   = NULL;
    OIDSKI1750_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4436:2: ( OIDTag OIDSKI )
        // Grammar/RFC5280.g:4436:3: OIDTag OIDSKI
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1749 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_skioid10813);
            if  (HASEXCEPTION())
            {
                goto ruleskioidEx;
            }

            OIDTag1749_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1749));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1749_tree);


            OIDSKI1750 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDSKI, &FOLLOW_OIDSKI_in_skioid10815);
            if  (HASEXCEPTION())
            {
                goto ruleskioidEx;
            }

            OIDSKI1750_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDSKI1750));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDSKI1750_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,1993020);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_subject_key_identifier);

                		printf("It's SKI \n");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleskioidEx; /* Prevent compiler warnings */
    ruleskioidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end skioid */

/**
 * $ANTLR start bcoid
 * Grammar/RFC5280.g:4447:1: bcoid returns [ASN1_OBJECT * obj] : OIDTag OIDBC ;
 */
static RFC5280Parser_bcoid_return
bcoid(pRFC5280Parser ctx)
{
    RFC5280Parser_bcoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1751;
    pANTLR3_COMMON_TOKEN    OIDBC1752;

    pANTLR3_BASE_TREE OIDTag1751_tree;
    pANTLR3_BASE_TREE OIDBC1752_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1751       = NULL;
    OIDBC1752       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1751_tree   = NULL;
    OIDBC1752_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4450:2: ( OIDTag OIDBC )
        // Grammar/RFC5280.g:4450:3: OIDTag OIDBC
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1751 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_bcoid10834);
            if  (HASEXCEPTION())
            {
                goto rulebcoidEx;
            }

            OIDTag1751_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1751));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1751_tree);


            OIDBC1752 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDBC, &FOLLOW_OIDBC_in_bcoid10836);
            if  (HASEXCEPTION())
            {
                goto rulebcoidEx;
            }

            OIDBC1752_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDBC1752));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDBC1752_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2003020);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_basic_constraints);

                		printf("It's BC");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebcoidEx; /* Prevent compiler warnings */
    rulebcoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end bcoid */

/**
 * $ANTLR start polconstraintsoid
 * Grammar/RFC5280.g:4461:1: polconstraintsoid returns [ASN1_OBJECT * obj] : OIDTag OIDPOLCONST ;
 */
static RFC5280Parser_polconstraintsoid_return
polconstraintsoid(pRFC5280Parser ctx)
{
    RFC5280Parser_polconstraintsoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1753;
    pANTLR3_COMMON_TOKEN    OIDPOLCONST1754;

    pANTLR3_BASE_TREE OIDTag1753_tree;
    pANTLR3_BASE_TREE OIDPOLCONST1754_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1753       = NULL;
    OIDPOLCONST1754       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1753_tree   = NULL;
    OIDPOLCONST1754_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4465:2: ( OIDTag OIDPOLCONST )
        // Grammar/RFC5280.g:4465:3: OIDTag OIDPOLCONST
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1753 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_polconstraintsoid10856);
            if  (HASEXCEPTION())
            {
                goto rulepolconstraintsoidEx;
            }

            OIDTag1753_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1753));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1753_tree);


            OIDPOLCONST1754 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDPOLCONST, &FOLLOW_OIDPOLCONST_in_polconstraintsoid10858);
            if  (HASEXCEPTION())
            {
                goto rulepolconstraintsoidEx;
            }

            OIDPOLCONST1754_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDPOLCONST1754));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDPOLCONST1754_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2037207);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_policy_constraints);

                		printf("It's POLCONST");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepolconstraintsoidEx; /* Prevent compiler warnings */
    rulepolconstraintsoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end polconstraintsoid */

/**
 * $ANTLR start certpolioid
 * Grammar/RFC5280.g:4477:1: certpolioid returns [ASN1_OBJECT * obj] : OIDTag OIDCERTPOL ;
 */
static RFC5280Parser_certpolioid_return
certpolioid(pRFC5280Parser ctx)
{
    RFC5280Parser_certpolioid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1755;
    pANTLR3_COMMON_TOKEN    OIDCERTPOL1756;

    pANTLR3_BASE_TREE OIDTag1755_tree;
    pANTLR3_BASE_TREE OIDCERTPOL1756_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1755       = NULL;
    OIDCERTPOL1756       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1755_tree   = NULL;
    OIDCERTPOL1756_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4481:2: ( OIDTag OIDCERTPOL )
        // Grammar/RFC5280.g:4481:3: OIDTag OIDCERTPOL
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1755 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_certpolioid10881);
            if  (HASEXCEPTION())
            {
                goto rulecertpolioidEx;
            }

            OIDTag1755_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1755));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1755_tree);


            OIDCERTPOL1756 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDCERTPOL, &FOLLOW_OIDCERTPOL_in_certpolioid10883);
            if  (HASEXCEPTION())
            {
                goto rulecertpolioidEx;
            }

            OIDCERTPOL1756_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDCERTPOL1756));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDCERTPOL1756_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2029137);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_certificate_policies);

                		printf("It's CERTPOL");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecertpolioidEx; /* Prevent compiler warnings */
    rulecertpolioidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end certpolioid */

/**
 * $ANTLR start polmapoid
 * Grammar/RFC5280.g:4492:1: polmapoid returns [ASN1_OBJECT * obj] : OIDTag OIDPOLMAP ;
 */
static RFC5280Parser_polmapoid_return
polmapoid(pRFC5280Parser ctx)
{
    RFC5280Parser_polmapoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1757;
    pANTLR3_COMMON_TOKEN    OIDPOLMAP1758;

    pANTLR3_BASE_TREE OIDTag1757_tree;
    pANTLR3_BASE_TREE OIDPOLMAP1758_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1757       = NULL;
    OIDPOLMAP1758       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1757_tree   = NULL;
    OIDPOLMAP1758_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4496:2: ( OIDTag OIDPOLMAP )
        // Grammar/RFC5280.g:4496:3: OIDTag OIDPOLMAP
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1757 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_polmapoid10905);
            if  (HASEXCEPTION())
            {
                goto rulepolmapoidEx;
            }

            OIDTag1757_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1757));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1757_tree);


            OIDPOLMAP1758 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDPOLMAP, &FOLLOW_OIDPOLMAP_in_polmapoid10907);
            if  (HASEXCEPTION())
            {
                goto rulepolmapoidEx;
            }

            OIDPOLMAP1758_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDPOLMAP1758));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDPOLMAP1758_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2031153);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_policy_mappings);

                		printf("It's POLMAP");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepolmapoidEx; /* Prevent compiler warnings */
    rulepolmapoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end polmapoid */

/**
 * $ANTLR start keyusageoid
 * Grammar/RFC5280.g:4507:1: keyusageoid returns [ASN1_OBJECT * obj] : OIDTag OIDKEYUS ;
 */
static RFC5280Parser_keyusageoid_return
keyusageoid(pRFC5280Parser ctx)
{
    RFC5280Parser_keyusageoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1759;
    pANTLR3_COMMON_TOKEN    OIDKEYUS1760;

    pANTLR3_BASE_TREE OIDTag1759_tree;
    pANTLR3_BASE_TREE OIDKEYUS1760_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1759       = NULL;
    OIDKEYUS1760       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1759_tree   = NULL;
    OIDKEYUS1760_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4511:2: ( OIDTag OIDKEYUS )
        // Grammar/RFC5280.g:4511:3: OIDTag OIDKEYUS
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1759 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_keyusageoid10929);
            if  (HASEXCEPTION())
            {
                goto rulekeyusageoidEx;
            }

            OIDTag1759_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1759));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1759_tree);


            OIDKEYUS1760 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDKEYUS, &FOLLOW_OIDKEYUS_in_keyusageoid10931);
            if  (HASEXCEPTION())
            {
                goto rulekeyusageoidEx;
            }

            OIDKEYUS1760_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDKEYUS1760));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDKEYUS1760_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,1995018);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_key_usage);

                		printf("It's KEYUS");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeyusageoidEx; /* Prevent compiler warnings */
    rulekeyusageoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end keyusageoid */

/**
 * $ANTLR start subaltoid
 * Grammar/RFC5280.g:4522:1: subaltoid returns [ASN1_OBJECT * obj] : OIDTag OIDSUBALT ;
 */
static RFC5280Parser_subaltoid_return
subaltoid(pRFC5280Parser ctx)
{
    RFC5280Parser_subaltoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1761;
    pANTLR3_COMMON_TOKEN    OIDSUBALT1762;

    pANTLR3_BASE_TREE OIDTag1761_tree;
    pANTLR3_BASE_TREE OIDSUBALT1762_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1761       = NULL;
    OIDSUBALT1762       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1761_tree   = NULL;
    OIDSUBALT1762_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4526:2: ( OIDTag OIDSUBALT )
        // Grammar/RFC5280.g:4526:3: OIDTag OIDSUBALT
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1761 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_subaltoid10952);
            if  (HASEXCEPTION())
            {
                goto rulesubaltoidEx;
            }

            OIDTag1761_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1761));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1761_tree);


            OIDSUBALT1762 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDSUBALT, &FOLLOW_OIDSUBALT_in_subaltoid10954);
            if  (HASEXCEPTION())
            {
                goto rulesubaltoidEx;
            }

            OIDSUBALT1762_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDSUBALT1762));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDSUBALT1762_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,1999017);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_subject_alt_name);

                		printf("It's SUBALT");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubaltoidEx; /* Prevent compiler warnings */
    rulesubaltoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subaltoid */

/**
 * $ANTLR start issaltoid
 * Grammar/RFC5280.g:4538:1: issaltoid returns [ASN1_OBJECT * obj] : OIDTag OIDISSALT ;
 */
static RFC5280Parser_issaltoid_return
issaltoid(pRFC5280Parser ctx)
{
    RFC5280Parser_issaltoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1763;
    pANTLR3_COMMON_TOKEN    OIDISSALT1764;

    pANTLR3_BASE_TREE OIDTag1763_tree;
    pANTLR3_BASE_TREE OIDISSALT1764_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1763       = NULL;
    OIDISSALT1764       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1763_tree   = NULL;
    OIDISSALT1764_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4542:2: ( OIDTag OIDISSALT )
        // Grammar/RFC5280.g:4542:3: OIDTag OIDISSALT
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1763 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_issaltoid10978);
            if  (HASEXCEPTION())
            {
                goto ruleissaltoidEx;
            }

            OIDTag1763_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1763));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1763_tree);


            OIDISSALT1764 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDISSALT, &FOLLOW_OIDISSALT_in_issaltoid10980);
            if  (HASEXCEPTION())
            {
                goto ruleissaltoidEx;
            }

            OIDISSALT1764_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDISSALT1764));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDISSALT1764_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2001018);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_issuer_alt_name);

                		printf("It's ISSALT");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleissaltoidEx; /* Prevent compiler warnings */
    ruleissaltoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end issaltoid */

/**
 * $ANTLR start subdiroid
 * Grammar/RFC5280.g:4553:1: subdiroid returns [ASN1_OBJECT * obj] : OIDTag OIDSUBDIR ;
 */
static RFC5280Parser_subdiroid_return
subdiroid(pRFC5280Parser ctx)
{
    RFC5280Parser_subdiroid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1765;
    pANTLR3_COMMON_TOKEN    OIDSUBDIR1766;

    pANTLR3_BASE_TREE OIDTag1765_tree;
    pANTLR3_BASE_TREE OIDSUBDIR1766_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1765       = NULL;
    OIDSUBDIR1766       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1765_tree   = NULL;
    OIDSUBDIR1766_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4557:2: ( OIDTag OIDSUBDIR )
        // Grammar/RFC5280.g:4557:3: OIDTag OIDSUBDIR
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1765 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_subdiroid11001);
            if  (HASEXCEPTION())
            {
                goto rulesubdiroidEx;
            }

            OIDTag1765_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1765));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1765_tree);


            OIDSUBDIR1766 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDSUBDIR, &FOLLOW_OIDSUBDIR_in_subdiroid11003);
            if  (HASEXCEPTION())
            {
                goto rulesubdiroidEx;
            }

            OIDSUBDIR1766_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDSUBDIR1766));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDSUBDIR1766_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,1983045);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_subject_directory_attributes);

                		printf("It's SUBDIR");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesubdiroidEx; /* Prevent compiler warnings */
    rulesubdiroidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end subdiroid */

/**
 * $ANTLR start nameoid
 * Grammar/RFC5280.g:4568:1: nameoid returns [ASN1_OBJECT * obj] : OIDTag OIDNAME ;
 */
static RFC5280Parser_nameoid_return
nameoid(pRFC5280Parser ctx)
{
    RFC5280Parser_nameoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1767;
    pANTLR3_COMMON_TOKEN    OIDNAME1768;

    pANTLR3_BASE_TREE OIDTag1767_tree;
    pANTLR3_BASE_TREE OIDNAME1768_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1767       = NULL;
    OIDNAME1768       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1767_tree   = NULL;
    OIDNAME1768_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4571:2: ( OIDTag OIDNAME )
        // Grammar/RFC5280.g:4571:3: OIDTag OIDNAME
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1767 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_nameoid11023);
            if  (HASEXCEPTION())
            {
                goto rulenameoidEx;
            }

            OIDTag1767_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1767));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1767_tree);


            OIDNAME1768 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDNAME, &FOLLOW_OIDNAME_in_nameoid11025);
            if  (HASEXCEPTION())
            {
                goto rulenameoidEx;
            }

            OIDNAME1768_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDNAME1768));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDNAME1768_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2025108);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_name_constraints);

                		printf("It's NAMECONST");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenameoidEx; /* Prevent compiler warnings */
    rulenameoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end nameoid */

/**
 * $ANTLR start ekuoid
 * Grammar/RFC5280.g:4582:1: ekuoid returns [ASN1_OBJECT * obj] : OIDTag OIDEXTKEY ;
 */
static RFC5280Parser_ekuoid_return
ekuoid(pRFC5280Parser ctx)
{
    RFC5280Parser_ekuoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1769;
    pANTLR3_COMMON_TOKEN    OIDEXTKEY1770;

    pANTLR3_BASE_TREE OIDTag1769_tree;
    pANTLR3_BASE_TREE OIDEXTKEY1770_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1769       = NULL;
    OIDEXTKEY1770       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1769_tree   = NULL;
    OIDEXTKEY1770_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4586:2: ( OIDTag OIDEXTKEY )
        // Grammar/RFC5280.g:4586:3: OIDTag OIDEXTKEY
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1769 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_ekuoid11047);
            if  (HASEXCEPTION())
            {
                goto ruleekuoidEx;
            }

            OIDTag1769_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1769));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1769_tree);


            OIDEXTKEY1770 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDEXTKEY, &FOLLOW_OIDEXTKEY_in_ekuoid11049);
            if  (HASEXCEPTION())
            {
                goto ruleekuoidEx;
            }

            OIDEXTKEY1770_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDEXTKEY1770));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDEXTKEY1770_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2039227);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_ext_key_usage);

                		printf("It's EXTKEY");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleekuoidEx; /* Prevent compiler warnings */
    ruleekuoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ekuoid */

/**
 * $ANTLR start crldpoid
 * Grammar/RFC5280.g:4597:1: crldpoid returns [ASN1_OBJECT * obj] : OIDTag OIDCRL ;
 */
static RFC5280Parser_crldpoid_return
crldpoid(pRFC5280Parser ctx)
{
    RFC5280Parser_crldpoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1771;
    pANTLR3_COMMON_TOKEN    OIDCRL1772;

    pANTLR3_BASE_TREE OIDTag1771_tree;
    pANTLR3_BASE_TREE OIDCRL1772_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1771       = NULL;
    OIDCRL1772       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1771_tree   = NULL;
    OIDCRL1772_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4600:2: ( OIDTag OIDCRL )
        // Grammar/RFC5280.g:4600:3: OIDTag OIDCRL
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1771 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_crldpoid11069);
            if  (HASEXCEPTION())
            {
                goto rulecrldpoidEx;
            }

            OIDTag1771_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1771));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1771_tree);


            OIDCRL1772 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDCRL, &FOLLOW_OIDCRL_in_crldpoid11071);
            if  (HASEXCEPTION())
            {
                goto rulecrldpoidEx;
            }

            OIDCRL1772_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDCRL1772));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDCRL1772_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2027122);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_crl_distribution_points);

                		printf("It's CRLDP");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecrldpoidEx; /* Prevent compiler warnings */
    rulecrldpoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end crldpoid */

/**
 * $ANTLR start inhibitanyoid
 * Grammar/RFC5280.g:4611:1: inhibitanyoid returns [ASN1_OBJECT * obj] : OIDTag OIDINHIBIT ;
 */
static RFC5280Parser_inhibitanyoid_return
inhibitanyoid(pRFC5280Parser ctx)
{
    RFC5280Parser_inhibitanyoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1773;
    pANTLR3_COMMON_TOKEN    OIDINHIBIT1774;

    pANTLR3_BASE_TREE OIDTag1773_tree;
    pANTLR3_BASE_TREE OIDINHIBIT1774_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1773       = NULL;
    OIDINHIBIT1774       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1773_tree   = NULL;
    OIDINHIBIT1774_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4615:2: ( OIDTag OIDINHIBIT )
        // Grammar/RFC5280.g:4615:3: OIDTag OIDINHIBIT
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1773 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_inhibitanyoid11092);
            if  (HASEXCEPTION())
            {
                goto ruleinhibitanyoidEx;
            }

            OIDTag1773_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1773));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1773_tree);


            OIDINHIBIT1774 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDINHIBIT, &FOLLOW_OIDINHIBIT_in_inhibitanyoid11094);
            if  (HASEXCEPTION())
            {
                goto ruleinhibitanyoidEx;
            }

            OIDINHIBIT1774_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDINHIBIT1774));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDINHIBIT1774_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2073720);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_inhibit_any_policy);

                		printf("It's INHIBITANY");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinhibitanyoidEx; /* Prevent compiler warnings */
    ruleinhibitanyoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end inhibitanyoid */

/**
 * $ANTLR start freshcrloid
 * Grammar/RFC5280.g:4626:1: freshcrloid returns [ASN1_OBJECT *obj] : OIDTag OIDFRESHCRL ;
 */
static RFC5280Parser_freshcrloid_return
freshcrloid(pRFC5280Parser ctx)
{
    RFC5280Parser_freshcrloid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1775;
    pANTLR3_COMMON_TOKEN    OIDFRESHCRL1776;

    pANTLR3_BASE_TREE OIDTag1775_tree;
    pANTLR3_BASE_TREE OIDFRESHCRL1776_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1775       = NULL;
    OIDFRESHCRL1776       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1775_tree   = NULL;
    OIDFRESHCRL1776_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4630:2: ( OIDTag OIDFRESHCRL )
        // Grammar/RFC5280.g:4630:3: OIDTag OIDFRESHCRL
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1775 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_freshcrloid11116);
            if  (HASEXCEPTION())
            {
                goto rulefreshcrloidEx;
            }

            OIDTag1775_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1775));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1775_tree);


            OIDFRESHCRL1776 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDFRESHCRL, &FOLLOW_OIDFRESHCRL_in_freshcrloid11118);
            if  (HASEXCEPTION())
            {
                goto rulefreshcrloidEx;
            }

            OIDFRESHCRL1776_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDFRESHCRL1776));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDFRESHCRL1776_tree);


            {

                		entire_encoding(3);
                		mpz_t index;
                		mpz_init_set_ui(index,2057452);
                		insert_extension(index);
                		retval.obj= OBJ_nid2obj(NID_freshest_crl);

                		printf("It's INHIBITANY");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefreshcrloidEx; /* Prevent compiler warnings */
    rulefreshcrloidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end freshcrloid */

/**
 * $ANTLR start caissueroid
 * Grammar/RFC5280.g:4642:1: caissueroid returns [ASN1_OBJECT * obj] : OIDTag CAISSUEROID ;
 */
static RFC5280Parser_caissueroid_return
caissueroid(pRFC5280Parser ctx)
{
    RFC5280Parser_caissueroid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1777;
    pANTLR3_COMMON_TOKEN    CAISSUEROID1778;

    pANTLR3_BASE_TREE OIDTag1777_tree;
    pANTLR3_BASE_TREE CAISSUEROID1778_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1777       = NULL;
    CAISSUEROID1778       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1777_tree   = NULL;
    CAISSUEROID1778_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4646:2: ( OIDTag CAISSUEROID )
        // Grammar/RFC5280.g:4646:3: OIDTag CAISSUEROID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1777 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_caissueroid11141);
            if  (HASEXCEPTION())
            {
                goto rulecaissueroidEx;
            }

            OIDTag1777_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1777));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1777_tree);


            CAISSUEROID1778 = (pANTLR3_COMMON_TOKEN) MATCHT(CAISSUEROID, &FOLLOW_CAISSUEROID_in_caissueroid11143);
            if  (HASEXCEPTION())
            {
                goto rulecaissueroidEx;
            }

            CAISSUEROID1778_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CAISSUEROID1778));
            ADAPTOR->addChild(ADAPTOR, root_0, CAISSUEROID1778_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_ad_ca_issuers);

                		printf("It's CAISSUER");	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecaissueroidEx; /* Prevent compiler warnings */
    rulecaissueroidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end caissueroid */

/**
 * $ANTLR start ocspoid
 * Grammar/RFC5280.g:4657:1: ocspoid returns [ASN1_OBJECT * obj] : OIDTag OCSPOID ;
 */
static RFC5280Parser_ocspoid_return
ocspoid(pRFC5280Parser ctx)
{
    RFC5280Parser_ocspoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1779;
    pANTLR3_COMMON_TOKEN    OCSPOID1780;

    pANTLR3_BASE_TREE OIDTag1779_tree;
    pANTLR3_BASE_TREE OCSPOID1780_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1779       = NULL;
    OCSPOID1780       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1779_tree   = NULL;
    OCSPOID1780_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4660:2: ( OIDTag OCSPOID )
        // Grammar/RFC5280.g:4660:3: OIDTag OCSPOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1779 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_ocspoid11167);
            if  (HASEXCEPTION())
            {
                goto ruleocspoidEx;
            }

            OIDTag1779_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1779));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1779_tree);


            OCSPOID1780 = (pANTLR3_COMMON_TOKEN) MATCHT(OCSPOID, &FOLLOW_OCSPOID_in_ocspoid11169);
            if  (HASEXCEPTION())
            {
                goto ruleocspoidEx;
            }

            OCSPOID1780_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OCSPOID1780));
            ADAPTOR->addChild(ADAPTOR, root_0, OCSPOID1780_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_ad_OCSP);

                		printf("It's OCSP");	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleocspoidEx; /* Prevent compiler warnings */
    ruleocspoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ocspoid */

/**
 * $ANTLR start carepooid
 * Grammar/RFC5280.g:4668:1: carepooid returns [ASN1_OBJECT * obj] : OIDTag CAREPOOID ;
 */
static RFC5280Parser_carepooid_return
carepooid(pRFC5280Parser ctx)
{
    RFC5280Parser_carepooid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1781;
    pANTLR3_COMMON_TOKEN    CAREPOOID1782;

    pANTLR3_BASE_TREE OIDTag1781_tree;
    pANTLR3_BASE_TREE CAREPOOID1782_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1781       = NULL;
    CAREPOOID1782       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1781_tree   = NULL;
    CAREPOOID1782_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4671:2: ( OIDTag CAREPOOID )
        // Grammar/RFC5280.g:4671:3: OIDTag CAREPOOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1781 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_carepooid11189);
            if  (HASEXCEPTION())
            {
                goto rulecarepooidEx;
            }

            OIDTag1781_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1781));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1781_tree);


            CAREPOOID1782 = (pANTLR3_COMMON_TOKEN) MATCHT(CAREPOOID, &FOLLOW_CAREPOOID_in_carepooid11191);
            if  (HASEXCEPTION())
            {
                goto rulecarepooidEx;
            }

            CAREPOOID1782_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CAREPOOID1782));
            ADAPTOR->addChild(ADAPTOR, root_0, CAREPOOID1782_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_caRepository);

                		printf("It's OCSP");	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecarepooidEx; /* Prevent compiler warnings */
    rulecarepooidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end carepooid */

/**
 * $ANTLR start tspoid
 * Grammar/RFC5280.g:4679:1: tspoid returns [ASN1_OBJECT * obj] : OIDTag TSPOID ;
 */
static RFC5280Parser_tspoid_return
tspoid(pRFC5280Parser ctx)
{
    RFC5280Parser_tspoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1783;
    pANTLR3_COMMON_TOKEN    TSPOID1784;

    pANTLR3_BASE_TREE OIDTag1783_tree;
    pANTLR3_BASE_TREE TSPOID1784_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1783       = NULL;
    TSPOID1784       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1783_tree   = NULL;
    TSPOID1784_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4682:2: ( OIDTag TSPOID )
        // Grammar/RFC5280.g:4682:3: OIDTag TSPOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1783 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_tspoid11211);
            if  (HASEXCEPTION())
            {
                goto ruletspoidEx;
            }

            OIDTag1783_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1783));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1783_tree);


            TSPOID1784 = (pANTLR3_COMMON_TOKEN) MATCHT(TSPOID, &FOLLOW_TSPOID_in_tspoid11213);
            if  (HASEXCEPTION())
            {
                goto ruletspoidEx;
            }

            TSPOID1784_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TSPOID1784));
            ADAPTOR->addChild(ADAPTOR, root_0, TSPOID1784_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_ad_timeStamping);

                		printf("It's OCSP");	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletspoidEx; /* Prevent compiler warnings */
    ruletspoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tspoid */

/**
 * $ANTLR start cpsoid
 * Grammar/RFC5280.g:4690:1: cpsoid returns [ASN1_OBJECT * obj] : OIDTag CPSOID ;
 */
static RFC5280Parser_cpsoid_return
cpsoid(pRFC5280Parser ctx)
{
    RFC5280Parser_cpsoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1785;
    pANTLR3_COMMON_TOKEN    CPSOID1786;

    pANTLR3_BASE_TREE OIDTag1785_tree;
    pANTLR3_BASE_TREE CPSOID1786_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1785       = NULL;
    CPSOID1786       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1785_tree   = NULL;
    CPSOID1786_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4693:2: ( OIDTag CPSOID )
        // Grammar/RFC5280.g:4693:3: OIDTag CPSOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1785 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_cpsoid11234);
            if  (HASEXCEPTION())
            {
                goto rulecpsoidEx;
            }

            OIDTag1785_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1785));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1785_tree);


            CPSOID1786 = (pANTLR3_COMMON_TOKEN) MATCHT(CPSOID, &FOLLOW_CPSOID_in_cpsoid11236);
            if  (HASEXCEPTION())
            {
                goto rulecpsoidEx;
            }

            CPSOID1786_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CPSOID1786));
            ADAPTOR->addChild(ADAPTOR, root_0, CPSOID1786_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_id_qt_cps);

                		printf("It's CSP");	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecpsoidEx; /* Prevent compiler warnings */
    rulecpsoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end cpsoid */

/**
 * $ANTLR start unoticeoid
 * Grammar/RFC5280.g:4702:1: unoticeoid returns [ASN1_OBJECT * obj] : OIDTag UNOTICEOID ;
 */
static RFC5280Parser_unoticeoid_return
unoticeoid(pRFC5280Parser ctx)
{
    RFC5280Parser_unoticeoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1787;
    pANTLR3_COMMON_TOKEN    UNOTICEOID1788;

    pANTLR3_BASE_TREE OIDTag1787_tree;
    pANTLR3_BASE_TREE UNOTICEOID1788_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1787       = NULL;
    UNOTICEOID1788       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1787_tree   = NULL;
    UNOTICEOID1788_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4706:2: ( OIDTag UNOTICEOID )
        // Grammar/RFC5280.g:4706:3: OIDTag UNOTICEOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1787 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_unoticeoid11259);
            if  (HASEXCEPTION())
            {
                goto ruleunoticeoidEx;
            }

            OIDTag1787_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1787));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1787_tree);


            UNOTICEOID1788 = (pANTLR3_COMMON_TOKEN) MATCHT(UNOTICEOID, &FOLLOW_UNOTICEOID_in_unoticeoid11261);
            if  (HASEXCEPTION())
            {
                goto ruleunoticeoidEx;
            }

            UNOTICEOID1788_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, UNOTICEOID1788));
            ADAPTOR->addChild(ADAPTOR, root_0, UNOTICEOID1788_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_id_qt_unotice);

                		printf("It's UNOTICE");	
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunoticeoidEx; /* Prevent compiler warnings */
    ruleunoticeoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end unoticeoid */

/**
 * $ANTLR start oidname
 * Grammar/RFC5280.g:4715:1: oidname returns [ASN1_OBJECT * obj] : OIDTag NAMEOID ;
 */
static RFC5280Parser_oidname_return
oidname(pRFC5280Parser ctx)
{
    RFC5280Parser_oidname_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1789;
    pANTLR3_COMMON_TOKEN    NAMEOID1790;

    pANTLR3_BASE_TREE OIDTag1789_tree;
    pANTLR3_BASE_TREE NAMEOID1790_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1789       = NULL;
    NAMEOID1790       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1789_tree   = NULL;
    NAMEOID1790_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4719:2: ( OIDTag NAMEOID )
        // Grammar/RFC5280.g:4719:3: OIDTag NAMEOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1789 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_oidname11285);
            if  (HASEXCEPTION())
            {
                goto ruleoidnameEx;
            }

            OIDTag1789_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1789));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1789_tree);


            NAMEOID1790 = (pANTLR3_COMMON_TOKEN) MATCHT(NAMEOID, &FOLLOW_NAMEOID_in_oidname11287);
            if  (HASEXCEPTION())
            {
                goto ruleoidnameEx;
            }

            NAMEOID1790_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NAMEOID1790));
            ADAPTOR->addChild(ADAPTOR, root_0, NAMEOID1790_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_name);

                		printf("it's NAMEOID \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoidnameEx; /* Prevent compiler warnings */
    ruleoidnameEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end oidname */

/**
 * $ANTLR start surnameoid
 * Grammar/RFC5280.g:4726:1: surnameoid returns [ASN1_OBJECT * obj] : OIDTag SURNAMEOID ;
 */
static RFC5280Parser_surnameoid_return
surnameoid(pRFC5280Parser ctx)
{
    RFC5280Parser_surnameoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1791;
    pANTLR3_COMMON_TOKEN    SURNAMEOID1792;

    pANTLR3_BASE_TREE OIDTag1791_tree;
    pANTLR3_BASE_TREE SURNAMEOID1792_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1791       = NULL;
    SURNAMEOID1792       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1791_tree   = NULL;
    SURNAMEOID1792_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4730:2: ( OIDTag SURNAMEOID )
        // Grammar/RFC5280.g:4730:3: OIDTag SURNAMEOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1791 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_surnameoid11310);
            if  (HASEXCEPTION())
            {
                goto rulesurnameoidEx;
            }

            OIDTag1791_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1791));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1791_tree);


            SURNAMEOID1792 = (pANTLR3_COMMON_TOKEN) MATCHT(SURNAMEOID, &FOLLOW_SURNAMEOID_in_surnameoid11312);
            if  (HASEXCEPTION())
            {
                goto rulesurnameoidEx;
            }

            SURNAMEOID1792_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SURNAMEOID1792));
            ADAPTOR->addChild(ADAPTOR, root_0, SURNAMEOID1792_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_surname);

                		printf("it's SURNAME \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesurnameoidEx; /* Prevent compiler warnings */
    rulesurnameoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end surnameoid */

/**
 * $ANTLR start givenoid
 * Grammar/RFC5280.g:4737:1: givenoid returns [ASN1_OBJECT * obj] : OIDTag OIDGIVENAME ;
 */
static RFC5280Parser_givenoid_return
givenoid(pRFC5280Parser ctx)
{
    RFC5280Parser_givenoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1793;
    pANTLR3_COMMON_TOKEN    OIDGIVENAME1794;

    pANTLR3_BASE_TREE OIDTag1793_tree;
    pANTLR3_BASE_TREE OIDGIVENAME1794_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1793       = NULL;
    OIDGIVENAME1794       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1793_tree   = NULL;
    OIDGIVENAME1794_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4741:2: ( OIDTag OIDGIVENAME )
        // Grammar/RFC5280.g:4741:3: OIDTag OIDGIVENAME
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1793 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_givenoid11334);
            if  (HASEXCEPTION())
            {
                goto rulegivenoidEx;
            }

            OIDTag1793_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1793));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1793_tree);


            OIDGIVENAME1794 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDGIVENAME, &FOLLOW_OIDGIVENAME_in_givenoid11336);
            if  (HASEXCEPTION())
            {
                goto rulegivenoidEx;
            }

            OIDGIVENAME1794_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDGIVENAME1794));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDGIVENAME1794_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_givenName);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegivenoidEx; /* Prevent compiler warnings */
    rulegivenoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end givenoid */

/**
 * $ANTLR start initoid
 * Grammar/RFC5280.g:4748:1: initoid returns [ASN1_OBJECT * obj] : OIDTag OIDINIT ;
 */
static RFC5280Parser_initoid_return
initoid(pRFC5280Parser ctx)
{
    RFC5280Parser_initoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1795;
    pANTLR3_COMMON_TOKEN    OIDINIT1796;

    pANTLR3_BASE_TREE OIDTag1795_tree;
    pANTLR3_BASE_TREE OIDINIT1796_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1795       = NULL;
    OIDINIT1796       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1795_tree   = NULL;
    OIDINIT1796_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4751:2: ( OIDTag OIDINIT )
        // Grammar/RFC5280.g:4751:3: OIDTag OIDINIT
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1795 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_initoid11355);
            if  (HASEXCEPTION())
            {
                goto ruleinitoidEx;
            }

            OIDTag1795_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1795));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1795_tree);


            OIDINIT1796 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDINIT, &FOLLOW_OIDINIT_in_initoid11357);
            if  (HASEXCEPTION())
            {
                goto ruleinitoidEx;
            }

            OIDINIT1796_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDINIT1796));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDINIT1796_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_initials);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinitoidEx; /* Prevent compiler warnings */
    ruleinitoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end initoid */

/**
 * $ANTLR start genqualifieroid
 * Grammar/RFC5280.g:4758:1: genqualifieroid returns [ASN1_OBJECT * obj] : OIDTag OIDGENQUALIFIER ;
 */
static RFC5280Parser_genqualifieroid_return
genqualifieroid(pRFC5280Parser ctx)
{
    RFC5280Parser_genqualifieroid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1797;
    pANTLR3_COMMON_TOKEN    OIDGENQUALIFIER1798;

    pANTLR3_BASE_TREE OIDTag1797_tree;
    pANTLR3_BASE_TREE OIDGENQUALIFIER1798_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1797       = NULL;
    OIDGENQUALIFIER1798       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1797_tree   = NULL;
    OIDGENQUALIFIER1798_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4762:2: ( OIDTag OIDGENQUALIFIER )
        // Grammar/RFC5280.g:4762:3: OIDTag OIDGENQUALIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1797 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_genqualifieroid11379);
            if  (HASEXCEPTION())
            {
                goto rulegenqualifieroidEx;
            }

            OIDTag1797_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1797));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1797_tree);


            OIDGENQUALIFIER1798 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDGENQUALIFIER, &FOLLOW_OIDGENQUALIFIER_in_genqualifieroid11381);
            if  (HASEXCEPTION())
            {
                goto rulegenqualifieroidEx;
            }

            OIDGENQUALIFIER1798_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDGENQUALIFIER1798));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDGENQUALIFIER1798_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_generationQualifier);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegenqualifieroidEx; /* Prevent compiler warnings */
    rulegenqualifieroidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end genqualifieroid */

/**
 * $ANTLR start localoid
 * Grammar/RFC5280.g:4769:1: localoid returns [ASN1_OBJECT * obj] : OIDTag OIDLOCAL ;
 */
static RFC5280Parser_localoid_return
localoid(pRFC5280Parser ctx)
{
    RFC5280Parser_localoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1799;
    pANTLR3_COMMON_TOKEN    OIDLOCAL1800;

    pANTLR3_BASE_TREE OIDTag1799_tree;
    pANTLR3_BASE_TREE OIDLOCAL1800_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1799       = NULL;
    OIDLOCAL1800       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1799_tree   = NULL;
    OIDLOCAL1800_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4773:2: ( OIDTag OIDLOCAL )
        // Grammar/RFC5280.g:4773:3: OIDTag OIDLOCAL
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1799 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_localoid11403);
            if  (HASEXCEPTION())
            {
                goto rulelocaloidEx;
            }

            OIDTag1799_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1799));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1799_tree);


            OIDLOCAL1800 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDLOCAL, &FOLLOW_OIDLOCAL_in_localoid11405);
            if  (HASEXCEPTION())
            {
                goto rulelocaloidEx;
            }

            OIDLOCAL1800_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDLOCAL1800));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDLOCAL1800_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_localityName);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelocaloidEx; /* Prevent compiler warnings */
    rulelocaloidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end localoid */

/**
 * $ANTLR start sorpoid
 * Grammar/RFC5280.g:4780:1: sorpoid returns [ASN1_OBJECT * obj] : OIDTag OIDSORP ;
 */
static RFC5280Parser_sorpoid_return
sorpoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sorpoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1801;
    pANTLR3_COMMON_TOKEN    OIDSORP1802;

    pANTLR3_BASE_TREE OIDTag1801_tree;
    pANTLR3_BASE_TREE OIDSORP1802_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1801       = NULL;
    OIDSORP1802       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1801_tree   = NULL;
    OIDSORP1802_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4783:2: ( OIDTag OIDSORP )
        // Grammar/RFC5280.g:4783:3: OIDTag OIDSORP
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1801 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sorpoid11427);
            if  (HASEXCEPTION())
            {
                goto rulesorpoidEx;
            }

            OIDTag1801_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1801));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1801_tree);


            OIDSORP1802 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDSORP, &FOLLOW_OIDSORP_in_sorpoid11429);
            if  (HASEXCEPTION())
            {
                goto rulesorpoidEx;
            }

            OIDSORP1802_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDSORP1802));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDSORP1802_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_stateOrProvinceName);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesorpoidEx; /* Prevent compiler warnings */
    rulesorpoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sorpoid */

/**
 * $ANTLR start ouoid
 * Grammar/RFC5280.g:4790:1: ouoid returns [ASN1_OBJECT * obj] : OIDTag OIDOU ;
 */
static RFC5280Parser_ouoid_return
ouoid(pRFC5280Parser ctx)
{
    RFC5280Parser_ouoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1803;
    pANTLR3_COMMON_TOKEN    OIDOU1804;

    pANTLR3_BASE_TREE OIDTag1803_tree;
    pANTLR3_BASE_TREE OIDOU1804_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1803       = NULL;
    OIDOU1804       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1803_tree   = NULL;
    OIDOU1804_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4793:2: ( OIDTag OIDOU )
        // Grammar/RFC5280.g:4793:3: OIDTag OIDOU
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1803 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_ouoid11451);
            if  (HASEXCEPTION())
            {
                goto ruleouoidEx;
            }

            OIDTag1803_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1803));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1803_tree);


            OIDOU1804 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDOU, &FOLLOW_OIDOU_in_ouoid11453);
            if  (HASEXCEPTION())
            {
                goto ruleouoidEx;
            }

            OIDOU1804_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDOU1804));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDOU1804_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_organizationalUnitName);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleouoidEx; /* Prevent compiler warnings */
    ruleouoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ouoid */

/**
 * $ANTLR start titleoid
 * Grammar/RFC5280.g:4800:1: titleoid returns [ASN1_OBJECT * obj] : OIDTag OIDTITLE ;
 */
static RFC5280Parser_titleoid_return
titleoid(pRFC5280Parser ctx)
{
    RFC5280Parser_titleoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1805;
    pANTLR3_COMMON_TOKEN    OIDTITLE1806;

    pANTLR3_BASE_TREE OIDTag1805_tree;
    pANTLR3_BASE_TREE OIDTITLE1806_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1805       = NULL;
    OIDTITLE1806       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1805_tree   = NULL;
    OIDTITLE1806_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4804:2: ( OIDTag OIDTITLE )
        // Grammar/RFC5280.g:4804:3: OIDTag OIDTITLE
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1805 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_titleoid11473);
            if  (HASEXCEPTION())
            {
                goto ruletitleoidEx;
            }

            OIDTag1805_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1805));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1805_tree);


            OIDTITLE1806 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTITLE, &FOLLOW_OIDTITLE_in_titleoid11475);
            if  (HASEXCEPTION())
            {
                goto ruletitleoidEx;
            }

            OIDTITLE1806_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTITLE1806));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTITLE1806_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_title);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletitleoidEx; /* Prevent compiler warnings */
    ruletitleoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end titleoid */

/**
 * $ANTLR start dnoid
 * Grammar/RFC5280.g:4811:1: dnoid returns [ASN1_OBJECT * obj] : OIDTag OIDDNQUALIFIER ;
 */
static RFC5280Parser_dnoid_return
dnoid(pRFC5280Parser ctx)
{
    RFC5280Parser_dnoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1807;
    pANTLR3_COMMON_TOKEN    OIDDNQUALIFIER1808;

    pANTLR3_BASE_TREE OIDTag1807_tree;
    pANTLR3_BASE_TREE OIDDNQUALIFIER1808_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1807       = NULL;
    OIDDNQUALIFIER1808       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1807_tree   = NULL;
    OIDDNQUALIFIER1808_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4814:2: ( OIDTag OIDDNQUALIFIER )
        // Grammar/RFC5280.g:4814:3: OIDTag OIDDNQUALIFIER
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1807 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_dnoid11496);
            if  (HASEXCEPTION())
            {
                goto rulednoidEx;
            }

            OIDTag1807_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1807));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1807_tree);


            OIDDNQUALIFIER1808 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDDNQUALIFIER, &FOLLOW_OIDDNQUALIFIER_in_dnoid11498);
            if  (HASEXCEPTION())
            {
                goto rulednoidEx;
            }

            OIDDNQUALIFIER1808_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDDNQUALIFIER1808));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDDNQUALIFIER1808_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_dnQualifier);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulednoidEx; /* Prevent compiler warnings */
    rulednoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dnoid */

/**
 * $ANTLR start countryoid
 * Grammar/RFC5280.g:4821:1: countryoid returns [ASN1_OBJECT * obj] : OIDTag OIDCOUNTRY ;
 */
static RFC5280Parser_countryoid_return
countryoid(pRFC5280Parser ctx)
{
    RFC5280Parser_countryoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1809;
    pANTLR3_COMMON_TOKEN    OIDCOUNTRY1810;

    pANTLR3_BASE_TREE OIDTag1809_tree;
    pANTLR3_BASE_TREE OIDCOUNTRY1810_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1809       = NULL;
    OIDCOUNTRY1810       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1809_tree   = NULL;
    OIDCOUNTRY1810_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4825:2: ( OIDTag OIDCOUNTRY )
        // Grammar/RFC5280.g:4825:3: OIDTag OIDCOUNTRY
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1809 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_countryoid11520);
            if  (HASEXCEPTION())
            {
                goto rulecountryoidEx;
            }

            OIDTag1809_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1809));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1809_tree);


            OIDCOUNTRY1810 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDCOUNTRY, &FOLLOW_OIDCOUNTRY_in_countryoid11522);
            if  (HASEXCEPTION())
            {
                goto rulecountryoidEx;
            }

            OIDCOUNTRY1810_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDCOUNTRY1810));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDCOUNTRY1810_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_countryName);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecountryoidEx; /* Prevent compiler warnings */
    rulecountryoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end countryoid */

/**
 * $ANTLR start serialoid
 * Grammar/RFC5280.g:4832:1: serialoid returns [ASN1_OBJECT * obj] : OIDTag OIDSERIAL ;
 */
static RFC5280Parser_serialoid_return
serialoid(pRFC5280Parser ctx)
{
    RFC5280Parser_serialoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1811;
    pANTLR3_COMMON_TOKEN    OIDSERIAL1812;

    pANTLR3_BASE_TREE OIDTag1811_tree;
    pANTLR3_BASE_TREE OIDSERIAL1812_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1811       = NULL;
    OIDSERIAL1812       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1811_tree   = NULL;
    OIDSERIAL1812_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4836:2: ( OIDTag OIDSERIAL )
        // Grammar/RFC5280.g:4836:3: OIDTag OIDSERIAL
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1811 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_serialoid11544);
            if  (HASEXCEPTION())
            {
                goto ruleserialoidEx;
            }

            OIDTag1811_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1811));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1811_tree);


            OIDSERIAL1812 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDSERIAL, &FOLLOW_OIDSERIAL_in_serialoid11546);
            if  (HASEXCEPTION())
            {
                goto ruleserialoidEx;
            }

            OIDSERIAL1812_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDSERIAL1812));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDSERIAL1812_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_serialNumber);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleserialoidEx; /* Prevent compiler warnings */
    ruleserialoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end serialoid */

/**
 * $ANTLR start pseudooid
 * Grammar/RFC5280.g:4843:1: pseudooid returns [ASN1_OBJECT * obj] : OIDTag OIDPSEUDO ;
 */
static RFC5280Parser_pseudooid_return
pseudooid(pRFC5280Parser ctx)
{
    RFC5280Parser_pseudooid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1813;
    pANTLR3_COMMON_TOKEN    OIDPSEUDO1814;

    pANTLR3_BASE_TREE OIDTag1813_tree;
    pANTLR3_BASE_TREE OIDPSEUDO1814_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1813       = NULL;
    OIDPSEUDO1814       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1813_tree   = NULL;
    OIDPSEUDO1814_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4847:2: ( OIDTag OIDPSEUDO )
        // Grammar/RFC5280.g:4847:3: OIDTag OIDPSEUDO
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1813 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_pseudooid11568);
            if  (HASEXCEPTION())
            {
                goto rulepseudooidEx;
            }

            OIDTag1813_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1813));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1813_tree);


            OIDPSEUDO1814 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDPSEUDO, &FOLLOW_OIDPSEUDO_in_pseudooid11570);
            if  (HASEXCEPTION())
            {
                goto rulepseudooidEx;
            }

            OIDPSEUDO1814_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDPSEUDO1814));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDPSEUDO1814_tree);


            {

                		entire_encoding(3);
                		retval.obj= OBJ_nid2obj(NID_pseudonym);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepseudooidEx; /* Prevent compiler warnings */
    rulepseudooidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end pseudooid */

/**
 * $ANTLR start rsapkoid
 * Grammar/RFC5280.g:4854:1: rsapkoid returns [ASN1_OBJECT * obj] : OIDTag RSAPKOID ;
 */
static RFC5280Parser_rsapkoid_return
rsapkoid(pRFC5280Parser ctx)
{
    RFC5280Parser_rsapkoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1815;
    pANTLR3_COMMON_TOKEN    RSAPKOID1816;

    pANTLR3_BASE_TREE OIDTag1815_tree;
    pANTLR3_BASE_TREE RSAPKOID1816_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1815       = NULL;
    RSAPKOID1816       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1815_tree   = NULL;
    RSAPKOID1816_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4858:2: ( OIDTag RSAPKOID )
        // Grammar/RFC5280.g:4858:3: OIDTag RSAPKOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1815 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_rsapkoid11592);
            if  (HASEXCEPTION())
            {
                goto rulersapkoidEx;
            }

            OIDTag1815_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1815));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1815_tree);


            RSAPKOID1816 = (pANTLR3_COMMON_TOKEN) MATCHT(RSAPKOID, &FOLLOW_RSAPKOID_in_rsapkoid11594);
            if  (HASEXCEPTION())
            {
                goto rulersapkoidEx;
            }

            RSAPKOID1816_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, RSAPKOID1816));
            ADAPTOR->addChild(ADAPTOR, root_0, RSAPKOID1816_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_rsaEncryption);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersapkoidEx; /* Prevent compiler warnings */
    rulersapkoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsapkoid */

/**
 * $ANTLR start dsapkoid
 * Grammar/RFC5280.g:4865:1: dsapkoid returns [ASN1_OBJECT * obj] : OIDTag DSAPKOID ;
 */
static RFC5280Parser_dsapkoid_return
dsapkoid(pRFC5280Parser ctx)
{
    RFC5280Parser_dsapkoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1817;
    pANTLR3_COMMON_TOKEN    DSAPKOID1818;

    pANTLR3_BASE_TREE OIDTag1817_tree;
    pANTLR3_BASE_TREE DSAPKOID1818_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1817       = NULL;
    DSAPKOID1818       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1817_tree   = NULL;
    DSAPKOID1818_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4869:2: ( OIDTag DSAPKOID )
        // Grammar/RFC5280.g:4869:3: OIDTag DSAPKOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1817 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_dsapkoid11616);
            if  (HASEXCEPTION())
            {
                goto ruledsapkoidEx;
            }

            OIDTag1817_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1817));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1817_tree);


            DSAPKOID1818 = (pANTLR3_COMMON_TOKEN) MATCHT(DSAPKOID, &FOLLOW_DSAPKOID_in_dsapkoid11618);
            if  (HASEXCEPTION())
            {
                goto ruledsapkoidEx;
            }

            DSAPKOID1818_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DSAPKOID1818));
            ADAPTOR->addChild(ADAPTOR, root_0, DSAPKOID1818_tree);


            {

                		entire_encoding(7);
                		retval.obj= OBJ_nid2obj(NID_dsa);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledsapkoidEx; /* Prevent compiler warnings */
    ruledsapkoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dsapkoid */

/**
 * $ANTLR start dhpkoid
 * Grammar/RFC5280.g:4876:1: dhpkoid returns [ASN1_OBJECT * obj] : OIDTag DHPKOID ;
 */
static RFC5280Parser_dhpkoid_return
dhpkoid(pRFC5280Parser ctx)
{
    RFC5280Parser_dhpkoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1819;
    pANTLR3_COMMON_TOKEN    DHPKOID1820;

    pANTLR3_BASE_TREE OIDTag1819_tree;
    pANTLR3_BASE_TREE DHPKOID1820_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1819       = NULL;
    DHPKOID1820       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1819_tree   = NULL;
    DHPKOID1820_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4880:2: ( OIDTag DHPKOID )
        // Grammar/RFC5280.g:4880:3: OIDTag DHPKOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1819 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_dhpkoid11641);
            if  (HASEXCEPTION())
            {
                goto ruledhpkoidEx;
            }

            OIDTag1819_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1819));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1819_tree);


            DHPKOID1820 = (pANTLR3_COMMON_TOKEN) MATCHT(DHPKOID, &FOLLOW_DHPKOID_in_dhpkoid11643);
            if  (HASEXCEPTION())
            {
                goto ruledhpkoidEx;
            }

            DHPKOID1820_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DHPKOID1820));
            ADAPTOR->addChild(ADAPTOR, root_0, DHPKOID1820_tree);


            {

                		entire_encoding(7);
                		retval.obj= OBJ_nid2obj(NID_dhpublicnumber);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruledhpkoidEx; /* Prevent compiler warnings */
    ruledhpkoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end dhpkoid */

/**
 * $ANTLR start keapkoid
 * Grammar/RFC5280.g:4887:1: keapkoid returns [ASN1_OBJECT * obj] : OIDTag KEAPKOID ;
 */
static RFC5280Parser_keapkoid_return
keapkoid(pRFC5280Parser ctx)
{
    RFC5280Parser_keapkoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1821;
    pANTLR3_COMMON_TOKEN    KEAPKOID1822;

    pANTLR3_BASE_TREE OIDTag1821_tree;
    pANTLR3_BASE_TREE KEAPKOID1822_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1821       = NULL;
    KEAPKOID1822       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1821_tree   = NULL;
    KEAPKOID1822_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4891:2: ( OIDTag KEAPKOID )
        // Grammar/RFC5280.g:4891:3: OIDTag KEAPKOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1821 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_keapkoid11665);
            if  (HASEXCEPTION())
            {
                goto rulekeapkoidEx;
            }

            OIDTag1821_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1821));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1821_tree);


            KEAPKOID1822 = (pANTLR3_COMMON_TOKEN) MATCHT(KEAPKOID, &FOLLOW_KEAPKOID_in_keapkoid11667);
            if  (HASEXCEPTION())
            {
                goto rulekeapkoidEx;
            }

            KEAPKOID1822_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, KEAPKOID1822));
            ADAPTOR->addChild(ADAPTOR, root_0, KEAPKOID1822_tree);


            {

                		entire_encoding(9);
                		int new_nid = OBJ_txt2nid("2.16.840.1.101.2.1.1.22");
                		if(new_nid == NID_undef)
                			new_nid = OBJ_create("2.16.840.1.101.2.1.1.22","KEA","key_exchange_algorithm");
                		retval.obj= OBJ_nid2obj(new_nid);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekeapkoidEx; /* Prevent compiler warnings */
    rulekeapkoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end keapkoid */

/**
 * $ANTLR start ecpkoid
 * Grammar/RFC5280.g:4901:1: ecpkoid returns [ASN1_OBJECT * obj] : OIDTag ECPKOID ;
 */
static RFC5280Parser_ecpkoid_return
ecpkoid(pRFC5280Parser ctx)
{
    RFC5280Parser_ecpkoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1823;
    pANTLR3_COMMON_TOKEN    ECPKOID1824;

    pANTLR3_BASE_TREE OIDTag1823_tree;
    pANTLR3_BASE_TREE ECPKOID1824_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1823       = NULL;
    ECPKOID1824       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1823_tree   = NULL;
    ECPKOID1824_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4905:2: ( OIDTag ECPKOID )
        // Grammar/RFC5280.g:4905:3: OIDTag ECPKOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1823 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_ecpkoid11689);
            if  (HASEXCEPTION())
            {
                goto ruleecpkoidEx;
            }

            OIDTag1823_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1823));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1823_tree);


            ECPKOID1824 = (pANTLR3_COMMON_TOKEN) MATCHT(ECPKOID, &FOLLOW_ECPKOID_in_ecpkoid11691);
            if  (HASEXCEPTION())
            {
                goto ruleecpkoidEx;
            }

            ECPKOID1824_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ECPKOID1824));
            ADAPTOR->addChild(ADAPTOR, root_0, ECPKOID1824_tree);


            {

                		entire_encoding(7);
                		retval.obj= OBJ_nid2obj(NID_X9_62_id_ecPublicKey);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleecpkoidEx; /* Prevent compiler warnings */
    ruleecpkoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ecpkoid */

/**
 * $ANTLR start primeoid
 * Grammar/RFC5280.g:4913:1: primeoid returns [ASN1_OBJECT * obj] : OIDTag PRIMEOID ;
 */
static RFC5280Parser_primeoid_return
primeoid(pRFC5280Parser ctx)
{
    RFC5280Parser_primeoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1825;
    pANTLR3_COMMON_TOKEN    PRIMEOID1826;

    pANTLR3_BASE_TREE OIDTag1825_tree;
    pANTLR3_BASE_TREE PRIMEOID1826_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1825       = NULL;
    PRIMEOID1826       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1825_tree   = NULL;
    PRIMEOID1826_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4917:2: ( OIDTag PRIMEOID )
        // Grammar/RFC5280.g:4917:3: OIDTag PRIMEOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1825 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_primeoid11715);
            if  (HASEXCEPTION())
            {
                goto ruleprimeoidEx;
            }

            OIDTag1825_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1825));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1825_tree);


            PRIMEOID1826 = (pANTLR3_COMMON_TOKEN) MATCHT(PRIMEOID, &FOLLOW_PRIMEOID_in_primeoid11717);
            if  (HASEXCEPTION())
            {
                goto ruleprimeoidEx;
            }

            PRIMEOID1826_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PRIMEOID1826));
            ADAPTOR->addChild(ADAPTOR, root_0, PRIMEOID1826_tree);


            {

                		entire_encoding(7);
                		retval.obj= OBJ_nid2obj(NID_X9_62_prime_field);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprimeoidEx; /* Prevent compiler warnings */
    ruleprimeoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end primeoid */

/**
 * $ANTLR start basis2oid
 * Grammar/RFC5280.g:4925:1: basis2oid returns [ASN1_OBJECT * obj] : OIDTag BASIS2OID ;
 */
static RFC5280Parser_basis2oid_return
basis2oid(pRFC5280Parser ctx)
{
    RFC5280Parser_basis2oid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1827;
    pANTLR3_COMMON_TOKEN    BASIS2OID1828;

    pANTLR3_BASE_TREE OIDTag1827_tree;
    pANTLR3_BASE_TREE BASIS2OID1828_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1827       = NULL;
    BASIS2OID1828       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1827_tree   = NULL;
    BASIS2OID1828_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4929:2: ( OIDTag BASIS2OID )
        // Grammar/RFC5280.g:4929:3: OIDTag BASIS2OID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1827 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_basis2oid11740);
            if  (HASEXCEPTION())
            {
                goto rulebasis2oidEx;
            }

            OIDTag1827_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1827));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1827_tree);


            BASIS2OID1828 = (pANTLR3_COMMON_TOKEN) MATCHT(BASIS2OID, &FOLLOW_BASIS2OID_in_basis2oid11742);
            if  (HASEXCEPTION())
            {
                goto rulebasis2oidEx;
            }

            BASIS2OID1828_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BASIS2OID1828));
            ADAPTOR->addChild(ADAPTOR, root_0, BASIS2OID1828_tree);


            {

                		entire_encoding(7);
                		retval.obj= OBJ_nid2obj(NID_X9_62_characteristic_two_field);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebasis2oidEx; /* Prevent compiler warnings */
    rulebasis2oidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end basis2oid */

/**
 * $ANTLR start gnoid
 * Grammar/RFC5280.g:4937:1: gnoid returns [ASN1_OBJECT * obj] : OIDTag GNBASISOID ;
 */
static RFC5280Parser_gnoid_return
gnoid(pRFC5280Parser ctx)
{
    RFC5280Parser_gnoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1829;
    pANTLR3_COMMON_TOKEN    GNBASISOID1830;

    pANTLR3_BASE_TREE OIDTag1829_tree;
    pANTLR3_BASE_TREE GNBASISOID1830_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1829       = NULL;
    GNBASISOID1830       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1829_tree   = NULL;
    GNBASISOID1830_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4941:2: ( OIDTag GNBASISOID )
        // Grammar/RFC5280.g:4941:3: OIDTag GNBASISOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1829 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_gnoid11765);
            if  (HASEXCEPTION())
            {
                goto rulegnoidEx;
            }

            OIDTag1829_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1829));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1829_tree);


            GNBASISOID1830 = (pANTLR3_COMMON_TOKEN) MATCHT(GNBASISOID, &FOLLOW_GNBASISOID_in_gnoid11767);
            if  (HASEXCEPTION())
            {
                goto rulegnoidEx;
            }

            GNBASISOID1830_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GNBASISOID1830));
            ADAPTOR->addChild(ADAPTOR, root_0, GNBASISOID1830_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_X9_62_onBasis);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegnoidEx; /* Prevent compiler warnings */
    rulegnoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end gnoid */

/**
 * $ANTLR start tpoid
 * Grammar/RFC5280.g:4948:1: tpoid returns [ASN1_OBJECT * obj] : OIDTag TPBASISOID ;
 */
static RFC5280Parser_tpoid_return
tpoid(pRFC5280Parser ctx)
{
    RFC5280Parser_tpoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1831;
    pANTLR3_COMMON_TOKEN    TPBASISOID1832;

    pANTLR3_BASE_TREE OIDTag1831_tree;
    pANTLR3_BASE_TREE TPBASISOID1832_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1831       = NULL;
    TPBASISOID1832       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1831_tree   = NULL;
    TPBASISOID1832_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4952:2: ( OIDTag TPBASISOID )
        // Grammar/RFC5280.g:4952:3: OIDTag TPBASISOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1831 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_tpoid11787);
            if  (HASEXCEPTION())
            {
                goto ruletpoidEx;
            }

            OIDTag1831_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1831));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1831_tree);


            TPBASISOID1832 = (pANTLR3_COMMON_TOKEN) MATCHT(TPBASISOID, &FOLLOW_TPBASISOID_in_tpoid11789);
            if  (HASEXCEPTION())
            {
                goto ruletpoidEx;
            }

            TPBASISOID1832_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TPBASISOID1832));
            ADAPTOR->addChild(ADAPTOR, root_0, TPBASISOID1832_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_X9_62_tpBasis);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletpoidEx; /* Prevent compiler warnings */
    ruletpoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tpoid */

/**
 * $ANTLR start ppoid
 * Grammar/RFC5280.g:4959:1: ppoid returns [ASN1_OBJECT * obj] : OIDTag PPBASISOID ;
 */
static RFC5280Parser_ppoid_return
ppoid(pRFC5280Parser ctx)
{
    RFC5280Parser_ppoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1833;
    pANTLR3_COMMON_TOKEN    PPBASISOID1834;

    pANTLR3_BASE_TREE OIDTag1833_tree;
    pANTLR3_BASE_TREE PPBASISOID1834_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1833       = NULL;
    PPBASISOID1834       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1833_tree   = NULL;
    PPBASISOID1834_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4963:2: ( OIDTag PPBASISOID )
        // Grammar/RFC5280.g:4963:3: OIDTag PPBASISOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1833 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_ppoid11809);
            if  (HASEXCEPTION())
            {
                goto ruleppoidEx;
            }

            OIDTag1833_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1833));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1833_tree);


            PPBASISOID1834 = (pANTLR3_COMMON_TOKEN) MATCHT(PPBASISOID, &FOLLOW_PPBASISOID_in_ppoid11811);
            if  (HASEXCEPTION())
            {
                goto ruleppoidEx;
            }

            PPBASISOID1834_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PPBASISOID1834));
            ADAPTOR->addChild(ADAPTOR, root_0, PPBASISOID1834_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_X9_62_ppBasis);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleppoidEx; /* Prevent compiler warnings */
    ruleppoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ppoid */

/**
 * $ANTLR start sha1oid
 * Grammar/RFC5280.g:4971:1: sha1oid returns [ASN1_OBJECT * obj] : OIDTag SHA1OID ;
 */
static RFC5280Parser_sha1oid_return
sha1oid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha1oid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1835;
    pANTLR3_COMMON_TOKEN    SHA1OID1836;

    pANTLR3_BASE_TREE OIDTag1835_tree;
    pANTLR3_BASE_TREE SHA1OID1836_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1835       = NULL;
    SHA1OID1836       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1835_tree   = NULL;
    SHA1OID1836_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4975:2: ( OIDTag SHA1OID )
        // Grammar/RFC5280.g:4975:3: OIDTag SHA1OID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1835 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha1oid11834);
            if  (HASEXCEPTION())
            {
                goto rulesha1oidEx;
            }

            OIDTag1835_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1835));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1835_tree);


            SHA1OID1836 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA1OID, &FOLLOW_SHA1OID_in_sha1oid11836);
            if  (HASEXCEPTION())
            {
                goto rulesha1oidEx;
            }

            SHA1OID1836_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA1OID1836));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA1OID1836_tree);


            {

                		entire_encoding(5);
                		retval.obj= OBJ_nid2obj(NID_sha1);

                		printf("it's SHA1 \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha1oidEx; /* Prevent compiler warnings */
    rulesha1oidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha1oid */

/**
 * $ANTLR start sha224oid
 * Grammar/RFC5280.g:4981:1: sha224oid returns [ASN1_OBJECT * obj] : OIDTag SHA224OID ;
 */
static RFC5280Parser_sha224oid_return
sha224oid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha224oid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1837;
    pANTLR3_COMMON_TOKEN    SHA224OID1838;

    pANTLR3_BASE_TREE OIDTag1837_tree;
    pANTLR3_BASE_TREE SHA224OID1838_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1837       = NULL;
    SHA224OID1838       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1837_tree   = NULL;
    SHA224OID1838_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4985:2: ( OIDTag SHA224OID )
        // Grammar/RFC5280.g:4985:3: OIDTag SHA224OID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1837 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha224oid11855);
            if  (HASEXCEPTION())
            {
                goto rulesha224oidEx;
            }

            OIDTag1837_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1837));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1837_tree);


            SHA224OID1838 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA224OID, &FOLLOW_SHA224OID_in_sha224oid11857);
            if  (HASEXCEPTION())
            {
                goto rulesha224oidEx;
            }

            SHA224OID1838_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA224OID1838));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA224OID1838_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_sha224);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha224oidEx; /* Prevent compiler warnings */
    rulesha224oidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha224oid */

/**
 * $ANTLR start sha256oid
 * Grammar/RFC5280.g:4992:1: sha256oid returns [ASN1_OBJECT * obj] : OIDTag SHA256OID ;
 */
static RFC5280Parser_sha256oid_return
sha256oid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha256oid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1839;
    pANTLR3_COMMON_TOKEN    SHA256OID1840;

    pANTLR3_BASE_TREE OIDTag1839_tree;
    pANTLR3_BASE_TREE SHA256OID1840_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1839       = NULL;
    SHA256OID1840       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1839_tree   = NULL;
    SHA256OID1840_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:4996:2: ( OIDTag SHA256OID )
        // Grammar/RFC5280.g:4996:3: OIDTag SHA256OID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1839 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha256oid11879);
            if  (HASEXCEPTION())
            {
                goto rulesha256oidEx;
            }

            OIDTag1839_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1839));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1839_tree);


            SHA256OID1840 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA256OID, &FOLLOW_SHA256OID_in_sha256oid11881);
            if  (HASEXCEPTION())
            {
                goto rulesha256oidEx;
            }

            SHA256OID1840_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA256OID1840));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA256OID1840_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_sha256);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha256oidEx; /* Prevent compiler warnings */
    rulesha256oidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha256oid */

/**
 * $ANTLR start sha384oid
 * Grammar/RFC5280.g:5003:1: sha384oid returns [ASN1_OBJECT * obj] : OIDTag SHA384OID ;
 */
static RFC5280Parser_sha384oid_return
sha384oid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha384oid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1841;
    pANTLR3_COMMON_TOKEN    SHA384OID1842;

    pANTLR3_BASE_TREE OIDTag1841_tree;
    pANTLR3_BASE_TREE SHA384OID1842_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1841       = NULL;
    SHA384OID1842       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1841_tree   = NULL;
    SHA384OID1842_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5007:2: ( OIDTag SHA384OID )
        // Grammar/RFC5280.g:5007:3: OIDTag SHA384OID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1841 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha384oid11901);
            if  (HASEXCEPTION())
            {
                goto rulesha384oidEx;
            }

            OIDTag1841_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1841));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1841_tree);


            SHA384OID1842 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA384OID, &FOLLOW_SHA384OID_in_sha384oid11903);
            if  (HASEXCEPTION())
            {
                goto rulesha384oidEx;
            }

            SHA384OID1842_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA384OID1842));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA384OID1842_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_sha384);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha384oidEx; /* Prevent compiler warnings */
    rulesha384oidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha384oid */

/**
 * $ANTLR start sha512oid
 * Grammar/RFC5280.g:5014:1: sha512oid returns [ASN1_OBJECT * obj] : OIDTag SHA512OID ;
 */
static RFC5280Parser_sha512oid_return
sha512oid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha512oid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1843;
    pANTLR3_COMMON_TOKEN    SHA512OID1844;

    pANTLR3_BASE_TREE OIDTag1843_tree;
    pANTLR3_BASE_TREE SHA512OID1844_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1843       = NULL;
    SHA512OID1844       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1843_tree   = NULL;
    SHA512OID1844_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5018:2: ( OIDTag SHA512OID )
        // Grammar/RFC5280.g:5018:3: OIDTag SHA512OID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1843 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha512oid11923);
            if  (HASEXCEPTION())
            {
                goto rulesha512oidEx;
            }

            OIDTag1843_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1843));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1843_tree);


            SHA512OID1844 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA512OID, &FOLLOW_SHA512OID_in_sha512oid11925);
            if  (HASEXCEPTION())
            {
                goto rulesha512oidEx;
            }

            SHA512OID1844_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA512OID1844));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA512OID1844_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_sha512);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha512oidEx; /* Prevent compiler warnings */
    rulesha512oidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha512oid */

/**
 * $ANTLR start mgf1oid
 * Grammar/RFC5280.g:5025:1: mgf1oid returns [ASN1_OBJECT * obj] : OIDTag MGF1OID ;
 */
static RFC5280Parser_mgf1oid_return
mgf1oid(pRFC5280Parser ctx)
{
    RFC5280Parser_mgf1oid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1845;
    pANTLR3_COMMON_TOKEN    MGF1OID1846;

    pANTLR3_BASE_TREE OIDTag1845_tree;
    pANTLR3_BASE_TREE MGF1OID1846_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1845       = NULL;
    MGF1OID1846       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1845_tree   = NULL;
    MGF1OID1846_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5029:2: ( OIDTag MGF1OID )
        // Grammar/RFC5280.g:5029:3: OIDTag MGF1OID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1845 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_mgf1oid11945);
            if  (HASEXCEPTION())
            {
                goto rulemgf1oidEx;
            }

            OIDTag1845_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1845));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1845_tree);


            MGF1OID1846 = (pANTLR3_COMMON_TOKEN) MATCHT(MGF1OID, &FOLLOW_MGF1OID_in_mgf1oid11947);
            if  (HASEXCEPTION())
            {
                goto rulemgf1oidEx;
            }

            MGF1OID1846_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, MGF1OID1846));
            ADAPTOR->addChild(ADAPTOR, root_0, MGF1OID1846_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_mgf1);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemgf1oidEx; /* Prevent compiler warnings */
    rulemgf1oidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end mgf1oid */

/**
 * $ANTLR start rsapssoid
 * Grammar/RFC5280.g:5036:1: rsapssoid returns [ASN1_OBJECT * obj] : OIDTag RSAPSSOID ;
 */
static RFC5280Parser_rsapssoid_return
rsapssoid(pRFC5280Parser ctx)
{
    RFC5280Parser_rsapssoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1847;
    pANTLR3_COMMON_TOKEN    RSAPSSOID1848;

    pANTLR3_BASE_TREE OIDTag1847_tree;
    pANTLR3_BASE_TREE RSAPSSOID1848_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1847       = NULL;
    RSAPSSOID1848       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1847_tree   = NULL;
    RSAPSSOID1848_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5040:2: ( OIDTag RSAPSSOID )
        // Grammar/RFC5280.g:5040:3: OIDTag RSAPSSOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1847 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_rsapssoid11967);
            if  (HASEXCEPTION())
            {
                goto rulersapssoidEx;
            }

            OIDTag1847_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1847));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1847_tree);


            RSAPSSOID1848 = (pANTLR3_COMMON_TOKEN) MATCHT(RSAPSSOID, &FOLLOW_RSAPSSOID_in_rsapssoid11969);
            if  (HASEXCEPTION())
            {
                goto rulersapssoidEx;
            }

            RSAPSSOID1848_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, RSAPSSOID1848));
            ADAPTOR->addChild(ADAPTOR, root_0, RSAPSSOID1848_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_rsassaPss);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersapssoidEx; /* Prevent compiler warnings */
    rulersapssoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsapssoid */

/**
 * $ANTLR start rsaoaepoid
 * Grammar/RFC5280.g:5047:1: rsaoaepoid returns [ASN1_OBJECT * obj] : OIDTag RSAOAEPOID ;
 */
static RFC5280Parser_rsaoaepoid_return
rsaoaepoid(pRFC5280Parser ctx)
{
    RFC5280Parser_rsaoaepoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1849;
    pANTLR3_COMMON_TOKEN    RSAOAEPOID1850;

    pANTLR3_BASE_TREE OIDTag1849_tree;
    pANTLR3_BASE_TREE RSAOAEPOID1850_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1849       = NULL;
    RSAOAEPOID1850       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1849_tree   = NULL;
    RSAOAEPOID1850_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5051:2: ( OIDTag RSAOAEPOID )
        // Grammar/RFC5280.g:5051:3: OIDTag RSAOAEPOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1849 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_rsaoaepoid11989);
            if  (HASEXCEPTION())
            {
                goto rulersaoaepoidEx;
            }

            OIDTag1849_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1849));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1849_tree);


            RSAOAEPOID1850 = (pANTLR3_COMMON_TOKEN) MATCHT(RSAOAEPOID, &FOLLOW_RSAOAEPOID_in_rsaoaepoid11991);
            if  (HASEXCEPTION())
            {
                goto rulersaoaepoidEx;
            }

            RSAOAEPOID1850_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, RSAOAEPOID1850));
            ADAPTOR->addChild(ADAPTOR, root_0, RSAOAEPOID1850_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_rsaesOaep);

                		printf("it's ON \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulersaoaepoidEx; /* Prevent compiler warnings */
    rulersaoaepoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end rsaoaepoid */

/**
 * $ANTLR start pspecoid
 * Grammar/RFC5280.g:5058:1: pspecoid returns [ASN1_OBJECT * obj] : OIDTag PSPECOID ;
 */
static RFC5280Parser_pspecoid_return
pspecoid(pRFC5280Parser ctx)
{
    RFC5280Parser_pspecoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1851;
    pANTLR3_COMMON_TOKEN    PSPECOID1852;

    pANTLR3_BASE_TREE OIDTag1851_tree;
    pANTLR3_BASE_TREE PSPECOID1852_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1851       = NULL;
    PSPECOID1852       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1851_tree   = NULL;
    PSPECOID1852_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5062:2: ( OIDTag PSPECOID )
        // Grammar/RFC5280.g:5062:3: OIDTag PSPECOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1851 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_pspecoid12013);
            if  (HASEXCEPTION())
            {
                goto rulepspecoidEx;
            }

            OIDTag1851_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1851));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1851_tree);


            PSPECOID1852 = (pANTLR3_COMMON_TOKEN) MATCHT(PSPECOID, &FOLLOW_PSPECOID_in_pspecoid12015);
            if  (HASEXCEPTION())
            {
                goto rulepspecoidEx;
            }

            PSPECOID1852_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PSPECOID1852));
            ADAPTOR->addChild(ADAPTOR, root_0, PSPECOID1852_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_pSpecified);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulepspecoidEx; /* Prevent compiler warnings */
    rulepspecoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end pspecoid */

/**
 * $ANTLR start md2rsaoid
 * Grammar/RFC5280.g:5070:1: md2rsaoid returns [ASN1_OBJECT * obj] : OIDTag MD2RSAOID ;
 */
static RFC5280Parser_md2rsaoid_return
md2rsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_md2rsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1853;
    pANTLR3_COMMON_TOKEN    MD2RSAOID1854;

    pANTLR3_BASE_TREE OIDTag1853_tree;
    pANTLR3_BASE_TREE MD2RSAOID1854_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1853       = NULL;
    MD2RSAOID1854       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1853_tree   = NULL;
    MD2RSAOID1854_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5074:2: ( OIDTag MD2RSAOID )
        // Grammar/RFC5280.g:5074:3: OIDTag MD2RSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1853 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_md2rsaoid12036);
            if  (HASEXCEPTION())
            {
                goto rulemd2rsaoidEx;
            }

            OIDTag1853_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1853));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1853_tree);


            MD2RSAOID1854 = (pANTLR3_COMMON_TOKEN) MATCHT(MD2RSAOID, &FOLLOW_MD2RSAOID_in_md2rsaoid12038);
            if  (HASEXCEPTION())
            {
                goto rulemd2rsaoidEx;
            }

            MD2RSAOID1854_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, MD2RSAOID1854));
            ADAPTOR->addChild(ADAPTOR, root_0, MD2RSAOID1854_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_md2WithRSAEncryption);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemd2rsaoidEx; /* Prevent compiler warnings */
    rulemd2rsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end md2rsaoid */

/**
 * $ANTLR start md5rsaoid
 * Grammar/RFC5280.g:5082:1: md5rsaoid returns [ASN1_OBJECT * obj] : OIDTag MD5RSAOID ;
 */
static RFC5280Parser_md5rsaoid_return
md5rsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_md5rsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1855;
    pANTLR3_COMMON_TOKEN    MD5RSAOID1856;

    pANTLR3_BASE_TREE OIDTag1855_tree;
    pANTLR3_BASE_TREE MD5RSAOID1856_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1855       = NULL;
    MD5RSAOID1856       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1855_tree   = NULL;
    MD5RSAOID1856_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5086:2: ( OIDTag MD5RSAOID )
        // Grammar/RFC5280.g:5086:3: OIDTag MD5RSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1855 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_md5rsaoid12059);
            if  (HASEXCEPTION())
            {
                goto rulemd5rsaoidEx;
            }

            OIDTag1855_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1855));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1855_tree);


            MD5RSAOID1856 = (pANTLR3_COMMON_TOKEN) MATCHT(MD5RSAOID, &FOLLOW_MD5RSAOID_in_md5rsaoid12061);
            if  (HASEXCEPTION())
            {
                goto rulemd5rsaoidEx;
            }

            MD5RSAOID1856_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, MD5RSAOID1856));
            ADAPTOR->addChild(ADAPTOR, root_0, MD5RSAOID1856_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_md5WithRSAEncryption);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemd5rsaoidEx; /* Prevent compiler warnings */
    rulemd5rsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end md5rsaoid */

/**
 * $ANTLR start sha1rsaoid
 * Grammar/RFC5280.g:5093:1: sha1rsaoid returns [ASN1_OBJECT * obj] : OIDTag SHA1RSAOID ;
 */
static RFC5280Parser_sha1rsaoid_return
sha1rsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha1rsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1857;
    pANTLR3_COMMON_TOKEN    SHA1RSAOID1858;

    pANTLR3_BASE_TREE OIDTag1857_tree;
    pANTLR3_BASE_TREE SHA1RSAOID1858_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1857       = NULL;
    SHA1RSAOID1858       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1857_tree   = NULL;
    SHA1RSAOID1858_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5097:2: ( OIDTag SHA1RSAOID )
        // Grammar/RFC5280.g:5097:3: OIDTag SHA1RSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1857 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha1rsaoid12081);
            if  (HASEXCEPTION())
            {
                goto rulesha1rsaoidEx;
            }

            OIDTag1857_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1857));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1857_tree);


            SHA1RSAOID1858 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA1RSAOID, &FOLLOW_SHA1RSAOID_in_sha1rsaoid12083);
            if  (HASEXCEPTION())
            {
                goto rulesha1rsaoidEx;
            }

            SHA1RSAOID1858_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA1RSAOID1858));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA1RSAOID1858_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_sha1WithRSAEncryption);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha1rsaoidEx; /* Prevent compiler warnings */
    rulesha1rsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha1rsaoid */

/**
 * $ANTLR start sha224rsaoid
 * Grammar/RFC5280.g:5105:1: sha224rsaoid returns [ASN1_OBJECT * obj] : OIDTag SHA224RSAOID ;
 */
static RFC5280Parser_sha224rsaoid_return
sha224rsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha224rsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1859;
    pANTLR3_COMMON_TOKEN    SHA224RSAOID1860;

    pANTLR3_BASE_TREE OIDTag1859_tree;
    pANTLR3_BASE_TREE SHA224RSAOID1860_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1859       = NULL;
    SHA224RSAOID1860       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1859_tree   = NULL;
    SHA224RSAOID1860_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5109:2: ( OIDTag SHA224RSAOID )
        // Grammar/RFC5280.g:5109:3: OIDTag SHA224RSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1859 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha224rsaoid12104);
            if  (HASEXCEPTION())
            {
                goto rulesha224rsaoidEx;
            }

            OIDTag1859_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1859));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1859_tree);


            SHA224RSAOID1860 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA224RSAOID, &FOLLOW_SHA224RSAOID_in_sha224rsaoid12106);
            if  (HASEXCEPTION())
            {
                goto rulesha224rsaoidEx;
            }

            SHA224RSAOID1860_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA224RSAOID1860));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA224RSAOID1860_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_sha224WithRSAEncryption);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha224rsaoidEx; /* Prevent compiler warnings */
    rulesha224rsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha224rsaoid */

/**
 * $ANTLR start sha256rsaoid
 * Grammar/RFC5280.g:5117:1: sha256rsaoid returns [ASN1_OBJECT * obj] : OIDTag SHA256RSAOID ;
 */
static RFC5280Parser_sha256rsaoid_return
sha256rsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha256rsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1861;
    pANTLR3_COMMON_TOKEN    SHA256RSAOID1862;

    pANTLR3_BASE_TREE OIDTag1861_tree;
    pANTLR3_BASE_TREE SHA256RSAOID1862_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1861       = NULL;
    SHA256RSAOID1862       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1861_tree   = NULL;
    SHA256RSAOID1862_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5121:2: ( OIDTag SHA256RSAOID )
        // Grammar/RFC5280.g:5121:3: OIDTag SHA256RSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1861 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha256rsaoid12127);
            if  (HASEXCEPTION())
            {
                goto rulesha256rsaoidEx;
            }

            OIDTag1861_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1861));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1861_tree);


            SHA256RSAOID1862 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA256RSAOID, &FOLLOW_SHA256RSAOID_in_sha256rsaoid12129);
            if  (HASEXCEPTION())
            {
                goto rulesha256rsaoidEx;
            }

            SHA256RSAOID1862_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA256RSAOID1862));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA256RSAOID1862_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_sha256WithRSAEncryption);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha256rsaoidEx; /* Prevent compiler warnings */
    rulesha256rsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha256rsaoid */

/**
 * $ANTLR start sha384rsaoid
 * Grammar/RFC5280.g:5129:1: sha384rsaoid returns [ASN1_OBJECT * obj] : OIDTag SHA384RSAOID ;
 */
static RFC5280Parser_sha384rsaoid_return
sha384rsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha384rsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1863;
    pANTLR3_COMMON_TOKEN    SHA384RSAOID1864;

    pANTLR3_BASE_TREE OIDTag1863_tree;
    pANTLR3_BASE_TREE SHA384RSAOID1864_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1863       = NULL;
    SHA384RSAOID1864       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1863_tree   = NULL;
    SHA384RSAOID1864_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5133:2: ( OIDTag SHA384RSAOID )
        // Grammar/RFC5280.g:5133:3: OIDTag SHA384RSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1863 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha384rsaoid12150);
            if  (HASEXCEPTION())
            {
                goto rulesha384rsaoidEx;
            }

            OIDTag1863_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1863));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1863_tree);


            SHA384RSAOID1864 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA384RSAOID, &FOLLOW_SHA384RSAOID_in_sha384rsaoid12152);
            if  (HASEXCEPTION())
            {
                goto rulesha384rsaoidEx;
            }

            SHA384RSAOID1864_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA384RSAOID1864));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA384RSAOID1864_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_sha384WithRSAEncryption);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha384rsaoidEx; /* Prevent compiler warnings */
    rulesha384rsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha384rsaoid */

/**
 * $ANTLR start sha512rsaoid
 * Grammar/RFC5280.g:5141:1: sha512rsaoid returns [ASN1_OBJECT * obj] : OIDTag SHA512RSAOID ;
 */
static RFC5280Parser_sha512rsaoid_return
sha512rsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha512rsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1865;
    pANTLR3_COMMON_TOKEN    SHA512RSAOID1866;

    pANTLR3_BASE_TREE OIDTag1865_tree;
    pANTLR3_BASE_TREE SHA512RSAOID1866_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1865       = NULL;
    SHA512RSAOID1866       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1865_tree   = NULL;
    SHA512RSAOID1866_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5145:2: ( OIDTag SHA512RSAOID )
        // Grammar/RFC5280.g:5145:3: OIDTag SHA512RSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1865 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha512rsaoid12173);
            if  (HASEXCEPTION())
            {
                goto rulesha512rsaoidEx;
            }

            OIDTag1865_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1865));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1865_tree);


            SHA512RSAOID1866 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA512RSAOID, &FOLLOW_SHA512RSAOID_in_sha512rsaoid12175);
            if  (HASEXCEPTION())
            {
                goto rulesha512rsaoidEx;
            }

            SHA512RSAOID1866_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA512RSAOID1866));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA512RSAOID1866_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_sha512WithRSAEncryption);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha512rsaoidEx; /* Prevent compiler warnings */
    rulesha512rsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha512rsaoid */

/**
 * $ANTLR start sha1dsaoid
 * Grammar/RFC5280.g:5151:1: sha1dsaoid returns [ASN1_OBJECT * obj] : OIDTag SHA1DSAOID ;
 */
static RFC5280Parser_sha1dsaoid_return
sha1dsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha1dsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1867;
    pANTLR3_COMMON_TOKEN    SHA1DSAOID1868;

    pANTLR3_BASE_TREE OIDTag1867_tree;
    pANTLR3_BASE_TREE SHA1DSAOID1868_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1867       = NULL;
    SHA1DSAOID1868       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1867_tree   = NULL;
    SHA1DSAOID1868_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5155:2: ( OIDTag SHA1DSAOID )
        // Grammar/RFC5280.g:5155:3: OIDTag SHA1DSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1867 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha1dsaoid12194);
            if  (HASEXCEPTION())
            {
                goto rulesha1dsaoidEx;
            }

            OIDTag1867_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1867));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1867_tree);


            SHA1DSAOID1868 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA1DSAOID, &FOLLOW_SHA1DSAOID_in_sha1dsaoid12196);
            if  (HASEXCEPTION())
            {
                goto rulesha1dsaoidEx;
            }

            SHA1DSAOID1868_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA1DSAOID1868));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA1DSAOID1868_tree);


            {

                		entire_encoding(7);
                		retval.obj= OBJ_nid2obj(NID_dsaWithSHA1);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha1dsaoidEx; /* Prevent compiler warnings */
    rulesha1dsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha1dsaoid */

/**
 * $ANTLR start sha224dsaoid
 * Grammar/RFC5280.g:5163:1: sha224dsaoid returns [ASN1_OBJECT * obj] : OIDTag SHA224DSAOID ;
 */
static RFC5280Parser_sha224dsaoid_return
sha224dsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha224dsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1869;
    pANTLR3_COMMON_TOKEN    SHA224DSAOID1870;

    pANTLR3_BASE_TREE OIDTag1869_tree;
    pANTLR3_BASE_TREE SHA224DSAOID1870_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1869       = NULL;
    SHA224DSAOID1870       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1869_tree   = NULL;
    SHA224DSAOID1870_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5167:2: ( OIDTag SHA224DSAOID )
        // Grammar/RFC5280.g:5167:3: OIDTag SHA224DSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1869 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha224dsaoid12219);
            if  (HASEXCEPTION())
            {
                goto rulesha224dsaoidEx;
            }

            OIDTag1869_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1869));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1869_tree);


            SHA224DSAOID1870 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA224DSAOID, &FOLLOW_SHA224DSAOID_in_sha224dsaoid12221);
            if  (HASEXCEPTION())
            {
                goto rulesha224dsaoidEx;
            }

            SHA224DSAOID1870_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA224DSAOID1870));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA224DSAOID1870_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_dsa_with_SHA224);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha224dsaoidEx; /* Prevent compiler warnings */
    rulesha224dsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha224dsaoid */

/**
 * $ANTLR start sha256dsaoid
 * Grammar/RFC5280.g:5175:1: sha256dsaoid returns [ASN1_OBJECT * obj] : OIDTag SHA256DSAOID ;
 */
static RFC5280Parser_sha256dsaoid_return
sha256dsaoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha256dsaoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1871;
    pANTLR3_COMMON_TOKEN    SHA256DSAOID1872;

    pANTLR3_BASE_TREE OIDTag1871_tree;
    pANTLR3_BASE_TREE SHA256DSAOID1872_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1871       = NULL;
    SHA256DSAOID1872       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1871_tree   = NULL;
    SHA256DSAOID1872_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5179:2: ( OIDTag SHA256DSAOID )
        // Grammar/RFC5280.g:5179:3: OIDTag SHA256DSAOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1871 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha256dsaoid12244);
            if  (HASEXCEPTION())
            {
                goto rulesha256dsaoidEx;
            }

            OIDTag1871_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1871));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1871_tree);


            SHA256DSAOID1872 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA256DSAOID, &FOLLOW_SHA256DSAOID_in_sha256dsaoid12246);
            if  (HASEXCEPTION())
            {
                goto rulesha256dsaoidEx;
            }

            SHA256DSAOID1872_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA256DSAOID1872));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA256DSAOID1872_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_dsa_with_SHA256);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha256dsaoidEx; /* Prevent compiler warnings */
    rulesha256dsaoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha256dsaoid */

/**
 * $ANTLR start sha1ecoid
 * Grammar/RFC5280.g:5186:1: sha1ecoid returns [ASN1_OBJECT * obj] : OIDTag SHA1ECOID ;
 */
static RFC5280Parser_sha1ecoid_return
sha1ecoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha1ecoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1873;
    pANTLR3_COMMON_TOKEN    SHA1ECOID1874;

    pANTLR3_BASE_TREE OIDTag1873_tree;
    pANTLR3_BASE_TREE SHA1ECOID1874_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1873       = NULL;
    SHA1ECOID1874       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1873_tree   = NULL;
    SHA1ECOID1874_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5190:2: ( OIDTag SHA1ECOID )
        // Grammar/RFC5280.g:5190:3: OIDTag SHA1ECOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1873 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha1ecoid12266);
            if  (HASEXCEPTION())
            {
                goto rulesha1ecoidEx;
            }

            OIDTag1873_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1873));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1873_tree);


            SHA1ECOID1874 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA1ECOID, &FOLLOW_SHA1ECOID_in_sha1ecoid12268);
            if  (HASEXCEPTION())
            {
                goto rulesha1ecoidEx;
            }

            SHA1ECOID1874_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA1ECOID1874));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA1ECOID1874_tree);


            {

                		entire_encoding(7);
                		retval.obj= OBJ_nid2obj(NID_ecdsa_with_SHA1);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha1ecoidEx; /* Prevent compiler warnings */
    rulesha1ecoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha1ecoid */

/**
 * $ANTLR start sha224ecoid
 * Grammar/RFC5280.g:5198:1: sha224ecoid returns [ASN1_OBJECT * obj] : OIDTag SHA224ECOID ;
 */
static RFC5280Parser_sha224ecoid_return
sha224ecoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha224ecoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1875;
    pANTLR3_COMMON_TOKEN    SHA224ECOID1876;

    pANTLR3_BASE_TREE OIDTag1875_tree;
    pANTLR3_BASE_TREE SHA224ECOID1876_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1875       = NULL;
    SHA224ECOID1876       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1875_tree   = NULL;
    SHA224ECOID1876_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5202:2: ( OIDTag SHA224ECOID )
        // Grammar/RFC5280.g:5202:3: OIDTag SHA224ECOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1875 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha224ecoid12289);
            if  (HASEXCEPTION())
            {
                goto rulesha224ecoidEx;
            }

            OIDTag1875_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1875));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1875_tree);


            SHA224ECOID1876 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA224ECOID, &FOLLOW_SHA224ECOID_in_sha224ecoid12291);
            if  (HASEXCEPTION())
            {
                goto rulesha224ecoidEx;
            }

            SHA224ECOID1876_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA224ECOID1876));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA224ECOID1876_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_ecdsa_with_SHA224);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha224ecoidEx; /* Prevent compiler warnings */
    rulesha224ecoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha224ecoid */

/**
 * $ANTLR start sha256ecoid
 * Grammar/RFC5280.g:5210:1: sha256ecoid returns [ASN1_OBJECT * obj] : OIDTag SHA256ECOID ;
 */
static RFC5280Parser_sha256ecoid_return
sha256ecoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha256ecoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1877;
    pANTLR3_COMMON_TOKEN    SHA256ECOID1878;

    pANTLR3_BASE_TREE OIDTag1877_tree;
    pANTLR3_BASE_TREE SHA256ECOID1878_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1877       = NULL;
    SHA256ECOID1878       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1877_tree   = NULL;
    SHA256ECOID1878_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5214:2: ( OIDTag SHA256ECOID )
        // Grammar/RFC5280.g:5214:3: OIDTag SHA256ECOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1877 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha256ecoid12312);
            if  (HASEXCEPTION())
            {
                goto rulesha256ecoidEx;
            }

            OIDTag1877_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1877));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1877_tree);


            SHA256ECOID1878 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA256ECOID, &FOLLOW_SHA256ECOID_in_sha256ecoid12314);
            if  (HASEXCEPTION())
            {
                goto rulesha256ecoidEx;
            }

            SHA256ECOID1878_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA256ECOID1878));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA256ECOID1878_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_ecdsa_with_SHA256);

                		printf("it's ECDSA SHA256 \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha256ecoidEx; /* Prevent compiler warnings */
    rulesha256ecoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha256ecoid */

/**
 * $ANTLR start sha384ecoid
 * Grammar/RFC5280.g:5221:1: sha384ecoid returns [ASN1_OBJECT * obj] : OIDTag SHA384ECOID ;
 */
static RFC5280Parser_sha384ecoid_return
sha384ecoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha384ecoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1879;
    pANTLR3_COMMON_TOKEN    SHA384ECOID1880;

    pANTLR3_BASE_TREE OIDTag1879_tree;
    pANTLR3_BASE_TREE SHA384ECOID1880_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1879       = NULL;
    SHA384ECOID1880       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1879_tree   = NULL;
    SHA384ECOID1880_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5225:2: ( OIDTag SHA384ECOID )
        // Grammar/RFC5280.g:5225:3: OIDTag SHA384ECOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1879 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha384ecoid12334);
            if  (HASEXCEPTION())
            {
                goto rulesha384ecoidEx;
            }

            OIDTag1879_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1879));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1879_tree);


            SHA384ECOID1880 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA384ECOID, &FOLLOW_SHA384ECOID_in_sha384ecoid12336);
            if  (HASEXCEPTION())
            {
                goto rulesha384ecoidEx;
            }

            SHA384ECOID1880_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA384ECOID1880));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA384ECOID1880_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_ecdsa_with_SHA384);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha384ecoidEx; /* Prevent compiler warnings */
    rulesha384ecoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha384ecoid */

/**
 * $ANTLR start sha512ecoid
 * Grammar/RFC5280.g:5232:1: sha512ecoid returns [ASN1_OBJECT * obj] : OIDTag SHA512ECOID ;
 */
static RFC5280Parser_sha512ecoid_return
sha512ecoid(pRFC5280Parser ctx)
{
    RFC5280Parser_sha512ecoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1881;
    pANTLR3_COMMON_TOKEN    SHA512ECOID1882;

    pANTLR3_BASE_TREE OIDTag1881_tree;
    pANTLR3_BASE_TREE SHA512ECOID1882_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1881       = NULL;
    SHA512ECOID1882       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1881_tree   = NULL;
    SHA512ECOID1882_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5236:2: ( OIDTag SHA512ECOID )
        // Grammar/RFC5280.g:5236:3: OIDTag SHA512ECOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1881 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_sha512ecoid12358);
            if  (HASEXCEPTION())
            {
                goto rulesha512ecoidEx;
            }

            OIDTag1881_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1881));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1881_tree);


            SHA512ECOID1882 = (pANTLR3_COMMON_TOKEN) MATCHT(SHA512ECOID, &FOLLOW_SHA512ECOID_in_sha512ecoid12360);
            if  (HASEXCEPTION())
            {
                goto rulesha512ecoidEx;
            }

            SHA512ECOID1882_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SHA512ECOID1882));
            ADAPTOR->addChild(ADAPTOR, root_0, SHA512ECOID1882_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_ecdsa_with_SHA512);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesha512ecoidEx; /* Prevent compiler warnings */
    rulesha512ecoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sha512ecoid */

/**
 * $ANTLR start gost94pkoid
 * Grammar/RFC5280.g:5244:1: gost94pkoid returns [ASN1_OBJECT * obj] : OIDTag GOST94PK ;
 */
static RFC5280Parser_gost94pkoid_return
gost94pkoid(pRFC5280Parser ctx)
{
    RFC5280Parser_gost94pkoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1883;
    pANTLR3_COMMON_TOKEN    GOST94PK1884;

    pANTLR3_BASE_TREE OIDTag1883_tree;
    pANTLR3_BASE_TREE GOST94PK1884_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1883       = NULL;
    GOST94PK1884       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1883_tree   = NULL;
    GOST94PK1884_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5248:2: ( OIDTag GOST94PK )
        // Grammar/RFC5280.g:5248:3: OIDTag GOST94PK
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1883 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_gost94pkoid12383);
            if  (HASEXCEPTION())
            {
                goto rulegost94pkoidEx;
            }

            OIDTag1883_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1883));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1883_tree);


            GOST94PK1884 = (pANTLR3_COMMON_TOKEN) MATCHT(GOST94PK, &FOLLOW_GOST94PK_in_gost94pkoid12385);
            if  (HASEXCEPTION())
            {
                goto rulegost94pkoidEx;
            }

            GOST94PK1884_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GOST94PK1884));
            ADAPTOR->addChild(ADAPTOR, root_0, GOST94PK1884_tree);


            {

                		entire_encoding(6);
                		retval.obj= OBJ_nid2obj(NID_id_GostR3410_94);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegost94pkoidEx; /* Prevent compiler warnings */
    rulegost94pkoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end gost94pkoid */

/**
 * $ANTLR start gost01pkoid
 * Grammar/RFC5280.g:5255:1: gost01pkoid returns [ASN1_OBJECT * obj] : OIDTag GOST01PK ;
 */
static RFC5280Parser_gost01pkoid_return
gost01pkoid(pRFC5280Parser ctx)
{
    RFC5280Parser_gost01pkoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1885;
    pANTLR3_COMMON_TOKEN    GOST01PK1886;

    pANTLR3_BASE_TREE OIDTag1885_tree;
    pANTLR3_BASE_TREE GOST01PK1886_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1885       = NULL;
    GOST01PK1886       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1885_tree   = NULL;
    GOST01PK1886_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5259:2: ( OIDTag GOST01PK )
        // Grammar/RFC5280.g:5259:3: OIDTag GOST01PK
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1885 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_gost01pkoid12407);
            if  (HASEXCEPTION())
            {
                goto rulegost01pkoidEx;
            }

            OIDTag1885_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1885));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1885_tree);


            GOST01PK1886 = (pANTLR3_COMMON_TOKEN) MATCHT(GOST01PK, &FOLLOW_GOST01PK_in_gost01pkoid12409);
            if  (HASEXCEPTION())
            {
                goto rulegost01pkoidEx;
            }

            GOST01PK1886_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GOST01PK1886));
            ADAPTOR->addChild(ADAPTOR, root_0, GOST01PK1886_tree);


            {

                		entire_encoding(6);
                		retval.obj= OBJ_nid2obj(NID_id_GostR3410_2001);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegost01pkoidEx; /* Prevent compiler warnings */
    rulegost01pkoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end gost01pkoid */

/**
 * $ANTLR start gost94signoid
 * Grammar/RFC5280.g:5266:1: gost94signoid returns [ASN1_OBJECT * obj] : OIDTag GOST94SIGN ;
 */
static RFC5280Parser_gost94signoid_return
gost94signoid(pRFC5280Parser ctx)
{
    RFC5280Parser_gost94signoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1887;
    pANTLR3_COMMON_TOKEN    GOST94SIGN1888;

    pANTLR3_BASE_TREE OIDTag1887_tree;
    pANTLR3_BASE_TREE GOST94SIGN1888_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1887       = NULL;
    GOST94SIGN1888       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1887_tree   = NULL;
    GOST94SIGN1888_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5270:2: ( OIDTag GOST94SIGN )
        // Grammar/RFC5280.g:5270:3: OIDTag GOST94SIGN
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1887 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_gost94signoid12429);
            if  (HASEXCEPTION())
            {
                goto rulegost94signoidEx;
            }

            OIDTag1887_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1887));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1887_tree);


            GOST94SIGN1888 = (pANTLR3_COMMON_TOKEN) MATCHT(GOST94SIGN, &FOLLOW_GOST94SIGN_in_gost94signoid12431);
            if  (HASEXCEPTION())
            {
                goto rulegost94signoidEx;
            }

            GOST94SIGN1888_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GOST94SIGN1888));
            ADAPTOR->addChild(ADAPTOR, root_0, GOST94SIGN1888_tree);


            {

                		entire_encoding(6);
                		retval.obj= OBJ_nid2obj(NID_id_GostR3411_94_with_GostR3410_94);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegost94signoidEx; /* Prevent compiler warnings */
    rulegost94signoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end gost94signoid */

/**
 * $ANTLR start gost01signoid
 * Grammar/RFC5280.g:5277:1: gost01signoid returns [ASN1_OBJECT * obj] : OIDTag GOST01SIGN ;
 */
static RFC5280Parser_gost01signoid_return
gost01signoid(pRFC5280Parser ctx)
{
    RFC5280Parser_gost01signoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1889;
    pANTLR3_COMMON_TOKEN    GOST01SIGN1890;

    pANTLR3_BASE_TREE OIDTag1889_tree;
    pANTLR3_BASE_TREE GOST01SIGN1890_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1889       = NULL;
    GOST01SIGN1890       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1889_tree   = NULL;
    GOST01SIGN1890_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5281:2: ( OIDTag GOST01SIGN )
        // Grammar/RFC5280.g:5281:3: OIDTag GOST01SIGN
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1889 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_gost01signoid12451);
            if  (HASEXCEPTION())
            {
                goto rulegost01signoidEx;
            }

            OIDTag1889_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1889));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1889_tree);


            GOST01SIGN1890 = (pANTLR3_COMMON_TOKEN) MATCHT(GOST01SIGN, &FOLLOW_GOST01SIGN_in_gost01signoid12453);
            if  (HASEXCEPTION())
            {
                goto rulegost01signoidEx;
            }

            GOST01SIGN1890_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GOST01SIGN1890));
            ADAPTOR->addChild(ADAPTOR, root_0, GOST01SIGN1890_tree);


            {

                		entire_encoding(6);
                		retval.obj= OBJ_nid2obj(NID_id_GostR3411_94_with_GostR3410_2001);

                		printf("it's PSPEC \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegost01signoidEx; /* Prevent compiler warnings */
    rulegost01signoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end gost01signoid */

/**
 * $ANTLR start serverauthoid
 * Grammar/RFC5280.g:5289:1: serverauthoid returns [ASN1_OBJECT * obj] : OIDTag SERVERAUTHOID ;
 */
static RFC5280Parser_serverauthoid_return
serverauthoid(pRFC5280Parser ctx)
{
    RFC5280Parser_serverauthoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1891;
    pANTLR3_COMMON_TOKEN    SERVERAUTHOID1892;

    pANTLR3_BASE_TREE OIDTag1891_tree;
    pANTLR3_BASE_TREE SERVERAUTHOID1892_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1891       = NULL;
    SERVERAUTHOID1892       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1891_tree   = NULL;
    SERVERAUTHOID1892_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5293:2: ( OIDTag SERVERAUTHOID )
        // Grammar/RFC5280.g:5293:3: OIDTag SERVERAUTHOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1891 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_serverauthoid12476);
            if  (HASEXCEPTION())
            {
                goto ruleserverauthoidEx;
            }

            OIDTag1891_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1891));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1891_tree);


            SERVERAUTHOID1892 = (pANTLR3_COMMON_TOKEN) MATCHT(SERVERAUTHOID, &FOLLOW_SERVERAUTHOID_in_serverauthoid12478);
            if  (HASEXCEPTION())
            {
                goto ruleserverauthoidEx;
            }

            SERVERAUTHOID1892_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SERVERAUTHOID1892));
            ADAPTOR->addChild(ADAPTOR, root_0, SERVERAUTHOID1892_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_server_auth);

                		printf("it's SERVERAUTHOID \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleserverauthoidEx; /* Prevent compiler warnings */
    ruleserverauthoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end serverauthoid */

/**
 * $ANTLR start clientauthoid
 * Grammar/RFC5280.g:5300:1: clientauthoid returns [ASN1_OBJECT * obj] : OIDTag CLIENTAUTHOID ;
 */
static RFC5280Parser_clientauthoid_return
clientauthoid(pRFC5280Parser ctx)
{
    RFC5280Parser_clientauthoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1893;
    pANTLR3_COMMON_TOKEN    CLIENTAUTHOID1894;

    pANTLR3_BASE_TREE OIDTag1893_tree;
    pANTLR3_BASE_TREE CLIENTAUTHOID1894_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1893       = NULL;
    CLIENTAUTHOID1894       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1893_tree   = NULL;
    CLIENTAUTHOID1894_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5304:2: ( OIDTag CLIENTAUTHOID )
        // Grammar/RFC5280.g:5304:3: OIDTag CLIENTAUTHOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1893 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_clientauthoid12498);
            if  (HASEXCEPTION())
            {
                goto ruleclientauthoidEx;
            }

            OIDTag1893_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1893));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1893_tree);


            CLIENTAUTHOID1894 = (pANTLR3_COMMON_TOKEN) MATCHT(CLIENTAUTHOID, &FOLLOW_CLIENTAUTHOID_in_clientauthoid12500);
            if  (HASEXCEPTION())
            {
                goto ruleclientauthoidEx;
            }

            CLIENTAUTHOID1894_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CLIENTAUTHOID1894));
            ADAPTOR->addChild(ADAPTOR, root_0, CLIENTAUTHOID1894_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_client_auth);

                		printf("it's CLIENTAUTHOID \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleclientauthoidEx; /* Prevent compiler warnings */
    ruleclientauthoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end clientauthoid */

/**
 * $ANTLR start codesignoid
 * Grammar/RFC5280.g:5311:1: codesignoid returns [ASN1_OBJECT * obj] : OIDTag CODESIGNOID ;
 */
static RFC5280Parser_codesignoid_return
codesignoid(pRFC5280Parser ctx)
{
    RFC5280Parser_codesignoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1895;
    pANTLR3_COMMON_TOKEN    CODESIGNOID1896;

    pANTLR3_BASE_TREE OIDTag1895_tree;
    pANTLR3_BASE_TREE CODESIGNOID1896_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1895       = NULL;
    CODESIGNOID1896       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1895_tree   = NULL;
    CODESIGNOID1896_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5315:2: ( OIDTag CODESIGNOID )
        // Grammar/RFC5280.g:5315:3: OIDTag CODESIGNOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1895 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_codesignoid12520);
            if  (HASEXCEPTION())
            {
                goto rulecodesignoidEx;
            }

            OIDTag1895_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1895));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1895_tree);


            CODESIGNOID1896 = (pANTLR3_COMMON_TOKEN) MATCHT(CODESIGNOID, &FOLLOW_CODESIGNOID_in_codesignoid12522);
            if  (HASEXCEPTION())
            {
                goto rulecodesignoidEx;
            }

            CODESIGNOID1896_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CODESIGNOID1896));
            ADAPTOR->addChild(ADAPTOR, root_0, CODESIGNOID1896_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_code_sign);

                		printf("it's CODESIGNOID \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulecodesignoidEx; /* Prevent compiler warnings */
    rulecodesignoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end codesignoid */

/**
 * $ANTLR start emailprotectoid
 * Grammar/RFC5280.g:5322:1: emailprotectoid returns [ASN1_OBJECT * obj] : OIDTag EMAILPROTECTOID ;
 */
static RFC5280Parser_emailprotectoid_return
emailprotectoid(pRFC5280Parser ctx)
{
    RFC5280Parser_emailprotectoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1897;
    pANTLR3_COMMON_TOKEN    EMAILPROTECTOID1898;

    pANTLR3_BASE_TREE OIDTag1897_tree;
    pANTLR3_BASE_TREE EMAILPROTECTOID1898_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1897       = NULL;
    EMAILPROTECTOID1898       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1897_tree   = NULL;
    EMAILPROTECTOID1898_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5326:2: ( OIDTag EMAILPROTECTOID )
        // Grammar/RFC5280.g:5326:3: OIDTag EMAILPROTECTOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1897 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_emailprotectoid12542);
            if  (HASEXCEPTION())
            {
                goto ruleemailprotectoidEx;
            }

            OIDTag1897_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1897));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1897_tree);


            EMAILPROTECTOID1898 = (pANTLR3_COMMON_TOKEN) MATCHT(EMAILPROTECTOID, &FOLLOW_EMAILPROTECTOID_in_emailprotectoid12544);
            if  (HASEXCEPTION())
            {
                goto ruleemailprotectoidEx;
            }

            EMAILPROTECTOID1898_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EMAILPROTECTOID1898));
            ADAPTOR->addChild(ADAPTOR, root_0, EMAILPROTECTOID1898_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_email_protect);

                		printf("it's EMAILPROTECTOID \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleemailprotectoidEx; /* Prevent compiler warnings */
    ruleemailprotectoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end emailprotectoid */

/**
 * $ANTLR start timestampoid
 * Grammar/RFC5280.g:5334:1: timestampoid returns [ASN1_OBJECT * obj] : OIDTag TIMESTAMPOID ;
 */
static RFC5280Parser_timestampoid_return
timestampoid(pRFC5280Parser ctx)
{
    RFC5280Parser_timestampoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1899;
    pANTLR3_COMMON_TOKEN    TIMESTAMPOID1900;

    pANTLR3_BASE_TREE OIDTag1899_tree;
    pANTLR3_BASE_TREE TIMESTAMPOID1900_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1899       = NULL;
    TIMESTAMPOID1900       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1899_tree   = NULL;
    TIMESTAMPOID1900_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5338:2: ( OIDTag TIMESTAMPOID )
        // Grammar/RFC5280.g:5338:3: OIDTag TIMESTAMPOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1899 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_timestampoid12567);
            if  (HASEXCEPTION())
            {
                goto ruletimestampoidEx;
            }

            OIDTag1899_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1899));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1899_tree);


            TIMESTAMPOID1900 = (pANTLR3_COMMON_TOKEN) MATCHT(TIMESTAMPOID, &FOLLOW_TIMESTAMPOID_in_timestampoid12569);
            if  (HASEXCEPTION())
            {
                goto ruletimestampoidEx;
            }

            TIMESTAMPOID1900_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TIMESTAMPOID1900));
            ADAPTOR->addChild(ADAPTOR, root_0, TIMESTAMPOID1900_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_time_stamp);

                		printf("it's TIMESTAMPOID \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletimestampoidEx; /* Prevent compiler warnings */
    ruletimestampoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end timestampoid */

/**
 * $ANTLR start ocspsignoid
 * Grammar/RFC5280.g:5345:1: ocspsignoid returns [ASN1_OBJECT * obj] : OIDTag OCSPSIGNOID ;
 */
static RFC5280Parser_ocspsignoid_return
ocspsignoid(pRFC5280Parser ctx)
{
    RFC5280Parser_ocspsignoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1901;
    pANTLR3_COMMON_TOKEN    OCSPSIGNOID1902;

    pANTLR3_BASE_TREE OIDTag1901_tree;
    pANTLR3_BASE_TREE OCSPSIGNOID1902_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1901       = NULL;
    OCSPSIGNOID1902       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1901_tree   = NULL;
    OCSPSIGNOID1902_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5349:2: ( OIDTag OCSPSIGNOID )
        // Grammar/RFC5280.g:5349:3: OIDTag OCSPSIGNOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1901 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_ocspsignoid12589);
            if  (HASEXCEPTION())
            {
                goto ruleocspsignoidEx;
            }

            OIDTag1901_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1901));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1901_tree);


            OCSPSIGNOID1902 = (pANTLR3_COMMON_TOKEN) MATCHT(OCSPSIGNOID, &FOLLOW_OCSPSIGNOID_in_ocspsignoid12591);
            if  (HASEXCEPTION())
            {
                goto ruleocspsignoidEx;
            }

            OCSPSIGNOID1902_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OCSPSIGNOID1902));
            ADAPTOR->addChild(ADAPTOR, root_0, OCSPSIGNOID1902_tree);


            {

                		entire_encoding(8);
                		retval.obj= OBJ_nid2obj(NID_OCSP_sign);

                		printf("it's OCSPSIGNOID \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleocspsignoidEx; /* Prevent compiler warnings */
    ruleocspsignoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ocspsignoid */

/**
 * $ANTLR start anyusageoid
 * Grammar/RFC5280.g:5357:1: anyusageoid returns [ASN1_OBJECT * obj] : OIDTag ANYUSAGEOID ;
 */
static RFC5280Parser_anyusageoid_return
anyusageoid(pRFC5280Parser ctx)
{
    RFC5280Parser_anyusageoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1903;
    pANTLR3_COMMON_TOKEN    ANYUSAGEOID1904;

    pANTLR3_BASE_TREE OIDTag1903_tree;
    pANTLR3_BASE_TREE ANYUSAGEOID1904_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1903       = NULL;
    ANYUSAGEOID1904       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1903_tree   = NULL;
    ANYUSAGEOID1904_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5361:2: ( OIDTag ANYUSAGEOID )
        // Grammar/RFC5280.g:5361:3: OIDTag ANYUSAGEOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1903 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_anyusageoid12615);
            if  (HASEXCEPTION())
            {
                goto ruleanyusageoidEx;
            }

            OIDTag1903_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1903));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1903_tree);


            ANYUSAGEOID1904 = (pANTLR3_COMMON_TOKEN) MATCHT(ANYUSAGEOID, &FOLLOW_ANYUSAGEOID_in_anyusageoid12617);
            if  (HASEXCEPTION())
            {
                goto ruleanyusageoidEx;
            }

            ANYUSAGEOID1904_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ANYUSAGEOID1904));
            ADAPTOR->addChild(ADAPTOR, root_0, ANYUSAGEOID1904_tree);


            {

                		entire_encoding(4);
                		retval.obj= OBJ_nid2obj(NID_anyExtendedKeyUsage);

                		printf("it's ANYUSAGEOID \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleanyusageoidEx; /* Prevent compiler warnings */
    ruleanyusageoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end anyusageoid */

/**
 * $ANTLR start anypolicyoid
 * Grammar/RFC5280.g:5368:1: anypolicyoid returns [ASN1_OBJECT * obj] : OIDTag ANYPOLICYOID ;
 */
static RFC5280Parser_anypolicyoid_return
anypolicyoid(pRFC5280Parser ctx)
{
    RFC5280Parser_anypolicyoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1905;
    pANTLR3_COMMON_TOKEN    ANYPOLICYOID1906;

    pANTLR3_BASE_TREE OIDTag1905_tree;
    pANTLR3_BASE_TREE ANYPOLICYOID1906_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1905       = NULL;
    ANYPOLICYOID1906       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1905_tree   = NULL;
    ANYPOLICYOID1906_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5372:2: ( OIDTag ANYPOLICYOID )
        // Grammar/RFC5280.g:5372:3: OIDTag ANYPOLICYOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1905 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_anypolicyoid12639);
            if  (HASEXCEPTION())
            {
                goto ruleanypolicyoidEx;
            }

            OIDTag1905_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1905));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1905_tree);


            ANYPOLICYOID1906 = (pANTLR3_COMMON_TOKEN) MATCHT(ANYPOLICYOID, &FOLLOW_ANYPOLICYOID_in_anypolicyoid12641);
            if  (HASEXCEPTION())
            {
                goto ruleanypolicyoidEx;
            }

            ANYPOLICYOID1906_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ANYPOLICYOID1906));
            ADAPTOR->addChild(ADAPTOR, root_0, ANYPOLICYOID1906_tree);


            {

                		entire_encoding(4);
                		retval.obj= OBJ_nid2obj(NID_any_policy);

                		printf("it's ANYPOLICYOID \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleanypolicyoidEx; /* Prevent compiler warnings */
    ruleanypolicyoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end anypolicyoid */

/**
 * $ANTLR start legacyemailoid
 * Grammar/RFC5280.g:5379:1: legacyemailoid returns [ASN1_OBJECT * obj] : OIDTag LEGACYEMAILOID ;
 */
static RFC5280Parser_legacyemailoid_return
legacyemailoid(pRFC5280Parser ctx)
{
    RFC5280Parser_legacyemailoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1907;
    pANTLR3_COMMON_TOKEN    LEGACYEMAILOID1908;

    pANTLR3_BASE_TREE OIDTag1907_tree;
    pANTLR3_BASE_TREE LEGACYEMAILOID1908_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1907       = NULL;
    LEGACYEMAILOID1908       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1907_tree   = NULL;
    LEGACYEMAILOID1908_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5383:2: ( OIDTag LEGACYEMAILOID )
        // Grammar/RFC5280.g:5383:3: OIDTag LEGACYEMAILOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1907 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_legacyemailoid12664);
            if  (HASEXCEPTION())
            {
                goto rulelegacyemailoidEx;
            }

            OIDTag1907_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1907));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1907_tree);


            LEGACYEMAILOID1908 = (pANTLR3_COMMON_TOKEN) MATCHT(LEGACYEMAILOID, &FOLLOW_LEGACYEMAILOID_in_legacyemailoid12666);
            if  (HASEXCEPTION())
            {
                goto rulelegacyemailoidEx;
            }

            LEGACYEMAILOID1908_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LEGACYEMAILOID1908));
            ADAPTOR->addChild(ADAPTOR, root_0, LEGACYEMAILOID1908_tree);


            {

                		entire_encoding(9);
                		retval.obj= OBJ_nid2obj(NID_pkcs9_emailAddress);

                		printf("It's legacy email oid \n");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulelegacyemailoidEx; /* Prevent compiler warnings */
    rulelegacyemailoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end legacyemailoid */

/**
 * $ANTLR start ecdhoid
 * Grammar/RFC5280.g:5391:1: ecdhoid returns [ASN1_OBJECT * obj] : OIDTag ECDHOID ;
 */
static RFC5280Parser_ecdhoid_return
ecdhoid(pRFC5280Parser ctx)
{
    RFC5280Parser_ecdhoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1909;
    pANTLR3_COMMON_TOKEN    ECDHOID1910;

    pANTLR3_BASE_TREE OIDTag1909_tree;
    pANTLR3_BASE_TREE ECDHOID1910_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1909       = NULL;
    ECDHOID1910       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1909_tree   = NULL;
    ECDHOID1910_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5395:2: ( OIDTag ECDHOID )
        // Grammar/RFC5280.g:5395:3: OIDTag ECDHOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1909 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_ecdhoid12687);
            if  (HASEXCEPTION())
            {
                goto ruleecdhoidEx;
            }

            OIDTag1909_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1909));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1909_tree);


            ECDHOID1910 = (pANTLR3_COMMON_TOKEN) MATCHT(ECDHOID, &FOLLOW_ECDHOID_in_ecdhoid12689);
            if  (HASEXCEPTION())
            {
                goto ruleecdhoidEx;
            }

            ECDHOID1910_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ECDHOID1910));
            ADAPTOR->addChild(ADAPTOR, root_0, ECDHOID1910_tree);


            {

                		entire_encoding(5);
                		int new_nid = OBJ_txt2nid("1.3.132.1.12");
                		if(new_nid == NID_undef)
                			new_nid = OBJ_create("1.3.132.1.12","ECDH","ecdh_algorithm");
                		retval.obj= OBJ_nid2obj(new_nid);

                		printf("It's legacy email oid \n");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleecdhoidEx; /* Prevent compiler warnings */
    ruleecdhoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ecdhoid */

/**
 * $ANTLR start ecmqvoid
 * Grammar/RFC5280.g:5406:1: ecmqvoid returns [ASN1_OBJECT * obj] : OIDTag ECMQVOID ;
 */
static RFC5280Parser_ecmqvoid_return
ecmqvoid(pRFC5280Parser ctx)
{
    RFC5280Parser_ecmqvoid_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OIDTag1911;
    pANTLR3_COMMON_TOKEN    ECMQVOID1912;

    pANTLR3_BASE_TREE OIDTag1911_tree;
    pANTLR3_BASE_TREE ECMQVOID1912_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OIDTag1911       = NULL;
    ECMQVOID1912       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OIDTag1911_tree   = NULL;
    ECMQVOID1912_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5410:2: ( OIDTag ECMQVOID )
        // Grammar/RFC5280.g:5410:3: OIDTag ECMQVOID
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            OIDTag1911 = (pANTLR3_COMMON_TOKEN) MATCHT(OIDTag, &FOLLOW_OIDTag_in_ecmqvoid12711);
            if  (HASEXCEPTION())
            {
                goto ruleecmqvoidEx;
            }

            OIDTag1911_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OIDTag1911));
            ADAPTOR->addChild(ADAPTOR, root_0, OIDTag1911_tree);


            ECMQVOID1912 = (pANTLR3_COMMON_TOKEN) MATCHT(ECMQVOID, &FOLLOW_ECMQVOID_in_ecmqvoid12713);
            if  (HASEXCEPTION())
            {
                goto ruleecmqvoidEx;
            }

            ECMQVOID1912_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ECMQVOID1912));
            ADAPTOR->addChild(ADAPTOR, root_0, ECMQVOID1912_tree);


            {

                		entire_encoding(5);
                		int new_nid = OBJ_txt2nid("1.3.132.1.13");
                		if(new_nid == NID_undef)
                			new_nid = OBJ_create("1.3.132.1.13","ECMQV","ecmqv_algorithm");
                		retval.obj= OBJ_nid2obj(new_nid);

                		printf("It's legacy email oid \n");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleecmqvoidEx; /* Prevent compiler warnings */
    ruleecmqvoidEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ecmqvoid */

/**
 * $ANTLR start printString
 * Grammar/RFC5280.g:5421:1: printString returns [ASN1_PRINTABLESTRING* text] : PrintStringTag printable ;
 */
static RFC5280Parser_printString_return
printString(pRFC5280Parser ctx)
{
    RFC5280Parser_printString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    PrintStringTag1913;
    RFC5280Parser_printable_return printable1914;
    #undef	RETURN_TYPE_printable1914
    #define	RETURN_TYPE_printable1914 RFC5280Parser_printable_return

    pANTLR3_BASE_TREE PrintStringTag1913_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    PrintStringTag1913       = NULL;
    printable1914.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    PrintStringTag1913_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5424:2: ( PrintStringTag printable )
        // Grammar/RFC5280.g:5424:3: PrintStringTag printable
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            PrintStringTag1913 = (pANTLR3_COMMON_TOKEN) MATCHT(PrintStringTag, &FOLLOW_PrintStringTag_in_printString12732);
            if  (HASEXCEPTION())
            {
                goto ruleprintStringEx;
            }

            PrintStringTag1913_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PrintStringTag1913));
            ADAPTOR->addChild(ADAPTOR, root_0, PrintStringTag1913_tree);


            FOLLOWPUSH(FOLLOW_printable_in_printString12734);
            printable1914=printable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleprintStringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, printable1914.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((PrintStringTag1913->getText(PrintStringTag1913))->chars,length);
                	
                		
                retval.text= (ASN1_PRINTABLESTRING *) new_asn1_string (19,mpz_get_ui(length),
                printable1914.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprintStringEx; /* Prevent compiler warnings */
    ruleprintStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end printString */

/**
 * $ANTLR start ia5String
 * Grammar/RFC5280.g:5435:1: ia5String returns [ASN1_IA5STRING* text] : IA5StringTag printable ;
 */
static RFC5280Parser_ia5String_return
ia5String(pRFC5280Parser ctx)
{
    RFC5280Parser_ia5String_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    IA5StringTag1915;
    RFC5280Parser_printable_return printable1916;
    #undef	RETURN_TYPE_printable1916
    #define	RETURN_TYPE_printable1916 RFC5280Parser_printable_return

    pANTLR3_BASE_TREE IA5StringTag1915_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    IA5StringTag1915       = NULL;
    printable1916.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    IA5StringTag1915_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5438:2: ( IA5StringTag printable )
        // Grammar/RFC5280.g:5438:3: IA5StringTag printable
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            IA5StringTag1915 = (pANTLR3_COMMON_TOKEN) MATCHT(IA5StringTag, &FOLLOW_IA5StringTag_in_ia5String12757);
            if  (HASEXCEPTION())
            {
                goto ruleia5StringEx;
            }

            IA5StringTag1915_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IA5StringTag1915));
            ADAPTOR->addChild(ADAPTOR, root_0, IA5StringTag1915_tree);


            FOLLOWPUSH(FOLLOW_printable_in_ia5String12759);
            printable1916=printable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleia5StringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, printable1916.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((IA5StringTag1915->getText(IA5StringTag1915))->chars,length);
                		
                retval.text= (ASN1_IA5STRING *) new_asn1_string (22,mpz_get_ui(length),
                printable1916.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleia5StringEx; /* Prevent compiler warnings */
    ruleia5StringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end ia5String */

/**
 * $ANTLR start utc
 * Grammar/RFC5280.g:5448:1: utc returns [ASN1_TIME* text] : UTCTag printable ;
 */
static RFC5280Parser_utc_return
utc(pRFC5280Parser ctx)
{
    RFC5280Parser_utc_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    UTCTag1917;
    RFC5280Parser_printable_return printable1918;
    #undef	RETURN_TYPE_printable1918
    #define	RETURN_TYPE_printable1918 RFC5280Parser_printable_return

    pANTLR3_BASE_TREE UTCTag1917_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    UTCTag1917       = NULL;
    printable1918.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    UTCTag1917_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5451:2: ( UTCTag printable )
        // Grammar/RFC5280.g:5451:3: UTCTag printable
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            UTCTag1917 = (pANTLR3_COMMON_TOKEN) MATCHT(UTCTag, &FOLLOW_UTCTag_in_utc12782);
            if  (HASEXCEPTION())
            {
                goto ruleutcEx;
            }

            UTCTag1917_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, UTCTag1917));
            ADAPTOR->addChild(ADAPTOR, root_0, UTCTag1917_tree);


            FOLLOWPUSH(FOLLOW_printable_in_utc12784);
            printable1918=printable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleutcEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, printable1918.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((UTCTag1917->getText(UTCTag1917))->chars,length);
                		//char pattern[20]="^[0-9]{12}Z\\z";
                		char pattern[400]="(((0|2|4|6|8)(0|4|8)|(1|3|5|7|9)(2|6))((01|03|05|07|08|10|12)(0[1-9]|1[0-9]|2[0-9]|30|31)|(04|06|09|11)(0[1-9]|1[0-9]|2[0-9]|30)|02(0[1-9]|1[0-9]|2[0-9]))|((0|2|4|6|8)(1|2|3|5|6|7|9)|(1|3|5|7|9)(0|1|3|4|5|7|8|9))((01|03|05|07|08|10|12)(0[1-9]|1[0-9]|2[0-9]|30|31)|(04|06|09|11)(0[1-9]|1[0-9]|2[0-9]|30)|02(0[1-9]|1[0-9]|2[0-8])))(0[0-9]|1[0-9]|2[0-3])[0-5][0-9][0-5][0-9]Z$";
                		if(check_string(pattern,
                printable1918.text
                ,mpz_get_ui(length)))
                		{
                			printf("Error in UTC %s \n",printable1918.text
                );
                			exit(UTC_REGEXP_ERROR);
                		}
                		retval.text=malloc(sizeof(ASN1_TIME));

                		retval.text
                ->data = printable1918.text
                ;
                		retval.text
                ->length = mpz_get_ui(length);
                		retval.text
                ->type = 23;
                		retval.text
                ->flags = 0;
                		printf("Time check is %d \n",ASN1_TIME_check(retval.text
                ));
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleutcEx; /* Prevent compiler warnings */
    ruleutcEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end utc */

/**
 * $ANTLR start genTime
 * Grammar/RFC5280.g:5473:1: genTime returns [ASN1_TIME* text] : GeneralTimeTag printable ;
 */
static RFC5280Parser_genTime_return
genTime(pRFC5280Parser ctx)
{
    RFC5280Parser_genTime_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    GeneralTimeTag1919;
    RFC5280Parser_printable_return printable1920;
    #undef	RETURN_TYPE_printable1920
    #define	RETURN_TYPE_printable1920 RFC5280Parser_printable_return

    pANTLR3_BASE_TREE GeneralTimeTag1919_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    GeneralTimeTag1919       = NULL;
    printable1920.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    GeneralTimeTag1919_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5476:2: ( GeneralTimeTag printable )
        // Grammar/RFC5280.g:5476:3: GeneralTimeTag printable
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            GeneralTimeTag1919 = (pANTLR3_COMMON_TOKEN) MATCHT(GeneralTimeTag, &FOLLOW_GeneralTimeTag_in_genTime12807);
            if  (HASEXCEPTION())
            {
                goto rulegenTimeEx;
            }

            GeneralTimeTag1919_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GeneralTimeTag1919));
            ADAPTOR->addChild(ADAPTOR, root_0, GeneralTimeTag1919_tree);


            FOLLOWPUSH(FOLLOW_printable_in_genTime12809);
            printable1920=printable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegenTimeEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, printable1920.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((GeneralTimeTag1919->getText(GeneralTimeTag1919))->chars,length);
                		//char pattern[20]="^[0-9]{14}Z\\z";
                		char pattern[400]="^[0-9][0-9](((0|2|4|6|8)(0|4|8)|(1|3|5|7|9)(2|6))((01|03|05|07|08|10|12)(0[1-9]|1[0-9]|2[0-9]|30|31)|(04|06|09|11)(0[1-9]|1[0-9]|2[0-9]|30)|02(0[1-9]|1[0-9]|2[0-9]))|((0|2|4|6|8)(1|2|3|5|6|7|9)|(1|3|5|7|9)(0|1|3|4|5|7|8|9))((01|03|05|07|08|10|12)(0[1-9]|1[0-9]|2[0-9]|30|31)|(04|06|09|11)(0[1-9]|1[0-9]|2[0-9]|30)|02(0[1-9]|1[0-9]|2[0-8])))(0[0-9]|1[0-9]|2[0-3])[0-5][0-9][0-5][0-9]Z$";
                		if(check_string(pattern,
                printable1920.text
                ,mpz_get_ui(length)))
                		{
                			printf("Error in Generalied Time %s \n",printable1920.text
                );
                			exit(GENERALIZED_TIME_REGEXP_ERROR);
                		}
                		retval.text=malloc(sizeof(ASN1_TIME));

                		retval.text
                ->data = printable1920.text
                ;
                		retval.text
                ->length = mpz_get_ui(length);
                		retval.text
                ->type = 24;
                		retval.text
                ->flags = 0;
                		printf("Time check is %d \n",ASN1_TIME_check(retval.text
                ));
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegenTimeEx; /* Prevent compiler warnings */
    rulegenTimeEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end genTime */

/**
 * $ANTLR start truevalue
 * Grammar/RFC5280.g:5498:1: truevalue : TrueTag ;
 */
static RFC5280Parser_truevalue_return
truevalue(pRFC5280Parser ctx)
{
    RFC5280Parser_truevalue_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TrueTag1921;

    pANTLR3_BASE_TREE TrueTag1921_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TrueTag1921       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TrueTag1921_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5501:2: ( TrueTag )
        // Grammar/RFC5280.g:5501:3: TrueTag
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TrueTag1921 = (pANTLR3_COMMON_TOKEN) MATCHT(TrueTag, &FOLLOW_TrueTag_in_truevalue12829);
            if  (HASEXCEPTION())
            {
                goto ruletruevalueEx;
            }

            TrueTag1921_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TrueTag1921));
            ADAPTOR->addChild(ADAPTOR, root_0, TrueTag1921_tree);


            {

                		entire_encoding(1);
                		printf("True \n");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletruevalueEx; /* Prevent compiler warnings */
    ruletruevalueEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end truevalue */

/**
 * $ANTLR start falsevalue
 * Grammar/RFC5280.g:5509:1: falsevalue : FalseTag ;
 */
static RFC5280Parser_falsevalue_return
falsevalue(pRFC5280Parser ctx)
{
    RFC5280Parser_falsevalue_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    FalseTag1922;

    pANTLR3_BASE_TREE FalseTag1922_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    FalseTag1922       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    FalseTag1922_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5512:2: ( FalseTag )
        // Grammar/RFC5280.g:5512:3: FalseTag
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            FalseTag1922 = (pANTLR3_COMMON_TOKEN) MATCHT(FalseTag, &FOLLOW_FalseTag_in_falsevalue12848);
            if  (HASEXCEPTION())
            {
                goto rulefalsevalueEx;
            }

            FalseTag1922_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, FalseTag1922));
            ADAPTOR->addChild(ADAPTOR, root_0, FalseTag1922_tree);


            {

                		
                		entire_encoding(1);
                		printf("False \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefalsevalueEx; /* Prevent compiler warnings */
    rulefalsevalueEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end falsevalue */

/**
 * $ANTLR start utf8String
 * Grammar/RFC5280.g:5519:1: utf8String returns [ASN1_UTF8STRING* text] : UTF8Tag printable ;
 */
static RFC5280Parser_utf8String_return
utf8String(pRFC5280Parser ctx)
{
    RFC5280Parser_utf8String_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    UTF8Tag1923;
    RFC5280Parser_printable_return printable1924;
    #undef	RETURN_TYPE_printable1924
    #define	RETURN_TYPE_printable1924 RFC5280Parser_printable_return

    pANTLR3_BASE_TREE UTF8Tag1923_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    UTF8Tag1923       = NULL;
    printable1924.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    UTF8Tag1923_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5522:2: ( UTF8Tag printable )
        // Grammar/RFC5280.g:5522:3: UTF8Tag printable
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            UTF8Tag1923 = (pANTLR3_COMMON_TOKEN) MATCHT(UTF8Tag, &FOLLOW_UTF8Tag_in_utf8String12868);
            if  (HASEXCEPTION())
            {
                goto ruleutf8StringEx;
            }

            UTF8Tag1923_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, UTF8Tag1923));
            ADAPTOR->addChild(ADAPTOR, root_0, UTF8Tag1923_tree);


            FOLLOWPUSH(FOLLOW_printable_in_utf8String12870);
            printable1924=printable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleutf8StringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, printable1924.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((UTF8Tag1923->getText(UTF8Tag1923))->chars,length);
                		
                retval.text= (ASN1_UTF8STRING *) new_asn1_string (12,mpz_get_ui(length),
                printable1924.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleutf8StringEx; /* Prevent compiler warnings */
    ruleutf8StringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end utf8String */

/**
 * $ANTLR start teletexString
 * Grammar/RFC5280.g:5533:1: teletexString returns [ASN1_T61STRING* text] : TeletexTag printable ;
 */
static RFC5280Parser_teletexString_return
teletexString(pRFC5280Parser ctx)
{
    RFC5280Parser_teletexString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TeletexTag1925;
    RFC5280Parser_printable_return printable1926;
    #undef	RETURN_TYPE_printable1926
    #define	RETURN_TYPE_printable1926 RFC5280Parser_printable_return

    pANTLR3_BASE_TREE TeletexTag1925_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TeletexTag1925       = NULL;
    printable1926.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TeletexTag1925_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5536:2: ( TeletexTag printable )
        // Grammar/RFC5280.g:5536:3: TeletexTag printable
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TeletexTag1925 = (pANTLR3_COMMON_TOKEN) MATCHT(TeletexTag, &FOLLOW_TeletexTag_in_teletexString12894);
            if  (HASEXCEPTION())
            {
                goto ruleteletexStringEx;
            }

            TeletexTag1925_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TeletexTag1925));
            ADAPTOR->addChild(ADAPTOR, root_0, TeletexTag1925_tree);


            FOLLOWPUSH(FOLLOW_printable_in_teletexString12896);
            printable1926=printable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleteletexStringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, printable1926.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((TeletexTag1925->getText(TeletexTag1925))->chars,length);
                		
                retval.text= (ASN1_T61STRING *) new_asn1_string (20,mpz_get_ui(length),
                printable1926.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleteletexStringEx; /* Prevent compiler warnings */
    ruleteletexStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end teletexString */

/**
 * $ANTLR start bmpString
 * Grammar/RFC5280.g:5546:1: bmpString returns [ASN1_BMPSTRING* text] : BMPTag val ;
 */
static RFC5280Parser_bmpString_return
bmpString(pRFC5280Parser ctx)
{
    RFC5280Parser_bmpString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    BMPTag1927;
    RFC5280Parser_val_return val1928;
    #undef	RETURN_TYPE_val1928
    #define	RETURN_TYPE_val1928 RFC5280Parser_val_return

    pANTLR3_BASE_TREE BMPTag1927_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    BMPTag1927       = NULL;
    val1928.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    BMPTag1927_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5549:2: ( BMPTag val )
        // Grammar/RFC5280.g:5549:3: BMPTag val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            BMPTag1927 = (pANTLR3_COMMON_TOKEN) MATCHT(BMPTag, &FOLLOW_BMPTag_in_bmpString12919);
            if  (HASEXCEPTION())
            {
                goto rulebmpStringEx;
            }

            BMPTag1927_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BMPTag1927));
            ADAPTOR->addChild(ADAPTOR, root_0, BMPTag1927_tree);


            FOLLOWPUSH(FOLLOW_val_in_bmpString12921);
            val1928=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebmpStringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1928.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((BMPTag1927->getText(BMPTag1927))->chars,length);
                		
                retval.text= (ASN1_BMPSTRING *) new_asn1_string (30,mpz_get_ui(length),
                val1928.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebmpStringEx; /* Prevent compiler warnings */
    rulebmpStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end bmpString */

/**
 * $ANTLR start univerString
 * Grammar/RFC5280.g:5559:1: univerString returns [ASN1_UNIVERSALSTRING* text] : UniverStringTag printable ;
 */
static RFC5280Parser_univerString_return
univerString(pRFC5280Parser ctx)
{
    RFC5280Parser_univerString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    UniverStringTag1929;
    RFC5280Parser_printable_return printable1930;
    #undef	RETURN_TYPE_printable1930
    #define	RETURN_TYPE_printable1930 RFC5280Parser_printable_return

    pANTLR3_BASE_TREE UniverStringTag1929_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    UniverStringTag1929       = NULL;
    printable1930.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    UniverStringTag1929_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5562:2: ( UniverStringTag printable )
        // Grammar/RFC5280.g:5562:3: UniverStringTag printable
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            UniverStringTag1929 = (pANTLR3_COMMON_TOKEN) MATCHT(UniverStringTag, &FOLLOW_UniverStringTag_in_univerString12944);
            if  (HASEXCEPTION())
            {
                goto ruleuniverStringEx;
            }

            UniverStringTag1929_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, UniverStringTag1929));
            ADAPTOR->addChild(ADAPTOR, root_0, UniverStringTag1929_tree);


            FOLLOWPUSH(FOLLOW_printable_in_univerString12946);
            printable1930=printable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuniverStringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, printable1930.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((UniverStringTag1929->getText(UniverStringTag1929))->chars,length);
                		
                retval.text= (ASN1_UNIVERSALSTRING *) new_asn1_string (28,mpz_get_ui(length),
                printable1930.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleuniverStringEx; /* Prevent compiler warnings */
    ruleuniverStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end univerString */

/**
 * $ANTLR start visibleString
 * Grammar/RFC5280.g:5572:1: visibleString returns [ASN1_VISIBLESTRING* text] : VisibleStringTag printable ;
 */
static RFC5280Parser_visibleString_return
visibleString(pRFC5280Parser ctx)
{
    RFC5280Parser_visibleString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    VisibleStringTag1931;
    RFC5280Parser_printable_return printable1932;
    #undef	RETURN_TYPE_printable1932
    #define	RETURN_TYPE_printable1932 RFC5280Parser_printable_return

    pANTLR3_BASE_TREE VisibleStringTag1931_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    VisibleStringTag1931       = NULL;
    printable1932.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    VisibleStringTag1931_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5575:2: ( VisibleStringTag printable )
        // Grammar/RFC5280.g:5575:3: VisibleStringTag printable
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            VisibleStringTag1931 = (pANTLR3_COMMON_TOKEN) MATCHT(VisibleStringTag, &FOLLOW_VisibleStringTag_in_visibleString12969);
            if  (HASEXCEPTION())
            {
                goto rulevisibleStringEx;
            }

            VisibleStringTag1931_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, VisibleStringTag1931));
            ADAPTOR->addChild(ADAPTOR, root_0, VisibleStringTag1931_tree);


            FOLLOWPUSH(FOLLOW_printable_in_visibleString12971);
            printable1932=printable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevisibleStringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, printable1932.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((VisibleStringTag1931->getText(VisibleStringTag1931))->chars,length);
                		
                retval.text= (ASN1_VISIBLESTRING *) new_asn1_string (26,mpz_get_ui(length),
                printable1932.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevisibleStringEx; /* Prevent compiler warnings */
    rulevisibleStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end visibleString */

/**
 * $ANTLR start numericString
 * Grammar/RFC5280.g:5585:1: numericString returns [ASN1_STRING* text] : NumericStringTag printable ;
 */
static RFC5280Parser_numericString_return
numericString(pRFC5280Parser ctx)
{
    RFC5280Parser_numericString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    NumericStringTag1933;
    RFC5280Parser_printable_return printable1934;
    #undef	RETURN_TYPE_printable1934
    #define	RETURN_TYPE_printable1934 RFC5280Parser_printable_return

    pANTLR3_BASE_TREE NumericStringTag1933_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    NumericStringTag1933       = NULL;
    printable1934.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    NumericStringTag1933_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5588:2: ( NumericStringTag printable )
        // Grammar/RFC5280.g:5588:3: NumericStringTag printable
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            NumericStringTag1933 = (pANTLR3_COMMON_TOKEN) MATCHT(NumericStringTag, &FOLLOW_NumericStringTag_in_numericString12995);
            if  (HASEXCEPTION())
            {
                goto rulenumericStringEx;
            }

            NumericStringTag1933_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NumericStringTag1933));
            ADAPTOR->addChild(ADAPTOR, root_0, NumericStringTag1933_tree);


            FOLLOWPUSH(FOLLOW_printable_in_numericString12997);
            printable1934=printable(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulenumericStringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, printable1934.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((NumericStringTag1933->getText(NumericStringTag1933))->chars,length);
                		
                retval.text= (ASN1_STRING *) new_asn1_string (18,mpz_get_ui(length),
                printable1934.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenumericStringEx; /* Prevent compiler warnings */
    rulenumericStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end numericString */

/**
 * $ANTLR start generalString
 * Grammar/RFC5280.g:5598:1: generalString returns [ASN1_STRING* text] : GeneralStringTag val ;
 */
static RFC5280Parser_generalString_return
generalString(pRFC5280Parser ctx)
{
    RFC5280Parser_generalString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    GeneralStringTag1935;
    RFC5280Parser_val_return val1936;
    #undef	RETURN_TYPE_val1936
    #define	RETURN_TYPE_val1936 RFC5280Parser_val_return

    pANTLR3_BASE_TREE GeneralStringTag1935_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    GeneralStringTag1935       = NULL;
    val1936.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    GeneralStringTag1935_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5601:2: ( GeneralStringTag val )
        // Grammar/RFC5280.g:5601:3: GeneralStringTag val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            GeneralStringTag1935 = (pANTLR3_COMMON_TOKEN) MATCHT(GeneralStringTag, &FOLLOW_GeneralStringTag_in_generalString13017);
            if  (HASEXCEPTION())
            {
                goto rulegeneralStringEx;
            }

            GeneralStringTag1935_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GeneralStringTag1935));
            ADAPTOR->addChild(ADAPTOR, root_0, GeneralStringTag1935_tree);


            FOLLOWPUSH(FOLLOW_val_in_generalString13019);
            val1936=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegeneralStringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1936.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((GeneralStringTag1935->getText(GeneralStringTag1935))->chars,length);
                		
                retval.text= (ASN1_STRING *) new_asn1_string (27,mpz_get_ui(length),
                val1936.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegeneralStringEx; /* Prevent compiler warnings */
    rulegeneralStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end generalString */

/**
 * $ANTLR start graphicString
 * Grammar/RFC5280.g:5611:1: graphicString returns [ASN1_STRING* text] : GraphicalStringTag val ;
 */
static RFC5280Parser_graphicString_return
graphicString(pRFC5280Parser ctx)
{
    RFC5280Parser_graphicString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    GraphicalStringTag1937;
    RFC5280Parser_val_return val1938;
    #undef	RETURN_TYPE_val1938
    #define	RETURN_TYPE_val1938 RFC5280Parser_val_return

    pANTLR3_BASE_TREE GraphicalStringTag1937_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    GraphicalStringTag1937       = NULL;
    val1938.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    GraphicalStringTag1937_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5614:2: ( GraphicalStringTag val )
        // Grammar/RFC5280.g:5614:3: GraphicalStringTag val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            GraphicalStringTag1937 = (pANTLR3_COMMON_TOKEN) MATCHT(GraphicalStringTag, &FOLLOW_GraphicalStringTag_in_graphicString13039);
            if  (HASEXCEPTION())
            {
                goto rulegraphicStringEx;
            }

            GraphicalStringTag1937_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GraphicalStringTag1937));
            ADAPTOR->addChild(ADAPTOR, root_0, GraphicalStringTag1937_tree);


            FOLLOWPUSH(FOLLOW_val_in_graphicString13041);
            val1938=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulegraphicStringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1938.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((GraphicalStringTag1937->getText(GraphicalStringTag1937))->chars,length);
                		
                retval.text= (ASN1_STRING *) new_asn1_string (25,mpz_get_ui(length),
                val1938.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulegraphicStringEx; /* Prevent compiler warnings */
    rulegraphicStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end graphicString */

/**
 * $ANTLR start videoString
 * Grammar/RFC5280.g:5624:1: videoString returns [ASN1_STRING* text] : VideoStringTag val ;
 */
static RFC5280Parser_videoString_return
videoString(pRFC5280Parser ctx)
{
    RFC5280Parser_videoString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    VideoStringTag1939;
    RFC5280Parser_val_return val1940;
    #undef	RETURN_TYPE_val1940
    #define	RETURN_TYPE_val1940 RFC5280Parser_val_return

    pANTLR3_BASE_TREE VideoStringTag1939_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    VideoStringTag1939       = NULL;
    val1940.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    VideoStringTag1939_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5627:2: ( VideoStringTag val )
        // Grammar/RFC5280.g:5627:3: VideoStringTag val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            VideoStringTag1939 = (pANTLR3_COMMON_TOKEN) MATCHT(VideoStringTag, &FOLLOW_VideoStringTag_in_videoString13060);
            if  (HASEXCEPTION())
            {
                goto rulevideoStringEx;
            }

            VideoStringTag1939_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, VideoStringTag1939));
            ADAPTOR->addChild(ADAPTOR, root_0, VideoStringTag1939_tree);


            FOLLOWPUSH(FOLLOW_val_in_videoString13062);
            val1940=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevideoStringEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1940.tree);

            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((VideoStringTag1939->getText(VideoStringTag1939))->chars,length);
                		
                retval.text= (ASN1_STRING *) new_asn1_string (21,mpz_get_ui(length),
                val1940.text
                );

                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevideoStringEx; /* Prevent compiler warnings */
    rulevideoStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end videoString */

/**
 * $ANTLR start null
 * Grammar/RFC5280.g:5638:1: null : Null ;
 */
static RFC5280Parser_null_return
null(pRFC5280Parser ctx)
{
    RFC5280Parser_null_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Null1941;

    pANTLR3_BASE_TREE Null1941_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Null1941       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Null1941_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5641:2: ( Null )
        // Grammar/RFC5280.g:5641:3: Null
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Null1941 = (pANTLR3_COMMON_TOKEN) MATCHT(Null, &FOLLOW_Null_in_null13080);
            if  (HASEXCEPTION())
            {
                goto rulenullEx;
            }

            Null1941_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Null1941));
            ADAPTOR->addChild(ADAPTOR, root_0, Null1941_tree);


            {
                entire_encoding(0);
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulenullEx; /* Prevent compiler warnings */
    rulenullEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end null */

/**
 * $ANTLR start sequenceTag
 * Grammar/RFC5280.g:5647:1: sequenceTag : SequenceTag ;
 */
static RFC5280Parser_sequenceTag_return
sequenceTag(pRFC5280Parser ctx)
{
    RFC5280Parser_sequenceTag_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SequenceTag1942;

    pANTLR3_BASE_TREE SequenceTag1942_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SequenceTag1942       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SequenceTag1942_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5651:2: ( SequenceTag )
        // Grammar/RFC5280.g:5651:3: SequenceTag
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            SequenceTag1942 = (pANTLR3_COMMON_TOKEN) MATCHT(SequenceTag, &FOLLOW_SequenceTag_in_sequenceTag13102);
            if  (HASEXCEPTION())
            {
                goto rulesequenceTagEx;
            }

            SequenceTag1942_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SequenceTag1942));
            ADAPTOR->addChild(ADAPTOR, root_0, SequenceTag1942_tree);


            {

                		constructed_type((SequenceTag1942->getText(SequenceTag1942))->chars);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesequenceTagEx; /* Prevent compiler warnings */
    rulesequenceTagEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end sequenceTag */

/**
 * $ANTLR start set
 * Grammar/RFC5280.g:5659:1: set : SetTag ;
 */
static RFC5280Parser_set_return
set(pRFC5280Parser ctx)
{
    RFC5280Parser_set_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SetTag1943;

    pANTLR3_BASE_TREE SetTag1943_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SetTag1943       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SetTag1943_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5662:2: ( SetTag )
        // Grammar/RFC5280.g:5662:3: SetTag
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            SetTag1943 = (pANTLR3_COMMON_TOKEN) MATCHT(SetTag, &FOLLOW_SetTag_in_set13123);
            if  (HASEXCEPTION())
            {
                goto rulesetEx;
            }

            SetTag1943_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SetTag1943));
            ADAPTOR->addChild(ADAPTOR, root_0, SetTag1943_tree);


            {

                		constructed_type((SetTag1943->getText(SetTag1943))->chars);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesetEx; /* Prevent compiler warnings */
    rulesetEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end set */

/**
 * $ANTLR start constructedOctetString
 * Grammar/RFC5280.g:5670:1: constructedOctetString : ConstructedOctetTag ;
 */
static RFC5280Parser_constructedOctetString_return
constructedOctetString(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedOctetString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedOctetTag1944;

    pANTLR3_BASE_TREE ConstructedOctetTag1944_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedOctetTag1944       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedOctetTag1944_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5674:2: ( ConstructedOctetTag )
        // Grammar/RFC5280.g:5674:3: ConstructedOctetTag
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedOctetTag1944 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedOctetTag, &FOLLOW_ConstructedOctetTag_in_constructedOctetString13145);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedOctetStringEx;
            }

            ConstructedOctetTag1944_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedOctetTag1944));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedOctetTag1944_tree);


            {

                		constructed_type((ConstructedOctetTag1944->getText(ConstructedOctetTag1944))->chars);
                		printf("It's a constructed Octet String \n");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedOctetStringEx; /* Prevent compiler warnings */
    ruleconstructedOctetStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedOctetString */

/**
 * $ANTLR start constructedBitString
 * Grammar/RFC5280.g:5683:1: constructedBitString : ConstructedBitStringTag ;
 */
static RFC5280Parser_constructedBitString_return
constructedBitString(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedBitString_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedBitStringTag1945;

    pANTLR3_BASE_TREE ConstructedBitStringTag1945_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedBitStringTag1945       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedBitStringTag1945_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5687:2: ( ConstructedBitStringTag )
        // Grammar/RFC5280.g:5687:3: ConstructedBitStringTag
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedBitStringTag1945 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedBitStringTag, &FOLLOW_ConstructedBitStringTag_in_constructedBitString13168);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedBitStringEx;
            }

            ConstructedBitStringTag1945_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedBitStringTag1945));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedBitStringTag1945_tree);


            {

                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		int len =compute_len((ConstructedBitStringTag1945->getText(ConstructedBitStringTag1945))->chars,length);
                		mpz_sub_ui(length,length,1);
                		push(length,len+1);
                		printf("It's a constructed Bit String \n");
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedBitStringEx; /* Prevent compiler warnings */
    ruleconstructedBitStringEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedBitString */

/**
 * $ANTLR start constructedTag0
 * Grammar/RFC5280.g:5701:1: constructedTag0 : ConstructedTag0 ;
 */
static RFC5280Parser_constructedTag0_return
constructedTag0(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedTag0_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedTag01946;

    pANTLR3_BASE_TREE ConstructedTag01946_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedTag01946       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedTag01946_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5704:2: ( ConstructedTag0 )
        // Grammar/RFC5280.g:5704:3: ConstructedTag0
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedTag01946 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedTag0, &FOLLOW_ConstructedTag0_in_constructedTag013193);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedTag0Ex;
            }

            ConstructedTag01946_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedTag01946));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedTag01946_tree);


            {

                		constructed_type((ConstructedTag01946->getText(ConstructedTag01946))->chars);
                		printf("it's tag0 constructed \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedTag0Ex; /* Prevent compiler warnings */
    ruleconstructedTag0Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedTag0 */

/**
 * $ANTLR start tag0
 * Grammar/RFC5280.g:5709:1: tag0 returns [tag_type* text] : ( onlyTag0 | ( tagInt1 | tagInt2 | tagInt3 | tagInt4 | tagInt5 | tagInt6 | tagInt7 | tagInt8 | tagInt9 | tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt16 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 | tagInt22 | tagInt23 ) );
 */
static RFC5280Parser_tag0_return
tag0(pRFC5280Parser ctx)
{
    RFC5280Parser_tag0_return retval;


    pANTLR3_BASE_TREE root_0;

    RFC5280Parser_onlyTag0_return onlyTag01947;
    #undef	RETURN_TYPE_onlyTag01947
    #define	RETURN_TYPE_onlyTag01947 RFC5280Parser_onlyTag0_return

    RFC5280Parser_tagInt1_return tagInt11948;
    #undef	RETURN_TYPE_tagInt11948
    #define	RETURN_TYPE_tagInt11948 RFC5280Parser_tagInt1_return

    RFC5280Parser_tagInt2_return tagInt21949;
    #undef	RETURN_TYPE_tagInt21949
    #define	RETURN_TYPE_tagInt21949 RFC5280Parser_tagInt2_return

    RFC5280Parser_tagInt3_return tagInt31950;
    #undef	RETURN_TYPE_tagInt31950
    #define	RETURN_TYPE_tagInt31950 RFC5280Parser_tagInt3_return

    RFC5280Parser_tagInt4_return tagInt41951;
    #undef	RETURN_TYPE_tagInt41951
    #define	RETURN_TYPE_tagInt41951 RFC5280Parser_tagInt4_return

    RFC5280Parser_tagInt5_return tagInt51952;
    #undef	RETURN_TYPE_tagInt51952
    #define	RETURN_TYPE_tagInt51952 RFC5280Parser_tagInt5_return

    RFC5280Parser_tagInt6_return tagInt61953;
    #undef	RETURN_TYPE_tagInt61953
    #define	RETURN_TYPE_tagInt61953 RFC5280Parser_tagInt6_return

    RFC5280Parser_tagInt7_return tagInt71954;
    #undef	RETURN_TYPE_tagInt71954
    #define	RETURN_TYPE_tagInt71954 RFC5280Parser_tagInt7_return

    RFC5280Parser_tagInt8_return tagInt81955;
    #undef	RETURN_TYPE_tagInt81955
    #define	RETURN_TYPE_tagInt81955 RFC5280Parser_tagInt8_return

    RFC5280Parser_tagInt9_return tagInt91956;
    #undef	RETURN_TYPE_tagInt91956
    #define	RETURN_TYPE_tagInt91956 RFC5280Parser_tagInt9_return

    RFC5280Parser_tagInt10_return tagInt101957;
    #undef	RETURN_TYPE_tagInt101957
    #define	RETURN_TYPE_tagInt101957 RFC5280Parser_tagInt10_return

    RFC5280Parser_tagInt11_return tagInt111958;
    #undef	RETURN_TYPE_tagInt111958
    #define	RETURN_TYPE_tagInt111958 RFC5280Parser_tagInt11_return

    RFC5280Parser_tagInt12_return tagInt121959;
    #undef	RETURN_TYPE_tagInt121959
    #define	RETURN_TYPE_tagInt121959 RFC5280Parser_tagInt12_return

    RFC5280Parser_tagInt13_return tagInt131960;
    #undef	RETURN_TYPE_tagInt131960
    #define	RETURN_TYPE_tagInt131960 RFC5280Parser_tagInt13_return

    RFC5280Parser_tagInt14_return tagInt141961;
    #undef	RETURN_TYPE_tagInt141961
    #define	RETURN_TYPE_tagInt141961 RFC5280Parser_tagInt14_return

    RFC5280Parser_tagInt15_return tagInt151962;
    #undef	RETURN_TYPE_tagInt151962
    #define	RETURN_TYPE_tagInt151962 RFC5280Parser_tagInt15_return

    RFC5280Parser_tagInt16_return tagInt161963;
    #undef	RETURN_TYPE_tagInt161963
    #define	RETURN_TYPE_tagInt161963 RFC5280Parser_tagInt16_return

    RFC5280Parser_tagInt17_return tagInt171964;
    #undef	RETURN_TYPE_tagInt171964
    #define	RETURN_TYPE_tagInt171964 RFC5280Parser_tagInt17_return

    RFC5280Parser_tagInt18_return tagInt181965;
    #undef	RETURN_TYPE_tagInt181965
    #define	RETURN_TYPE_tagInt181965 RFC5280Parser_tagInt18_return

    RFC5280Parser_tagInt19_return tagInt191966;
    #undef	RETURN_TYPE_tagInt191966
    #define	RETURN_TYPE_tagInt191966 RFC5280Parser_tagInt19_return

    RFC5280Parser_tagInt20_return tagInt201967;
    #undef	RETURN_TYPE_tagInt201967
    #define	RETURN_TYPE_tagInt201967 RFC5280Parser_tagInt20_return

    RFC5280Parser_tagInt21_return tagInt211968;
    #undef	RETURN_TYPE_tagInt211968
    #define	RETURN_TYPE_tagInt211968 RFC5280Parser_tagInt21_return

    RFC5280Parser_tagInt22_return tagInt221969;
    #undef	RETURN_TYPE_tagInt221969
    #define	RETURN_TYPE_tagInt221969 RFC5280Parser_tagInt22_return

    RFC5280Parser_tagInt23_return tagInt231970;
    #undef	RETURN_TYPE_tagInt231970
    #define	RETURN_TYPE_tagInt231970 RFC5280Parser_tagInt23_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    #ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    	retval.text= malloc(sizeof(tag_type));

    onlyTag01947.tree = NULL;

    tagInt11948.tree = NULL;

    tagInt21949.tree = NULL;

    tagInt31950.tree = NULL;

    tagInt41951.tree = NULL;

    tagInt51952.tree = NULL;

    tagInt61953.tree = NULL;

    tagInt71954.tree = NULL;

    tagInt81955.tree = NULL;

    tagInt91956.tree = NULL;

    tagInt101957.tree = NULL;

    tagInt111958.tree = NULL;

    tagInt121959.tree = NULL;

    tagInt131960.tree = NULL;

    tagInt141961.tree = NULL;

    tagInt151962.tree = NULL;

    tagInt161963.tree = NULL;

    tagInt171964.tree = NULL;

    tagInt181965.tree = NULL;

    tagInt191966.tree = NULL;

    tagInt201967.tree = NULL;

    tagInt211968.tree = NULL;

    tagInt221969.tree = NULL;

    tagInt231970.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  Grammar/RFC5280.g:5716:2: ( onlyTag0 | ( tagInt1 | tagInt2 | tagInt3 | tagInt4 | tagInt5 | tagInt6 | tagInt7 | tagInt8 | tagInt9 | tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt16 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 | tagInt22 | tagInt23 ) )

            ANTLR3_UINT32 alt478;

            alt478=2;

            switch ( LA(1) )
            {
            case Tag0:
            	{
            		alt478=1;
            	}
                break;
            case TagInt1:
            case TagInt10:
            case TagInt11:
            case TagInt12:
            case TagInt13:
            case TagInt14:
            case TagInt15:
            case TagInt16:
            case TagInt17:
            case TagInt18:
            case TagInt19:
            case TagInt2:
            case TagInt20:
            case TagInt21:
            case TagInt22:
            case TagInt23:
            case TagInt3:
            case TagInt4:
            case TagInt5:
            case TagInt6:
            case TagInt7:
            case TagInt8:
            case TagInt9:
            	{
            		alt478=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 478;
                EXCEPTION->state        = 0;


                goto ruletag0Ex;

            }

            switch (alt478)
            {
        	case 1:
        	    // Grammar/RFC5280.g:5717:3: onlyTag0
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_onlyTag0_in_tag013218);
        	        onlyTag01947=onlyTag0(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletag0Ex;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, onlyTag01947.tree);

        	        {

        	            		free(retval.text
        	            );
        	            		retval.text=
        	            onlyTag01947.text
        	            ;

        	            		
        	        }


        	    }
        	    break;
        	case 2:
        	    // Grammar/RFC5280.g:5722:3: ( tagInt1 | tagInt2 | tagInt3 | tagInt4 | tagInt5 | tagInt6 | tagInt7 | tagInt8 | tagInt9 | tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt16 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 | tagInt22 | tagInt23 )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        // Grammar/RFC5280.g:5722:3: ( tagInt1 | tagInt2 | tagInt3 | tagInt4 | tagInt5 | tagInt6 | tagInt7 | tagInt8 | tagInt9 | tagInt10 | tagInt11 | tagInt12 | tagInt13 | tagInt14 | tagInt15 | tagInt16 | tagInt17 | tagInt18 | tagInt19 | tagInt20 | tagInt21 | tagInt22 | tagInt23 )
        	        {
        	            int alt477=23;
        	            switch ( LA(1) )
        	            {
        	            case TagInt1:
        	            	{
        	            		alt477=1;
        	            	}
        	                break;
        	            case TagInt2:
        	            	{
        	            		alt477=2;
        	            	}
        	                break;
        	            case TagInt3:
        	            	{
        	            		alt477=3;
        	            	}
        	                break;
        	            case TagInt4:
        	            	{
        	            		alt477=4;
        	            	}
        	                break;
        	            case TagInt5:
        	            	{
        	            		alt477=5;
        	            	}
        	                break;
        	            case TagInt6:
        	            	{
        	            		alt477=6;
        	            	}
        	                break;
        	            case TagInt7:
        	            	{
        	            		alt477=7;
        	            	}
        	                break;
        	            case TagInt8:
        	            	{
        	            		alt477=8;
        	            	}
        	                break;
        	            case TagInt9:
        	            	{
        	            		alt477=9;
        	            	}
        	                break;
        	            case TagInt10:
        	            	{
        	            		alt477=10;
        	            	}
        	                break;
        	            case TagInt11:
        	            	{
        	            		alt477=11;
        	            	}
        	                break;
        	            case TagInt12:
        	            	{
        	            		alt477=12;
        	            	}
        	                break;
        	            case TagInt13:
        	            	{
        	            		alt477=13;
        	            	}
        	                break;
        	            case TagInt14:
        	            	{
        	            		alt477=14;
        	            	}
        	                break;
        	            case TagInt15:
        	            	{
        	            		alt477=15;
        	            	}
        	                break;
        	            case TagInt16:
        	            	{
        	            		alt477=16;
        	            	}
        	                break;
        	            case TagInt17:
        	            	{
        	            		alt477=17;
        	            	}
        	                break;
        	            case TagInt18:
        	            	{
        	            		alt477=18;
        	            	}
        	                break;
        	            case TagInt19:
        	            	{
        	            		alt477=19;
        	            	}
        	                break;
        	            case TagInt20:
        	            	{
        	            		alt477=20;
        	            	}
        	                break;
        	            case TagInt21:
        	            	{
        	            		alt477=21;
        	            	}
        	                break;
        	            case TagInt22:
        	            	{
        	            		alt477=22;
        	            	}
        	                break;
        	            case TagInt23:
        	            	{
        	            		alt477=23;
        	            	}
        	                break;

        	            default:
        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
        	                EXCEPTION->message      = (void *)"";
        	                EXCEPTION->decisionNum  = 477;
        	                EXCEPTION->state        = 0;


        	                goto ruletag0Ex;

        	            }

        	            switch (alt477)
        	            {
        	        	case 1:
        	        	    // Grammar/RFC5280.g:5722:4: tagInt1
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt1_in_tag013229);
        	        	        tagInt11948=tagInt1(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt11948.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=1;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 2:
        	        	    // Grammar/RFC5280.g:5723:4: tagInt2
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt2_in_tag013236);
        	        	        tagInt21949=tagInt2(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt21949.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=2;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 3:
        	        	    // Grammar/RFC5280.g:5724:4: tagInt3
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt3_in_tag013243);
        	        	        tagInt31950=tagInt3(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt31950.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=3;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 4:
        	        	    // Grammar/RFC5280.g:5725:4: tagInt4
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt4_in_tag013250);
        	        	        tagInt41951=tagInt4(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt41951.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=4;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 5:
        	        	    // Grammar/RFC5280.g:5726:4: tagInt5
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt5_in_tag013257);
        	        	        tagInt51952=tagInt5(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt51952.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=5;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 6:
        	        	    // Grammar/RFC5280.g:5727:4: tagInt6
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt6_in_tag013264);
        	        	        tagInt61953=tagInt6(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt61953.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=6;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 7:
        	        	    // Grammar/RFC5280.g:5728:4: tagInt7
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt7_in_tag013271);
        	        	        tagInt71954=tagInt7(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt71954.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=7;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 8:
        	        	    // Grammar/RFC5280.g:5729:4: tagInt8
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt8_in_tag013278);
        	        	        tagInt81955=tagInt8(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt81955.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=8;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 9:
        	        	    // Grammar/RFC5280.g:5730:4: tagInt9
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt9_in_tag013285);
        	        	        tagInt91956=tagInt9(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt91956.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=9;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 10:
        	        	    // Grammar/RFC5280.g:5731:4: tagInt10
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt10_in_tag013292);
        	        	        tagInt101957=tagInt10(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt101957.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=10;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 11:
        	        	    // Grammar/RFC5280.g:5732:4: tagInt11
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt11_in_tag013299);
        	        	        tagInt111958=tagInt11(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt111958.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=11;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 12:
        	        	    // Grammar/RFC5280.g:5733:4: tagInt12
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt12_in_tag013306);
        	        	        tagInt121959=tagInt12(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt121959.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=12;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 13:
        	        	    // Grammar/RFC5280.g:5734:4: tagInt13
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt13_in_tag013313);
        	        	        tagInt131960=tagInt13(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt131960.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=13;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 14:
        	        	    // Grammar/RFC5280.g:5735:4: tagInt14
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt14_in_tag013320);
        	        	        tagInt141961=tagInt14(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt141961.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=14;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 15:
        	        	    // Grammar/RFC5280.g:5736:4: tagInt15
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt15_in_tag013327);
        	        	        tagInt151962=tagInt15(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt151962.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=15;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 16:
        	        	    // Grammar/RFC5280.g:5737:4: tagInt16
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt16_in_tag013334);
        	        	        tagInt161963=tagInt16(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt161963.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=16;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 17:
        	        	    // Grammar/RFC5280.g:5738:4: tagInt17
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt17_in_tag013341);
        	        	        tagInt171964=tagInt17(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt171964.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=17;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 18:
        	        	    // Grammar/RFC5280.g:5739:4: tagInt18
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt18_in_tag013348);
        	        	        tagInt181965=tagInt18(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt181965.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=18;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 19:
        	        	    // Grammar/RFC5280.g:5740:4: tagInt19
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt19_in_tag013355);
        	        	        tagInt191966=tagInt19(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt191966.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=19;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 20:
        	        	    // Grammar/RFC5280.g:5741:4: tagInt20
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt20_in_tag013362);
        	        	        tagInt201967=tagInt20(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt201967.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=20;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 21:
        	        	    // Grammar/RFC5280.g:5742:4: tagInt21
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt21_in_tag013369);
        	        	        tagInt211968=tagInt21(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt211968.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=21;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 22:
        	        	    // Grammar/RFC5280.g:5743:4: tagInt22
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt22_in_tag013376);
        	        	        tagInt221969=tagInt22(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt221969.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=22;
        	        	        }


        	        	    }
        	        	    break;
        	        	case 23:
        	        	    // Grammar/RFC5280.g:5744:4: tagInt23
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_tagInt23_in_tag013383);
        	        	        tagInt231970=tagInt23(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruletag0Ex;
        	        	        }

        	        	        ADAPTOR->addChild(ADAPTOR, root_0, tagInt231970.tree);

        	        	        {
        	        	            retval.text
        	        	            ->value=malloc(1);retval.text
        	        	            ->value[1]=23;
        	        	        }


        	        	    }
        	        	    break;

        	            }
        	        }

        	        {

        	            		retval.text
        	            ->length = 1;
        	            		
        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletag0Ex; /* Prevent compiler warnings */
    ruletag0Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tag0 */

/**
 * $ANTLR start onlyTag0
 * Grammar/RFC5280.g:5751:1: onlyTag0 returns [tag_type *text] : Tag0 val ;
 */
static RFC5280Parser_onlyTag0_return
onlyTag0(pRFC5280Parser ctx)
{
    RFC5280Parser_onlyTag0_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Tag01971;
    RFC5280Parser_val_return val1972;
    #undef	RETURN_TYPE_val1972
    #define	RETURN_TYPE_val1972 RFC5280Parser_val_return

    pANTLR3_BASE_TREE Tag01971_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Tag01971       = NULL;
    val1972.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Tag01971_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5752:2: ( Tag0 val )
        // Grammar/RFC5280.g:5752:4: Tag0 val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            Tag01971 = (pANTLR3_COMMON_TOKEN) MATCHT(Tag0, &FOLLOW_Tag0_in_onlyTag013409);
            if  (HASEXCEPTION())
            {
                goto ruleonlyTag0Ex;
            }

            Tag01971_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Tag01971));
            ADAPTOR->addChild(ADAPTOR, root_0, Tag01971_tree);


            FOLLOWPUSH(FOLLOW_val_in_onlyTag013411);
            val1972=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleonlyTag0Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1972.tree);

            {

                		printf("it's tag0 \n");
                		mpz_t length;
                		mpz_init_set_ui(length,0);		
                		primitive_type((Tag01971->getText(Tag01971))->chars,length);
                		
                retval.text=malloc(sizeof(tag_type));

                		retval.text
                ->value = val1972.text
                ;
                		retval.text
                ->length = mpz_get_ui(length);
                		mpz_clear(length);
                		
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleonlyTag0Ex; /* Prevent compiler warnings */
    ruleonlyTag0Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
    return retval;
}
/* $ANTLR end onlyTag0 */

/**
 * $ANTLR start constructedTag1
 * Grammar/RFC5280.g:5763:1: constructedTag1 : ConstructedTag1 ;
 */
static RFC5280Parser_constructedTag1_return
constructedTag1(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedTag1_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedTag11973;

    pANTLR3_BASE_TREE ConstructedTag11973_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedTag11973       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedTag11973_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5766:2: ( ConstructedTag1 )
        // Grammar/RFC5280.g:5766:3: ConstructedTag1
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedTag11973 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedTag1, &FOLLOW_ConstructedTag1_in_constructedTag113429);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedTag1Ex;
            }

            ConstructedTag11973_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedTag11973));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedTag11973_tree);


            {

                		constructed_type((ConstructedTag11973->getText(ConstructedTag11973))->chars);
                		printf("it's tag1 constructed \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedTag1Ex; /* Prevent compiler warnings */
    ruleconstructedTag1Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedTag1 */

/**
 * $ANTLR start tag1
 * Grammar/RFC5280.g:5771:1: tag1 returns [tag_type* text] : Tag1 val ;
 */
static RFC5280Parser_tag1_return
tag1(pRFC5280Parser ctx)
{
    RFC5280Parser_tag1_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Tag11974;
    RFC5280Parser_val_return val1975;
    #undef	RETURN_TYPE_val1975
    #define	RETURN_TYPE_val1975 RFC5280Parser_val_return

    pANTLR3_BASE_TREE Tag11974_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Tag11974       = NULL;
    val1975.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Tag11974_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5774:2: ( Tag1 val )
        // Grammar/RFC5280.g:5774:3: Tag1 val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Tag11974 = (pANTLR3_COMMON_TOKEN) MATCHT(Tag1, &FOLLOW_Tag1_in_tag113448);
            if  (HASEXCEPTION())
            {
                goto ruletag1Ex;
            }

            Tag11974_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Tag11974));
            ADAPTOR->addChild(ADAPTOR, root_0, Tag11974_tree);


            FOLLOWPUSH(FOLLOW_val_in_tag113451);
            val1975=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletag1Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1975.tree);

            {

                		printf("it's tag1 \n");
                		mpz_t length;
                		mpz_init_set_ui(length,0);		
                		primitive_type((Tag11974->getText(Tag11974))->chars,length);
                		tag_type *tag = malloc(sizeof(tag_type));
                		tag->value = 
                val1975.text
                ;
                		tag->length = mpz_get_ui(length);
                		mpz_clear(length);
                		retval.text= tag ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletag1Ex; /* Prevent compiler warnings */
    ruletag1Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tag1 */

/**
 * $ANTLR start appTag1
 * Grammar/RFC5280.g:5806:1: appTag1 : AppTag1 ;
 */
static RFC5280Parser_appTag1_return
appTag1(pRFC5280Parser ctx)
{
    RFC5280Parser_appTag1_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AppTag11976;

    pANTLR3_BASE_TREE AppTag11976_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    AppTag11976       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    AppTag11976_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5809:2: ( AppTag1 )
        // Grammar/RFC5280.g:5809:3: AppTag1
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            AppTag11976 = (pANTLR3_COMMON_TOKEN) MATCHT(AppTag1, &FOLLOW_AppTag1_in_appTag113474);
            if  (HASEXCEPTION())
            {
                goto ruleappTag1Ex;
            }

            AppTag11976_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AppTag11976));
            ADAPTOR->addChild(ADAPTOR, root_0, AppTag11976_tree);


            {

                	constructed_type((AppTag11976->getText(AppTag11976))->chars);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleappTag1Ex; /* Prevent compiler warnings */
    ruleappTag1Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end appTag1 */

/**
 * $ANTLR start appTag2
 * Grammar/RFC5280.g:5815:1: appTag2 : AppTag2 ;
 */
static RFC5280Parser_appTag2_return
appTag2(pRFC5280Parser ctx)
{
    RFC5280Parser_appTag2_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AppTag21977;

    pANTLR3_BASE_TREE AppTag21977_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    AppTag21977       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    AppTag21977_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5818:2: ( AppTag2 )
        // Grammar/RFC5280.g:5818:3: AppTag2
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            AppTag21977 = (pANTLR3_COMMON_TOKEN) MATCHT(AppTag2, &FOLLOW_AppTag2_in_appTag213491);
            if  (HASEXCEPTION())
            {
                goto ruleappTag2Ex;
            }

            AppTag21977_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AppTag21977));
            ADAPTOR->addChild(ADAPTOR, root_0, AppTag21977_tree);


            {

                	constructed_type((AppTag21977->getText(AppTag21977))->chars);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleappTag2Ex; /* Prevent compiler warnings */
    ruleappTag2Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end appTag2 */

/**
 * $ANTLR start constructedTag2
 * Grammar/RFC5280.g:5825:1: constructedTag2 : ConstructedTag2 ;
 */
static RFC5280Parser_constructedTag2_return
constructedTag2(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedTag2_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedTag21978;

    pANTLR3_BASE_TREE ConstructedTag21978_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedTag21978       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedTag21978_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5828:2: ( ConstructedTag2 )
        // Grammar/RFC5280.g:5828:3: ConstructedTag2
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedTag21978 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedTag2, &FOLLOW_ConstructedTag2_in_constructedTag213509);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedTag2Ex;
            }

            ConstructedTag21978_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedTag21978));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedTag21978_tree);


            {

                		constructed_type((ConstructedTag21978->getText(ConstructedTag21978))->chars);
                		printf("it's tag2 constructed \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedTag2Ex; /* Prevent compiler warnings */
    ruleconstructedTag2Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedTag2 */

/**
 * $ANTLR start tag2
 * Grammar/RFC5280.g:5833:1: tag2 returns [tag_type* text] : Tag2 val ;
 */
static RFC5280Parser_tag2_return
tag2(pRFC5280Parser ctx)
{
    RFC5280Parser_tag2_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Tag21979;
    RFC5280Parser_val_return val1980;
    #undef	RETURN_TYPE_val1980
    #define	RETURN_TYPE_val1980 RFC5280Parser_val_return

    pANTLR3_BASE_TREE Tag21979_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Tag21979       = NULL;
    val1980.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Tag21979_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5836:2: ( Tag2 val )
        // Grammar/RFC5280.g:5836:3: Tag2 val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Tag21979 = (pANTLR3_COMMON_TOKEN) MATCHT(Tag2, &FOLLOW_Tag2_in_tag213528);
            if  (HASEXCEPTION())
            {
                goto ruletag2Ex;
            }

            Tag21979_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Tag21979));
            ADAPTOR->addChild(ADAPTOR, root_0, Tag21979_tree);


            FOLLOWPUSH(FOLLOW_val_in_tag213531);
            val1980=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletag2Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1980.tree);

            {

                		printf("it's tag2 \n");
                		mpz_t length;
                		mpz_init_set_ui(length,0);		
                		primitive_type((Tag21979->getText(Tag21979))->chars,length);
                		tag_type *tag = malloc(sizeof(tag_type));
                		tag->value = 
                val1980.text
                ;
                		tag->length = mpz_get_ui(length);
                		mpz_clear(length);
                		retval.text= tag ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletag2Ex; /* Prevent compiler warnings */
    ruletag2Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tag2 */

/**
 * $ANTLR start constructedTag3
 * Grammar/RFC5280.g:5868:1: constructedTag3 : ConstructedTag3 ;
 */
static RFC5280Parser_constructedTag3_return
constructedTag3(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedTag3_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedTag31981;

    pANTLR3_BASE_TREE ConstructedTag31981_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedTag31981       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedTag31981_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5871:2: ( ConstructedTag3 )
        // Grammar/RFC5280.g:5871:3: ConstructedTag3
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedTag31981 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedTag3, &FOLLOW_ConstructedTag3_in_constructedTag313553);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedTag3Ex;
            }

            ConstructedTag31981_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedTag31981));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedTag31981_tree);


            {

                		constructed_type((ConstructedTag31981->getText(ConstructedTag31981))->chars);
                		printf("it's tag3 constructed \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedTag3Ex; /* Prevent compiler warnings */
    ruleconstructedTag3Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedTag3 */

/**
 * $ANTLR start tag3
 * Grammar/RFC5280.g:5876:1: tag3 returns [tag_type* text] : Tag3 val ;
 */
static RFC5280Parser_tag3_return
tag3(pRFC5280Parser ctx)
{
    RFC5280Parser_tag3_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Tag31982;
    RFC5280Parser_val_return val1983;
    #undef	RETURN_TYPE_val1983
    #define	RETURN_TYPE_val1983 RFC5280Parser_val_return

    pANTLR3_BASE_TREE Tag31982_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Tag31982       = NULL;
    val1983.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Tag31982_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5879:2: ( Tag3 val )
        // Grammar/RFC5280.g:5879:3: Tag3 val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Tag31982 = (pANTLR3_COMMON_TOKEN) MATCHT(Tag3, &FOLLOW_Tag3_in_tag313572);
            if  (HASEXCEPTION())
            {
                goto ruletag3Ex;
            }

            Tag31982_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Tag31982));
            ADAPTOR->addChild(ADAPTOR, root_0, Tag31982_tree);


            FOLLOWPUSH(FOLLOW_val_in_tag313575);
            val1983=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletag3Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1983.tree);

            {

                		printf("it's tag3 \n");	
                		mpz_t length;
                		mpz_init_set_ui(length,0);	
                		primitive_type((Tag31982->getText(Tag31982))->chars,length);
                		tag_type *tag = malloc(sizeof(tag_type));
                		tag->value = 
                val1983.text
                ;
                		tag->length = mpz_get_ui(length);
                		mpz_clear(length);
                		retval.text= tag ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletag3Ex; /* Prevent compiler warnings */
    ruletag3Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tag3 */

/**
 * $ANTLR start constructedTag4
 * Grammar/RFC5280.g:5894:1: constructedTag4 : ConstructedTag4 ;
 */
static RFC5280Parser_constructedTag4_return
constructedTag4(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedTag4_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedTag41984;

    pANTLR3_BASE_TREE ConstructedTag41984_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedTag41984       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedTag41984_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5897:2: ( ConstructedTag4 )
        // Grammar/RFC5280.g:5897:3: ConstructedTag4
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedTag41984 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedTag4, &FOLLOW_ConstructedTag4_in_constructedTag413596);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedTag4Ex;
            }

            ConstructedTag41984_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedTag41984));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedTag41984_tree);


            {

                		constructed_type((ConstructedTag41984->getText(ConstructedTag41984))->chars);
                		printf("it's tag4 constructed \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedTag4Ex; /* Prevent compiler warnings */
    ruleconstructedTag4Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedTag4 */

/**
 * $ANTLR start tag4
 * Grammar/RFC5280.g:5902:1: tag4 returns [tag_type* text] : Tag4 val ;
 */
static RFC5280Parser_tag4_return
tag4(pRFC5280Parser ctx)
{
    RFC5280Parser_tag4_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Tag41985;
    RFC5280Parser_val_return val1986;
    #undef	RETURN_TYPE_val1986
    #define	RETURN_TYPE_val1986 RFC5280Parser_val_return

    pANTLR3_BASE_TREE Tag41985_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Tag41985       = NULL;
    val1986.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Tag41985_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5905:2: ( Tag4 val )
        // Grammar/RFC5280.g:5905:3: Tag4 val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Tag41985 = (pANTLR3_COMMON_TOKEN) MATCHT(Tag4, &FOLLOW_Tag4_in_tag413615);
            if  (HASEXCEPTION())
            {
                goto ruletag4Ex;
            }

            Tag41985_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Tag41985));
            ADAPTOR->addChild(ADAPTOR, root_0, Tag41985_tree);


            FOLLOWPUSH(FOLLOW_val_in_tag413618);
            val1986=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletag4Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1986.tree);

            {

                		printf("it's tag4 \n");		
                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((Tag41985->getText(Tag41985))->chars,length);
                		tag_type *tag = malloc(sizeof(tag_type));
                		tag->value = 
                val1986.text
                ;
                		tag->length = mpz_get_ui(length);
                		mpz_clear(length);
                		retval.text= tag ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletag4Ex; /* Prevent compiler warnings */
    ruletag4Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tag4 */

/**
 * $ANTLR start constructedTag5
 * Grammar/RFC5280.g:5920:1: constructedTag5 : ConstructedTag5 ;
 */
static RFC5280Parser_constructedTag5_return
constructedTag5(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedTag5_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedTag51987;

    pANTLR3_BASE_TREE ConstructedTag51987_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedTag51987       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedTag51987_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5923:2: ( ConstructedTag5 )
        // Grammar/RFC5280.g:5923:3: ConstructedTag5
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedTag51987 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedTag5, &FOLLOW_ConstructedTag5_in_constructedTag513639);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedTag5Ex;
            }

            ConstructedTag51987_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedTag51987));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedTag51987_tree);


            {

                		constructed_type((ConstructedTag51987->getText(ConstructedTag51987))->chars);
                		printf("it's tag5 constructed \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedTag5Ex; /* Prevent compiler warnings */
    ruleconstructedTag5Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedTag5 */

/**
 * $ANTLR start tag5
 * Grammar/RFC5280.g:5928:1: tag5 returns [tag_type* text] : Tag5 val ;
 */
static RFC5280Parser_tag5_return
tag5(pRFC5280Parser ctx)
{
    RFC5280Parser_tag5_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Tag51988;
    RFC5280Parser_val_return val1989;
    #undef	RETURN_TYPE_val1989
    #define	RETURN_TYPE_val1989 RFC5280Parser_val_return

    pANTLR3_BASE_TREE Tag51988_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Tag51988       = NULL;
    val1989.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Tag51988_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5931:2: ( Tag5 val )
        // Grammar/RFC5280.g:5931:3: Tag5 val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Tag51988 = (pANTLR3_COMMON_TOKEN) MATCHT(Tag5, &FOLLOW_Tag5_in_tag513658);
            if  (HASEXCEPTION())
            {
                goto ruletag5Ex;
            }

            Tag51988_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Tag51988));
            ADAPTOR->addChild(ADAPTOR, root_0, Tag51988_tree);


            FOLLOWPUSH(FOLLOW_val_in_tag513661);
            val1989=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletag5Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1989.tree);

            {

                		printf("it's tag5 \n");		
                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((Tag51988->getText(Tag51988))->chars,length);
                		tag_type *tag = malloc(sizeof(tag_type));
                		tag->value = 
                val1989.text
                ;
                		tag->length = mpz_get_ui(length);
                		mpz_clear(length);
                		retval.text= tag ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletag5Ex; /* Prevent compiler warnings */
    ruletag5Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tag5 */

/**
 * $ANTLR start constructedTag6
 * Grammar/RFC5280.g:5946:1: constructedTag6 : ConstructedTag6 ;
 */
static RFC5280Parser_constructedTag6_return
constructedTag6(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedTag6_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedTag61990;

    pANTLR3_BASE_TREE ConstructedTag61990_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedTag61990       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedTag61990_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5949:2: ( ConstructedTag6 )
        // Grammar/RFC5280.g:5949:3: ConstructedTag6
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedTag61990 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedTag6, &FOLLOW_ConstructedTag6_in_constructedTag613682);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedTag6Ex;
            }

            ConstructedTag61990_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedTag61990));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedTag61990_tree);


            {

                		constructed_type((ConstructedTag61990->getText(ConstructedTag61990))->chars);
                		printf("it's tag6 constructed \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedTag6Ex; /* Prevent compiler warnings */
    ruleconstructedTag6Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedTag6 */

/**
 * $ANTLR start tag6
 * Grammar/RFC5280.g:5954:1: tag6 returns [tag_type* text] : Tag6 val ;
 */
static RFC5280Parser_tag6_return
tag6(pRFC5280Parser ctx)
{
    RFC5280Parser_tag6_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Tag61991;
    RFC5280Parser_val_return val1992;
    #undef	RETURN_TYPE_val1992
    #define	RETURN_TYPE_val1992 RFC5280Parser_val_return

    pANTLR3_BASE_TREE Tag61991_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Tag61991       = NULL;
    val1992.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Tag61991_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5957:2: ( Tag6 val )
        // Grammar/RFC5280.g:5957:3: Tag6 val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Tag61991 = (pANTLR3_COMMON_TOKEN) MATCHT(Tag6, &FOLLOW_Tag6_in_tag613701);
            if  (HASEXCEPTION())
            {
                goto ruletag6Ex;
            }

            Tag61991_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Tag61991));
            ADAPTOR->addChild(ADAPTOR, root_0, Tag61991_tree);


            FOLLOWPUSH(FOLLOW_val_in_tag613704);
            val1992=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletag6Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1992.tree);

            {

                		printf("it's tag6 \n");		
                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((Tag61991->getText(Tag61991))->chars,length);
                		tag_type *tag = malloc(sizeof(tag_type));
                		tag->value = 
                val1992.text
                ;
                		tag->length = mpz_get_ui(length);
                		mpz_clear(length);
                		retval.text= tag ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletag6Ex; /* Prevent compiler warnings */
    ruletag6Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tag6 */

/**
 * $ANTLR start constructedTag7
 * Grammar/RFC5280.g:5972:1: constructedTag7 : ConstructedTag7 ;
 */
static RFC5280Parser_constructedTag7_return
constructedTag7(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedTag7_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedTag71993;

    pANTLR3_BASE_TREE ConstructedTag71993_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedTag71993       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedTag71993_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5975:2: ( ConstructedTag7 )
        // Grammar/RFC5280.g:5975:3: ConstructedTag7
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedTag71993 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedTag7, &FOLLOW_ConstructedTag7_in_constructedTag713725);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedTag7Ex;
            }

            ConstructedTag71993_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedTag71993));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedTag71993_tree);


            {

                		constructed_type((ConstructedTag71993->getText(ConstructedTag71993))->chars);
                		printf("it's tag7 constructed \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedTag7Ex; /* Prevent compiler warnings */
    ruleconstructedTag7Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedTag7 */

/**
 * $ANTLR start tag7
 * Grammar/RFC5280.g:5980:1: tag7 returns [tag_type* text] : Tag7 val ;
 */
static RFC5280Parser_tag7_return
tag7(pRFC5280Parser ctx)
{
    RFC5280Parser_tag7_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Tag71994;
    RFC5280Parser_val_return val1995;
    #undef	RETURN_TYPE_val1995
    #define	RETURN_TYPE_val1995 RFC5280Parser_val_return

    pANTLR3_BASE_TREE Tag71994_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Tag71994       = NULL;
    val1995.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Tag71994_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:5983:2: ( Tag7 val )
        // Grammar/RFC5280.g:5983:3: Tag7 val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Tag71994 = (pANTLR3_COMMON_TOKEN) MATCHT(Tag7, &FOLLOW_Tag7_in_tag713746);
            if  (HASEXCEPTION())
            {
                goto ruletag7Ex;
            }

            Tag71994_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Tag71994));
            ADAPTOR->addChild(ADAPTOR, root_0, Tag71994_tree);


            FOLLOWPUSH(FOLLOW_val_in_tag713749);
            val1995=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletag7Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1995.tree);

            {

                		printf("it's tag7 \n");		
                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((Tag71994->getText(Tag71994))->chars,length);
                		tag_type *tag = malloc(sizeof(tag_type));
                		tag->value = 
                val1995.text
                ;
                		tag->length = mpz_get_ui(length);
                		mpz_clear(length);
                		retval.text= tag ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletag7Ex; /* Prevent compiler warnings */
    ruletag7Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tag7 */

/**
 * $ANTLR start constructedTag8
 * Grammar/RFC5280.g:5998:1: constructedTag8 : ConstructedTag8 ;
 */
static RFC5280Parser_constructedTag8_return
constructedTag8(pRFC5280Parser ctx)
{
    RFC5280Parser_constructedTag8_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    ConstructedTag81996;

    pANTLR3_BASE_TREE ConstructedTag81996_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    ConstructedTag81996       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    ConstructedTag81996_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6001:2: ( ConstructedTag8 )
        // Grammar/RFC5280.g:6001:3: ConstructedTag8
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            ConstructedTag81996 = (pANTLR3_COMMON_TOKEN) MATCHT(ConstructedTag8, &FOLLOW_ConstructedTag8_in_constructedTag813770);
            if  (HASEXCEPTION())
            {
                goto ruleconstructedTag8Ex;
            }

            ConstructedTag81996_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ConstructedTag81996));
            ADAPTOR->addChild(ADAPTOR, root_0, ConstructedTag81996_tree);


            {

                		constructed_type((ConstructedTag81996->getText(ConstructedTag81996))->chars);
                		printf("it's tag8 constructed \n");
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconstructedTag8Ex; /* Prevent compiler warnings */
    ruleconstructedTag8Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end constructedTag8 */

/**
 * $ANTLR start tag8
 * Grammar/RFC5280.g:6006:1: tag8 returns [tag_type* text] : Tag8 val ;
 */
static RFC5280Parser_tag8_return
tag8(pRFC5280Parser ctx)
{
    RFC5280Parser_tag8_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    Tag81997;
    RFC5280Parser_val_return val1998;
    #undef	RETURN_TYPE_val1998
    #define	RETURN_TYPE_val1998 RFC5280Parser_val_return

    pANTLR3_BASE_TREE Tag81997_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    Tag81997       = NULL;
    val1998.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    Tag81997_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6009:2: ( Tag8 val )
        // Grammar/RFC5280.g:6009:3: Tag8 val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            Tag81997 = (pANTLR3_COMMON_TOKEN) MATCHT(Tag8, &FOLLOW_Tag8_in_tag813789);
            if  (HASEXCEPTION())
            {
                goto ruletag8Ex;
            }

            Tag81997_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, Tag81997));
            ADAPTOR->addChild(ADAPTOR, root_0, Tag81997_tree);


            FOLLOWPUSH(FOLLOW_val_in_tag813792);
            val1998=val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletag8Ex;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, val1998.tree);

            {

                		printf("it's tag8 \n");
                		mpz_t length;
                		mpz_init_set_ui(length,0);
                		primitive_type((Tag81997->getText(Tag81997))->chars,length);
                		tag_type *tag = malloc(sizeof(tag_type));
                		tag->value = 
                val1998.text
                ;
                		tag->length = mpz_get_ui(length);
                		mpz_clear(length);
                		retval.text= tag ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletag8Ex; /* Prevent compiler warnings */
    ruletag8Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tag8 */

/**
 * $ANTLR start tagInt1
 * Grammar/RFC5280.g:6023:1: tagInt1 : TagInt1 ;
 */
static RFC5280Parser_tagInt1_return
tagInt1(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt1_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt11999;

    pANTLR3_BASE_TREE TagInt11999_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt11999       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt11999_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6026:2: ( TagInt1 )
        // Grammar/RFC5280.g:6026:3: TagInt1
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt11999 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt1, &FOLLOW_TagInt1_in_tagInt113812);
            if  (HASEXCEPTION())
            {
                goto ruletagInt1Ex;
            }

            TagInt11999_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt11999));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt11999_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt1Ex; /* Prevent compiler warnings */
    ruletagInt1Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt1 */

/**
 * $ANTLR start tagInt2
 * Grammar/RFC5280.g:6029:1: tagInt2 : TagInt2 ;
 */
static RFC5280Parser_tagInt2_return
tagInt2(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt2_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt22000;

    pANTLR3_BASE_TREE TagInt22000_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt22000       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt22000_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6032:2: ( TagInt2 )
        // Grammar/RFC5280.g:6032:3: TagInt2
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt22000 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt2, &FOLLOW_TagInt2_in_tagInt213828);
            if  (HASEXCEPTION())
            {
                goto ruletagInt2Ex;
            }

            TagInt22000_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt22000));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt22000_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt2Ex; /* Prevent compiler warnings */
    ruletagInt2Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt2 */

/**
 * $ANTLR start tagInt3
 * Grammar/RFC5280.g:6035:1: tagInt3 : TagInt3 ;
 */
static RFC5280Parser_tagInt3_return
tagInt3(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt3_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt32001;

    pANTLR3_BASE_TREE TagInt32001_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt32001       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt32001_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6038:2: ( TagInt3 )
        // Grammar/RFC5280.g:6038:3: TagInt3
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt32001 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt3, &FOLLOW_TagInt3_in_tagInt313844);
            if  (HASEXCEPTION())
            {
                goto ruletagInt3Ex;
            }

            TagInt32001_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt32001));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt32001_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt3Ex; /* Prevent compiler warnings */
    ruletagInt3Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt3 */

/**
 * $ANTLR start tagInt4
 * Grammar/RFC5280.g:6041:1: tagInt4 : TagInt4 ;
 */
static RFC5280Parser_tagInt4_return
tagInt4(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt4_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt42002;

    pANTLR3_BASE_TREE TagInt42002_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt42002       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt42002_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6044:2: ( TagInt4 )
        // Grammar/RFC5280.g:6044:3: TagInt4
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt42002 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt4, &FOLLOW_TagInt4_in_tagInt413860);
            if  (HASEXCEPTION())
            {
                goto ruletagInt4Ex;
            }

            TagInt42002_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt42002));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt42002_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt4Ex; /* Prevent compiler warnings */
    ruletagInt4Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt4 */

/**
 * $ANTLR start tagInt5
 * Grammar/RFC5280.g:6047:1: tagInt5 : TagInt5 ;
 */
static RFC5280Parser_tagInt5_return
tagInt5(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt5_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt52003;

    pANTLR3_BASE_TREE TagInt52003_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt52003       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt52003_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6050:2: ( TagInt5 )
        // Grammar/RFC5280.g:6050:3: TagInt5
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt52003 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt5, &FOLLOW_TagInt5_in_tagInt513876);
            if  (HASEXCEPTION())
            {
                goto ruletagInt5Ex;
            }

            TagInt52003_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt52003));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt52003_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt5Ex; /* Prevent compiler warnings */
    ruletagInt5Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt5 */

/**
 * $ANTLR start tagInt6
 * Grammar/RFC5280.g:6053:1: tagInt6 : TagInt6 ;
 */
static RFC5280Parser_tagInt6_return
tagInt6(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt6_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt62004;

    pANTLR3_BASE_TREE TagInt62004_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt62004       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt62004_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6056:2: ( TagInt6 )
        // Grammar/RFC5280.g:6056:3: TagInt6
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt62004 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt6, &FOLLOW_TagInt6_in_tagInt613892);
            if  (HASEXCEPTION())
            {
                goto ruletagInt6Ex;
            }

            TagInt62004_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt62004));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt62004_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt6Ex; /* Prevent compiler warnings */
    ruletagInt6Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt6 */

/**
 * $ANTLR start tagInt7
 * Grammar/RFC5280.g:6059:1: tagInt7 : TagInt7 ;
 */
static RFC5280Parser_tagInt7_return
tagInt7(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt7_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt72005;

    pANTLR3_BASE_TREE TagInt72005_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt72005       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt72005_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6062:2: ( TagInt7 )
        // Grammar/RFC5280.g:6062:3: TagInt7
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt72005 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt7, &FOLLOW_TagInt7_in_tagInt713908);
            if  (HASEXCEPTION())
            {
                goto ruletagInt7Ex;
            }

            TagInt72005_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt72005));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt72005_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt7Ex; /* Prevent compiler warnings */
    ruletagInt7Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt7 */

/**
 * $ANTLR start tagInt8
 * Grammar/RFC5280.g:6065:1: tagInt8 : TagInt8 ;
 */
static RFC5280Parser_tagInt8_return
tagInt8(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt8_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt82006;

    pANTLR3_BASE_TREE TagInt82006_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt82006       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt82006_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6068:2: ( TagInt8 )
        // Grammar/RFC5280.g:6068:3: TagInt8
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt82006 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt8, &FOLLOW_TagInt8_in_tagInt813924);
            if  (HASEXCEPTION())
            {
                goto ruletagInt8Ex;
            }

            TagInt82006_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt82006));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt82006_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt8Ex; /* Prevent compiler warnings */
    ruletagInt8Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt8 */

/**
 * $ANTLR start tagInt9
 * Grammar/RFC5280.g:6071:1: tagInt9 : TagInt9 ;
 */
static RFC5280Parser_tagInt9_return
tagInt9(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt9_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt92007;

    pANTLR3_BASE_TREE TagInt92007_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt92007       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt92007_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6074:2: ( TagInt9 )
        // Grammar/RFC5280.g:6074:3: TagInt9
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt92007 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt9, &FOLLOW_TagInt9_in_tagInt913940);
            if  (HASEXCEPTION())
            {
                goto ruletagInt9Ex;
            }

            TagInt92007_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt92007));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt92007_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt9Ex; /* Prevent compiler warnings */
    ruletagInt9Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt9 */

/**
 * $ANTLR start tagInt10
 * Grammar/RFC5280.g:6077:1: tagInt10 : TagInt10 ;
 */
static RFC5280Parser_tagInt10_return
tagInt10(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt10_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt102008;

    pANTLR3_BASE_TREE TagInt102008_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt102008       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt102008_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6080:2: ( TagInt10 )
        // Grammar/RFC5280.g:6080:3: TagInt10
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt102008 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt10, &FOLLOW_TagInt10_in_tagInt1013956);
            if  (HASEXCEPTION())
            {
                goto ruletagInt10Ex;
            }

            TagInt102008_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt102008));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt102008_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt10Ex; /* Prevent compiler warnings */
    ruletagInt10Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt10 */

/**
 * $ANTLR start tagInt11
 * Grammar/RFC5280.g:6083:1: tagInt11 : TagInt11 ;
 */
static RFC5280Parser_tagInt11_return
tagInt11(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt11_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt112009;

    pANTLR3_BASE_TREE TagInt112009_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt112009       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt112009_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6086:2: ( TagInt11 )
        // Grammar/RFC5280.g:6086:3: TagInt11
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt112009 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt11, &FOLLOW_TagInt11_in_tagInt1113972);
            if  (HASEXCEPTION())
            {
                goto ruletagInt11Ex;
            }

            TagInt112009_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt112009));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt112009_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt11Ex; /* Prevent compiler warnings */
    ruletagInt11Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt11 */

/**
 * $ANTLR start tagInt12
 * Grammar/RFC5280.g:6089:1: tagInt12 : TagInt12 ;
 */
static RFC5280Parser_tagInt12_return
tagInt12(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt12_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt122010;

    pANTLR3_BASE_TREE TagInt122010_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt122010       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt122010_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6092:2: ( TagInt12 )
        // Grammar/RFC5280.g:6092:3: TagInt12
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt122010 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt12, &FOLLOW_TagInt12_in_tagInt1213988);
            if  (HASEXCEPTION())
            {
                goto ruletagInt12Ex;
            }

            TagInt122010_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt122010));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt122010_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt12Ex; /* Prevent compiler warnings */
    ruletagInt12Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt12 */

/**
 * $ANTLR start tagInt13
 * Grammar/RFC5280.g:6095:1: tagInt13 : TagInt13 ;
 */
static RFC5280Parser_tagInt13_return
tagInt13(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt13_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt132011;

    pANTLR3_BASE_TREE TagInt132011_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt132011       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt132011_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6098:2: ( TagInt13 )
        // Grammar/RFC5280.g:6098:3: TagInt13
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt132011 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt13, &FOLLOW_TagInt13_in_tagInt1314004);
            if  (HASEXCEPTION())
            {
                goto ruletagInt13Ex;
            }

            TagInt132011_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt132011));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt132011_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt13Ex; /* Prevent compiler warnings */
    ruletagInt13Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt13 */

/**
 * $ANTLR start tagInt14
 * Grammar/RFC5280.g:6101:1: tagInt14 : TagInt14 ;
 */
static RFC5280Parser_tagInt14_return
tagInt14(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt14_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt142012;

    pANTLR3_BASE_TREE TagInt142012_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt142012       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt142012_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6104:2: ( TagInt14 )
        // Grammar/RFC5280.g:6104:3: TagInt14
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt142012 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt14, &FOLLOW_TagInt14_in_tagInt1414020);
            if  (HASEXCEPTION())
            {
                goto ruletagInt14Ex;
            }

            TagInt142012_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt142012));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt142012_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt14Ex; /* Prevent compiler warnings */
    ruletagInt14Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt14 */

/**
 * $ANTLR start tagInt15
 * Grammar/RFC5280.g:6107:1: tagInt15 : TagInt15 ;
 */
static RFC5280Parser_tagInt15_return
tagInt15(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt15_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt152013;

    pANTLR3_BASE_TREE TagInt152013_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt152013       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt152013_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6110:2: ( TagInt15 )
        // Grammar/RFC5280.g:6110:3: TagInt15
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt152013 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt15, &FOLLOW_TagInt15_in_tagInt1514036);
            if  (HASEXCEPTION())
            {
                goto ruletagInt15Ex;
            }

            TagInt152013_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt152013));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt152013_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt15Ex; /* Prevent compiler warnings */
    ruletagInt15Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt15 */

/**
 * $ANTLR start tagInt16
 * Grammar/RFC5280.g:6113:1: tagInt16 : TagInt16 ;
 */
static RFC5280Parser_tagInt16_return
tagInt16(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt16_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt162014;

    pANTLR3_BASE_TREE TagInt162014_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt162014       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt162014_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6116:2: ( TagInt16 )
        // Grammar/RFC5280.g:6116:3: TagInt16
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt162014 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt16, &FOLLOW_TagInt16_in_tagInt1614052);
            if  (HASEXCEPTION())
            {
                goto ruletagInt16Ex;
            }

            TagInt162014_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt162014));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt162014_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt16Ex; /* Prevent compiler warnings */
    ruletagInt16Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt16 */

/**
 * $ANTLR start tagInt17
 * Grammar/RFC5280.g:6119:1: tagInt17 : TagInt17 ;
 */
static RFC5280Parser_tagInt17_return
tagInt17(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt17_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt172015;

    pANTLR3_BASE_TREE TagInt172015_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt172015       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt172015_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6122:2: ( TagInt17 )
        // Grammar/RFC5280.g:6122:3: TagInt17
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt172015 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt17, &FOLLOW_TagInt17_in_tagInt1714068);
            if  (HASEXCEPTION())
            {
                goto ruletagInt17Ex;
            }

            TagInt172015_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt172015));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt172015_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt17Ex; /* Prevent compiler warnings */
    ruletagInt17Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt17 */

/**
 * $ANTLR start tagInt18
 * Grammar/RFC5280.g:6125:1: tagInt18 : TagInt18 ;
 */
static RFC5280Parser_tagInt18_return
tagInt18(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt18_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt182016;

    pANTLR3_BASE_TREE TagInt182016_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt182016       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt182016_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6128:2: ( TagInt18 )
        // Grammar/RFC5280.g:6128:3: TagInt18
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt182016 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt18, &FOLLOW_TagInt18_in_tagInt1814084);
            if  (HASEXCEPTION())
            {
                goto ruletagInt18Ex;
            }

            TagInt182016_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt182016));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt182016_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt18Ex; /* Prevent compiler warnings */
    ruletagInt18Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt18 */

/**
 * $ANTLR start tagInt19
 * Grammar/RFC5280.g:6131:1: tagInt19 : TagInt19 ;
 */
static RFC5280Parser_tagInt19_return
tagInt19(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt19_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt192017;

    pANTLR3_BASE_TREE TagInt192017_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt192017       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt192017_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6134:2: ( TagInt19 )
        // Grammar/RFC5280.g:6134:3: TagInt19
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt192017 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt19, &FOLLOW_TagInt19_in_tagInt1914100);
            if  (HASEXCEPTION())
            {
                goto ruletagInt19Ex;
            }

            TagInt192017_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt192017));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt192017_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt19Ex; /* Prevent compiler warnings */
    ruletagInt19Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt19 */

/**
 * $ANTLR start tagInt20
 * Grammar/RFC5280.g:6137:1: tagInt20 : TagInt20 ;
 */
static RFC5280Parser_tagInt20_return
tagInt20(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt20_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt202018;

    pANTLR3_BASE_TREE TagInt202018_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt202018       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt202018_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6140:2: ( TagInt20 )
        // Grammar/RFC5280.g:6140:3: TagInt20
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt202018 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt20, &FOLLOW_TagInt20_in_tagInt2014116);
            if  (HASEXCEPTION())
            {
                goto ruletagInt20Ex;
            }

            TagInt202018_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt202018));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt202018_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt20Ex; /* Prevent compiler warnings */
    ruletagInt20Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt20 */

/**
 * $ANTLR start tagInt21
 * Grammar/RFC5280.g:6143:1: tagInt21 : TagInt21 ;
 */
static RFC5280Parser_tagInt21_return
tagInt21(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt21_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt212019;

    pANTLR3_BASE_TREE TagInt212019_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt212019       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt212019_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6146:2: ( TagInt21 )
        // Grammar/RFC5280.g:6146:3: TagInt21
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt212019 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt21, &FOLLOW_TagInt21_in_tagInt2114132);
            if  (HASEXCEPTION())
            {
                goto ruletagInt21Ex;
            }

            TagInt212019_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt212019));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt212019_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt21Ex; /* Prevent compiler warnings */
    ruletagInt21Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt21 */

/**
 * $ANTLR start tagInt22
 * Grammar/RFC5280.g:6149:1: tagInt22 : TagInt22 ;
 */
static RFC5280Parser_tagInt22_return
tagInt22(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt22_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt222020;

    pANTLR3_BASE_TREE TagInt222020_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt222020       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt222020_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6152:2: ( TagInt22 )
        // Grammar/RFC5280.g:6152:3: TagInt22
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt222020 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt22, &FOLLOW_TagInt22_in_tagInt2214148);
            if  (HASEXCEPTION())
            {
                goto ruletagInt22Ex;
            }

            TagInt222020_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt222020));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt222020_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt22Ex; /* Prevent compiler warnings */
    ruletagInt22Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt22 */

/**
 * $ANTLR start tagInt23
 * Grammar/RFC5280.g:6155:1: tagInt23 : TagInt23 ;
 */
static RFC5280Parser_tagInt23_return
tagInt23(pRFC5280Parser ctx)
{
    RFC5280Parser_tagInt23_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    TagInt232021;

    pANTLR3_BASE_TREE TagInt232021_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    TagInt232021       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    TagInt232021_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6158:2: ( TagInt23 )
        // Grammar/RFC5280.g:6158:3: TagInt23
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            TagInt232021 = (pANTLR3_COMMON_TOKEN) MATCHT(TagInt23, &FOLLOW_TagInt23_in_tagInt2314164);
            if  (HASEXCEPTION())
            {
                goto ruletagInt23Ex;
            }

            TagInt232021_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, TagInt232021));
            ADAPTOR->addChild(ADAPTOR, root_0, TagInt232021_tree);


            {
                entire_encoding(1);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletagInt23Ex; /* Prevent compiler warnings */
    ruletagInt23Ex: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end tagInt23 */

/**
 * $ANTLR start printable
 * Grammar/RFC5280.g:6188:1: printable returns [char* text] : ( PRINTABLE )+ ;
 */
static RFC5280Parser_printable_return
printable(pRFC5280Parser ctx)
{
    RFC5280Parser_printable_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    PRINTABLE2022;

    pANTLR3_BASE_TREE PRINTABLE2022_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    int i=0;char *s = malloc(16);
    PRINTABLE2022       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    PRINTABLE2022_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6192:3: ( ( PRINTABLE )+ )
        // Grammar/RFC5280.g:6192:4: ( PRINTABLE )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                #ifdef DEBUG 
                	push_rule(__func__); 
                	#endif
            }


            // Grammar/RFC5280.g:6194:10: ( PRINTABLE )+
            {
                int cnt479=0;

                for (;;)
                {
                    int alt479=2;
            	switch ( LA(1) )
            	{
            	case PRINTABLE:
            		{
            			alt479=1;
            		}
            	    break;

            	}

            	switch (alt479)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:6194:11: PRINTABLE
            	        {
            	            PRINTABLE2022 = (pANTLR3_COMMON_TOKEN) MATCHT(PRINTABLE, &FOLLOW_PRINTABLE_in_printable14198);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleprintableEx;
            	            }

            	            PRINTABLE2022_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PRINTABLE2022));
            	            ADAPTOR->addChild(ADAPTOR, root_0, PRINTABLE2022_tree);


            	            {
            	                i=store_value((PRINTABLE2022->getText(PRINTABLE2022))->chars,i,&s,(PRINTABLE2022->getText(PRINTABLE2022))->len);
            	                		
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt479 >= 1 )
            		{
            		    goto loop479;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleprintableEx;
            	}
            	cnt479++;
                }
                loop479: ;	/* Jump to here if this rule does not match */
            }

            {
                s[i]=0;retval.text=s;
                printf("it's printable %s \n",retval.text
                );
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprintableEx; /* Prevent compiler warnings */
    ruleprintableEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end printable */

/**
 * $ANTLR start val
 * Grammar/RFC5280.g:6199:1: val returns [char* text] : ( VALUE | PRINTABLE )+ ;
 */
static RFC5280Parser_val_return
val(pRFC5280Parser ctx)
{
    RFC5280Parser_val_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    VALUE2023;
    pANTLR3_COMMON_TOKEN    PRINTABLE2024;

    pANTLR3_BASE_TREE VALUE2023_tree;
    pANTLR3_BASE_TREE PRINTABLE2024_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    int i=0;char *s = malloc(16);
    	#ifdef DEBUG 
    	push_rule(__func__); 
    	#endif
    VALUE2023       = NULL;
    PRINTABLE2024       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    VALUE2023_tree   = NULL;
    PRINTABLE2024_tree   = NULL;


    retval.tree  = NULL;

    {
        // Grammar/RFC5280.g:6205:9: ( ( VALUE | PRINTABLE )+ )
        // Grammar/RFC5280.g:6206:2: ( VALUE | PRINTABLE )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            {
                printf("It's val \n");
            }


            // Grammar/RFC5280.g:6206:27: ( VALUE | PRINTABLE )+
            {
                int cnt480=0;

                for (;;)
                {
                    int alt480=3;
            	switch ( LA(1) )
            	{
            	case VALUE:
            		{
            			alt480=1;
            		}
            	    break;
            	case PRINTABLE:
            		{
            			alt480=2;
            		}
            	    break;

            	}

            	switch (alt480)
            	{
            	    case 1:
            	        // Grammar/RFC5280.g:6206:28: VALUE
            	        {
            	            VALUE2023 = (pANTLR3_COMMON_TOKEN) MATCHT(VALUE, &FOLLOW_VALUE_in_val14233);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulevalEx;
            	            }

            	            VALUE2023_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, VALUE2023));
            	            ADAPTOR->addChild(ADAPTOR, root_0, VALUE2023_tree);


            	            {
            	                i=store_value((VALUE2023->getText(VALUE2023))->chars,i,&s,(VALUE2023->getText(VALUE2023))->len);
            	            }


            	        }
            	        break;
            	    case 2:
            	        // Grammar/RFC5280.g:6207:3: PRINTABLE
            	        {
            	            PRINTABLE2024 = (pANTLR3_COMMON_TOKEN) MATCHT(PRINTABLE, &FOLLOW_PRINTABLE_in_val14238);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulevalEx;
            	            }

            	            PRINTABLE2024_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, PRINTABLE2024));
            	            ADAPTOR->addChild(ADAPTOR, root_0, PRINTABLE2024_tree);


            	            {
            	                i=store_value((PRINTABLE2024->getText(PRINTABLE2024))->chars,i,&s,(PRINTABLE2024->getText(PRINTABLE2024))->len);
            	            }


            	        }
            	        break;

            	    default:

            		if ( cnt480 >= 1 )
            		{
            		    goto loop480;
            		}
            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulevalEx;
            	}
            	cnt480++;
                }
                loop480: ;	/* Jump to here if this rule does not match */
            }

            {
                s[i]=0;retval.text=s;
                printf("Val lexed %s \n",retval.text
                );
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevalEx; /* Prevent compiler warnings */
    rulevalEx: ;
    retval.stop = LT(-1);


    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }
            else
            {
                {
                    #ifdef DEBUG
                    	pop_rule(); 
                    	#endif
                }
            }


    return retval;
}
/* $ANTLR end val */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
